# double linked list of transport

## параметры ДЗ

Ваиант задания: 4 Транспорт
Зариант структуры данных: 4 Двусвязный список
Язык программирования: rust

## Вступление

Здесь представлена имплементация двусвязного списка, хранящего и обрабатывающего альтернативы абстрактного типа `transport`, а так же продемонстирорована возможность эволюционного расширения данного проекта без изменения ранее написанных пакетов кода

## Структура всего проекта

Здесь лежат директории вида `task_*`, в них лежат версии проекта. В названии каждой версии указано, в рамках выполнения какого задания она создана, и у некоторых указано, результат какого задания был взят за основу. Например, название `task_04_based_on_task_01` означает, что была взята версия 1 и модифицирована в соответствии с заданием 4.

## Структура каждой версии проекта

Тут будет рассказано о том, что внутри каждой директории вида `task_*`.

Каждая версия состоит из нескольких пакетов.

У каждого пакета есть своя директория. В ней свой файл `Cargo.toml` с описанием, от каких пакетов (локальных или репозитория) зависит текущий пакет, свой файл `Cargo.lock`, который генерируется компилятором и в котором указаны версии пакетов для детерминированых сборок, своя директория src с исходниками.

Каждый пакет это отдельная единица компиляции. Компилятор проводит топологическую сортировку пакетов на основе зависимостей, скачивает необходимые зависимости с репозитория и запускает процесс сборки, компилируя по одному пакету за раз.

## Описание пакетов

### Общие пакеты, присутствующие в каждой версии

Пакет `main`. В нём написаны тесты на всю систему, а именно, что она способна прочитать список объектов со стандартного входа и распечатать его на стандартный вывод так, как этого просят в задании. Все файлы этого проекта меняются от версии к версии.

Пакет `object`. В нём создан тип `Object`, имеющий переменный список полей переменного типа. Он лежит в основе механизма системы эволюционно расширяемых типов данных.

Пакет `types`. В нём описан эволюционно расширяемый механизм типов данных, позволяющий в процессе развития проекта менять список альтернатив абстрактного типа данных, список полей и методов, добавлять декораторы к методам и многое другое. Так же там описан механизм ввода-вывода заранее неизвестных типов данных.

Пакет `double_linked_list`. В нём написан шаблонный контейнер на двусвязном списке. Он реализован в стиле ООП по аналогии с тем, как реализуются контейнеры в стандартных библиотеках. Интерфейс содержит необходимый минимум функций для работы с ним.

Пакет `list_of_objects`. В нём на основе двусвязного списка из пакета `double_linked_list` созадётся контейнер для хранения объектов типа `Object` из пакета `object`, причём этот контейнер создаётся как тип в системе типов пакета `types`, что позволяет позднее по мере развития пакетов менять список методов а так же навешивать на них декораторы.

### Пакеты, напрямую выполняющие конкретную задачу

Пакеты вида `*_type`. Появляются в разных версиях. Создают новый тип данных.

Пакеты вида `*_attr`. Появляются в разных версиях. Создают новый атрибут для существующих типов данных.

## Запуск для использования/ручного тестирования

### Сборка

1. Перейдите в директорию нужной версии
2. Перейдите в директорию main
3. Выполните сборку проекта `cargo build`
4. 

## Юнит тесты и их запуск

### О тестах 

В пакете main каждой версии есть юнит тесты, проверяющие, что вся система способна считать данные со стандартного ввода и вывести в стандартный вывод.

В некоторых пакетах есть юнит тесты, тестирующие конкретный пакет.

### Запуск тестов

В каждой версии есть исполняемый файл `test_all.sh`. Этот файл запускает все юнит тесты во всех пакетах текущей версии. После работы независимо от результата тестирования он удаляет все артефакты сборки. Этот файл совпадает во всех версиях.

В корневой директории проекта, то есть, вне версионных директорий, есть файл `test_all.sh`, который запускает файлы `test_all.sh` всех версий.

## Сравнение файлов и проверка эволюционности проекта

В корневой директории проекта лежит исполняемый файл `comparer.sh`.

Он сравнивает различные версии.

Он не требует аргументов командной строки, вместо этого, он смотрит на названия версий, и если видит название вида `task_04_based_on_task_01`, то рекурсивно сравнивает пару директорий `task_01` и `task_04_based_on_task_01`.

В процессе исполнения этот файл печатает, какие директории он решил сравнивать и результат сравнения (различающиеся файлы с одинаковыми именами и файлы, которые присутствуют только в одной директории).

В файле `good_comparer_output.txt` лежит вывод команды `./comparer.sh` соответствующий ситуации, когда отличаются только те файлы, которым можно отличаться.

Команда `diff <(./comparer.sh) good_comparer_output.txt` покажет, чем отличается фактический вывод команды `./comparer.sh` от того, что должно быть напечатано в хорошем случае. Если вывод пустой, то всё в порядке. Если нет, стоит внимательно его изучаить, вможет быть, файлы были рассмотрены командой diff в другом порядке и всё в порядке, а может быть, это сигнал, что что-то не так.

## Перед началом тестирования

### Установка cargo+rust на свою ситему

Лучше всего действовать по [официальной инструкции](https://doc.rust-lang.org/cargo/getting-started/installation.html).

В случае linux/macos, это

`curl https://sh.rustup.rs -sSf | sh`

По моим наблюдениям, на ubuntu так же нужно сначала установить curl и gcc. Вероятно, на других дистрибутивах так же.

#### Использование docker

Если не получается установить cargo+rust на хост, есть возможность запустить всё в контейнере.

1. Переходим в директорию, где лежит Dockerfile
2. Собираем образ диска: `docker build -t transport_list .`
3. Запускаем контейнер: `docker container run --rm -it --name transport_list transport_list bash`

Вся директория проекта скопируется в контейнер и Вы окажетесь в ней. Можно будет выполнять любые описанные здесь команды.