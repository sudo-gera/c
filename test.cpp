# 1 "tin3.cpp"
# 1 "<built-in>" 1
# 1 "<built-in>" 3
# 460 "<built-in>" 3
# 1 "<command line>" 1
# 1 "<built-in>" 2
# 1 "tin3.cpp" 2
# 1 "/usr/local/include/bits/stdc++.h" 1
# 34 "/usr/local/include/bits/stdc++.h"
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 1 3
# 19 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__config" 1 3
# 13 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__config" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__config_site" 1 3
# 14 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__config" 2 3
# 23 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__config" 3
# 859 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__config" 3
namespace std { inline namespace __1 { } }
# 1167 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__config" 3
extern "C" __attribute__ ((__visibility__("default"))) void __sanitizer_annotate_contiguous_container(
  const void *, const void *, const void *, const void *);
# 20 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/assert.h" 1 3 4
# 42 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/assert.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/cdefs.h" 1 3 4
# 659 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/cdefs.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_symbol_aliasing.h" 1 3 4
# 660 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/cdefs.h" 2 3 4
# 725 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/cdefs.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_posix_availability.h" 1 3 4
# 726 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/cdefs.h" 2 3 4
# 43 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/assert.h" 2 3 4

# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/stdlib.h" 1 3 4
# 91 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/stdlib.h" 3


# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/stdlib.h" 1 3 4
# 61 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/stdlib.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/Availability.h" 1 3 4
# 135 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/Availability.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/AvailabilityVersions.h" 1 3 4
# 136 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/Availability.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/AvailabilityInternal.h" 1 3 4
# 137 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/Availability.h" 2 3 4
# 62 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/stdlib.h" 2 3 4


# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/_types.h" 1 3 4
# 27 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/_types.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types.h" 1 3 4
# 33 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/machine/_types.h" 1 3 4
# 34 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/machine/_types.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/arm/_types.h" 1 3 4
# 15 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/arm/_types.h" 3 4
typedef signed char __int8_t;



typedef unsigned char __uint8_t;
typedef short __int16_t;
typedef unsigned short __uint16_t;
typedef int __int32_t;
typedef unsigned int __uint32_t;
typedef long long __int64_t;
typedef unsigned long long __uint64_t;

typedef long __darwin_intptr_t;
typedef unsigned int __darwin_natural_t;
# 48 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/arm/_types.h" 3 4
typedef int __darwin_ct_rune_t;





typedef union {
 char __mbstate8[128];
 long long _mbstateL;
} __mbstate_t;

typedef __mbstate_t __darwin_mbstate_t;


typedef long int __darwin_ptrdiff_t;







typedef long unsigned int __darwin_size_t;





typedef __builtin_va_list __darwin_va_list;





typedef int __darwin_wchar_t;




typedef __darwin_wchar_t __darwin_rune_t;


typedef int __darwin_wint_t;




typedef unsigned long __darwin_clock_t;
typedef __uint32_t __darwin_socklen_t;
typedef long __darwin_ssize_t;
typedef long __darwin_time_t;
# 35 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/machine/_types.h" 2 3 4
# 34 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types.h" 2 3 4
# 55 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types.h" 3 4
typedef __int64_t __darwin_blkcnt_t;
typedef __int32_t __darwin_blksize_t;
typedef __int32_t __darwin_dev_t;
typedef unsigned int __darwin_fsblkcnt_t;
typedef unsigned int __darwin_fsfilcnt_t;
typedef __uint32_t __darwin_gid_t;
typedef __uint32_t __darwin_id_t;
typedef __uint64_t __darwin_ino64_t;

typedef __darwin_ino64_t __darwin_ino_t;



typedef __darwin_natural_t __darwin_mach_port_name_t;
typedef __darwin_mach_port_name_t __darwin_mach_port_t;
typedef __uint16_t __darwin_mode_t;
typedef __int64_t __darwin_off_t;
typedef __int32_t __darwin_pid_t;
typedef __uint32_t __darwin_sigset_t;
typedef __int32_t __darwin_suseconds_t;
typedef __uint32_t __darwin_uid_t;
typedef __uint32_t __darwin_useconds_t;
typedef unsigned char __darwin_uuid_t[16];
typedef char __darwin_uuid_string_t[37];

# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_pthread/_pthread_types.h" 1 3 4
# 57 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_pthread/_pthread_types.h" 3 4
struct __darwin_pthread_handler_rec {
 void (*__routine)(void *);
 void *__arg;
 struct __darwin_pthread_handler_rec *__next;
};

struct _opaque_pthread_attr_t {
 long __sig;
 char __opaque[56];
};

struct _opaque_pthread_cond_t {
 long __sig;
 char __opaque[40];
};

struct _opaque_pthread_condattr_t {
 long __sig;
 char __opaque[8];
};

struct _opaque_pthread_mutex_t {
 long __sig;
 char __opaque[56];
};

struct _opaque_pthread_mutexattr_t {
 long __sig;
 char __opaque[8];
};

struct _opaque_pthread_once_t {
 long __sig;
 char __opaque[8];
};

struct _opaque_pthread_rwlock_t {
 long __sig;
 char __opaque[192];
};

struct _opaque_pthread_rwlockattr_t {
 long __sig;
 char __opaque[16];
};

struct _opaque_pthread_t {
 long __sig;
 struct __darwin_pthread_handler_rec *__cleanup_stack;
 char __opaque[8176];
};

typedef struct _opaque_pthread_attr_t __darwin_pthread_attr_t;
typedef struct _opaque_pthread_cond_t __darwin_pthread_cond_t;
typedef struct _opaque_pthread_condattr_t __darwin_pthread_condattr_t;
typedef unsigned long __darwin_pthread_key_t;
typedef struct _opaque_pthread_mutex_t __darwin_pthread_mutex_t;
typedef struct _opaque_pthread_mutexattr_t __darwin_pthread_mutexattr_t;
typedef struct _opaque_pthread_once_t __darwin_pthread_once_t;
typedef struct _opaque_pthread_rwlock_t __darwin_pthread_rwlock_t;
typedef struct _opaque_pthread_rwlockattr_t __darwin_pthread_rwlockattr_t;
typedef struct _opaque_pthread_t *__darwin_pthread_t;
# 81 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types.h" 2 3 4
# 28 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/_types.h" 2 3 4
# 40 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/_types.h" 3 4
typedef int __darwin_nl_item;
typedef int __darwin_wctrans_t;

typedef __uint32_t __darwin_wctype_t;
# 65 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/stdlib.h" 2 3 4

# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/wait.h" 1 3 4
# 79 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/wait.h" 3 4
typedef enum {
 P_ALL,
 P_PID,
 P_PGID
} idtype_t;





# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_pid_t.h" 1 3 4
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_pid_t.h" 3 4
typedef __darwin_pid_t pid_t;
# 90 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/wait.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_id_t.h" 1 3 4
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_id_t.h" 3 4
typedef __darwin_id_t id_t;
# 91 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/wait.h" 2 3 4
# 109 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/wait.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/signal.h" 1 3 4
# 73 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/signal.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/appleapiopts.h" 1 3 4
# 74 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/signal.h" 2 3 4








# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/machine/signal.h" 1 3 4
# 34 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/machine/signal.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/arm/signal.h" 1 3 4
# 17 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/arm/signal.h" 3 4
typedef int sig_atomic_t;
# 35 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/machine/signal.h" 2 3 4
# 83 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/signal.h" 2 3 4
# 146 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/signal.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/machine/_mcontext.h" 1 3 4
# 34 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/machine/_mcontext.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/arm/_mcontext.h" 1 3 4
# 36 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/arm/_mcontext.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/mach/machine/_structs.h" 1 3 4
# 35 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/mach/machine/_structs.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/mach/arm/_structs.h" 1 3 4
# 37 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/mach/arm/_structs.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/machine/types.h" 1 3 4
# 37 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/machine/types.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/arm/types.h" 1 3 4
# 55 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/arm/types.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_int8_t.h" 1 3 4
# 30 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_int8_t.h" 3 4
typedef signed char int8_t;
# 56 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/arm/types.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_int16_t.h" 1 3 4
# 30 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_int16_t.h" 3 4
typedef short int16_t;
# 57 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/arm/types.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_int32_t.h" 1 3 4
# 30 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_int32_t.h" 3 4
typedef int int32_t;
# 58 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/arm/types.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_int64_t.h" 1 3 4
# 30 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_int64_t.h" 3 4
typedef long long int64_t;
# 59 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/arm/types.h" 2 3 4

# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_u_int8_t.h" 1 3 4
# 30 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_u_int8_t.h" 3 4
typedef unsigned char u_int8_t;
# 61 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/arm/types.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_u_int16_t.h" 1 3 4
# 30 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_u_int16_t.h" 3 4
typedef unsigned short u_int16_t;
# 62 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/arm/types.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_u_int32_t.h" 1 3 4
# 30 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_u_int32_t.h" 3 4
typedef unsigned int u_int32_t;
# 63 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/arm/types.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_u_int64_t.h" 1 3 4
# 30 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_u_int64_t.h" 3 4
typedef unsigned long long u_int64_t;
# 64 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/arm/types.h" 2 3 4


typedef int64_t register_t;




# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_intptr_t.h" 1 3 4
# 30 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_intptr_t.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/machine/types.h" 1 3 4
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_intptr_t.h" 2 3 4

typedef __darwin_intptr_t intptr_t;
# 72 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/arm/types.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_uintptr_t.h" 1 3 4
# 34 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_uintptr_t.h" 3 4
typedef unsigned long uintptr_t;
# 73 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/arm/types.h" 2 3 4




typedef u_int64_t user_addr_t;
typedef u_int64_t user_size_t;
typedef int64_t user_ssize_t;
typedef int64_t user_long_t;
typedef u_int64_t user_ulong_t;
typedef int64_t user_time_t;
typedef int64_t user_off_t;
# 104 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/arm/types.h" 3 4
typedef u_int64_t syscall_arg_t;
# 38 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/machine/types.h" 2 3 4
# 38 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/mach/arm/_structs.h" 2 3 4



struct __darwin_arm_exception_state
{
 __uint32_t __exception;
 __uint32_t __fsr;
 __uint32_t __far;
};
# 59 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/mach/arm/_structs.h" 3 4
struct __darwin_arm_exception_state64
{
 __uint64_t __far;
 __uint32_t __esr;
 __uint32_t __exception;
};
# 77 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/mach/arm/_structs.h" 3 4
struct __darwin_arm_thread_state
{
 __uint32_t __r[13];
 __uint32_t __sp;
 __uint32_t __lr;
 __uint32_t __pc;
 __uint32_t __cpsr;
};
# 136 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/mach/arm/_structs.h" 3 4
struct __darwin_arm_thread_state64
{
 __uint64_t __x[29];
 __uint64_t __fp;
 __uint64_t __lr;
 __uint64_t __sp;
 __uint64_t __pc;
 __uint32_t __cpsr;
 __uint32_t __pad;
};
# 433 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/mach/arm/_structs.h" 3 4
struct __darwin_arm_vfp_state
{
 __uint32_t __r[64];
 __uint32_t __fpscr;
};
# 452 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/mach/arm/_structs.h" 3 4
struct __darwin_arm_neon_state64
{
 __uint128_t __v[32];
 __uint32_t __fpsr;
 __uint32_t __fpcr;
};

struct __darwin_arm_neon_state
{
 __uint128_t __v[16];
 __uint32_t __fpsr;
 __uint32_t __fpcr;
};
# 523 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/mach/arm/_structs.h" 3 4
struct __arm_pagein_state
{
 int __pagein_error;
};
# 560 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/mach/arm/_structs.h" 3 4
struct __arm_legacy_debug_state
{
 __uint32_t __bvr[16];
 __uint32_t __bcr[16];
 __uint32_t __wvr[16];
 __uint32_t __wcr[16];
};
# 583 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/mach/arm/_structs.h" 3 4
struct __darwin_arm_debug_state32
{
 __uint32_t __bvr[16];
 __uint32_t __bcr[16];
 __uint32_t __wvr[16];
 __uint32_t __wcr[16];
 __uint64_t __mdscr_el1;
};


struct __darwin_arm_debug_state64
{
 __uint64_t __bvr[16];
 __uint64_t __bcr[16];
 __uint64_t __wvr[16];
 __uint64_t __wcr[16];
 __uint64_t __mdscr_el1;
};
# 625 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/mach/arm/_structs.h" 3 4
struct __darwin_arm_cpmu_state64
{
 __uint64_t __ctrs[16];
};
# 36 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/mach/machine/_structs.h" 2 3 4
# 37 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/arm/_mcontext.h" 2 3 4




struct __darwin_mcontext32
{
 struct __darwin_arm_exception_state __es;
 struct __darwin_arm_thread_state __ss;
 struct __darwin_arm_vfp_state __fs;
};
# 64 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/arm/_mcontext.h" 3 4
struct __darwin_mcontext64
{
 struct __darwin_arm_exception_state64 __es;
 struct __darwin_arm_thread_state64 __ss;
 struct __darwin_arm_neon_state64 __ns;
};
# 85 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/arm/_mcontext.h" 3 4
typedef struct __darwin_mcontext64 *mcontext_t;
# 35 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/machine/_mcontext.h" 2 3 4
# 147 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/signal.h" 2 3 4

# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_pthread/_pthread_attr_t.h" 1 3 4
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_pthread/_pthread_attr_t.h" 3 4
typedef __darwin_pthread_attr_t pthread_attr_t;
# 149 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/signal.h" 2 3 4

# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_sigaltstack.h" 1 3 4
# 42 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_sigaltstack.h" 3 4
struct __darwin_sigaltstack
{
 void *ss_sp;
 __darwin_size_t ss_size;
 int ss_flags;
};
typedef struct __darwin_sigaltstack stack_t;
# 151 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/signal.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_ucontext.h" 1 3 4
# 43 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_ucontext.h" 3 4
struct __darwin_ucontext
{
 int uc_onstack;
 __darwin_sigset_t uc_sigmask;
 struct __darwin_sigaltstack uc_stack;
 struct __darwin_ucontext *uc_link;
 __darwin_size_t uc_mcsize;
 struct __darwin_mcontext64 *uc_mcontext;



};


typedef struct __darwin_ucontext ucontext_t;
# 152 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/signal.h" 2 3 4


# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_sigset_t.h" 1 3 4
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_sigset_t.h" 3 4
typedef __darwin_sigset_t sigset_t;
# 155 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/signal.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_size_t.h" 1 3 4
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_size_t.h" 3 4
typedef __darwin_size_t size_t;
# 156 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/signal.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_uid_t.h" 1 3 4
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_uid_t.h" 3 4
typedef __darwin_uid_t uid_t;
# 157 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/signal.h" 2 3 4

union sigval {

 int sival_int;
 void *sival_ptr;
};





struct sigevent {
 int sigev_notify;
 int sigev_signo;
 union sigval sigev_value;
 void (*sigev_notify_function)(union sigval);
 pthread_attr_t *sigev_notify_attributes;
};


typedef struct __siginfo {
 int si_signo;
 int si_errno;
 int si_code;
 pid_t si_pid;
 uid_t si_uid;
 int si_status;
 void *si_addr;
 union sigval si_value;
 long si_band;
 unsigned long __pad[7];
} siginfo_t;
# 269 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/signal.h" 3 4
union __sigaction_u {
 void (*__sa_handler)(int);
 void (*__sa_sigaction)(int, struct __siginfo *,
     void *);
};


struct __sigaction {
 union __sigaction_u __sigaction_u;
 void (*sa_tramp)(void *, int, int, siginfo_t *, void *);
 sigset_t sa_mask;
 int sa_flags;
};




struct sigaction {
 union __sigaction_u __sigaction_u;
 sigset_t sa_mask;
 int sa_flags;
};
# 331 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/signal.h" 3 4
typedef void (*sig_t)(int);
# 348 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/signal.h" 3 4
struct sigvec {
 void (*sv_handler)(int);
 int sv_mask;
 int sv_flags;
};
# 367 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/signal.h" 3 4
struct sigstack {
 char *ss_sp;
 int ss_onstack;
};
# 389 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/signal.h" 3 4
extern "C" {
    void(*signal(int, void (*)(int)))(int);
}
# 110 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/wait.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/resource.h" 1 3 4
# 72 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/resource.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/stdint.h" 1 3 4
# 110 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/stdint.h" 3
# 123 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/stdint.h" 3
# 1 "/Library/Developer/CommandLineTools/usr/lib/clang/13.1.6/include/stdint.h" 1 3
# 52 "/Library/Developer/CommandLineTools/usr/lib/clang/13.1.6/include/stdint.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/stdint.h" 1 3 4
# 23 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/stdint.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/_types/_uint8_t.h" 1 3 4
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/_types/_uint8_t.h" 3 4
typedef unsigned char uint8_t;
# 24 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/stdint.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/_types/_uint16_t.h" 1 3 4
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/_types/_uint16_t.h" 3 4
typedef unsigned short uint16_t;
# 25 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/stdint.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/_types/_uint32_t.h" 1 3 4
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/_types/_uint32_t.h" 3 4
typedef unsigned int uint32_t;
# 26 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/stdint.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/_types/_uint64_t.h" 1 3 4
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/_types/_uint64_t.h" 3 4
typedef unsigned long long uint64_t;
# 27 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/stdint.h" 2 3 4


typedef int8_t int_least8_t;
typedef int16_t int_least16_t;
typedef int32_t int_least32_t;
typedef int64_t int_least64_t;
typedef uint8_t uint_least8_t;
typedef uint16_t uint_least16_t;
typedef uint32_t uint_least32_t;
typedef uint64_t uint_least64_t;



typedef int8_t int_fast8_t;
typedef int16_t int_fast16_t;
typedef int32_t int_fast32_t;
typedef int64_t int_fast64_t;
typedef uint8_t uint_fast8_t;
typedef uint16_t uint_fast16_t;
typedef uint32_t uint_fast32_t;
typedef uint64_t uint_fast64_t;
# 58 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/stdint.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/_types/_intmax_t.h" 1 3 4
# 32 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/_types/_intmax_t.h" 3 4
typedef long int intmax_t;
# 59 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/stdint.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/_types/_uintmax_t.h" 1 3 4
# 32 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/_types/_uintmax_t.h" 3 4
typedef long unsigned int uintmax_t;
# 60 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/stdint.h" 2 3 4
# 53 "/Library/Developer/CommandLineTools/usr/lib/clang/13.1.6/include/stdint.h" 2 3
# 124 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/stdint.h" 2 3
# 73 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/resource.h" 2 3 4







# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_timeval.h" 1 3 4
# 34 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_timeval.h" 3 4
struct timeval
{
 __darwin_time_t tv_sec;
 __darwin_suseconds_t tv_usec;
};
# 81 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/resource.h" 2 3 4








typedef __uint64_t rlim_t;
# 152 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/resource.h" 3 4
struct rusage {
 struct timeval ru_utime;
 struct timeval ru_stime;
# 163 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/resource.h" 3 4
 long ru_maxrss;

 long ru_ixrss;
 long ru_idrss;
 long ru_isrss;
 long ru_minflt;
 long ru_majflt;
 long ru_nswap;
 long ru_inblock;
 long ru_oublock;
 long ru_msgsnd;
 long ru_msgrcv;
 long ru_nsignals;
 long ru_nvcsw;
 long ru_nivcsw;


};
# 199 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/resource.h" 3 4
typedef void *rusage_info_t;

struct rusage_info_v0 {
 uint8_t ri_uuid[16];
 uint64_t ri_user_time;
 uint64_t ri_system_time;
 uint64_t ri_pkg_idle_wkups;
 uint64_t ri_interrupt_wkups;
 uint64_t ri_pageins;
 uint64_t ri_wired_size;
 uint64_t ri_resident_size;
 uint64_t ri_phys_footprint;
 uint64_t ri_proc_start_abstime;
 uint64_t ri_proc_exit_abstime;
};

struct rusage_info_v1 {
 uint8_t ri_uuid[16];
 uint64_t ri_user_time;
 uint64_t ri_system_time;
 uint64_t ri_pkg_idle_wkups;
 uint64_t ri_interrupt_wkups;
 uint64_t ri_pageins;
 uint64_t ri_wired_size;
 uint64_t ri_resident_size;
 uint64_t ri_phys_footprint;
 uint64_t ri_proc_start_abstime;
 uint64_t ri_proc_exit_abstime;
 uint64_t ri_child_user_time;
 uint64_t ri_child_system_time;
 uint64_t ri_child_pkg_idle_wkups;
 uint64_t ri_child_interrupt_wkups;
 uint64_t ri_child_pageins;
 uint64_t ri_child_elapsed_abstime;
};

struct rusage_info_v2 {
 uint8_t ri_uuid[16];
 uint64_t ri_user_time;
 uint64_t ri_system_time;
 uint64_t ri_pkg_idle_wkups;
 uint64_t ri_interrupt_wkups;
 uint64_t ri_pageins;
 uint64_t ri_wired_size;
 uint64_t ri_resident_size;
 uint64_t ri_phys_footprint;
 uint64_t ri_proc_start_abstime;
 uint64_t ri_proc_exit_abstime;
 uint64_t ri_child_user_time;
 uint64_t ri_child_system_time;
 uint64_t ri_child_pkg_idle_wkups;
 uint64_t ri_child_interrupt_wkups;
 uint64_t ri_child_pageins;
 uint64_t ri_child_elapsed_abstime;
 uint64_t ri_diskio_bytesread;
 uint64_t ri_diskio_byteswritten;
};

struct rusage_info_v3 {
 uint8_t ri_uuid[16];
 uint64_t ri_user_time;
 uint64_t ri_system_time;
 uint64_t ri_pkg_idle_wkups;
 uint64_t ri_interrupt_wkups;
 uint64_t ri_pageins;
 uint64_t ri_wired_size;
 uint64_t ri_resident_size;
 uint64_t ri_phys_footprint;
 uint64_t ri_proc_start_abstime;
 uint64_t ri_proc_exit_abstime;
 uint64_t ri_child_user_time;
 uint64_t ri_child_system_time;
 uint64_t ri_child_pkg_idle_wkups;
 uint64_t ri_child_interrupt_wkups;
 uint64_t ri_child_pageins;
 uint64_t ri_child_elapsed_abstime;
 uint64_t ri_diskio_bytesread;
 uint64_t ri_diskio_byteswritten;
 uint64_t ri_cpu_time_qos_default;
 uint64_t ri_cpu_time_qos_maintenance;
 uint64_t ri_cpu_time_qos_background;
 uint64_t ri_cpu_time_qos_utility;
 uint64_t ri_cpu_time_qos_legacy;
 uint64_t ri_cpu_time_qos_user_initiated;
 uint64_t ri_cpu_time_qos_user_interactive;
 uint64_t ri_billed_system_time;
 uint64_t ri_serviced_system_time;
};

struct rusage_info_v4 {
 uint8_t ri_uuid[16];
 uint64_t ri_user_time;
 uint64_t ri_system_time;
 uint64_t ri_pkg_idle_wkups;
 uint64_t ri_interrupt_wkups;
 uint64_t ri_pageins;
 uint64_t ri_wired_size;
 uint64_t ri_resident_size;
 uint64_t ri_phys_footprint;
 uint64_t ri_proc_start_abstime;
 uint64_t ri_proc_exit_abstime;
 uint64_t ri_child_user_time;
 uint64_t ri_child_system_time;
 uint64_t ri_child_pkg_idle_wkups;
 uint64_t ri_child_interrupt_wkups;
 uint64_t ri_child_pageins;
 uint64_t ri_child_elapsed_abstime;
 uint64_t ri_diskio_bytesread;
 uint64_t ri_diskio_byteswritten;
 uint64_t ri_cpu_time_qos_default;
 uint64_t ri_cpu_time_qos_maintenance;
 uint64_t ri_cpu_time_qos_background;
 uint64_t ri_cpu_time_qos_utility;
 uint64_t ri_cpu_time_qos_legacy;
 uint64_t ri_cpu_time_qos_user_initiated;
 uint64_t ri_cpu_time_qos_user_interactive;
 uint64_t ri_billed_system_time;
 uint64_t ri_serviced_system_time;
 uint64_t ri_logical_writes;
 uint64_t ri_lifetime_max_phys_footprint;
 uint64_t ri_instructions;
 uint64_t ri_cycles;
 uint64_t ri_billed_energy;
 uint64_t ri_serviced_energy;
 uint64_t ri_interval_max_phys_footprint;
 uint64_t ri_runnable_time;
};

struct rusage_info_v5 {
 uint8_t ri_uuid[16];
 uint64_t ri_user_time;
 uint64_t ri_system_time;
 uint64_t ri_pkg_idle_wkups;
 uint64_t ri_interrupt_wkups;
 uint64_t ri_pageins;
 uint64_t ri_wired_size;
 uint64_t ri_resident_size;
 uint64_t ri_phys_footprint;
 uint64_t ri_proc_start_abstime;
 uint64_t ri_proc_exit_abstime;
 uint64_t ri_child_user_time;
 uint64_t ri_child_system_time;
 uint64_t ri_child_pkg_idle_wkups;
 uint64_t ri_child_interrupt_wkups;
 uint64_t ri_child_pageins;
 uint64_t ri_child_elapsed_abstime;
 uint64_t ri_diskio_bytesread;
 uint64_t ri_diskio_byteswritten;
 uint64_t ri_cpu_time_qos_default;
 uint64_t ri_cpu_time_qos_maintenance;
 uint64_t ri_cpu_time_qos_background;
 uint64_t ri_cpu_time_qos_utility;
 uint64_t ri_cpu_time_qos_legacy;
 uint64_t ri_cpu_time_qos_user_initiated;
 uint64_t ri_cpu_time_qos_user_interactive;
 uint64_t ri_billed_system_time;
 uint64_t ri_serviced_system_time;
 uint64_t ri_logical_writes;
 uint64_t ri_lifetime_max_phys_footprint;
 uint64_t ri_instructions;
 uint64_t ri_cycles;
 uint64_t ri_billed_energy;
 uint64_t ri_serviced_energy;
 uint64_t ri_interval_max_phys_footprint;
 uint64_t ri_runnable_time;
 uint64_t ri_flags;
};

typedef struct rusage_info_v5 rusage_info_current;
# 411 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/resource.h" 3 4
struct rlimit {
 rlim_t rlim_cur;
 rlim_t rlim_max;
};
# 446 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/resource.h" 3 4
struct proc_rlimit_control_wakeupmon {
 uint32_t wm_flags;
 int32_t wm_rate;
};
# 510 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/resource.h" 3 4
extern "C" {
int getpriority(int, id_t);

int getiopolicy_np(int, int) __attribute__((availability(macosx,introduced=10.5)));

int getrlimit(int, struct rlimit *) __asm("_" "getrlimit" );
int getrusage(int, struct rusage *);
int setpriority(int, id_t, int);

int setiopolicy_np(int, int, int) __attribute__((availability(macosx,introduced=10.5)));

int setrlimit(int, const struct rlimit *) __asm("_" "setrlimit" );
}
# 111 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/wait.h" 2 3 4
# 186 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/wait.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/machine/endian.h" 1 3 4
# 37 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/machine/endian.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/arm/endian.h" 1 3 4
# 77 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/arm/endian.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_endian.h" 1 3 4
# 130 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_endian.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/libkern/_OSByteOrder.h" 1 3 4
# 80 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/libkern/_OSByteOrder.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/libkern/arm/OSByteOrder.h" 1 3 4








# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/arm/arch.h" 1 3 4
# 10 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/libkern/arm/OSByteOrder.h" 2 3 4



static inline
uint16_t
_OSSwapInt16(
 uint16_t _data
 )
{

 return (uint16_t)(_data << 8 | _data >> 8);
}

static inline
uint32_t
_OSSwapInt32(
 uint32_t _data
 )
{

 _data = __builtin_bswap32(_data);





 return _data;
}

static inline
uint64_t
_OSSwapInt64(
 uint64_t _data
 )
{

 return __builtin_bswap64(_data);
# 60 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/libkern/arm/OSByteOrder.h" 3 4
}



struct _OSUnalignedU16 {
 volatile uint16_t __val;
} __attribute__((__packed__));

struct _OSUnalignedU32 {
 volatile uint32_t __val;
} __attribute__((__packed__));

struct _OSUnalignedU64 {
 volatile uint64_t __val;
} __attribute__((__packed__));
# 87 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/libkern/arm/OSByteOrder.h" 3 4
static inline
uint16_t
OSReadSwapInt16(
 const volatile void * _base,
 uintptr_t _offset
 )
{
 return _OSSwapInt16(((struct _OSUnalignedU16 *)((uintptr_t)_base + _offset))->__val);
}
# 109 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/libkern/arm/OSByteOrder.h" 3 4
static inline
uint32_t
OSReadSwapInt32(
 const volatile void * _base,
 uintptr_t _offset
 )
{
 return _OSSwapInt32(((struct _OSUnalignedU32 *)((uintptr_t)_base + _offset))->__val);
}
# 131 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/libkern/arm/OSByteOrder.h" 3 4
static inline
uint64_t
OSReadSwapInt64(
 const volatile void * _base,
 uintptr_t _offset
 )
{
 return _OSSwapInt64(((struct _OSUnalignedU64 *)((uintptr_t)_base + _offset))->__val);
}
# 156 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/libkern/arm/OSByteOrder.h" 3 4
static inline
void
OSWriteSwapInt16(
 volatile void * _base,
 uintptr_t _offset,
 uint16_t _data
 )
{
 ((struct _OSUnalignedU16 *)((uintptr_t)_base + _offset))->__val = _OSSwapInt16(_data);
}
# 180 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/libkern/arm/OSByteOrder.h" 3 4
static inline
void
OSWriteSwapInt32(
 volatile void * _base,
 uintptr_t _offset,
 uint32_t _data
 )
{
 ((struct _OSUnalignedU32 *)((uintptr_t)_base + _offset))->__val = _OSSwapInt32(_data);
}
# 204 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/libkern/arm/OSByteOrder.h" 3 4
static inline
void
OSWriteSwapInt64(
 volatile void * _base,
 uintptr_t _offset,
 uint64_t _data
 )
{
 ((struct _OSUnalignedU64 *)((uintptr_t)_base + _offset))->__val = _OSSwapInt64(_data);
}
# 81 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/libkern/_OSByteOrder.h" 2 3 4
# 131 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_endian.h" 2 3 4
# 78 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/arm/endian.h" 2 3 4
# 38 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/machine/endian.h" 2 3 4
# 187 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/wait.h" 2 3 4







union wait {
 int w_status;



 struct {

  unsigned int w_Termsig:7,
      w_Coredump:1,
      w_Retcode:8,
      w_Filler:16;







 } w_T;





 struct {

  unsigned int w_Stopval:8,
      w_Stopsig:8,
      w_Filler:16;






 } w_S;
};
# 247 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/wait.h" 3 4
extern "C" {
pid_t wait(int *) __asm("_" "wait" );
pid_t waitpid(pid_t, int *, int) __asm("_" "waitpid" );

int waitid(idtype_t, id_t, siginfo_t *, int) __asm("_" "waitid" );


pid_t wait3(int *, int, struct rusage *);
pid_t wait4(pid_t, int *, int, struct rusage *);

}
# 67 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/stdlib.h" 2 3 4

# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/alloca.h" 1 3 4
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/alloca.h" 3 4
extern "C" {
void *alloca(size_t);
}
# 69 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/stdlib.h" 2 3 4








# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_ct_rune_t.h" 1 3 4
# 32 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_ct_rune_t.h" 3 4
typedef __darwin_ct_rune_t ct_rune_t;
# 78 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/stdlib.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_rune_t.h" 1 3 4
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_rune_t.h" 3 4
typedef __darwin_rune_t rune_t;
# 79 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/stdlib.h" 2 3 4


# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_wchar_t.h" 1 3 4
# 82 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/stdlib.h" 2 3 4

typedef struct {
 int quot;
 int rem;
} div_t;

typedef struct {
 long quot;
 long rem;
} ldiv_t;


typedef struct {
 long long quot;
 long long rem;
} lldiv_t;


# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_null.h" 1 3 4
# 101 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/stdlib.h" 2 3 4
# 118 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/stdlib.h" 3 4
extern int __mb_cur_max;
# 128 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/stdlib.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/malloc/_malloc.h" 1 3 4
# 38 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/malloc/_malloc.h" 3 4
extern "C" {

void *malloc(size_t __size) __attribute__((__warn_unused_result__)) __attribute__((alloc_size(1)));
void *calloc(size_t __count, size_t __size) __attribute__((__warn_unused_result__)) __attribute__((alloc_size(1,2)));
void free(void *);
void *realloc(void *__ptr, size_t __size) __attribute__((__warn_unused_result__)) __attribute__((alloc_size(2)));

void *valloc(size_t) __attribute__((alloc_size(1)));




void *aligned_alloc(size_t __alignment, size_t __size) __attribute__((__warn_unused_result__)) __attribute__((alloc_size(2))) __attribute__((availability(macosx,introduced=10.15))) __attribute__((availability(ios,introduced=13.0))) __attribute__((availability(tvos,introduced=13.0))) __attribute__((availability(watchos,introduced=6.0)));

int posix_memalign(void **__memptr, size_t __alignment, size_t __size) __attribute__((availability(macosx,introduced=10.6)));

}
# 129 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/stdlib.h" 2 3 4

extern "C" {
void abort(void) __attribute__((__cold__)) __attribute__((__noreturn__));
int abs(int) __attribute__((__const__));
int atexit(void (* _Nonnull)(void));
double atof(const char *);
int atoi(const char *);
long atol(const char *);

long long
  atoll(const char *);

void *bsearch(const void *__key, const void *__base, size_t __nel,
     size_t __width, int (* _Nonnull __compar)(const void *, const void *));

div_t div(int, int) __attribute__((__const__));
void exit(int) __attribute__((__noreturn__));

char *getenv(const char *);
long labs(long) __attribute__((__const__));
ldiv_t ldiv(long, long) __attribute__((__const__));

long long
  llabs(long long);
lldiv_t lldiv(long long, long long);


int mblen(const char *__s, size_t __n);
size_t mbstowcs(wchar_t * , const char * , size_t);
int mbtowc(wchar_t * , const char * , size_t);

void qsort(void *__base, size_t __nel, size_t __width,
     int (* _Nonnull __compar)(const void *, const void *));
int rand(void) __attribute__((__availability__(swift, unavailable, message="Use arc4random instead.")));

void srand(unsigned) __attribute__((__availability__(swift, unavailable, message="Use arc4random instead.")));
double strtod(const char *, char **) __asm("_" "strtod" );
float strtof(const char *, char **) __asm("_" "strtof" );
long strtol(const char *__str, char **__endptr, int __base);
long double
  strtold(const char *, char **);

long long
  strtoll(const char *__str, char **__endptr, int __base);

unsigned long
  strtoul(const char *__str, char **__endptr, int __base);

unsigned long long
  strtoull(const char *__str, char **__endptr, int __base);


__attribute__((__availability__(swift, unavailable, message="Use posix_spawn APIs or NSTask instead. (On iOS, process spawning is unavailable.)")))
__attribute__((availability(macos,introduced=10.0))) __attribute__((availability(ios,unavailable)))
__attribute__((availability(watchos,unavailable))) __attribute__((availability(tvos,unavailable)))
int system(const char *) __asm("_" "system" );


size_t wcstombs(char * , const wchar_t * , size_t);
int wctomb(char *, wchar_t);


void _Exit(int) __attribute__((__noreturn__));
long a64l(const char *);
double drand48(void);
char *ecvt(double, int, int *, int *);
double erand48(unsigned short[3]);
char *fcvt(double, int, int *, int *);
char *gcvt(double, int, char *);
int getsubopt(char **, char * const *, char **);
int grantpt(int);

char *initstate(unsigned, char *, size_t);



long jrand48(unsigned short[3]) __attribute__((__availability__(swift, unavailable, message="Use arc4random instead.")));
char *l64a(long);
void lcong48(unsigned short[7]);
long lrand48(void) __attribute__((__availability__(swift, unavailable, message="Use arc4random instead.")));
char *mktemp(char *);
int mkstemp(char *);
long mrand48(void) __attribute__((__availability__(swift, unavailable, message="Use arc4random instead.")));
long nrand48(unsigned short[3]) __attribute__((__availability__(swift, unavailable, message="Use arc4random instead.")));
int posix_openpt(int);
char *ptsname(int);


int ptsname_r(int fildes, char *buffer, size_t buflen) __attribute__((availability(macos,introduced=10.13.4))) __attribute__((availability(ios,introduced=11.3))) __attribute__((availability(tvos,introduced=11.3))) __attribute__((availability(watchos,introduced=4.3)));


int putenv(char *) __asm("_" "putenv" );
long random(void) __attribute__((__availability__(swift, unavailable, message="Use arc4random instead.")));
int rand_r(unsigned *) __attribute__((__availability__(swift, unavailable, message="Use arc4random instead.")));

char *realpath(const char * , char * ) __asm("_" "realpath" "$DARWIN_EXTSN");



unsigned short
 *seed48(unsigned short[3]);
int setenv(const char * __name, const char * __value, int __overwrite) __asm("_" "setenv" );

void setkey(const char *) __asm("_" "setkey" );



char *setstate(const char *);
void srand48(long);

void srandom(unsigned);



int unlockpt(int);

int unsetenv(const char *) __asm("_" "unsetenv" );







# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_dev_t.h" 1 3 4
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_dev_t.h" 3 4
typedef __darwin_dev_t dev_t;
# 254 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/stdlib.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_mode_t.h" 1 3 4
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_mode_t.h" 3 4
typedef __darwin_mode_t mode_t;
# 255 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/stdlib.h" 2 3 4


uint32_t arc4random(void);
void arc4random_addrandom(unsigned char * , int )
    __attribute__((availability(macosx,introduced=10.0))) __attribute__((availability(macosx,deprecated=10.12,message="use arc4random_stir")))
    __attribute__((availability(ios,introduced=2.0))) __attribute__((availability(ios,deprecated=10.0,message="use arc4random_stir")))
    __attribute__((availability(tvos,introduced=2.0))) __attribute__((availability(tvos,deprecated=10.0,message="use arc4random_stir")))
    __attribute__((availability(watchos,introduced=1.0))) __attribute__((availability(watchos,deprecated=3.0,message="use arc4random_stir")));
void arc4random_buf(void * __buf, size_t __nbytes) __attribute__((availability(macosx,introduced=10.7)));
void arc4random_stir(void);
uint32_t
  arc4random_uniform(uint32_t __upper_bound) __attribute__((availability(macosx,introduced=10.7)));

int atexit_b(void (^ _Nonnull)(void)) __attribute__((availability(macosx,introduced=10.6)));
# 277 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/stdlib.h" 3 4
void *bsearch_b(const void *__key, const void *__base, size_t __nel,
     size_t __width, int (^ _Nonnull __compar)(const void *, const void *) __attribute__((__noescape__)))
     __attribute__((availability(macosx,introduced=10.6)));



char *cgetcap(char *, const char *, int);
int cgetclose(void);
int cgetent(char **, char **, const char *);
int cgetfirst(char **, char **);
int cgetmatch(const char *, const char *);
int cgetnext(char **, char **);
int cgetnum(char *, const char *, long *);
int cgetset(const char *);
int cgetstr(char *, const char *, char **);
int cgetustr(char *, const char *, char **);

int daemon(int, int) __asm("_" "daemon" ) __attribute__((availability(macosx,introduced=10.0,deprecated=10.5,message="Use posix_spawn APIs instead."))) __attribute__((availability(watchos,unavailable))) __attribute__((availability(tvos,unavailable)));
char *devname(dev_t, mode_t);
char *devname_r(dev_t, mode_t, char *buf, int len);
char *getbsize(int *, long *);
int getloadavg(double [], int);
const char
 *getprogname(void);
void setprogname(const char *);
# 311 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/stdlib.h" 3 4
int heapsort(void *__base, size_t __nel, size_t __width,
     int (* _Nonnull __compar)(const void *, const void *));

int heapsort_b(void *__base, size_t __nel, size_t __width,
     int (^ _Nonnull __compar)(const void *, const void *) __attribute__((__noescape__)))
     __attribute__((availability(macosx,introduced=10.6)));

int mergesort(void *__base, size_t __nel, size_t __width,
     int (* _Nonnull __compar)(const void *, const void *));

int mergesort_b(void *__base, size_t __nel, size_t __width,
     int (^ _Nonnull __compar)(const void *, const void *) __attribute__((__noescape__)))
     __attribute__((availability(macosx,introduced=10.6)));

void psort(void *__base, size_t __nel, size_t __width,
     int (* _Nonnull __compar)(const void *, const void *))
     __attribute__((availability(macosx,introduced=10.6)));

void psort_b(void *__base, size_t __nel, size_t __width,
     int (^ _Nonnull __compar)(const void *, const void *) __attribute__((__noescape__)))
     __attribute__((availability(macosx,introduced=10.6)));

void psort_r(void *__base, size_t __nel, size_t __width, void *,
     int (* _Nonnull __compar)(void *, const void *, const void *))
     __attribute__((availability(macosx,introduced=10.6)));

void qsort_b(void *__base, size_t __nel, size_t __width,
     int (^ _Nonnull __compar)(const void *, const void *) __attribute__((__noescape__)))
     __attribute__((availability(macosx,introduced=10.6)));

void qsort_r(void *__base, size_t __nel, size_t __width, void *,
     int (* _Nonnull __compar)(void *, const void *, const void *));
int radixsort(const unsigned char **__base, int __nel, const unsigned char *__table,
     unsigned __endbyte);
int rpmatch(const char *)
 __attribute__((availability(macos,introduced=10.15))) __attribute__((availability(ios,introduced=13.0))) __attribute__((availability(tvos,introduced=13.0))) __attribute__((availability(watchos,introduced=6.0)));
int sradixsort(const unsigned char **__base, int __nel, const unsigned char *__table,
     unsigned __endbyte);
void sranddev(void);
void srandomdev(void);
void *reallocf(void *__ptr, size_t __size) __attribute__((alloc_size(2)));
long long
 strtonum(const char *__numstr, long long __minval, long long __maxval, const char **__errstrp)
 __attribute__((availability(macos,introduced=11.0))) __attribute__((availability(ios,introduced=14.0))) __attribute__((availability(tvos,introduced=14.0))) __attribute__((availability(watchos,introduced=7.0)));

long long
  strtoq(const char *__str, char **__endptr, int __base);
unsigned long long
  strtouq(const char *__str, char **__endptr, int __base);

extern char *suboptarg;







}
# 94 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/stdlib.h" 2 3


extern "C++" {
# 107 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/stdlib.h" 3
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) long abs(long __x) noexcept {
  return __builtin_labs(__x);
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) long long abs(long long __x) noexcept {
  return __builtin_llabs(__x);
}




inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) float abs(float __lcpp_x) noexcept {
  return __builtin_fabsf(__lcpp_x);
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) double abs(double __lcpp_x) noexcept {
  return __builtin_fabs(__lcpp_x);
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) long double
abs(long double __lcpp_x) noexcept {
  return __builtin_fabsl(__lcpp_x);
}
# 142 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/stdlib.h" 3
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) ldiv_t div(long __x, long __y) noexcept {
  return ::ldiv(__x, __y);
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) lldiv_t div(long long __x,
                                             long long __y) noexcept {
  return ::lldiv(__x, __y);
}


}
# 45 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/assert.h" 2 3 4
# 81 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/assert.h" 3 4
extern "C" {
void __assert_rtn(const char *, const char *, int, const char *) __attribute__((__noreturn__)) __attribute__((__cold__)) __attribute__((__disable_tail_calls__));



}
# 21 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 2 3
# 24 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 3
# 35 "/usr/local/include/bits/stdc++.h" 2



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cctype" 1 3
# 38 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cctype" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/ctype.h" 1 3
# 36 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/ctype.h" 3


# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/ctype.h" 1 3 4
# 69 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/ctype.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/_ctype.h" 1 3 4
# 70 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/_ctype.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/runetype.h" 1 3 4
# 49 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/runetype.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_wchar_t.h" 1 3 4
# 50 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/runetype.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_wint_t.h" 1 3 4
# 32 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_wint_t.h" 3 4
typedef __darwin_wint_t wint_t;
# 51 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/runetype.h" 2 3 4
# 60 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/runetype.h" 3 4
typedef struct {
 __darwin_rune_t __min;
 __darwin_rune_t __max;
 __darwin_rune_t __map;
 __uint32_t *__types;
} _RuneEntry;

typedef struct {
 int __nranges;
 _RuneEntry *__ranges;
} _RuneRange;

typedef struct {
 char __name[14];
 __uint32_t __mask;
} _RuneCharClass;

typedef struct {
 char __magic[8];
 char __encoding[32];

 __darwin_rune_t (*__sgetrune)(const char *, __darwin_size_t, char const **);
 int (*__sputrune)(__darwin_rune_t, char *, __darwin_size_t, char **);
 __darwin_rune_t __invalid_rune;

 __uint32_t __runetype[(1 <<8 )];
 __darwin_rune_t __maplower[(1 <<8 )];
 __darwin_rune_t __mapupper[(1 <<8 )];






 _RuneRange __runetype_ext;
 _RuneRange __maplower_ext;
 _RuneRange __mapupper_ext;

 void *__variable;
 int __variable_len;




 int __ncharclasses;
 _RuneCharClass *__charclasses;
} _RuneLocale;



extern "C" {
extern _RuneLocale _DefaultRuneLocale;
extern _RuneLocale *_CurrentRuneLocale;
}
# 71 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/_ctype.h" 2 3 4
# 128 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/_ctype.h" 3 4
extern "C" {
unsigned long ___runetype(__darwin_ct_rune_t);
__darwin_ct_rune_t ___tolower(__darwin_ct_rune_t);
__darwin_ct_rune_t ___toupper(__darwin_ct_rune_t);
}

inline int
isascii(int _c)
{
 return ((_c & ~0x7F) == 0);
}
# 147 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/_ctype.h" 3 4
extern "C" {
int __maskrune(__darwin_ct_rune_t, unsigned long);
}


inline int
__istype(__darwin_ct_rune_t _c, unsigned long _f)
{



 return (isascii(_c) ? !!(_DefaultRuneLocale.__runetype[_c] & _f)
  : !!__maskrune(_c, _f));

}

inline __darwin_ct_rune_t
__isctype(__darwin_ct_rune_t _c, unsigned long _f)
{



 return (_c < 0 || _c >= (1 <<8 )) ? 0 :
  !!(_DefaultRuneLocale.__runetype[_c] & _f);

}
# 187 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/_ctype.h" 3 4
extern "C" {
__darwin_ct_rune_t __toupper(__darwin_ct_rune_t);
__darwin_ct_rune_t __tolower(__darwin_ct_rune_t);
}


inline int
__wcwidth(__darwin_ct_rune_t _c)
{
 unsigned int _x;

 if (_c == 0)
  return (0);
 _x = (unsigned int)__maskrune(_c, 0xe0000000L|0x00040000L);
 if ((_x & 0xe0000000L) != 0)
  return ((_x & 0xe0000000L) >> 30);
 return ((_x & 0x00040000L) != 0 ? 1 : -1);
}






inline int
isalnum(int _c)
{
 return (__istype(_c, 0x00000100L|0x00000400L));
}

inline int
isalpha(int _c)
{
 return (__istype(_c, 0x00000100L));
}

inline int
isblank(int _c)
{
 return (__istype(_c, 0x00020000L));
}

inline int
iscntrl(int _c)
{
 return (__istype(_c, 0x00000200L));
}


inline int
isdigit(int _c)
{
 return (__isctype(_c, 0x00000400L));
}

inline int
isgraph(int _c)
{
 return (__istype(_c, 0x00000800L));
}

inline int
islower(int _c)
{
 return (__istype(_c, 0x00001000L));
}

inline int
isprint(int _c)
{
 return (__istype(_c, 0x00040000L));
}

inline int
ispunct(int _c)
{
 return (__istype(_c, 0x00002000L));
}

inline int
isspace(int _c)
{
 return (__istype(_c, 0x00004000L));
}

inline int
isupper(int _c)
{
 return (__istype(_c, 0x00008000L));
}


inline int
isxdigit(int _c)
{
 return (__isctype(_c, 0x00010000L));
}

inline int
toascii(int _c)
{
 return (_c & 0x7F);
}

inline int
tolower(int _c)
{
        return (__tolower(_c));
}

inline int
toupper(int _c)
{
        return (__toupper(_c));
}


inline int
digittoint(int _c)
{
 return (__maskrune(_c, 0x0F));
}

inline int
ishexnumber(int _c)
{
 return (__istype(_c, 0x00010000L));
}

inline int
isideogram(int _c)
{
 return (__istype(_c, 0x00080000L));
}

inline int
isnumber(int _c)
{
 return (__istype(_c, 0x00000400L));
}

inline int
isphonogram(int _c)
{
 return (__istype(_c, 0x00200000L));
}

inline int
isrune(int _c)
{
 return (__istype(_c, 0xFFFFFFF0L));
}

inline int
isspecial(int _c)
{
 return (__istype(_c, 0x00100000L));
}
# 70 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/ctype.h" 2 3 4
# 39 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/ctype.h" 2 3
# 39 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cctype" 2 3
# 42 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cctype" 3


namespace std { inline namespace __1 {
# 103 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cctype" 3
using ::isalnum __attribute__((using_if_exists));
using ::isalpha __attribute__((using_if_exists));
using ::isblank __attribute__((using_if_exists));
using ::iscntrl __attribute__((using_if_exists));
using ::isdigit __attribute__((using_if_exists));
using ::isgraph __attribute__((using_if_exists));
using ::islower __attribute__((using_if_exists));
using ::isprint __attribute__((using_if_exists));
using ::ispunct __attribute__((using_if_exists));
using ::isspace __attribute__((using_if_exists));
using ::isupper __attribute__((using_if_exists));
using ::isxdigit __attribute__((using_if_exists));
using ::tolower __attribute__((using_if_exists));
using ::toupper __attribute__((using_if_exists));

} }
# 39 "/usr/local/include/bits/stdc++.h" 2


# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cerrno" 1 3
# 26 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cerrno" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/errno.h" 1 3
# 29 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/errno.h" 3


# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/errno.h" 1 3 4
# 23 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/errno.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/errno.h" 1 3 4
# 79 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/errno.h" 3 4
extern "C" {
extern int * __error(void);

}
# 24 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/errno.h" 2 3 4
# 32 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/errno.h" 2 3
# 27 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cerrno" 2 3
# 30 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cerrno" 3
# 42 "/usr/local/include/bits/stdc++.h" 2


# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cfloat" 1 3
# 73 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cfloat" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/float.h" 1 3
# 77 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/float.h" 3


# 1 "/Library/Developer/CommandLineTools/usr/lib/clang/13.1.6/include/float.h" 1 3
# 31 "/Library/Developer/CommandLineTools/usr/lib/clang/13.1.6/include/float.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/float.h" 1 3 4
# 32 "/Library/Developer/CommandLineTools/usr/lib/clang/13.1.6/include/float.h" 2 3
# 80 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/float.h" 2 3
# 74 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cfloat" 2 3
# 77 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cfloat" 3
# 45 "/usr/local/include/bits/stdc++.h" 2


# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/ciso646" 1 3
# 22 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/ciso646" 3
# 48 "/usr/local/include/bits/stdc++.h" 2


# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/climits" 1 3
# 41 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/climits" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/limits.h" 1 3
# 44 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/limits.h" 3
# 57 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/limits.h" 3
# 1 "/Library/Developer/CommandLineTools/usr/lib/clang/13.1.6/include/limits.h" 1 3
# 21 "/Library/Developer/CommandLineTools/usr/lib/clang/13.1.6/include/limits.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/limits.h" 1 3 4
# 64 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/limits.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/machine/limits.h" 1 3 4
# 11 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/machine/limits.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/arm/limits.h" 1 3 4
# 45 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/arm/limits.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/arm/_limits.h" 1 3 4
# 46 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/arm/limits.h" 2 3 4
# 12 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/machine/limits.h" 2 3 4
# 65 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/limits.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/syslimits.h" 1 3 4
# 66 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/limits.h" 2 3 4
# 22 "/Library/Developer/CommandLineTools/usr/lib/clang/13.1.6/include/limits.h" 2 3
# 58 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/limits.h" 2 3
# 42 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/climits" 2 3
# 45 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/climits" 3
# 51 "/usr/local/include/bits/stdc++.h" 2


# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/clocale" 1 3
# 38 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/clocale" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/locale.h" 1 3
# 44 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/locale.h" 3


# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/locale.h" 1 3 4
# 40 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/locale.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/_locale.h" 1 3 4
# 43 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/_locale.h" 3 4
struct lconv {
 char *decimal_point;
 char *thousands_sep;
 char *grouping;
 char *int_curr_symbol;
 char *currency_symbol;
 char *mon_decimal_point;
 char *mon_thousands_sep;
 char *mon_grouping;
 char *positive_sign;
 char *negative_sign;
 char int_frac_digits;
 char frac_digits;
 char p_cs_precedes;
 char p_sep_by_space;
 char n_cs_precedes;
 char n_sep_by_space;
 char p_sign_posn;
 char n_sign_posn;
 char int_p_cs_precedes;
 char int_n_cs_precedes;
 char int_p_sep_by_space;
 char int_n_sep_by_space;
 char int_p_sign_posn;
 char int_n_sign_posn;
};



extern "C" {
struct lconv *localeconv(void);
}
# 41 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/locale.h" 2 3 4
# 52 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/locale.h" 3 4
extern "C" {
char *setlocale(int, const char *);
}
# 47 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/locale.h" 2 3
# 39 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/clocale" 2 3
# 42 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/clocale" 3


namespace std { inline namespace __1 {

using ::lconv __attribute__((using_if_exists));

using ::setlocale __attribute__((using_if_exists));

using ::localeconv __attribute__((using_if_exists));

} }
# 54 "/usr/local/include/bits/stdc++.h" 2


# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cmath" 1 3
# 308 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cmath" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/math.h" 1 3
# 298 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/math.h" 3


# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/math.h" 1 3 4
# 33 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/math.h" 3 4
extern "C" {
# 44 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/math.h" 3 4
    typedef float float_t;
    typedef double double_t;
# 111 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/math.h" 3 4
extern int __math_errhandling(void);
# 131 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/math.h" 3 4
extern int __fpclassifyf(float);
extern int __fpclassifyd(double);
extern int __fpclassifyl(long double);
# 174 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/math.h" 3 4
inline __attribute__ ((__always_inline__)) int __inline_isfinitef(float);
inline __attribute__ ((__always_inline__)) int __inline_isfinited(double);
inline __attribute__ ((__always_inline__)) int __inline_isfinitel(long double);
inline __attribute__ ((__always_inline__)) int __inline_isinff(float);
inline __attribute__ ((__always_inline__)) int __inline_isinfd(double);
inline __attribute__ ((__always_inline__)) int __inline_isinfl(long double);
inline __attribute__ ((__always_inline__)) int __inline_isnanf(float);
inline __attribute__ ((__always_inline__)) int __inline_isnand(double);
inline __attribute__ ((__always_inline__)) int __inline_isnanl(long double);
inline __attribute__ ((__always_inline__)) int __inline_isnormalf(float);
inline __attribute__ ((__always_inline__)) int __inline_isnormald(double);
inline __attribute__ ((__always_inline__)) int __inline_isnormall(long double);
inline __attribute__ ((__always_inline__)) int __inline_signbitf(float);
inline __attribute__ ((__always_inline__)) int __inline_signbitd(double);
inline __attribute__ ((__always_inline__)) int __inline_signbitl(long double);

inline __attribute__ ((__always_inline__)) int __inline_isfinitef(float __x) {
    return __x == __x && __builtin_fabsf(__x) != __builtin_inff();
}
inline __attribute__ ((__always_inline__)) int __inline_isfinited(double __x) {
    return __x == __x && __builtin_fabs(__x) != __builtin_inf();
}
inline __attribute__ ((__always_inline__)) int __inline_isfinitel(long double __x) {
    return __x == __x && __builtin_fabsl(__x) != __builtin_infl();
}
inline __attribute__ ((__always_inline__)) int __inline_isinff(float __x) {
    return __builtin_fabsf(__x) == __builtin_inff();
}
inline __attribute__ ((__always_inline__)) int __inline_isinfd(double __x) {
    return __builtin_fabs(__x) == __builtin_inf();
}
inline __attribute__ ((__always_inline__)) int __inline_isinfl(long double __x) {
    return __builtin_fabsl(__x) == __builtin_infl();
}
inline __attribute__ ((__always_inline__)) int __inline_isnanf(float __x) {
    return __x != __x;
}
inline __attribute__ ((__always_inline__)) int __inline_isnand(double __x) {
    return __x != __x;
}
inline __attribute__ ((__always_inline__)) int __inline_isnanl(long double __x) {
    return __x != __x;
}
inline __attribute__ ((__always_inline__)) int __inline_signbitf(float __x) {
    union { float __f; unsigned int __u; } __u;
    __u.__f = __x;
    return (int)(__u.__u >> 31);
}
inline __attribute__ ((__always_inline__)) int __inline_signbitd(double __x) {
    union { double __f; unsigned long long __u; } __u;
    __u.__f = __x;
    return (int)(__u.__u >> 63);
}
# 237 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/math.h" 3 4
inline __attribute__ ((__always_inline__)) int __inline_signbitl(long double __x) {
    union { long double __f; unsigned long long __u;} __u;
    __u.__f = __x;
    return (int)(__u.__u >> 63);
}

inline __attribute__ ((__always_inline__)) int __inline_isnormalf(float __x) {
    return __inline_isfinitef(__x) && __builtin_fabsf(__x) >= 1.17549435e-38F;
}
inline __attribute__ ((__always_inline__)) int __inline_isnormald(double __x) {
    return __inline_isfinited(__x) && __builtin_fabs(__x) >= 2.2250738585072014e-308;
}
inline __attribute__ ((__always_inline__)) int __inline_isnormall(long double __x) {
    return __inline_isfinitel(__x) && __builtin_fabsl(__x) >= 2.2250738585072014e-308L;
}
# 308 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/math.h" 3 4
extern float acosf(float);
extern double acos(double);
extern long double acosl(long double);

extern float asinf(float);
extern double asin(double);
extern long double asinl(long double);

extern float atanf(float);
extern double atan(double);
extern long double atanl(long double);

extern float atan2f(float, float);
extern double atan2(double, double);
extern long double atan2l(long double, long double);

extern float cosf(float);
extern double cos(double);
extern long double cosl(long double);

extern float sinf(float);
extern double sin(double);
extern long double sinl(long double);

extern float tanf(float);
extern double tan(double);
extern long double tanl(long double);

extern float acoshf(float);
extern double acosh(double);
extern long double acoshl(long double);

extern float asinhf(float);
extern double asinh(double);
extern long double asinhl(long double);

extern float atanhf(float);
extern double atanh(double);
extern long double atanhl(long double);

extern float coshf(float);
extern double cosh(double);
extern long double coshl(long double);

extern float sinhf(float);
extern double sinh(double);
extern long double sinhl(long double);

extern float tanhf(float);
extern double tanh(double);
extern long double tanhl(long double);

extern float expf(float);
extern double exp(double);
extern long double expl(long double);

extern float exp2f(float);
extern double exp2(double);
extern long double exp2l(long double);

extern float expm1f(float);
extern double expm1(double);
extern long double expm1l(long double);

extern float logf(float);
extern double log(double);
extern long double logl(long double);

extern float log10f(float);
extern double log10(double);
extern long double log10l(long double);

extern float log2f(float);
extern double log2(double);
extern long double log2l(long double);

extern float log1pf(float);
extern double log1p(double);
extern long double log1pl(long double);

extern float logbf(float);
extern double logb(double);
extern long double logbl(long double);

extern float modff(float, float *);
extern double modf(double, double *);
extern long double modfl(long double, long double *);

extern float ldexpf(float, int);
extern double ldexp(double, int);
extern long double ldexpl(long double, int);

extern float frexpf(float, int *);
extern double frexp(double, int *);
extern long double frexpl(long double, int *);

extern int ilogbf(float);
extern int ilogb(double);
extern int ilogbl(long double);

extern float scalbnf(float, int);
extern double scalbn(double, int);
extern long double scalbnl(long double, int);

extern float scalblnf(float, long int);
extern double scalbln(double, long int);
extern long double scalblnl(long double, long int);

extern float fabsf(float);
extern double fabs(double);
extern long double fabsl(long double);

extern float cbrtf(float);
extern double cbrt(double);
extern long double cbrtl(long double);

extern float hypotf(float, float);
extern double hypot(double, double);
extern long double hypotl(long double, long double);

extern float powf(float, float);
extern double pow(double, double);
extern long double powl(long double, long double);

extern float sqrtf(float);
extern double sqrt(double);
extern long double sqrtl(long double);

extern float erff(float);
extern double erf(double);
extern long double erfl(long double);

extern float erfcf(float);
extern double erfc(double);
extern long double erfcl(long double);




extern float lgammaf(float);
extern double lgamma(double);
extern long double lgammal(long double);

extern float tgammaf(float);
extern double tgamma(double);
extern long double tgammal(long double);

extern float ceilf(float);
extern double ceil(double);
extern long double ceill(long double);

extern float floorf(float);
extern double floor(double);
extern long double floorl(long double);

extern float nearbyintf(float);
extern double nearbyint(double);
extern long double nearbyintl(long double);

extern float rintf(float);
extern double rint(double);
extern long double rintl(long double);

extern long int lrintf(float);
extern long int lrint(double);
extern long int lrintl(long double);

extern float roundf(float);
extern double round(double);
extern long double roundl(long double);

extern long int lroundf(float);
extern long int lround(double);
extern long int lroundl(long double);




extern long long int llrintf(float);
extern long long int llrint(double);
extern long long int llrintl(long double);

extern long long int llroundf(float);
extern long long int llround(double);
extern long long int llroundl(long double);


extern float truncf(float);
extern double trunc(double);
extern long double truncl(long double);

extern float fmodf(float, float);
extern double fmod(double, double);
extern long double fmodl(long double, long double);

extern float remainderf(float, float);
extern double remainder(double, double);
extern long double remainderl(long double, long double);

extern float remquof(float, float, int *);
extern double remquo(double, double, int *);
extern long double remquol(long double, long double, int *);

extern float copysignf(float, float);
extern double copysign(double, double);
extern long double copysignl(long double, long double);

extern float nanf(const char *);
extern double nan(const char *);
extern long double nanl(const char *);

extern float nextafterf(float, float);
extern double nextafter(double, double);
extern long double nextafterl(long double, long double);

extern double nexttoward(double, long double);
extern float nexttowardf(float, long double);
extern long double nexttowardl(long double, long double);

extern float fdimf(float, float);
extern double fdim(double, double);
extern long double fdiml(long double, long double);

extern float fmaxf(float, float);
extern double fmax(double, double);
extern long double fmaxl(long double, long double);

extern float fminf(float, float);
extern double fmin(double, double);
extern long double fminl(long double, long double);

extern float fmaf(float, float, float);
extern double fma(double, double, double);
extern long double fmal(long double, long double, long double);
# 588 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/math.h" 3 4
extern float __exp10f(float) __attribute__((availability(macos,introduced=10.9))) __attribute__((availability(ios,introduced=7.0)));
extern double __exp10(double) __attribute__((availability(macos,introduced=10.9))) __attribute__((availability(ios,introduced=7.0)));





inline __attribute__ ((__always_inline__)) void __sincosf(float __x, float *__sinp, float *__cosp);
inline __attribute__ ((__always_inline__)) void __sincos(double __x, double *__sinp, double *__cosp);
# 605 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/math.h" 3 4
extern float __cospif(float) __attribute__((availability(macos,introduced=10.9))) __attribute__((availability(ios,introduced=7.0)));
extern double __cospi(double) __attribute__((availability(macos,introduced=10.9))) __attribute__((availability(ios,introduced=7.0)));
extern float __sinpif(float) __attribute__((availability(macos,introduced=10.9))) __attribute__((availability(ios,introduced=7.0)));
extern double __sinpi(double) __attribute__((availability(macos,introduced=10.9))) __attribute__((availability(ios,introduced=7.0)));
extern float __tanpif(float) __attribute__((availability(macos,introduced=10.9))) __attribute__((availability(ios,introduced=7.0)));
extern double __tanpi(double) __attribute__((availability(macos,introduced=10.9))) __attribute__((availability(ios,introduced=7.0)));
# 636 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/math.h" 3 4
inline __attribute__ ((__always_inline__)) void __sincospif(float __x, float *__sinp, float *__cosp);
inline __attribute__ ((__always_inline__)) void __sincospi(double __x, double *__sinp, double *__cosp);






struct __float2 { float __sinval; float __cosval; };
struct __double2 { double __sinval; double __cosval; };

extern struct __float2 __sincosf_stret(float);
extern struct __double2 __sincos_stret(double);
extern struct __float2 __sincospif_stret(float);
extern struct __double2 __sincospi_stret(double);

inline __attribute__ ((__always_inline__)) void __sincosf(float __x, float *__sinp, float *__cosp) {
    const struct __float2 __stret = __sincosf_stret(__x);
    *__sinp = __stret.__sinval; *__cosp = __stret.__cosval;
}

inline __attribute__ ((__always_inline__)) void __sincos(double __x, double *__sinp, double *__cosp) {
    const struct __double2 __stret = __sincos_stret(__x);
    *__sinp = __stret.__sinval; *__cosp = __stret.__cosval;
}

inline __attribute__ ((__always_inline__)) void __sincospif(float __x, float *__sinp, float *__cosp) {
    const struct __float2 __stret = __sincospif_stret(__x);
    *__sinp = __stret.__sinval; *__cosp = __stret.__cosval;
}

inline __attribute__ ((__always_inline__)) void __sincospi(double __x, double *__sinp, double *__cosp) {
    const struct __double2 __stret = __sincospi_stret(__x);
    *__sinp = __stret.__sinval; *__cosp = __stret.__cosval;
}







extern double j0(double) __attribute__((availability(macos,introduced=10.0))) __attribute__((availability(ios,introduced=3.2)));
extern double j1(double) __attribute__((availability(macos,introduced=10.0))) __attribute__((availability(ios,introduced=3.2)));
extern double jn(int, double) __attribute__((availability(macos,introduced=10.0))) __attribute__((availability(ios,introduced=3.2)));
extern double y0(double) __attribute__((availability(macos,introduced=10.0))) __attribute__((availability(ios,introduced=3.2)));
extern double y1(double) __attribute__((availability(macos,introduced=10.0))) __attribute__((availability(ios,introduced=3.2)));
extern double yn(int, double) __attribute__((availability(macos,introduced=10.0))) __attribute__((availability(ios,introduced=3.2)));
extern double scalb(double, double);
extern int signgam;
# 774 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/math.h" 3 4
}
# 301 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/math.h" 2 3





extern "C++" {

# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/stdlib.h" 1 3
# 309 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/math.h" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 1 3
# 420 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cstddef" 1 3
# 37 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cstddef" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/version" 1 3
# 172 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/version" 3
# 38 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cstddef" 2 3
# 41 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cstddef" 3



# 1 "/Library/Developer/CommandLineTools/usr/lib/clang/13.1.6/include/stddef.h" 1 3
# 35 "/Library/Developer/CommandLineTools/usr/lib/clang/13.1.6/include/stddef.h" 3
typedef long int ptrdiff_t;
# 102 "/Library/Developer/CommandLineTools/usr/lib/clang/13.1.6/include/stddef.h" 3
# 1 "/Library/Developer/CommandLineTools/usr/lib/clang/13.1.6/include/__stddef_max_align_t.h" 1 3
# 16 "/Library/Developer/CommandLineTools/usr/lib/clang/13.1.6/include/__stddef_max_align_t.h" 3
typedef long double max_align_t;
# 103 "/Library/Developer/CommandLineTools/usr/lib/clang/13.1.6/include/stddef.h" 2 3
# 45 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cstddef" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__nullptr" 1 3
# 17 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__nullptr" 3
# 54 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__nullptr" 3
namespace std
{
    typedef decltype(nullptr) nullptr_t;
}
# 46 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cstddef" 2 3

namespace std { inline namespace __1 {

using ::ptrdiff_t __attribute__((using_if_exists));
using ::size_t __attribute__((using_if_exists));


using ::max_align_t __attribute__((using_if_exists));


template <class _Tp> struct __libcpp_is_integral { enum { value = 0 }; };
template <> struct __libcpp_is_integral<bool> { enum { value = 1 }; };
template <> struct __libcpp_is_integral<char> { enum { value = 1 }; };
template <> struct __libcpp_is_integral<signed char> { enum { value = 1 }; };
template <> struct __libcpp_is_integral<unsigned char> { enum { value = 1 }; };

template <> struct __libcpp_is_integral<wchar_t> { enum { value = 1 }; };





template <> struct __libcpp_is_integral<char16_t> { enum { value = 1 }; };
template <> struct __libcpp_is_integral<char32_t> { enum { value = 1 }; };

template <> struct __libcpp_is_integral<short> { enum { value = 1 }; };
template <> struct __libcpp_is_integral<unsigned short> { enum { value = 1 }; };
template <> struct __libcpp_is_integral<int> { enum { value = 1 }; };
template <> struct __libcpp_is_integral<unsigned int> { enum { value = 1 }; };
template <> struct __libcpp_is_integral<long> { enum { value = 1 }; };
template <> struct __libcpp_is_integral<unsigned long> { enum { value = 1 }; };
template <> struct __libcpp_is_integral<long long> { enum { value = 1 }; };
template <> struct __libcpp_is_integral<unsigned long long> { enum { value = 1 }; };

template <> struct __libcpp_is_integral<__int128_t> { enum { value = 1 }; };
template <> struct __libcpp_is_integral<__uint128_t> { enum { value = 1 }; };


} }


namespace std
{
enum class byte : unsigned char {};


template <bool> struct __enable_if_integral_imp {};
template <> struct __enable_if_integral_imp<true> { using type = byte; };
template <class _Tp> using _EnableByteOverload = typename __enable_if_integral_imp<__libcpp_is_integral<_Tp>::value>::type;

constexpr byte operator| (byte __lhs, byte __rhs) noexcept
{
    return static_cast<byte>(
      static_cast<unsigned char>(
         static_cast<unsigned int>(__lhs) | static_cast<unsigned int>(__rhs)
    ));
}

constexpr byte& operator|=(byte& __lhs, byte __rhs) noexcept
{ return __lhs = __lhs | __rhs; }

constexpr byte operator& (byte __lhs, byte __rhs) noexcept
{
    return static_cast<byte>(
      static_cast<unsigned char>(
         static_cast<unsigned int>(__lhs) & static_cast<unsigned int>(__rhs)
    ));
}

constexpr byte& operator&=(byte& __lhs, byte __rhs) noexcept
{ return __lhs = __lhs & __rhs; }

constexpr byte operator^ (byte __lhs, byte __rhs) noexcept
{
    return static_cast<byte>(
      static_cast<unsigned char>(
         static_cast<unsigned int>(__lhs) ^ static_cast<unsigned int>(__rhs)
    ));
}

constexpr byte& operator^=(byte& __lhs, byte __rhs) noexcept
{ return __lhs = __lhs ^ __rhs; }

constexpr byte operator~ (byte __b) noexcept
{
    return static_cast<byte>(
      static_cast<unsigned char>(
        ~static_cast<unsigned int>(__b)
    ));
}
template <class _Integer>
  constexpr _EnableByteOverload<_Integer> &
  operator<<=(byte& __lhs, _Integer __shift) noexcept
  { return __lhs = __lhs << __shift; }

template <class _Integer>
  constexpr _EnableByteOverload<_Integer>
  operator<< (byte __lhs, _Integer __shift) noexcept
  { return static_cast<byte>(static_cast<unsigned char>(static_cast<unsigned int>(__lhs) << __shift)); }

template <class _Integer>
  constexpr _EnableByteOverload<_Integer> &
  operator>>=(byte& __lhs, _Integer __shift) noexcept
  { return __lhs = __lhs >> __shift; }

template <class _Integer>
  constexpr _EnableByteOverload<_Integer>
  operator>> (byte __lhs, _Integer __shift) noexcept
  { return static_cast<byte>(static_cast<unsigned char>(static_cast<unsigned int>(__lhs) >> __shift)); }

template <class _Integer, class = _EnableByteOverload<_Integer> >
                        constexpr _Integer
  to_integer(byte __b) noexcept { return static_cast<_Integer>(__b); }
}
# 421 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 2 3
# 425 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 3


namespace std { inline namespace __1 {

template <class _T1, class _T2> struct __attribute__ ((__type_visibility__("default"))) pair;
template <class _Tp> class __attribute__ ((__type_visibility__("default"))) reference_wrapper;
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) hash;

template <class _Tp, _Tp __v>
struct __attribute__ ((__type_visibility__("default"))) integral_constant
{
  static constexpr const _Tp value = __v;
  typedef _Tp value_type;
  typedef integral_constant type;
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  constexpr operator value_type() const noexcept {return value;}

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  constexpr value_type operator ()() const noexcept {return value;}

};

template <class _Tp, _Tp __v>
constexpr const _Tp integral_constant<_Tp, __v>::value;


template <bool __b>
using bool_constant = integral_constant<bool, __b>;





typedef bool_constant<(true)> true_type;
typedef bool_constant<(false)> false_type;

template <bool _Val>
using _BoolConstant = integral_constant<bool, _Val>;

template <bool> struct _MetaBase;
template <>
struct _MetaBase<true> {
  template <class _Tp, class _Up>
  using _SelectImpl = _Tp;
  template <template <class...> class _FirstFn, template <class...> class, class ..._Args>
  using _SelectApplyImpl = _FirstFn<_Args...>;
  template <class _First, class...>
  using _FirstImpl = _First;
  template <class, class _Second, class...>
  using _SecondImpl = _Second;
  template <class _Tp = void>
  using _EnableIfImpl = _Tp;
  template <class _Result, class _First, class ..._Rest>
  using _OrImpl = typename _MetaBase<_First::value != true && sizeof...(_Rest) != 0>::template _OrImpl<_First, _Rest...>;
};

template <>
struct _MetaBase<false> {
  template <class _Tp, class _Up>
  using _SelectImpl = _Up;
  template <template <class...> class, template <class...> class _SecondFn, class ..._Args>
  using _SelectApplyImpl = _SecondFn<_Args...>;
  template <class _Result, class ...>
  using _OrImpl = _Result;
};
template <bool _Cond, class _Ret = void>
using _EnableIf = typename _MetaBase<_Cond>::template _EnableIfImpl<_Ret>;
template <bool _Cond, class _IfRes, class _ElseRes>
using _If = typename _MetaBase<_Cond>::template _SelectImpl<_IfRes, _ElseRes>;
template <class ..._Rest>
using _Or = typename _MetaBase< sizeof...(_Rest) != 0 >::template _OrImpl<false_type, _Rest...>;
template <class _Pred>
struct _Not : _BoolConstant<!_Pred::value> {};
template <class ..._Args>
using _FirstType = typename _MetaBase<(sizeof...(_Args) >= 1)>::template _FirstImpl<_Args...>;
template <class ..._Args>
using _SecondType = typename _MetaBase<(sizeof...(_Args) >= 2)>::template _SecondImpl<_Args...>;

template <class ...> using __expand_to_true = true_type;
template <class ..._Pred>
__expand_to_true<_EnableIf<_Pred::value>...> __and_helper(int);
template <class ...>
false_type __and_helper(...);
template <class ..._Pred>
using _And = decltype(__and_helper<_Pred...>(0));

template <template <class...> class _Func, class ..._Args>
struct _Lazy : _Func<_Args...> {};



template <template <class...> class _Templ, class ..._Args, class = _Templ<_Args...> >
true_type __sfinae_test_impl(int);
template <template <class...> class, class ...>
false_type __sfinae_test_impl(...);

template <template <class ...> class _Templ, class ..._Args>
using _IsValidExpansion = decltype(__sfinae_test_impl<_Templ, _Args...>(0));

template <class>
struct __void_t { typedef void type; };

template <class _Tp>
struct __identity { typedef _Tp type; };

template <class _Tp>
using __identity_t = typename __identity<_Tp>::type;

template <class _Tp, bool>
struct __attribute__ ((__type_visibility__("default"))) __dependent_type : public _Tp {};


template <bool _Bp, class _If, class _Then>
    struct __attribute__ ((__type_visibility__("default"))) conditional {typedef _If type;};
template <class _If, class _Then>
    struct __attribute__ ((__type_visibility__("default"))) conditional<false, _If, _Then> {typedef _Then type;};


template <bool _Bp, class _If, class _Then> using conditional_t = typename conditional<_Bp, _If, _Then>::type;


template <bool, class _Tp = void> struct __attribute__ ((__type_visibility__("default"))) enable_if {};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) enable_if<true, _Tp> {typedef _Tp type;};


template <bool _Bp, class _Tp = void> using enable_if_t = typename enable_if<_Bp, _Tp>::type;






template <class _Tp, class _Up>
struct __attribute__ ((__type_visibility__("default"))) is_same : _BoolConstant<__is_same(_Tp, _Up)> { };


template <class _Tp, class _Up>
inline constexpr bool is_same_v = __is_same(_Tp, _Up);
# 578 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 3
template <class _Tp, class _Up>
using _IsSame = _BoolConstant<

    __is_same(_Tp, _Up)



>;

template <class _Tp, class _Up>
using _IsNotSame = _BoolConstant<

    !__is_same(_Tp, _Up)



>;


template <class _Tp>
using __test_for_primary_template = _EnableIf<
    _IsSame<_Tp, typename _Tp::__primary_template>::value
  >;
template <class _Tp>
using __is_primary_template = _IsValidExpansion<
    __test_for_primary_template, _Tp
  >;

struct __two {char __lx[2];};







template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) is_const : _BoolConstant<__is_const(_Tp)> { };


template <class _Tp>
inline constexpr bool is_const_v = __is_const(_Tp);
# 639 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 3
template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) is_volatile : _BoolConstant<__is_volatile(_Tp)> { };


template <class _Tp>
inline constexpr bool is_volatile_v = __is_volatile(_Tp);
# 673 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 3
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) remove_const {typedef _Tp type;};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) remove_const<const _Tp> {typedef _Tp type;};

template <class _Tp> using remove_const_t = typename remove_const<_Tp>::type;
# 694 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 3
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) remove_volatile {typedef _Tp type;};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) remove_volatile<volatile _Tp> {typedef _Tp type;};

template <class _Tp> using remove_volatile_t = typename remove_volatile<_Tp>::type;
# 715 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 3
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) remove_cv
{typedef typename remove_volatile<typename remove_const<_Tp>::type>::type type;};

template <class _Tp> using remove_cv_t = typename remove_cv<_Tp>::type;
# 727 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 3
template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) is_void : _BoolConstant<__is_void(_Tp)> { };


template <class _Tp>
inline constexpr bool is_void_v = __is_void(_Tp);
# 750 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 3
template <class _Tp> struct __is_nullptr_t_impl : public false_type {};
template <> struct __is_nullptr_t_impl<nullptr_t> : public true_type {};

template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) __is_nullptr_t
    : public __is_nullptr_t_impl<typename remove_cv<_Tp>::type> {};


template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_null_pointer
    : public __is_nullptr_t_impl<typename remove_cv<_Tp>::type> {};


template <class _Tp>
inline constexpr bool is_null_pointer_v
    = is_null_pointer<_Tp>::value;







template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) is_integral : _BoolConstant<__is_integral(_Tp)> { };


template <class _Tp>
inline constexpr bool is_integral_v = __is_integral(_Tp);
# 799 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 3
template <class _Tp> struct __libcpp_is_signed_integer : public false_type {};
template <> struct __libcpp_is_signed_integer<signed char> : public true_type {};
template <> struct __libcpp_is_signed_integer<signed short> : public true_type {};
template <> struct __libcpp_is_signed_integer<signed int> : public true_type {};
template <> struct __libcpp_is_signed_integer<signed long> : public true_type {};
template <> struct __libcpp_is_signed_integer<signed long long> : public true_type {};

template <> struct __libcpp_is_signed_integer<__int128_t> : public true_type {};


template <class _Tp> struct __libcpp_is_unsigned_integer : public false_type {};
template <> struct __libcpp_is_unsigned_integer<unsigned char> : public true_type {};
template <> struct __libcpp_is_unsigned_integer<unsigned short> : public true_type {};
template <> struct __libcpp_is_unsigned_integer<unsigned int> : public true_type {};
template <> struct __libcpp_is_unsigned_integer<unsigned long> : public true_type {};
template <> struct __libcpp_is_unsigned_integer<unsigned long long> : public true_type {};

template <> struct __libcpp_is_unsigned_integer<__uint128_t> : public true_type {};




template <class _Tp> struct __libcpp_is_floating_point : public false_type {};
template <> struct __libcpp_is_floating_point<float> : public true_type {};
template <> struct __libcpp_is_floating_point<double> : public true_type {};
template <> struct __libcpp_is_floating_point<long double> : public true_type {};

template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_floating_point
    : public __libcpp_is_floating_point<typename remove_cv<_Tp>::type> {};


template <class _Tp>
inline constexpr bool is_floating_point_v
    = is_floating_point<_Tp>::value;






template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) is_array : _BoolConstant<__is_array(_Tp)> { };


template <class _Tp>
inline constexpr bool is_array_v = __is_array(_Tp);
# 871 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 3
template<class _Tp>
struct __attribute__ ((__type_visibility__("default"))) is_pointer : _BoolConstant<__is_pointer(_Tp)> { };


template <class _Tp>
inline constexpr bool is_pointer_v = __is_pointer(_Tp);
# 909 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 3
template<class _Tp>
struct __attribute__ ((__type_visibility__("default"))) is_lvalue_reference : _BoolConstant<__is_lvalue_reference(_Tp)> { };

template<class _Tp>
struct __attribute__ ((__type_visibility__("default"))) is_rvalue_reference : _BoolConstant<__is_rvalue_reference(_Tp)> { };

template<class _Tp>
struct __attribute__ ((__type_visibility__("default"))) is_reference : _BoolConstant<__is_reference(_Tp)> { };


template <class _Tp>
inline constexpr bool is_reference_v = __is_reference(_Tp);

template <class _Tp>
inline constexpr bool is_lvalue_reference_v = __is_lvalue_reference(_Tp);

template <class _Tp>
inline constexpr bool is_rvalue_reference_v = __is_rvalue_reference(_Tp);
# 961 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 3
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_union
    : public integral_constant<bool, __is_union(_Tp)> {};
# 973 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 3
template <class _Tp>
inline constexpr bool is_union_v
    = is_union<_Tp>::value;






template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_class
    : public integral_constant<bool, __is_class(_Tp)> {};
# 999 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 3
template <class _Tp>
inline constexpr bool is_class_v
    = is_class<_Tp>::value;




template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_function
    : public _BoolConstant<

    __is_function(_Tp)



    > {};



template <class _Tp>
inline constexpr bool is_function_v
    = is_function<_Tp>::value;


template <class _Tp> struct __libcpp_is_member_pointer {
  enum {
    __is_member = false,
    __is_func = false,
    __is_obj = false
  };
};
template <class _Tp, class _Up> struct __libcpp_is_member_pointer<_Tp _Up::*> {
  enum {
    __is_member = true,
    __is_func = is_function<_Tp>::value,
    __is_obj = !__is_func,
  };
};



template<class _Tp>
struct __attribute__ ((__type_visibility__("default"))) is_member_function_pointer
    : _BoolConstant<__is_member_function_pointer(_Tp)> { };


template <class _Tp>
inline constexpr bool is_member_function_pointer_v
    = __is_member_function_pointer(_Tp);
# 1066 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 3
template<class _Tp>
struct __attribute__ ((__type_visibility__("default"))) is_member_pointer : _BoolConstant<__is_member_pointer(_Tp)> { };


template <class _Tp>
inline constexpr bool is_member_pointer_v = __is_member_pointer(_Tp);
# 1091 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 3
template<class _Tp>
struct __attribute__ ((__type_visibility__("default"))) is_member_object_pointer
    : _BoolConstant<__is_member_object_pointer(_Tp)> { };


template <class _Tp>
inline constexpr bool is_member_object_pointer_v
    = __is_member_object_pointer(_Tp);
# 1118 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 3
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_enum
    : public integral_constant<bool, __is_enum(_Tp)> {};


template <class _Tp>
inline constexpr bool is_enum_v = __is_enum(_Tp);
# 1151 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 3
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_arithmetic
    : public integral_constant<bool, is_integral<_Tp>::value ||
                                     is_floating_point<_Tp>::value> {};


template <class _Tp>
inline constexpr bool is_arithmetic_v
    = is_arithmetic<_Tp>::value;
# 1169 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 3
template<class _Tp>
struct __attribute__ ((__type_visibility__("default"))) is_fundamental : _BoolConstant<__is_fundamental(_Tp)> { };


template <class _Tp>
inline constexpr bool is_fundamental_v = __is_fundamental(_Tp);
# 1197 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 3
template<class _Tp>
struct __attribute__ ((__type_visibility__("default"))) is_scalar : _BoolConstant<__is_scalar(_Tp)> { };


template <class _Tp>
inline constexpr bool is_scalar_v = __is_scalar(_Tp);
# 1234 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 3
template<class _Tp>
struct __attribute__ ((__type_visibility__("default"))) is_object : _BoolConstant<__is_object(_Tp)> { };


template <class _Tp>
inline constexpr bool is_object_v = __is_object(_Tp);
# 1263 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 3
template<class _Tp>
struct __attribute__ ((__type_visibility__("default"))) is_compound : _BoolConstant<__is_compound(_Tp)> { };


template <class _Tp>
inline constexpr bool is_compound_v = __is_compound(_Tp);
# 1286 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 3
struct __is_referenceable_impl {
    template <class _Tp> static _Tp& __test(int);
    template <class _Tp> static __two __test(...);
};

template <class _Tp>
struct __is_referenceable : integral_constant<bool,
    _IsNotSame<decltype(__is_referenceable_impl::__test<_Tp>(0)), __two>::value> {};




template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) add_const {
  typedef const _Tp type;
};


template <class _Tp> using add_const_t = typename add_const<_Tp>::type;




template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) add_volatile {
  typedef volatile _Tp type;
};


template <class _Tp> using add_volatile_t = typename add_volatile<_Tp>::type;



template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) add_cv {
  typedef const volatile _Tp type;
};


template <class _Tp> using add_cv_t = typename add_cv<_Tp>::type;
# 1334 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 3
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) remove_reference {typedef _Tp type;};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) remove_reference<_Tp&> {typedef _Tp type;};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) remove_reference<_Tp&&> {typedef _Tp type;};


template <class _Tp> using remove_reference_t = typename remove_reference<_Tp>::type;






template <class _Tp, bool = __is_referenceable<_Tp>::value> struct __add_lvalue_reference_impl { typedef _Tp type; };
template <class _Tp > struct __add_lvalue_reference_impl<_Tp, true> { typedef _Tp& type; };

template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) add_lvalue_reference
{typedef typename __add_lvalue_reference_impl<_Tp>::type type;};


template <class _Tp> using add_lvalue_reference_t = typename add_lvalue_reference<_Tp>::type;


template <class _Tp, bool = __is_referenceable<_Tp>::value> struct __add_rvalue_reference_impl { typedef _Tp type; };
template <class _Tp > struct __add_rvalue_reference_impl<_Tp, true> { typedef _Tp&& type; };

template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) add_rvalue_reference
{typedef typename __add_rvalue_reference_impl<_Tp>::type type;};


template <class _Tp> using add_rvalue_reference_t = typename add_rvalue_reference<_Tp>::type;




#pragma GCC diagnostic push
# 1368 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 3
#pragma GCC diagnostic ignored "-Wdeprecated"
# 1368 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 3
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
template <class _Tp> _Tp&& __declval(int);
template <class _Tp> _Tp __declval(long);
#pragma GCC diagnostic pop

template <class _Tp>
decltype(__declval<_Tp>(0))
declval() noexcept;



template <class _Tp>
struct __uncvref {
    typedef typename remove_cv<typename remove_reference<_Tp>::type>::type type;
};

template <class _Tp>
struct __unconstref {
    typedef typename remove_const<typename remove_reference<_Tp>::type>::type type;
};


template <class _Tp>
using __uncvref_t = typename __uncvref<_Tp>::type;




template <class _Tp, class _Up>
struct __is_same_uncvref : _IsSame<typename __uncvref<_Tp>::type,
                                   typename __uncvref<_Up>::type> {};
# 1409 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 3
struct __any
{
    __any(...);
};



template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) remove_pointer {typedef _Tp type;};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) remove_pointer<_Tp*> {typedef _Tp type;};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) remove_pointer<_Tp* const> {typedef _Tp type;};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) remove_pointer<_Tp* volatile> {typedef _Tp type;};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) remove_pointer<_Tp* const volatile> {typedef _Tp type;};


template <class _Tp> using remove_pointer_t = typename remove_pointer<_Tp>::type;




template <class _Tp,
        bool = __is_referenceable<_Tp>::value ||
                _IsSame<typename remove_cv<_Tp>::type, void>::value>
struct __add_pointer_impl
    {typedef typename remove_reference<_Tp>::type* type;};
template <class _Tp> struct __add_pointer_impl<_Tp, false>
    {typedef _Tp type;};

template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) add_pointer
    {typedef typename __add_pointer_impl<_Tp>::type type;};


template <class _Tp> using add_pointer_t = typename add_pointer<_Tp>::type;
# 1455 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 3
template<class _Tp>
struct __attribute__ ((__type_visibility__("default"))) is_signed : _BoolConstant<__is_signed(_Tp)> { };


template <class _Tp>
inline constexpr bool is_signed_v = __is_signed(_Tp);
# 1504 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 3
template <class _Tp, bool = is_integral<_Tp>::value>
struct __libcpp_is_unsigned_impl : public bool_constant<(_Tp(0) < _Tp(-1))> {};

template <class _Tp>
struct __libcpp_is_unsigned_impl<_Tp, false> : public false_type {};

template <class _Tp, bool = is_arithmetic<_Tp>::value>
struct __libcpp_is_unsigned : public __libcpp_is_unsigned_impl<_Tp> {};

template <class _Tp> struct __libcpp_is_unsigned<_Tp, false> : public false_type {};

template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_unsigned : public __libcpp_is_unsigned<_Tp> {};


template <class _Tp>
inline constexpr bool is_unsigned_v
    = is_unsigned<_Tp>::value;






template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) rank
    : public integral_constant<size_t, 0> {};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) rank<_Tp[]>
    : public integral_constant<size_t, rank<_Tp>::value + 1> {};
template <class _Tp, size_t _Np> struct __attribute__ ((__type_visibility__("default"))) rank<_Tp[_Np]>
    : public integral_constant<size_t, rank<_Tp>::value + 1> {};


template <class _Tp>
inline constexpr size_t rank_v
    = rank<_Tp>::value;






template<class _Tp, size_t _Dim = 0>
struct __attribute__ ((__type_visibility__("default"))) extent
    : integral_constant<size_t, __array_extent(_Tp, _Dim)> { };


template <class _Tp, unsigned _Ip = 0>
inline constexpr size_t extent_v = __array_extent(_Tp, _Ip);
# 1576 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 3
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) remove_extent
    {typedef _Tp type;};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) remove_extent<_Tp[]>
    {typedef _Tp type;};
template <class _Tp, size_t _Np> struct __attribute__ ((__type_visibility__("default"))) remove_extent<_Tp[_Np]>
    {typedef _Tp type;};


template <class _Tp> using remove_extent_t = typename remove_extent<_Tp>::type;




template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) remove_all_extents
    {typedef _Tp type;};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) remove_all_extents<_Tp[]>
    {typedef typename remove_all_extents<_Tp>::type type;};
template <class _Tp, size_t _Np> struct __attribute__ ((__type_visibility__("default"))) remove_all_extents<_Tp[_Np]>
    {typedef typename remove_all_extents<_Tp>::type type;};


template <class _Tp> using remove_all_extents_t = typename remove_all_extents<_Tp>::type;
# 1622 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 3
template <class _Up, bool>
struct __decay {
    typedef typename remove_cv<_Up>::type type;
};

template <class _Up>
struct __decay<_Up, true> {
public:
    typedef typename conditional
                     <
                         is_array<_Up>::value,
                         typename remove_extent<_Up>::type*,
                         typename conditional
                         <
                              is_function<_Up>::value,
                              typename add_pointer<_Up>::type,
                              typename remove_cv<_Up>::type
                         >::type
                     >::type type;
};

template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) decay
{
private:
    typedef typename remove_reference<_Tp>::type _Up;
public:
    typedef typename __decay<_Up, __is_referenceable<_Up>::value>::type type;
};


template <class _Tp> using decay_t = typename decay<_Tp>::type;




template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_abstract
    : public integral_constant<bool, __is_abstract(_Tp)> {};


template <class _Tp>
inline constexpr bool is_abstract_v
    = is_abstract<_Tp>::value;




template <class _Tp> struct __attribute__ ((__type_visibility__("default")))
__libcpp_is_final : public integral_constant<bool, __is_final(_Tp)> {};


template <class _Tp> struct __attribute__ ((__type_visibility__("default")))
is_final : public integral_constant<bool, __is_final(_Tp)> {};



template <class _Tp>
inline constexpr bool is_final_v
    = is_final<_Tp>::value;





template <class _Tp> struct __attribute__ ((__type_visibility__("default")))
is_aggregate : public integral_constant<bool, __is_aggregate(_Tp)> {};


template <class _Tp>
inline constexpr bool is_aggregate_v
    = is_aggregate<_Tp>::value;






template <class _Bp, class _Dp>
struct __attribute__ ((__type_visibility__("default"))) is_base_of
    : public integral_constant<bool, __is_base_of(_Bp, _Dp)> {};


template <class _Bp, class _Dp>
inline constexpr bool is_base_of_v
    = is_base_of<_Bp, _Dp>::value;
# 1716 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 3
template <class _Tp, class _Up, class = void>
struct __is_core_convertible : public false_type {};

template <class _Tp, class _Up>
struct __is_core_convertible<_Tp, _Up, decltype(
    static_cast<void(*)(_Up)>(0) ( static_cast<_Tp(*)()>(0)() )
)> : public true_type {};





template <class _T1, class _T2> struct __attribute__ ((__type_visibility__("default"))) is_convertible
    : public integral_constant<bool, __is_convertible_to(_T1, _T2)> {};
# 1801 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 3
template <class _From, class _To>
inline constexpr bool is_convertible_v
    = is_convertible<_From, _To>::value;
# 1836 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 3
template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) is_empty
    : public integral_constant<bool, __is_empty(_Tp)> {};
# 1864 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 3
template <class _Tp>
inline constexpr bool is_empty_v
    = is_empty<_Tp>::value;






template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) is_polymorphic
    : public integral_constant<bool, __is_polymorphic(_Tp)> {};
# 1890 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 3
template <class _Tp>
inline constexpr bool is_polymorphic_v
    = is_polymorphic<_Tp>::value;






template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) has_virtual_destructor
    : public integral_constant<bool, __has_virtual_destructor(_Tp)> {};
# 1910 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 3
template <class _Tp>
inline constexpr bool has_virtual_destructor_v
    = has_virtual_destructor<_Tp>::value;






template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) has_unique_object_representations
    : public integral_constant<bool,
       __has_unique_object_representations(remove_cv_t<remove_all_extents_t<_Tp>>)> {};


template <class _Tp>
inline constexpr bool has_unique_object_representations_v
    = has_unique_object_representations<_Tp>::value;






template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) alignment_of
    : public integral_constant<size_t, alignof(_Tp)> {};


template <class _Tp>
inline constexpr size_t alignment_of_v
    = alignment_of<_Tp>::value;




template <class _Hp, class _Tp>
struct __type_list
{
    typedef _Hp _Head;
    typedef _Tp _Tail;
};

struct __nat
{

    __nat() = delete;
    __nat(const __nat&) = delete;
    __nat& operator=(const __nat&) = delete;
    ~__nat() = delete;

};

template <class _Tp>
struct __align_type
{
    static const size_t value = __alignof(_Tp);
    typedef _Tp type;
};

struct __struct_double {long double __lx;};
struct __struct_double4 {double __lx[4];};

typedef
    __type_list<__align_type<unsigned char>,
    __type_list<__align_type<unsigned short>,
    __type_list<__align_type<unsigned int>,
    __type_list<__align_type<unsigned long>,
    __type_list<__align_type<unsigned long long>,
    __type_list<__align_type<double>,
    __type_list<__align_type<long double>,
    __type_list<__align_type<__struct_double>,
    __type_list<__align_type<__struct_double4>,
    __type_list<__align_type<int*>,
    __nat
    > > > > > > > > > > __all_types;

template <size_t _Align>
struct alignas(_Align) __fallback_overaligned {};

template <class _TL, size_t _Align> struct __find_pod;

template <class _Hp, size_t _Align>
struct __find_pod<__type_list<_Hp, __nat>, _Align>
{
    typedef typename conditional<
                             _Align == _Hp::value,
                             typename _Hp::type,
                             __fallback_overaligned<_Align>
                         >::type type;
};

template <class _Hp, class _Tp, size_t _Align>
struct __find_pod<__type_list<_Hp, _Tp>, _Align>
{
    typedef typename conditional<
                             _Align == _Hp::value,
                             typename _Hp::type,
                             typename __find_pod<_Tp, _Align>::type
                         >::type type;
};

template <class _TL, size_t _Len> struct __find_max_align;

template <class _Hp, size_t _Len>
struct __find_max_align<__type_list<_Hp, __nat>, _Len> : public integral_constant<size_t, _Hp::value> {};

template <size_t _Len, size_t _A1, size_t _A2>
struct __select_align
{
private:
    static const size_t __min = _A2 < _A1 ? _A2 : _A1;
    static const size_t __max = _A1 < _A2 ? _A2 : _A1;
public:
    static const size_t value = _Len < __max ? __min : __max;
};

template <class _Hp, class _Tp, size_t _Len>
struct __find_max_align<__type_list<_Hp, _Tp>, _Len>
    : public integral_constant<size_t, __select_align<_Len, _Hp::value, __find_max_align<_Tp, _Len>::value>::value> {};

template <size_t _Len, size_t _Align = __find_max_align<__all_types, _Len>::value>
struct __attribute__ ((__type_visibility__("default"))) aligned_storage
{
    typedef typename __find_pod<__all_types, _Align>::type _Aligner;
    union type
    {
        _Aligner __align;
        unsigned char __data[(_Len + _Align - 1)/_Align * _Align];
    };
};


template <size_t _Len, size_t _Align = __find_max_align<__all_types, _Len>::value>
    using aligned_storage_t = typename aligned_storage<_Len, _Align>::type;
# 2055 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 3
template <size_t _Len>struct __attribute__ ((__type_visibility__("default"))) aligned_storage<_Len, 0x1>{ struct alignas(0x1) type { unsigned char __lx[(_Len + 0x1 - 1)/0x1 * 0x1]; };};
template <size_t _Len>struct __attribute__ ((__type_visibility__("default"))) aligned_storage<_Len, 0x2>{ struct alignas(0x2) type { unsigned char __lx[(_Len + 0x2 - 1)/0x2 * 0x2]; };};
template <size_t _Len>struct __attribute__ ((__type_visibility__("default"))) aligned_storage<_Len, 0x4>{ struct alignas(0x4) type { unsigned char __lx[(_Len + 0x4 - 1)/0x4 * 0x4]; };};
template <size_t _Len>struct __attribute__ ((__type_visibility__("default"))) aligned_storage<_Len, 0x8>{ struct alignas(0x8) type { unsigned char __lx[(_Len + 0x8 - 1)/0x8 * 0x8]; };};
template <size_t _Len>struct __attribute__ ((__type_visibility__("default"))) aligned_storage<_Len, 0x10>{ struct alignas(0x10) type { unsigned char __lx[(_Len + 0x10 - 1)/0x10 * 0x10]; };};
template <size_t _Len>struct __attribute__ ((__type_visibility__("default"))) aligned_storage<_Len, 0x20>{ struct alignas(0x20) type { unsigned char __lx[(_Len + 0x20 - 1)/0x20 * 0x20]; };};
template <size_t _Len>struct __attribute__ ((__type_visibility__("default"))) aligned_storage<_Len, 0x40>{ struct alignas(0x40) type { unsigned char __lx[(_Len + 0x40 - 1)/0x40 * 0x40]; };};
template <size_t _Len>struct __attribute__ ((__type_visibility__("default"))) aligned_storage<_Len, 0x80>{ struct alignas(0x80) type { unsigned char __lx[(_Len + 0x80 - 1)/0x80 * 0x80]; };};
template <size_t _Len>struct __attribute__ ((__type_visibility__("default"))) aligned_storage<_Len, 0x100>{ struct alignas(0x100) type { unsigned char __lx[(_Len + 0x100 - 1)/0x100 * 0x100]; };};
template <size_t _Len>struct __attribute__ ((__type_visibility__("default"))) aligned_storage<_Len, 0x200>{ struct alignas(0x200) type { unsigned char __lx[(_Len + 0x200 - 1)/0x200 * 0x200]; };};
template <size_t _Len>struct __attribute__ ((__type_visibility__("default"))) aligned_storage<_Len, 0x400>{ struct alignas(0x400) type { unsigned char __lx[(_Len + 0x400 - 1)/0x400 * 0x400]; };};
template <size_t _Len>struct __attribute__ ((__type_visibility__("default"))) aligned_storage<_Len, 0x800>{ struct alignas(0x800) type { unsigned char __lx[(_Len + 0x800 - 1)/0x800 * 0x800]; };};
template <size_t _Len>struct __attribute__ ((__type_visibility__("default"))) aligned_storage<_Len, 0x1000>{ struct alignas(0x1000) type { unsigned char __lx[(_Len + 0x1000 - 1)/0x1000 * 0x1000]; };};
template <size_t _Len>struct __attribute__ ((__type_visibility__("default"))) aligned_storage<_Len, 0x2000>{ struct alignas(0x2000) type { unsigned char __lx[(_Len + 0x2000 - 1)/0x2000 * 0x2000]; };};


template <size_t _Len>struct __attribute__ ((__type_visibility__("default"))) aligned_storage<_Len, 0x4000>{ struct alignas(0x4000) type { unsigned char __lx[(_Len + 0x4000 - 1)/0x4000 * 0x4000]; };};







template <size_t _I0, size_t ..._In>
struct __static_max;

template <size_t _I0>
struct __static_max<_I0>
{
    static const size_t value = _I0;
};

template <size_t _I0, size_t _I1, size_t ..._In>
struct __static_max<_I0, _I1, _In...>
{
    static const size_t value = _I0 >= _I1 ? __static_max<_I0, _In...>::value :
                                             __static_max<_I1, _In...>::value;
};

template <size_t _Len, class _Type0, class ..._Types>
struct aligned_union
{
    static const size_t alignment_value = __static_max<__alignof(_Type0),
                                                       __alignof(_Types)...>::value;
    static const size_t __len = __static_max<_Len, sizeof(_Type0),
                                             sizeof(_Types)...>::value;
    typedef typename aligned_storage<__len, alignment_value>::type type;
};


template <size_t _Len, class ..._Types> using aligned_union_t = typename aligned_union<_Len, _Types...>::type;


template <class _Tp>
struct __numeric_type
{
   static void __test(...);
   static float __test(float);
   static double __test(char);
   static double __test(int);
   static double __test(unsigned);
   static double __test(long);
   static double __test(unsigned long);
   static double __test(long long);
   static double __test(unsigned long long);
   static double __test(double);
   static long double __test(long double);

   typedef decltype(__test(declval<_Tp>())) type;
   static const bool value = _IsNotSame<type, void>::value;
};

template <>
struct __numeric_type<void>
{
   static const bool value = true;
};



template <class _A1, class _A2 = void, class _A3 = void,
          bool = __numeric_type<_A1>::value &&
                 __numeric_type<_A2>::value &&
                 __numeric_type<_A3>::value>
class __promote_imp
{
public:
    static const bool value = false;
};

template <class _A1, class _A2, class _A3>
class __promote_imp<_A1, _A2, _A3, true>
{
private:
    typedef typename __promote_imp<_A1>::type __type1;
    typedef typename __promote_imp<_A2>::type __type2;
    typedef typename __promote_imp<_A3>::type __type3;
public:
    typedef decltype(__type1() + __type2() + __type3()) type;
    static const bool value = true;
};

template <class _A1, class _A2>
class __promote_imp<_A1, _A2, void, true>
{
private:
    typedef typename __promote_imp<_A1>::type __type1;
    typedef typename __promote_imp<_A2>::type __type2;
public:
    typedef decltype(__type1() + __type2()) type;
    static const bool value = true;
};

template <class _A1>
class __promote_imp<_A1, void, void, true>
{
public:
    typedef typename __numeric_type<_A1>::type type;
    static const bool value = true;
};

template <class _A1, class _A2 = void, class _A3 = void>
class __promote : public __promote_imp<_A1, _A2, _A3> {};



typedef
    __type_list<signed char,
    __type_list<signed short,
    __type_list<signed int,
    __type_list<signed long,
    __type_list<signed long long,

    __type_list<__int128_t,

    __nat

    >

    > > > > > __signed_types;

typedef
    __type_list<unsigned char,
    __type_list<unsigned short,
    __type_list<unsigned int,
    __type_list<unsigned long,
    __type_list<unsigned long long,

    __type_list<__uint128_t,

    __nat

    >

    > > > > > __unsigned_types;

template <class _TypeList, size_t _Size, bool = _Size <= sizeof(typename _TypeList::_Head)> struct __find_first;

template <class _Hp, class _Tp, size_t _Size>
struct __find_first<__type_list<_Hp, _Tp>, _Size, true>
{
    typedef _Hp type;
};

template <class _Hp, class _Tp, size_t _Size>
struct __find_first<__type_list<_Hp, _Tp>, _Size, false>
{
    typedef typename __find_first<_Tp, _Size>::type type;
};

template <class _Tp, class _Up, bool = is_const<typename remove_reference<_Tp>::type>::value,
                             bool = is_volatile<typename remove_reference<_Tp>::type>::value>
struct __apply_cv
{
    typedef _Up type;
};

template <class _Tp, class _Up>
struct __apply_cv<_Tp, _Up, true, false>
{
    typedef const _Up type;
};

template <class _Tp, class _Up>
struct __apply_cv<_Tp, _Up, false, true>
{
    typedef volatile _Up type;
};

template <class _Tp, class _Up>
struct __apply_cv<_Tp, _Up, true, true>
{
    typedef const volatile _Up type;
};

template <class _Tp, class _Up>
struct __apply_cv<_Tp&, _Up, false, false>
{
    typedef _Up& type;
};

template <class _Tp, class _Up>
struct __apply_cv<_Tp&, _Up, true, false>
{
    typedef const _Up& type;
};

template <class _Tp, class _Up>
struct __apply_cv<_Tp&, _Up, false, true>
{
    typedef volatile _Up& type;
};

template <class _Tp, class _Up>
struct __apply_cv<_Tp&, _Up, true, true>
{
    typedef const volatile _Up& type;
};

template <class _Tp, bool = is_integral<_Tp>::value || is_enum<_Tp>::value>
struct __make_signed {};

template <class _Tp>
struct __make_signed<_Tp, true>
{
    typedef typename __find_first<__signed_types, sizeof(_Tp)>::type type;
};

template <> struct __make_signed<bool, true> {};
template <> struct __make_signed< signed short, true> {typedef short type;};
template <> struct __make_signed<unsigned short, true> {typedef short type;};
template <> struct __make_signed< signed int, true> {typedef int type;};
template <> struct __make_signed<unsigned int, true> {typedef int type;};
template <> struct __make_signed< signed long, true> {typedef long type;};
template <> struct __make_signed<unsigned long, true> {typedef long type;};
template <> struct __make_signed< signed long long, true> {typedef long long type;};
template <> struct __make_signed<unsigned long long, true> {typedef long long type;};

template <> struct __make_signed<__int128_t, true> {typedef __int128_t type;};
template <> struct __make_signed<__uint128_t, true> {typedef __int128_t type;};


template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) make_signed
{
    typedef typename __apply_cv<_Tp, typename __make_signed<typename remove_cv<_Tp>::type>::type>::type type;
};


template <class _Tp> using make_signed_t = typename make_signed<_Tp>::type;


template <class _Tp, bool = is_integral<_Tp>::value || is_enum<_Tp>::value>
struct __make_unsigned {};

template <class _Tp>
struct __make_unsigned<_Tp, true>
{
    typedef typename __find_first<__unsigned_types, sizeof(_Tp)>::type type;
};

template <> struct __make_unsigned<bool, true> {};
template <> struct __make_unsigned< signed short, true> {typedef unsigned short type;};
template <> struct __make_unsigned<unsigned short, true> {typedef unsigned short type;};
template <> struct __make_unsigned< signed int, true> {typedef unsigned int type;};
template <> struct __make_unsigned<unsigned int, true> {typedef unsigned int type;};
template <> struct __make_unsigned< signed long, true> {typedef unsigned long type;};
template <> struct __make_unsigned<unsigned long, true> {typedef unsigned long type;};
template <> struct __make_unsigned< signed long long, true> {typedef unsigned long long type;};
template <> struct __make_unsigned<unsigned long long, true> {typedef unsigned long long type;};

template <> struct __make_unsigned<__int128_t, true> {typedef __uint128_t type;};
template <> struct __make_unsigned<__uint128_t, true> {typedef __uint128_t type;};


template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) make_unsigned
{
    typedef typename __apply_cv<_Tp, typename __make_unsigned<typename remove_cv<_Tp>::type>::type>::type type;
};


template <class _Tp> using make_unsigned_t = typename make_unsigned<_Tp>::type;



template <class _Tp>
[[nodiscard]] __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
typename make_unsigned<_Tp>::type __to_unsigned_like(_Tp __x) noexcept {
    return static_cast<typename make_unsigned<_Tp>::type>(__x);
}



template <class...> using void_t = void;
# 2371 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 3
template <class _Tp, class _Up, class = void>
struct __common_type2_imp {};



template <class _Tp, class _Up>
struct __common_type2_imp<_Tp, _Up,
                          typename __void_t<decltype(
                                            true ? declval<_Tp>() : declval<_Up>()
                                            )>::type>
{
  typedef typename decay<decltype(
                         true ? declval<_Tp>() : declval<_Up>()
                         )>::type type;
};

template <class, class = void>
struct __common_type_impl {};




template <class... Tp>
struct __common_types;
template <class... _Tp>
struct __attribute__ ((__type_visibility__("default"))) common_type;
# 2410 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 3
template <class _Tp, class _Up>
struct __common_type_impl<
    __common_types<_Tp, _Up>,
    typename __void_t<typename common_type<_Tp, _Up>::type>::type>
{
  typedef typename common_type<_Tp, _Up>::type type;
};

template <class _Tp, class _Up, class _Vp , class... _Rest>
struct __common_type_impl<
    __common_types<_Tp, _Up, _Vp , _Rest...>,
    typename __void_t<typename common_type<_Tp, _Up>::type>::type>
    : __common_type_impl<__common_types<typename common_type<_Tp, _Up>::type,
                                        _Vp , _Rest...> > {
};



template <>
struct __attribute__ ((__type_visibility__("default"))) common_type<> {};



template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) common_type<_Tp>
    : public common_type<_Tp, _Tp> {};




template <class _Tp, class _Up>
struct __attribute__ ((__type_visibility__("default"))) common_type<_Tp, _Up>
    : conditional<
        _IsSame<_Tp, typename decay<_Tp>::type>::value && _IsSame<_Up, typename decay<_Up>::type>::value,
        __common_type2_imp<_Tp, _Up>,
        common_type<typename decay<_Tp>::type, typename decay<_Up>::type>
    >::type
{};



template <class _Tp, class _Up, class _Vp , class... _Rest>
struct __attribute__ ((__type_visibility__("default")))
    common_type<_Tp, _Up, _Vp , _Rest...>
    : __common_type_impl<
          __common_types<_Tp, _Up, _Vp , _Rest...> > {};




template <class ..._Tp> using common_type_t = typename common_type<_Tp...>::type;





template <class _From, class _To>
struct __copy_cv
{
    using type = _To;
};

template <class _From, class _To>
struct __copy_cv<const _From, _To>
{
    using type = add_const_t<_To>;
};

template <class _From, class _To>
struct __copy_cv<volatile _From, _To>
{
    using type = add_volatile_t<_To>;
};

template <class _From, class _To>
struct __copy_cv<const volatile _From, _To>
{
    using type = add_cv_t<_To>;
};

template <class _From, class _To>
using __copy_cv_t = typename __copy_cv<_From, _To>::type;

template <class _From, class _To>
struct __copy_cvref
{
    using type = __copy_cv_t<_From, _To>;
};

template <class _From, class _To>
struct __copy_cvref<_From&, _To>
{
    using type = add_lvalue_reference_t<__copy_cv_t<_From, _To>>;
};

template <class _From, class _To>
struct __copy_cvref<_From&&, _To>
{
    using type = add_rvalue_reference_t<__copy_cv_t<_From, _To>>;
};

template <class _From, class _To>
using __copy_cvref_t = typename __copy_cvref<_From, _To>::type;
# 2675 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 3
template<typename, typename _Tp> struct __select_2nd { typedef _Tp type; };



template<class _Tp, class _Up>
struct __attribute__ ((__type_visibility__("default"))) is_assignable : _BoolConstant<__is_assignable(_Tp, _Up)> { };


template <class _Tp, class _Arg>
inline constexpr bool is_assignable_v = __is_assignable(_Tp, _Arg);
# 2721 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 3
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_copy_assignable
    : public is_assignable<typename add_lvalue_reference<_Tp>::type,
                  typename add_lvalue_reference<typename add_const<_Tp>::type>::type> {};


template <class _Tp>
inline constexpr bool is_copy_assignable_v
    = is_copy_assignable<_Tp>::value;




template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_move_assignable
    : public is_assignable<typename add_lvalue_reference<_Tp>::type,
                           typename add_rvalue_reference<_Tp>::type> {};


template <class _Tp>
inline constexpr bool is_move_assignable_v
    = is_move_assignable<_Tp>::value;
# 2764 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 3
template <class>
struct __is_destructible_apply { typedef int type; };

template <typename _Tp>
struct __is_destructor_wellformed {
    template <typename _Tp1>
    static char __test (
        typename __is_destructible_apply<decltype(declval<_Tp1&>().~_Tp1())>::type
    );

    template <typename _Tp1>
    static __two __test (...);

    static const bool value = sizeof(__test<_Tp>(12)) == sizeof(char);
};

template <class _Tp, bool>
struct __destructible_imp;

template <class _Tp>
struct __destructible_imp<_Tp, false>
   : public integral_constant<bool,
        __is_destructor_wellformed<typename remove_all_extents<_Tp>::type>::value> {};

template <class _Tp>
struct __destructible_imp<_Tp, true>
    : public true_type {};

template <class _Tp, bool>
struct __destructible_false;

template <class _Tp>
struct __destructible_false<_Tp, false> : public __destructible_imp<_Tp, is_reference<_Tp>::value> {};

template <class _Tp>
struct __destructible_false<_Tp, true> : public false_type {};

template <class _Tp>
struct is_destructible
    : public __destructible_false<_Tp, is_function<_Tp>::value> {};

template <class _Tp>
struct is_destructible<_Tp[]>
    : public false_type {};

template <>
struct is_destructible<void>
    : public false_type {};


template <class _Tp>
inline constexpr bool is_destructible_v
    = is_destructible<_Tp>::value;




template <class _MP, bool _IsMemberFunctionPtr, bool _IsMemberObjectPtr>
struct __member_pointer_traits_imp
{
};

template <class _Rp, class _Class, class ..._Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...), true, false>
{
    typedef _Class _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_Param...);
};

template <class _Rp, class _Class, class ..._Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...), true, false>
{
    typedef _Class _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_Param..., ...);
};

template <class _Rp, class _Class, class ..._Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const, true, false>
{
    typedef _Class const _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_Param...);
};

template <class _Rp, class _Class, class ..._Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) const, true, false>
{
    typedef _Class const _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_Param..., ...);
};

template <class _Rp, class _Class, class ..._Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) volatile, true, false>
{
    typedef _Class volatile _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_Param...);
};

template <class _Rp, class _Class, class ..._Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) volatile, true, false>
{
    typedef _Class volatile _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_Param..., ...);
};

template <class _Rp, class _Class, class ..._Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const volatile, true, false>
{
    typedef _Class const volatile _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_Param...);
};

template <class _Rp, class _Class, class ..._Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) const volatile, true, false>
{
    typedef _Class const volatile _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_Param..., ...);
};



template <class _Rp, class _Class, class ..._Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) &, true, false>
{
    typedef _Class& _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_Param...);
};

template <class _Rp, class _Class, class ..._Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) &, true, false>
{
    typedef _Class& _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_Param..., ...);
};

template <class _Rp, class _Class, class ..._Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const&, true, false>
{
    typedef _Class const& _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_Param...);
};

template <class _Rp, class _Class, class ..._Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) const&, true, false>
{
    typedef _Class const& _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_Param..., ...);
};

template <class _Rp, class _Class, class ..._Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) volatile&, true, false>
{
    typedef _Class volatile& _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_Param...);
};

template <class _Rp, class _Class, class ..._Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) volatile&, true, false>
{
    typedef _Class volatile& _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_Param..., ...);
};

template <class _Rp, class _Class, class ..._Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const volatile&, true, false>
{
    typedef _Class const volatile& _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_Param...);
};

template <class _Rp, class _Class, class ..._Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) const volatile&, true, false>
{
    typedef _Class const volatile& _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_Param..., ...);
};

template <class _Rp, class _Class, class ..._Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) &&, true, false>
{
    typedef _Class&& _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_Param...);
};

template <class _Rp, class _Class, class ..._Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) &&, true, false>
{
    typedef _Class&& _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_Param..., ...);
};

template <class _Rp, class _Class, class ..._Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const&&, true, false>
{
    typedef _Class const&& _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_Param...);
};

template <class _Rp, class _Class, class ..._Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) const&&, true, false>
{
    typedef _Class const&& _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_Param..., ...);
};

template <class _Rp, class _Class, class ..._Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) volatile&&, true, false>
{
    typedef _Class volatile&& _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_Param...);
};

template <class _Rp, class _Class, class ..._Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) volatile&&, true, false>
{
    typedef _Class volatile&& _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_Param..., ...);
};

template <class _Rp, class _Class, class ..._Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const volatile&&, true, false>
{
    typedef _Class const volatile&& _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_Param...);
};

template <class _Rp, class _Class, class ..._Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) const volatile&&, true, false>
{
    typedef _Class const volatile&& _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_Param..., ...);
};




template <class _Rp, class _Class>
struct __member_pointer_traits_imp<_Rp _Class::*, false, true>
{
    typedef _Class _ClassType;
    typedef _Rp _ReturnType;
};

template <class _MP>
struct __member_pointer_traits
    : public __member_pointer_traits_imp<typename remove_cv<_MP>::type,
                    is_member_function_pointer<_MP>::value,
                    is_member_object_pointer<_MP>::value>
{



};


template <class _DecayedFp>
struct __member_pointer_class_type {};

template <class _Ret, class _ClassType>
struct __member_pointer_class_type<_Ret _ClassType::*> {
  typedef _ClassType type;
};
# 3172 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 3
template <class _Tp, class ..._Args>
struct __attribute__ ((__type_visibility__("default"))) is_constructible
    : public integral_constant<bool, __is_constructible(_Tp, _Args...)>
    {};







template <class _Tp, class ..._Args>
inline constexpr bool is_constructible_v
    = is_constructible<_Tp, _Args...>::value;




template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) is_default_constructible
    : public is_constructible<_Tp>
    {};


template <class _Tp>
inline constexpr bool is_default_constructible_v
    = is_default_constructible<_Tp>::value;







template <class _Tp>
void __test_implicit_default_constructible(_Tp);

template <class _Tp, class = void, class = typename is_default_constructible<_Tp>::type>
struct __is_implicitly_default_constructible
    : false_type
{ };

template <class _Tp>
struct __is_implicitly_default_constructible<_Tp, decltype(__test_implicit_default_constructible<_Tp const&>({})), true_type>
    : true_type
{ };

template <class _Tp>
struct __is_implicitly_default_constructible<_Tp, decltype(__test_implicit_default_constructible<_Tp const&>({})), false_type>
    : false_type
{ };




template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) is_copy_constructible
    : public is_constructible<_Tp,
                  typename add_lvalue_reference<typename add_const<_Tp>::type>::type> {};


template <class _Tp>
inline constexpr bool is_copy_constructible_v
    = is_copy_constructible<_Tp>::value;




template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) is_move_constructible
    : public is_constructible<_Tp, typename add_rvalue_reference<_Tp>::type>
    {};


template <class _Tp>
inline constexpr bool is_move_constructible_v
    = is_move_constructible<_Tp>::value;






template <class _Tp, class... _Args>
struct __attribute__ ((__type_visibility__("default"))) is_trivially_constructible
    : integral_constant<bool, __is_trivially_constructible(_Tp, _Args...)>
{
};
# 3301 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 3
template <class _Tp, class... _Args>
inline constexpr bool is_trivially_constructible_v
    = is_trivially_constructible<_Tp, _Args...>::value;




template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_trivially_default_constructible
    : public is_trivially_constructible<_Tp>
    {};


template <class _Tp>
inline constexpr bool is_trivially_default_constructible_v
    = is_trivially_default_constructible<_Tp>::value;




template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_trivially_copy_constructible
    : public is_trivially_constructible<_Tp, typename add_lvalue_reference<const _Tp>::type>
    {};


template <class _Tp>
inline constexpr bool is_trivially_copy_constructible_v
    = is_trivially_copy_constructible<_Tp>::value;




template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_trivially_move_constructible
    : public is_trivially_constructible<_Tp, typename add_rvalue_reference<_Tp>::type>
    {};


template <class _Tp>
inline constexpr bool is_trivially_move_constructible_v
    = is_trivially_move_constructible<_Tp>::value;






template <class _Tp, class _Arg>
struct is_trivially_assignable
    : integral_constant<bool, __is_trivially_assignable(_Tp, _Arg)>
{
};
# 3377 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 3
template <class _Tp, class _Arg>
inline constexpr bool is_trivially_assignable_v
    = is_trivially_assignable<_Tp, _Arg>::value;




template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_trivially_copy_assignable
    : public is_trivially_assignable<typename add_lvalue_reference<_Tp>::type,
                  typename add_lvalue_reference<typename add_const<_Tp>::type>::type> {};


template <class _Tp>
inline constexpr bool is_trivially_copy_assignable_v
    = is_trivially_copy_assignable<_Tp>::value;




template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_trivially_move_assignable
    : public is_trivially_assignable<typename add_lvalue_reference<_Tp>::type,
                                     typename add_rvalue_reference<_Tp>::type>
    {};


template <class _Tp>
inline constexpr bool is_trivially_move_assignable_v
    = is_trivially_move_assignable<_Tp>::value;






template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_trivially_destructible
    : public integral_constant<bool, __is_trivially_destructible(_Tp)> {};
# 3434 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 3
template <class _Tp>
inline constexpr bool is_trivially_destructible_v
    = is_trivially_destructible<_Tp>::value;






template <class _Tp, class... _Args>
struct __attribute__ ((__type_visibility__("default"))) is_nothrow_constructible
    : public integral_constant<bool, __is_nothrow_constructible(_Tp, _Args...)> {};
# 3488 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 3
template <class _Tp, class ..._Args>
inline constexpr bool is_nothrow_constructible_v
    = is_nothrow_constructible<_Tp, _Args...>::value;




template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_nothrow_default_constructible
    : public is_nothrow_constructible<_Tp>
    {};


template <class _Tp>
inline constexpr bool is_nothrow_default_constructible_v
    = is_nothrow_default_constructible<_Tp>::value;




template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_nothrow_copy_constructible
    : public is_nothrow_constructible<_Tp,
                  typename add_lvalue_reference<typename add_const<_Tp>::type>::type> {};


template <class _Tp>
inline constexpr bool is_nothrow_copy_constructible_v
    = is_nothrow_copy_constructible<_Tp>::value;




template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_nothrow_move_constructible
    : public is_nothrow_constructible<_Tp, typename add_rvalue_reference<_Tp>::type>
    {};


template <class _Tp>
inline constexpr bool is_nothrow_move_constructible_v
    = is_nothrow_move_constructible<_Tp>::value;






template <class _Tp, class _Arg>
struct __attribute__ ((__type_visibility__("default"))) is_nothrow_assignable
    : public integral_constant<bool, __is_nothrow_assignable(_Tp, _Arg)> {};
# 3562 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 3
template <class _Tp, class _Arg>
inline constexpr bool is_nothrow_assignable_v
    = is_nothrow_assignable<_Tp, _Arg>::value;




template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_nothrow_copy_assignable
    : public is_nothrow_assignable<typename add_lvalue_reference<_Tp>::type,
                  typename add_lvalue_reference<typename add_const<_Tp>::type>::type> {};


template <class _Tp>
inline constexpr bool is_nothrow_copy_assignable_v
    = is_nothrow_copy_assignable<_Tp>::value;




template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_nothrow_move_assignable
    : public is_nothrow_assignable<typename add_lvalue_reference<_Tp>::type,
                                     typename add_rvalue_reference<_Tp>::type>
    {};


template <class _Tp>
inline constexpr bool is_nothrow_move_assignable_v
    = is_nothrow_move_assignable<_Tp>::value;






template <bool, class _Tp> struct __libcpp_is_nothrow_destructible;

template <class _Tp>
struct __libcpp_is_nothrow_destructible<false, _Tp>
    : public false_type
{
};

template <class _Tp>
struct __libcpp_is_nothrow_destructible<true, _Tp>
    : public integral_constant<bool, noexcept(declval<_Tp>().~_Tp()) >
{
};

template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) is_nothrow_destructible
    : public __libcpp_is_nothrow_destructible<is_destructible<_Tp>::value, _Tp>
{
};

template <class _Tp, size_t _Ns>
struct __attribute__ ((__type_visibility__("default"))) is_nothrow_destructible<_Tp[_Ns]>
    : public is_nothrow_destructible<_Tp>
{
};

template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) is_nothrow_destructible<_Tp&>
    : public true_type
{
};

template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) is_nothrow_destructible<_Tp&&>
    : public true_type
{
};
# 3650 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 3
template <class _Tp>
inline constexpr bool is_nothrow_destructible_v
    = is_nothrow_destructible<_Tp>::value;






template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_pod
    : public integral_constant<bool, __is_pod(_Tp)> {};
# 3673 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 3
template <class _Tp>
inline constexpr bool is_pod_v
    = is_pod<_Tp>::value;





template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) __attribute__ ((deprecated)) is_literal_type
    : public integral_constant<bool, __is_literal_type(_Tp)>
    {};


template <class _Tp>
__attribute__ ((deprecated)) inline constexpr bool is_literal_type_v
    = is_literal_type<_Tp>::value;





template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_standard_layout

    : public integral_constant<bool, __is_standard_layout(_Tp)>



    {};


template <class _Tp>
inline constexpr bool is_standard_layout_v
    = is_standard_layout<_Tp>::value;




template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_trivially_copyable

    : public integral_constant<bool, __is_trivially_copyable(_Tp)>





    {};


template <class _Tp>
inline constexpr bool is_trivially_copyable_v
    = is_trivially_copyable<_Tp>::value;




template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_trivial

    : public integral_constant<bool, __is_trivial(_Tp)>




    {};


template <class _Tp>
inline constexpr bool is_trivial_v
    = is_trivial<_Tp>::value;


template <class _Tp> struct __is_reference_wrapper_impl : public false_type {};
template <class _Tp> struct __is_reference_wrapper_impl<reference_wrapper<_Tp> > : public true_type {};
template <class _Tp> struct __is_reference_wrapper
    : public __is_reference_wrapper_impl<typename remove_cv<_Tp>::type> {};



template <class _Fp, class _A0,
         class _DecayFp = typename decay<_Fp>::type,
         class _DecayA0 = typename decay<_A0>::type,
         class _ClassT = typename __member_pointer_class_type<_DecayFp>::type>
using __enable_if_bullet1 = typename enable_if
    <
        is_member_function_pointer<_DecayFp>::value
        && is_base_of<_ClassT, _DecayA0>::value
    >::type;

template <class _Fp, class _A0,
         class _DecayFp = typename decay<_Fp>::type,
         class _DecayA0 = typename decay<_A0>::type>
using __enable_if_bullet2 = typename enable_if
    <
        is_member_function_pointer<_DecayFp>::value
        && __is_reference_wrapper<_DecayA0>::value
    >::type;

template <class _Fp, class _A0,
         class _DecayFp = typename decay<_Fp>::type,
         class _DecayA0 = typename decay<_A0>::type,
         class _ClassT = typename __member_pointer_class_type<_DecayFp>::type>
using __enable_if_bullet3 = typename enable_if
    <
        is_member_function_pointer<_DecayFp>::value
        && !is_base_of<_ClassT, _DecayA0>::value
        && !__is_reference_wrapper<_DecayA0>::value
    >::type;

template <class _Fp, class _A0,
         class _DecayFp = typename decay<_Fp>::type,
         class _DecayA0 = typename decay<_A0>::type,
         class _ClassT = typename __member_pointer_class_type<_DecayFp>::type>
using __enable_if_bullet4 = typename enable_if
    <
        is_member_object_pointer<_DecayFp>::value
        && is_base_of<_ClassT, _DecayA0>::value
    >::type;

template <class _Fp, class _A0,
         class _DecayFp = typename decay<_Fp>::type,
         class _DecayA0 = typename decay<_A0>::type>
using __enable_if_bullet5 = typename enable_if
    <
        is_member_object_pointer<_DecayFp>::value
        && __is_reference_wrapper<_DecayA0>::value
    >::type;

template <class _Fp, class _A0,
         class _DecayFp = typename decay<_Fp>::type,
         class _DecayA0 = typename decay<_A0>::type,
         class _ClassT = typename __member_pointer_class_type<_DecayFp>::type>
using __enable_if_bullet6 = typename enable_if
    <
        is_member_object_pointer<_DecayFp>::value
        && !is_base_of<_ClassT, _DecayA0>::value
        && !__is_reference_wrapper<_DecayA0>::value
    >::type;
# 3818 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 3
template <class ..._Args>
auto __invoke(__any, _Args&& ...__args) -> __nat;

template <class ..._Args>
auto __invoke_constexpr(__any, _Args&& ...__args) -> __nat;



template <class _Fp, class _A0, class ..._Args,
          class = __enable_if_bullet1<_Fp, _A0>>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
                              auto
__invoke(_Fp&& __f, _A0&& __a0, _Args&& ...__args)
noexcept(noexcept((static_cast<_A0&&>(__a0).*__f)(static_cast<_Args&&>(__args)...))) -> decltype((static_cast<_A0&&>(__a0).*__f)(static_cast<_Args&&>(__args)...)) { return (static_cast<_A0&&>(__a0).*__f)(static_cast<_Args&&>(__args)...); }

template <class _Fp, class _A0, class ..._Args,
          class = __enable_if_bullet1<_Fp, _A0>>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
constexpr auto
__invoke_constexpr(_Fp&& __f, _A0&& __a0, _Args&& ...__args)
noexcept(noexcept((static_cast<_A0&&>(__a0).*__f)(static_cast<_Args&&>(__args)...))) -> decltype((static_cast<_A0&&>(__a0).*__f)(static_cast<_Args&&>(__args)...)) { return (static_cast<_A0&&>(__a0).*__f)(static_cast<_Args&&>(__args)...); }

template <class _Fp, class _A0, class ..._Args,
          class = __enable_if_bullet2<_Fp, _A0>>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
                              auto
__invoke(_Fp&& __f, _A0&& __a0, _Args&& ...__args)
noexcept(noexcept((__a0.get().*__f)(static_cast<_Args&&>(__args)...))) -> decltype((__a0.get().*__f)(static_cast<_Args&&>(__args)...)) { return (__a0.get().*__f)(static_cast<_Args&&>(__args)...); }

template <class _Fp, class _A0, class ..._Args,
          class = __enable_if_bullet2<_Fp, _A0>>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
constexpr auto
__invoke_constexpr(_Fp&& __f, _A0&& __a0, _Args&& ...__args)
noexcept(noexcept((__a0.get().*__f)(static_cast<_Args&&>(__args)...))) -> decltype((__a0.get().*__f)(static_cast<_Args&&>(__args)...)) { return (__a0.get().*__f)(static_cast<_Args&&>(__args)...); }

template <class _Fp, class _A0, class ..._Args,
          class = __enable_if_bullet3<_Fp, _A0>>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
                              auto
__invoke(_Fp&& __f, _A0&& __a0, _Args&& ...__args)
noexcept(noexcept(((*static_cast<_A0&&>(__a0)).*__f)(static_cast<_Args&&>(__args)...))) -> decltype(((*static_cast<_A0&&>(__a0)).*__f)(static_cast<_Args&&>(__args)...)) { return ((*static_cast<_A0&&>(__a0)).*__f)(static_cast<_Args&&>(__args)...); }

template <class _Fp, class _A0, class ..._Args,
          class = __enable_if_bullet3<_Fp, _A0>>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
constexpr auto
__invoke_constexpr(_Fp&& __f, _A0&& __a0, _Args&& ...__args)
noexcept(noexcept(((*static_cast<_A0&&>(__a0)).*__f)(static_cast<_Args&&>(__args)...))) -> decltype(((*static_cast<_A0&&>(__a0)).*__f)(static_cast<_Args&&>(__args)...)) { return ((*static_cast<_A0&&>(__a0)).*__f)(static_cast<_Args&&>(__args)...); }



template <class _Fp, class _A0,
          class = __enable_if_bullet4<_Fp, _A0>>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
                              auto
__invoke(_Fp&& __f, _A0&& __a0)
noexcept(noexcept(static_cast<_A0&&>(__a0).*__f)) -> decltype(static_cast<_A0&&>(__a0).*__f) { return static_cast<_A0&&>(__a0).*__f; }

template <class _Fp, class _A0,
          class = __enable_if_bullet4<_Fp, _A0>>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
constexpr auto
__invoke_constexpr(_Fp&& __f, _A0&& __a0)
noexcept(noexcept(static_cast<_A0&&>(__a0).*__f)) -> decltype(static_cast<_A0&&>(__a0).*__f) { return static_cast<_A0&&>(__a0).*__f; }

template <class _Fp, class _A0,
          class = __enable_if_bullet5<_Fp, _A0>>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
                              auto
__invoke(_Fp&& __f, _A0&& __a0)
noexcept(noexcept(__a0.get().*__f)) -> decltype(__a0.get().*__f) { return __a0.get().*__f; }

template <class _Fp, class _A0,
          class = __enable_if_bullet5<_Fp, _A0>>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
constexpr auto
__invoke_constexpr(_Fp&& __f, _A0&& __a0)
noexcept(noexcept(__a0.get().*__f)) -> decltype(__a0.get().*__f) { return __a0.get().*__f; }

template <class _Fp, class _A0,
          class = __enable_if_bullet6<_Fp, _A0>>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
                              auto
__invoke(_Fp&& __f, _A0&& __a0)
noexcept(noexcept((*static_cast<_A0&&>(__a0)).*__f)) -> decltype((*static_cast<_A0&&>(__a0)).*__f) { return (*static_cast<_A0&&>(__a0)).*__f; }

template <class _Fp, class _A0,
          class = __enable_if_bullet6<_Fp, _A0>>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
constexpr auto
__invoke_constexpr(_Fp&& __f, _A0&& __a0)
noexcept(noexcept((*static_cast<_A0&&>(__a0)).*__f)) -> decltype((*static_cast<_A0&&>(__a0)).*__f) { return (*static_cast<_A0&&>(__a0)).*__f; }



template <class _Fp, class ..._Args>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
                              auto
__invoke(_Fp&& __f, _Args&& ...__args)
noexcept(noexcept(static_cast<_Fp&&>(__f)(static_cast<_Args&&>(__args)...))) -> decltype(static_cast<_Fp&&>(__f)(static_cast<_Args&&>(__args)...)) { return static_cast<_Fp&&>(__f)(static_cast<_Args&&>(__args)...); }

template <class _Fp, class ..._Args>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
constexpr auto
__invoke_constexpr(_Fp&& __f, _Args&& ...__args)
noexcept(noexcept(static_cast<_Fp&&>(__f)(static_cast<_Args&&>(__args)...))) -> decltype(static_cast<_Fp&&>(__f)(static_cast<_Args&&>(__args)...)) { return static_cast<_Fp&&>(__f)(static_cast<_Args&&>(__args)...); }




template <class _Ret, class _Fp, class ..._Args>
struct __invokable_r
{
  template <class _XFp, class ..._XArgs>
  static auto __try_call(int) -> decltype(
    std::__1::__invoke(declval<_XFp>(), declval<_XArgs>()...));
  template <class _XFp, class ..._XArgs>
  static __nat __try_call(...);



  using _Result = decltype(__try_call<_Fp, _Args...>(0));

  using type =
  typename conditional<
      _IsNotSame<_Result, __nat>::value,
      typename conditional<
          is_void<_Ret>::value,
          true_type,
          is_convertible<_Result, _Ret>
      >::type,
      false_type
  >::type;
  static const bool value = type::value;
};
template <class _Fp, class ..._Args>
using __invokable = __invokable_r<void, _Fp, _Args...>;

template <bool _IsInvokable, bool _IsCVVoid, class _Ret, class _Fp, class ..._Args>
struct __nothrow_invokable_r_imp {
  static const bool value = false;
};

template <class _Ret, class _Fp, class ..._Args>
struct __nothrow_invokable_r_imp<true, false, _Ret, _Fp, _Args...>
{
    typedef __nothrow_invokable_r_imp _ThisT;

    template <class _Tp>
    static void __test_noexcept(_Tp) noexcept;

    static const bool value = noexcept(_ThisT::__test_noexcept<_Ret>(
        std::__1::__invoke(declval<_Fp>(), declval<_Args>()...)));
};

template <class _Ret, class _Fp, class ..._Args>
struct __nothrow_invokable_r_imp<true, true, _Ret, _Fp, _Args...>
{
    static const bool value = noexcept(
        std::__1::__invoke(declval<_Fp>(), declval<_Args>()...));
};

template <class _Ret, class _Fp, class ..._Args>
using __nothrow_invokable_r =
    __nothrow_invokable_r_imp<
            __invokable_r<_Ret, _Fp, _Args...>::value,
            is_void<_Ret>::value,
            _Ret, _Fp, _Args...
    >;

template <class _Fp, class ..._Args>
using __nothrow_invokable =
    __nothrow_invokable_r_imp<
            __invokable<_Fp, _Args...>::value,
            true, void, _Fp, _Args...
    >;

template <class _Fp, class ..._Args>
struct __invoke_of
    : public enable_if<
        __invokable<_Fp, _Args...>::value,
        typename __invokable_r<void, _Fp, _Args...>::_Result>
{
};






template <class _Callable> class __attribute__ ((deprecated)) result_of;



template <class _Fp, class ..._Args>
class __attribute__ ((__type_visibility__("default"))) result_of<_Fp(_Args...)>
    : public __invoke_of<_Fp, _Args...>
{
};
# 4097 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 3
template <class _Tp> using result_of_t __attribute__ ((deprecated)) = typename result_of<_Tp>::type;







template <class _Fn, class... _Args>
struct __attribute__ ((__type_visibility__("default"))) invoke_result
    : __invoke_of<_Fn, _Args...>
{
};

template <class _Fn, class... _Args>
using invoke_result_t = typename invoke_result<_Fn, _Args...>::type;



template <class _Fn, class ..._Args>
struct __attribute__ ((__type_visibility__("default"))) is_invocable
    : integral_constant<bool, __invokable<_Fn, _Args...>::value> {};

template <class _Ret, class _Fn, class ..._Args>
struct __attribute__ ((__type_visibility__("default"))) is_invocable_r
    : integral_constant<bool, __invokable_r<_Ret, _Fn, _Args...>::value> {};

template <class _Fn, class ..._Args>
inline constexpr bool is_invocable_v
    = is_invocable<_Fn, _Args...>::value;

template <class _Ret, class _Fn, class ..._Args>
inline constexpr bool is_invocable_r_v
    = is_invocable_r<_Ret, _Fn, _Args...>::value;



template <class _Fn, class ..._Args>
struct __attribute__ ((__type_visibility__("default"))) is_nothrow_invocable
    : integral_constant<bool, __nothrow_invokable<_Fn, _Args...>::value> {};

template <class _Ret, class _Fn, class ..._Args>
struct __attribute__ ((__type_visibility__("default"))) is_nothrow_invocable_r
    : integral_constant<bool, __nothrow_invokable_r<_Ret, _Fn, _Args...>::value> {};

template <class _Fn, class ..._Args>
inline constexpr bool is_nothrow_invocable_v
    = is_nothrow_invocable<_Fn, _Args...>::value;

template <class _Ret, class _Fn, class ..._Args>
inline constexpr bool is_nothrow_invocable_r_v
    = is_nothrow_invocable_r<_Ret, _Fn, _Args...>::value;





template <class _Tp> struct __is_swappable;
template <class _Tp> struct __is_nothrow_swappable;



template <class _Tp>
using __swap_result_t = typename enable_if<is_move_constructible<_Tp>::value && is_move_assignable<_Tp>::value>::type;





template <class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
                              __swap_result_t<_Tp>
swap(_Tp& __x, _Tp& __y) noexcept(is_nothrow_move_constructible<_Tp>::value && is_nothrow_move_assignable<_Tp>::value);


template<class _Tp, size_t _Np>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename enable_if<
    __is_swappable<_Tp>::value
>::type
swap(_Tp (&__a)[_Np], _Tp (&__b)[_Np]) noexcept(__is_nothrow_swappable<_Tp>::value);

namespace __detail
{


template <class _Tp, class _Up = _Tp,
          bool _NotVoid = !is_void<_Tp>::value && !is_void<_Up>::value>
struct __swappable_with
{
    template <class _LHS, class _RHS>
    static decltype(swap(declval<_LHS>(), declval<_RHS>()))
    __test_swap(int);
    template <class, class>
    static __nat __test_swap(long);


    typedef decltype((__test_swap<_Tp, _Up>(0))) __swap1;
    typedef decltype((__test_swap<_Up, _Tp>(0))) __swap2;

    static const bool value = _IsNotSame<__swap1, __nat>::value
                           && _IsNotSame<__swap2, __nat>::value;
};

template <class _Tp, class _Up>
struct __swappable_with<_Tp, _Up, false> : false_type {};

template <class _Tp, class _Up = _Tp, bool _Swappable = __swappable_with<_Tp, _Up>::value>
struct __nothrow_swappable_with {
  static const bool value =

      noexcept(swap(declval<_Tp>(), declval<_Up>()))
  && noexcept(swap(declval<_Up>(), declval<_Tp>()));



};

template <class _Tp, class _Up>
struct __nothrow_swappable_with<_Tp, _Up, false> : false_type {};

}

template <class _Tp>
struct __is_swappable
    : public integral_constant<bool, __detail::__swappable_with<_Tp&>::value>
{
};

template <class _Tp>
struct __is_nothrow_swappable
    : public integral_constant<bool, __detail::__nothrow_swappable_with<_Tp&>::value>
{
};



template <class _Tp, class _Up>
struct __attribute__ ((__type_visibility__("default"))) is_swappable_with
    : public integral_constant<bool, __detail::__swappable_with<_Tp, _Up>::value>
{
};

template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) is_swappable
    : public conditional<
        __is_referenceable<_Tp>::value,
        is_swappable_with<
            typename add_lvalue_reference<_Tp>::type,
            typename add_lvalue_reference<_Tp>::type>,
        false_type
    >::type
{
};

template <class _Tp, class _Up>
struct __attribute__ ((__type_visibility__("default"))) is_nothrow_swappable_with
    : public integral_constant<bool, __detail::__nothrow_swappable_with<_Tp, _Up>::value>
{
};

template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) is_nothrow_swappable
    : public conditional<
        __is_referenceable<_Tp>::value,
        is_nothrow_swappable_with<
            typename add_lvalue_reference<_Tp>::type,
            typename add_lvalue_reference<_Tp>::type>,
        false_type
    >::type
{
};

template <class _Tp, class _Up>
inline constexpr bool is_swappable_with_v
    = is_swappable_with<_Tp, _Up>::value;

template <class _Tp>
inline constexpr bool is_swappable_v
    = is_swappable<_Tp>::value;

template <class _Tp, class _Up>
inline constexpr bool is_nothrow_swappable_with_v
    = is_nothrow_swappable_with<_Tp, _Up>::value;

template <class _Tp>
inline constexpr bool is_nothrow_swappable_v
    = is_nothrow_swappable<_Tp>::value;



template <class _Tp, bool = is_enum<_Tp>::value> struct __underlying_type_impl;

template <class _Tp>
struct __underlying_type_impl<_Tp, false> {};

template <class _Tp>
struct __underlying_type_impl<_Tp, true>
{
    typedef __underlying_type(_Tp) type;
};

template <class _Tp>
struct underlying_type : __underlying_type_impl<_Tp, is_enum<_Tp>::value> {};


template <class _Tp> using underlying_type_t = typename underlying_type<_Tp>::type;


template <class _Tp, bool = is_enum<_Tp>::value>
struct __sfinae_underlying_type
{
    typedef typename underlying_type<_Tp>::type type;
    typedef decltype(((type)1) + 0) __promoted_type;
};

template <class _Tp>
struct __sfinae_underlying_type<_Tp, false> {};

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
int __convert_to_integral(int __val) { return __val; }

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
unsigned __convert_to_integral(unsigned __val) { return __val; }

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
long __convert_to_integral(long __val) { return __val; }

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
unsigned long __convert_to_integral(unsigned long __val) { return __val; }

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
long long __convert_to_integral(long long __val) { return __val; }

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
unsigned long long __convert_to_integral(unsigned long long __val) {return __val; }

template<typename _Fp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
typename enable_if<is_floating_point<_Fp>::value, long long>::type
 __convert_to_integral(_Fp __val) { return __val; }


inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
__int128_t __convert_to_integral(__int128_t __val) { return __val; }

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
__uint128_t __convert_to_integral(__uint128_t __val) { return __val; }


template <class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
typename __sfinae_underlying_type<_Tp>::__promoted_type
__convert_to_integral(_Tp __val) { return __val; }



template <class _Tp>
struct __has_operator_addressof_member_imp
{
    template <class _Up>
        static auto __test(int)
            -> typename __select_2nd<decltype(declval<_Up>().operator&()), true_type>::type;
    template <class>
        static auto __test(long) -> false_type;

    static const bool value = decltype(__test<_Tp>(0))::value;
};

template <class _Tp>
struct __has_operator_addressof_free_imp
{
    template <class _Up>
        static auto __test(int)
            -> typename __select_2nd<decltype(operator&(declval<_Up>())), true_type>::type;
    template <class>
        static auto __test(long) -> false_type;

    static const bool value = decltype(__test<_Tp>(0))::value;
};

template <class _Tp>
struct __has_operator_addressof
    : public integral_constant<bool, __has_operator_addressof_member_imp<_Tp>::value
                                  || __has_operator_addressof_free_imp<_Tp>::value>
{};
# 4407 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 3
template <class... _Args>
struct conjunction : _And<_Args...> {};
template<class... _Args>
inline constexpr bool conjunction_v
    = conjunction<_Args...>::value;

template <class... _Args>
struct disjunction : _Or<_Args...> {};
template<class... _Args>
inline constexpr bool disjunction_v
    = disjunction<_Args...>::value;

template <class _Tp>
struct negation : _Not<_Tp> {};
template<class _Tp>
inline constexpr bool negation_v
    = negation<_Tp>::value;



struct __extract_key_fail_tag {};
struct __extract_key_self_tag {};
struct __extract_key_first_tag {};

template <class _ValTy, class _Key,
          class _RawValTy = typename __unconstref<_ValTy>::type>
struct __can_extract_key
    : conditional<_IsSame<_RawValTy, _Key>::value, __extract_key_self_tag,
                  __extract_key_fail_tag>::type {};

template <class _Pair, class _Key, class _First, class _Second>
struct __can_extract_key<_Pair, _Key, pair<_First, _Second> >
    : conditional<_IsSame<typename remove_const<_First>::type, _Key>::value,
                  __extract_key_first_tag, __extract_key_fail_tag>::type {};




template <class _ValTy, class _Key, class _ContainerValueTy,
          class _RawValTy = typename __unconstref<_ValTy>::type>
struct __can_extract_map_key
    : integral_constant<bool, _IsSame<_RawValTy, _Key>::value> {};



template <class _ValTy, class _Key, class _RawValTy>
struct __can_extract_map_key<_ValTy, _Key, _Key, _RawValTy>
    : false_type {};
# 4464 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 3
inline constexpr
bool __libcpp_is_constant_evaluated() noexcept { return __builtin_is_constant_evaluated(); }





template <class _CharT>
using _IsCharLikeType = _And<is_standard_layout<_CharT>, is_trivial<_CharT> >;

template<class _Tp>
using __make_const_lvalue_ref = const typename remove_reference<_Tp>::type&;






} }



namespace std
{


}







# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__utility/forward.h" 1 3
# 14 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__utility/forward.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 1 3
# 4498 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__utility/forward.h" 1 3
# 4499 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__utility/move.h" 1 3
# 14 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__utility/move.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 1 3
# 4498 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__utility/forward.h" 1 3
# 4499 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__utility/move.h" 1 3
# 4500 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 2 3
# 15 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__utility/move.h" 2 3
# 18 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__utility/move.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 22 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__utility/move.h" 2 3

namespace std { inline namespace __1 {

template <class _Tp>
                      inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr typename remove_reference<_Tp>::type&&
move(_Tp&& __t) noexcept {
  typedef typename remove_reference<_Tp>::type _Up;
  return static_cast<_Up&&>(__t);
}


template <class _Tp>
using __move_if_noexcept_result_t =
    typename conditional<!is_nothrow_move_constructible<_Tp>::value && is_copy_constructible<_Tp>::value, const _Tp&,
                         _Tp&&>::type;





template <class _Tp>
                      inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr __move_if_noexcept_result_t<_Tp>
move_if_noexcept(_Tp& __x) noexcept {
  return std::__1::move(__x);
}

} }
# 4500 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 2 3
# 15 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__utility/forward.h" 2 3
# 18 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__utility/forward.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 22 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__utility/forward.h" 2 3

namespace std { inline namespace __1 {

template <class _Tp>
                      inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr _Tp&&
forward(typename remove_reference<_Tp>::type& __t) noexcept {
  return static_cast<_Tp&&>(__t);
}

template <class _Tp>
                      inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr _Tp&&
forward(typename remove_reference<_Tp>::type&& __t) noexcept {
  static_assert(!is_lvalue_reference<_Tp>::value, "cannot forward an rvalue as an lvalue");
  return static_cast<_Tp&&>(__t);
}

} }
# 4499 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 2 3
# 310 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/math.h" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/limits" 1 3
# 105 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/limits" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 1 3
# 106 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/limits" 2 3
# 117 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/limits" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 121 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/limits" 2 3



namespace std { inline namespace __1 {

enum float_round_style
{
    round_indeterminate = -1,
    round_toward_zero = 0,
    round_to_nearest = 1,
    round_toward_infinity = 2,
    round_toward_neg_infinity = 3
};

enum float_denorm_style
{
    denorm_indeterminate = -1,
    denorm_absent = 0,
    denorm_present = 1
};

template <class _Tp, bool = is_arithmetic<_Tp>::value>
class __libcpp_numeric_limits
{
protected:
    typedef _Tp type;

    static constexpr const bool is_specialized = false;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) static constexpr type min() noexcept {return type();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) static constexpr type max() noexcept {return type();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) static constexpr type lowest() noexcept {return type();}

    static constexpr const int digits = 0;
    static constexpr const int digits10 = 0;
    static constexpr const int max_digits10 = 0;
    static constexpr const bool is_signed = false;
    static constexpr const bool is_integer = false;
    static constexpr const bool is_exact = false;
    static constexpr const int radix = 0;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) static constexpr type epsilon() noexcept {return type();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) static constexpr type round_error() noexcept {return type();}

    static constexpr const int min_exponent = 0;
    static constexpr const int min_exponent10 = 0;
    static constexpr const int max_exponent = 0;
    static constexpr const int max_exponent10 = 0;

    static constexpr const bool has_infinity = false;
    static constexpr const bool has_quiet_NaN = false;
    static constexpr const bool has_signaling_NaN = false;
    static constexpr const float_denorm_style has_denorm = denorm_absent;
    static constexpr const bool has_denorm_loss = false;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) static constexpr type infinity() noexcept {return type();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) static constexpr type quiet_NaN() noexcept {return type();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) static constexpr type signaling_NaN() noexcept {return type();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) static constexpr type denorm_min() noexcept {return type();}

    static constexpr const bool is_iec559 = false;
    static constexpr const bool is_bounded = false;
    static constexpr const bool is_modulo = false;

    static constexpr const bool traps = false;
    static constexpr const bool tinyness_before = false;
    static constexpr const float_round_style round_style = round_toward_zero;
};

template <class _Tp, int __digits, bool _IsSigned>
struct __libcpp_compute_min
{
    static constexpr const _Tp value = _Tp(_Tp(1) << __digits);
};

template <class _Tp, int __digits>
struct __libcpp_compute_min<_Tp, __digits, false>
{
    static constexpr const _Tp value = _Tp(0);
};

template <class _Tp>
class __libcpp_numeric_limits<_Tp, true>
{
protected:
    typedef _Tp type;

    static constexpr const bool is_specialized = true;

    static constexpr const bool is_signed = type(-1) < type(0);
    static constexpr const int digits = static_cast<int>(sizeof(type) * 8 - is_signed);
    static constexpr const int digits10 = digits * 3 / 10;
    static constexpr const int max_digits10 = 0;
    static constexpr const type __min = __libcpp_compute_min<type, digits, is_signed>::value;
    static constexpr const type __max = is_signed ? type(type(~0) ^ __min) : type(~0);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) static constexpr type min() noexcept {return __min;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) static constexpr type max() noexcept {return __max;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) static constexpr type lowest() noexcept {return min();}

    static constexpr const bool is_integer = true;
    static constexpr const bool is_exact = true;
    static constexpr const int radix = 2;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) static constexpr type epsilon() noexcept {return type(0);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) static constexpr type round_error() noexcept {return type(0);}

    static constexpr const int min_exponent = 0;
    static constexpr const int min_exponent10 = 0;
    static constexpr const int max_exponent = 0;
    static constexpr const int max_exponent10 = 0;

    static constexpr const bool has_infinity = false;
    static constexpr const bool has_quiet_NaN = false;
    static constexpr const bool has_signaling_NaN = false;
    static constexpr const float_denorm_style has_denorm = denorm_absent;
    static constexpr const bool has_denorm_loss = false;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) static constexpr type infinity() noexcept {return type(0);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) static constexpr type quiet_NaN() noexcept {return type(0);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) static constexpr type signaling_NaN() noexcept {return type(0);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) static constexpr type denorm_min() noexcept {return type(0);}

    static constexpr const bool is_iec559 = false;
    static constexpr const bool is_bounded = true;
    static constexpr const bool is_modulo = !std::__1::is_signed<_Tp>::value;





    static constexpr const bool traps = false;

    static constexpr const bool tinyness_before = false;
    static constexpr const float_round_style round_style = round_toward_zero;
};

template <>
class __libcpp_numeric_limits<bool, true>
{
protected:
    typedef bool type;

    static constexpr const bool is_specialized = true;

    static constexpr const bool is_signed = false;
    static constexpr const int digits = 1;
    static constexpr const int digits10 = 0;
    static constexpr const int max_digits10 = 0;
    static constexpr const type __min = false;
    static constexpr const type __max = true;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) static constexpr type min() noexcept {return __min;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) static constexpr type max() noexcept {return __max;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) static constexpr type lowest() noexcept {return min();}

    static constexpr const bool is_integer = true;
    static constexpr const bool is_exact = true;
    static constexpr const int radix = 2;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) static constexpr type epsilon() noexcept {return type(0);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) static constexpr type round_error() noexcept {return type(0);}

    static constexpr const int min_exponent = 0;
    static constexpr const int min_exponent10 = 0;
    static constexpr const int max_exponent = 0;
    static constexpr const int max_exponent10 = 0;

    static constexpr const bool has_infinity = false;
    static constexpr const bool has_quiet_NaN = false;
    static constexpr const bool has_signaling_NaN = false;
    static constexpr const float_denorm_style has_denorm = denorm_absent;
    static constexpr const bool has_denorm_loss = false;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) static constexpr type infinity() noexcept {return type(0);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) static constexpr type quiet_NaN() noexcept {return type(0);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) static constexpr type signaling_NaN() noexcept {return type(0);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) static constexpr type denorm_min() noexcept {return type(0);}

    static constexpr const bool is_iec559 = false;
    static constexpr const bool is_bounded = true;
    static constexpr const bool is_modulo = false;

    static constexpr const bool traps = false;
    static constexpr const bool tinyness_before = false;
    static constexpr const float_round_style round_style = round_toward_zero;
};

template <>
class __libcpp_numeric_limits<float, true>
{
protected:
    typedef float type;

    static constexpr const bool is_specialized = true;

    static constexpr const bool is_signed = true;
    static constexpr const int digits = 24;
    static constexpr const int digits10 = 6;
    static constexpr const int max_digits10 = 2+(digits * 30103l)/100000l;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) static constexpr type min() noexcept {return 1.17549435e-38F;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) static constexpr type max() noexcept {return 3.40282347e+38F;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) static constexpr type lowest() noexcept {return -max();}

    static constexpr const bool is_integer = false;
    static constexpr const bool is_exact = false;
    static constexpr const int radix = 2;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) static constexpr type epsilon() noexcept {return 1.19209290e-7F;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) static constexpr type round_error() noexcept {return 0.5F;}

    static constexpr const int min_exponent = (-125);
    static constexpr const int min_exponent10 = (-37);
    static constexpr const int max_exponent = 128;
    static constexpr const int max_exponent10 = 38;

    static constexpr const bool has_infinity = true;
    static constexpr const bool has_quiet_NaN = true;
    static constexpr const bool has_signaling_NaN = true;
    static constexpr const float_denorm_style has_denorm = denorm_present;
    static constexpr const bool has_denorm_loss = false;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) static constexpr type infinity() noexcept {return __builtin_huge_valf();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) static constexpr type quiet_NaN() noexcept {return __builtin_nanf("");}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) static constexpr type signaling_NaN() noexcept {return __builtin_nansf("");}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) static constexpr type denorm_min() noexcept {return 1.40129846e-45F;}

    static constexpr const bool is_iec559 = true;
    static constexpr const bool is_bounded = true;
    static constexpr const bool is_modulo = false;

    static constexpr const bool traps = false;
    static constexpr const bool tinyness_before = false;
    static constexpr const float_round_style round_style = round_to_nearest;
};

template <>
class __libcpp_numeric_limits<double, true>
{
protected:
    typedef double type;

    static constexpr const bool is_specialized = true;

    static constexpr const bool is_signed = true;
    static constexpr const int digits = 53;
    static constexpr const int digits10 = 15;
    static constexpr const int max_digits10 = 2+(digits * 30103l)/100000l;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) static constexpr type min() noexcept {return 2.2250738585072014e-308;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) static constexpr type max() noexcept {return 1.7976931348623157e+308;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) static constexpr type lowest() noexcept {return -max();}

    static constexpr const bool is_integer = false;
    static constexpr const bool is_exact = false;
    static constexpr const int radix = 2;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) static constexpr type epsilon() noexcept {return 2.2204460492503131e-16;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) static constexpr type round_error() noexcept {return 0.5;}

    static constexpr const int min_exponent = (-1021);
    static constexpr const int min_exponent10 = (-307);
    static constexpr const int max_exponent = 1024;
    static constexpr const int max_exponent10 = 308;

    static constexpr const bool has_infinity = true;
    static constexpr const bool has_quiet_NaN = true;
    static constexpr const bool has_signaling_NaN = true;
    static constexpr const float_denorm_style has_denorm = denorm_present;
    static constexpr const bool has_denorm_loss = false;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) static constexpr type infinity() noexcept {return __builtin_huge_val();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) static constexpr type quiet_NaN() noexcept {return __builtin_nan("");}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) static constexpr type signaling_NaN() noexcept {return __builtin_nans("");}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) static constexpr type denorm_min() noexcept {return 4.9406564584124654e-324;}

    static constexpr const bool is_iec559 = true;
    static constexpr const bool is_bounded = true;
    static constexpr const bool is_modulo = false;

    static constexpr const bool traps = false;
    static constexpr const bool tinyness_before = false;
    static constexpr const float_round_style round_style = round_to_nearest;
};

template <>
class __libcpp_numeric_limits<long double, true>
{
protected:
    typedef long double type;

    static constexpr const bool is_specialized = true;

    static constexpr const bool is_signed = true;
    static constexpr const int digits = 53;
    static constexpr const int digits10 = 15;
    static constexpr const int max_digits10 = 2+(digits * 30103l)/100000l;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) static constexpr type min() noexcept {return 2.2250738585072014e-308L;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) static constexpr type max() noexcept {return 1.7976931348623157e+308L;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) static constexpr type lowest() noexcept {return -max();}

    static constexpr const bool is_integer = false;
    static constexpr const bool is_exact = false;
    static constexpr const int radix = 2;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) static constexpr type epsilon() noexcept {return 2.2204460492503131e-16L;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) static constexpr type round_error() noexcept {return 0.5L;}

    static constexpr const int min_exponent = (-1021);
    static constexpr const int min_exponent10 = (-307);
    static constexpr const int max_exponent = 1024;
    static constexpr const int max_exponent10 = 308;

    static constexpr const bool has_infinity = true;
    static constexpr const bool has_quiet_NaN = true;
    static constexpr const bool has_signaling_NaN = true;
    static constexpr const float_denorm_style has_denorm = denorm_present;
    static constexpr const bool has_denorm_loss = false;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) static constexpr type infinity() noexcept {return __builtin_huge_vall();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) static constexpr type quiet_NaN() noexcept {return __builtin_nanl("");}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) static constexpr type signaling_NaN() noexcept {return __builtin_nansl("");}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) static constexpr type denorm_min() noexcept {return 4.9406564584124654e-324L;}




    static constexpr const bool is_iec559 = true;

    static constexpr const bool is_bounded = true;
    static constexpr const bool is_modulo = false;

    static constexpr const bool traps = false;
    static constexpr const bool tinyness_before = false;
    static constexpr const float_round_style round_style = round_to_nearest;
};

template <class _Tp>
class __attribute__ ((__type_visibility__("default"))) numeric_limits
    : private __libcpp_numeric_limits<typename remove_cv<_Tp>::type>
{
    typedef __libcpp_numeric_limits<typename remove_cv<_Tp>::type> __base;
    typedef typename __base::type type;
public:
    static constexpr const bool is_specialized = __base::is_specialized;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) static constexpr type min() noexcept {return __base::min();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) static constexpr type max() noexcept {return __base::max();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) static constexpr type lowest() noexcept {return __base::lowest();}

    static constexpr const int digits = __base::digits;
    static constexpr const int digits10 = __base::digits10;
    static constexpr const int max_digits10 = __base::max_digits10;
    static constexpr const bool is_signed = __base::is_signed;
    static constexpr const bool is_integer = __base::is_integer;
    static constexpr const bool is_exact = __base::is_exact;
    static constexpr const int radix = __base::radix;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) static constexpr type epsilon() noexcept {return __base::epsilon();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) static constexpr type round_error() noexcept {return __base::round_error();}

    static constexpr const int min_exponent = __base::min_exponent;
    static constexpr const int min_exponent10 = __base::min_exponent10;
    static constexpr const int max_exponent = __base::max_exponent;
    static constexpr const int max_exponent10 = __base::max_exponent10;

    static constexpr const bool has_infinity = __base::has_infinity;
    static constexpr const bool has_quiet_NaN = __base::has_quiet_NaN;
    static constexpr const bool has_signaling_NaN = __base::has_signaling_NaN;
    static constexpr const float_denorm_style has_denorm = __base::has_denorm;
    static constexpr const bool has_denorm_loss = __base::has_denorm_loss;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) static constexpr type infinity() noexcept {return __base::infinity();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) static constexpr type quiet_NaN() noexcept {return __base::quiet_NaN();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) static constexpr type signaling_NaN() noexcept {return __base::signaling_NaN();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) static constexpr type denorm_min() noexcept {return __base::denorm_min();}

    static constexpr const bool is_iec559 = __base::is_iec559;
    static constexpr const bool is_bounded = __base::is_bounded;
    static constexpr const bool is_modulo = __base::is_modulo;

    static constexpr const bool traps = __base::traps;
    static constexpr const bool tinyness_before = __base::tinyness_before;
    static constexpr const float_round_style round_style = __base::round_style;
};

template <class _Tp>
    constexpr const bool numeric_limits<_Tp>::is_specialized;
template <class _Tp>
    constexpr const int numeric_limits<_Tp>::digits;
template <class _Tp>
    constexpr const int numeric_limits<_Tp>::digits10;
template <class _Tp>
    constexpr const int numeric_limits<_Tp>::max_digits10;
template <class _Tp>
    constexpr const bool numeric_limits<_Tp>::is_signed;
template <class _Tp>
    constexpr const bool numeric_limits<_Tp>::is_integer;
template <class _Tp>
    constexpr const bool numeric_limits<_Tp>::is_exact;
template <class _Tp>
    constexpr const int numeric_limits<_Tp>::radix;
template <class _Tp>
    constexpr const int numeric_limits<_Tp>::min_exponent;
template <class _Tp>
    constexpr const int numeric_limits<_Tp>::min_exponent10;
template <class _Tp>
    constexpr const int numeric_limits<_Tp>::max_exponent;
template <class _Tp>
    constexpr const int numeric_limits<_Tp>::max_exponent10;
template <class _Tp>
    constexpr const bool numeric_limits<_Tp>::has_infinity;
template <class _Tp>
    constexpr const bool numeric_limits<_Tp>::has_quiet_NaN;
template <class _Tp>
    constexpr const bool numeric_limits<_Tp>::has_signaling_NaN;
template <class _Tp>
    constexpr const float_denorm_style numeric_limits<_Tp>::has_denorm;
template <class _Tp>
    constexpr const bool numeric_limits<_Tp>::has_denorm_loss;
template <class _Tp>
    constexpr const bool numeric_limits<_Tp>::is_iec559;
template <class _Tp>
    constexpr const bool numeric_limits<_Tp>::is_bounded;
template <class _Tp>
    constexpr const bool numeric_limits<_Tp>::is_modulo;
template <class _Tp>
    constexpr const bool numeric_limits<_Tp>::traps;
template <class _Tp>
    constexpr const bool numeric_limits<_Tp>::tinyness_before;
template <class _Tp>
    constexpr const float_round_style numeric_limits<_Tp>::round_style;

template <class _Tp>
class __attribute__ ((__type_visibility__("default"))) numeric_limits<const _Tp>
    : private numeric_limits<_Tp>
{
    typedef numeric_limits<_Tp> __base;
    typedef _Tp type;
public:
    static constexpr const bool is_specialized = __base::is_specialized;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) static constexpr type min() noexcept {return __base::min();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) static constexpr type max() noexcept {return __base::max();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) static constexpr type lowest() noexcept {return __base::lowest();}

    static constexpr const int digits = __base::digits;
    static constexpr const int digits10 = __base::digits10;
    static constexpr const int max_digits10 = __base::max_digits10;
    static constexpr const bool is_signed = __base::is_signed;
    static constexpr const bool is_integer = __base::is_integer;
    static constexpr const bool is_exact = __base::is_exact;
    static constexpr const int radix = __base::radix;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) static constexpr type epsilon() noexcept {return __base::epsilon();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) static constexpr type round_error() noexcept {return __base::round_error();}

    static constexpr const int min_exponent = __base::min_exponent;
    static constexpr const int min_exponent10 = __base::min_exponent10;
    static constexpr const int max_exponent = __base::max_exponent;
    static constexpr const int max_exponent10 = __base::max_exponent10;

    static constexpr const bool has_infinity = __base::has_infinity;
    static constexpr const bool has_quiet_NaN = __base::has_quiet_NaN;
    static constexpr const bool has_signaling_NaN = __base::has_signaling_NaN;
    static constexpr const float_denorm_style has_denorm = __base::has_denorm;
    static constexpr const bool has_denorm_loss = __base::has_denorm_loss;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) static constexpr type infinity() noexcept {return __base::infinity();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) static constexpr type quiet_NaN() noexcept {return __base::quiet_NaN();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) static constexpr type signaling_NaN() noexcept {return __base::signaling_NaN();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) static constexpr type denorm_min() noexcept {return __base::denorm_min();}

    static constexpr const bool is_iec559 = __base::is_iec559;
    static constexpr const bool is_bounded = __base::is_bounded;
    static constexpr const bool is_modulo = __base::is_modulo;

    static constexpr const bool traps = __base::traps;
    static constexpr const bool tinyness_before = __base::tinyness_before;
    static constexpr const float_round_style round_style = __base::round_style;
};

template <class _Tp>
    constexpr const bool numeric_limits<const _Tp>::is_specialized;
template <class _Tp>
    constexpr const int numeric_limits<const _Tp>::digits;
template <class _Tp>
    constexpr const int numeric_limits<const _Tp>::digits10;
template <class _Tp>
    constexpr const int numeric_limits<const _Tp>::max_digits10;
template <class _Tp>
    constexpr const bool numeric_limits<const _Tp>::is_signed;
template <class _Tp>
    constexpr const bool numeric_limits<const _Tp>::is_integer;
template <class _Tp>
    constexpr const bool numeric_limits<const _Tp>::is_exact;
template <class _Tp>
    constexpr const int numeric_limits<const _Tp>::radix;
template <class _Tp>
    constexpr const int numeric_limits<const _Tp>::min_exponent;
template <class _Tp>
    constexpr const int numeric_limits<const _Tp>::min_exponent10;
template <class _Tp>
    constexpr const int numeric_limits<const _Tp>::max_exponent;
template <class _Tp>
    constexpr const int numeric_limits<const _Tp>::max_exponent10;
template <class _Tp>
    constexpr const bool numeric_limits<const _Tp>::has_infinity;
template <class _Tp>
    constexpr const bool numeric_limits<const _Tp>::has_quiet_NaN;
template <class _Tp>
    constexpr const bool numeric_limits<const _Tp>::has_signaling_NaN;
template <class _Tp>
    constexpr const float_denorm_style numeric_limits<const _Tp>::has_denorm;
template <class _Tp>
    constexpr const bool numeric_limits<const _Tp>::has_denorm_loss;
template <class _Tp>
    constexpr const bool numeric_limits<const _Tp>::is_iec559;
template <class _Tp>
    constexpr const bool numeric_limits<const _Tp>::is_bounded;
template <class _Tp>
    constexpr const bool numeric_limits<const _Tp>::is_modulo;
template <class _Tp>
    constexpr const bool numeric_limits<const _Tp>::traps;
template <class _Tp>
    constexpr const bool numeric_limits<const _Tp>::tinyness_before;
template <class _Tp>
    constexpr const float_round_style numeric_limits<const _Tp>::round_style;

template <class _Tp>
class __attribute__ ((__type_visibility__("default"))) numeric_limits<volatile _Tp>
    : private numeric_limits<_Tp>
{
    typedef numeric_limits<_Tp> __base;
    typedef _Tp type;
public:
    static constexpr const bool is_specialized = __base::is_specialized;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) static constexpr type min() noexcept {return __base::min();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) static constexpr type max() noexcept {return __base::max();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) static constexpr type lowest() noexcept {return __base::lowest();}

    static constexpr const int digits = __base::digits;
    static constexpr const int digits10 = __base::digits10;
    static constexpr const int max_digits10 = __base::max_digits10;
    static constexpr const bool is_signed = __base::is_signed;
    static constexpr const bool is_integer = __base::is_integer;
    static constexpr const bool is_exact = __base::is_exact;
    static constexpr const int radix = __base::radix;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) static constexpr type epsilon() noexcept {return __base::epsilon();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) static constexpr type round_error() noexcept {return __base::round_error();}

    static constexpr const int min_exponent = __base::min_exponent;
    static constexpr const int min_exponent10 = __base::min_exponent10;
    static constexpr const int max_exponent = __base::max_exponent;
    static constexpr const int max_exponent10 = __base::max_exponent10;

    static constexpr const bool has_infinity = __base::has_infinity;
    static constexpr const bool has_quiet_NaN = __base::has_quiet_NaN;
    static constexpr const bool has_signaling_NaN = __base::has_signaling_NaN;
    static constexpr const float_denorm_style has_denorm = __base::has_denorm;
    static constexpr const bool has_denorm_loss = __base::has_denorm_loss;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) static constexpr type infinity() noexcept {return __base::infinity();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) static constexpr type quiet_NaN() noexcept {return __base::quiet_NaN();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) static constexpr type signaling_NaN() noexcept {return __base::signaling_NaN();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) static constexpr type denorm_min() noexcept {return __base::denorm_min();}

    static constexpr const bool is_iec559 = __base::is_iec559;
    static constexpr const bool is_bounded = __base::is_bounded;
    static constexpr const bool is_modulo = __base::is_modulo;

    static constexpr const bool traps = __base::traps;
    static constexpr const bool tinyness_before = __base::tinyness_before;
    static constexpr const float_round_style round_style = __base::round_style;
};

template <class _Tp>
    constexpr const bool numeric_limits<volatile _Tp>::is_specialized;
template <class _Tp>
    constexpr const int numeric_limits<volatile _Tp>::digits;
template <class _Tp>
    constexpr const int numeric_limits<volatile _Tp>::digits10;
template <class _Tp>
    constexpr const int numeric_limits<volatile _Tp>::max_digits10;
template <class _Tp>
    constexpr const bool numeric_limits<volatile _Tp>::is_signed;
template <class _Tp>
    constexpr const bool numeric_limits<volatile _Tp>::is_integer;
template <class _Tp>
    constexpr const bool numeric_limits<volatile _Tp>::is_exact;
template <class _Tp>
    constexpr const int numeric_limits<volatile _Tp>::radix;
template <class _Tp>
    constexpr const int numeric_limits<volatile _Tp>::min_exponent;
template <class _Tp>
    constexpr const int numeric_limits<volatile _Tp>::min_exponent10;
template <class _Tp>
    constexpr const int numeric_limits<volatile _Tp>::max_exponent;
template <class _Tp>
    constexpr const int numeric_limits<volatile _Tp>::max_exponent10;
template <class _Tp>
    constexpr const bool numeric_limits<volatile _Tp>::has_infinity;
template <class _Tp>
    constexpr const bool numeric_limits<volatile _Tp>::has_quiet_NaN;
template <class _Tp>
    constexpr const bool numeric_limits<volatile _Tp>::has_signaling_NaN;
template <class _Tp>
    constexpr const float_denorm_style numeric_limits<volatile _Tp>::has_denorm;
template <class _Tp>
    constexpr const bool numeric_limits<volatile _Tp>::has_denorm_loss;
template <class _Tp>
    constexpr const bool numeric_limits<volatile _Tp>::is_iec559;
template <class _Tp>
    constexpr const bool numeric_limits<volatile _Tp>::is_bounded;
template <class _Tp>
    constexpr const bool numeric_limits<volatile _Tp>::is_modulo;
template <class _Tp>
    constexpr const bool numeric_limits<volatile _Tp>::traps;
template <class _Tp>
    constexpr const bool numeric_limits<volatile _Tp>::tinyness_before;
template <class _Tp>
    constexpr const float_round_style numeric_limits<volatile _Tp>::round_style;

template <class _Tp>
class __attribute__ ((__type_visibility__("default"))) numeric_limits<const volatile _Tp>
    : private numeric_limits<_Tp>
{
    typedef numeric_limits<_Tp> __base;
    typedef _Tp type;
public:
    static constexpr const bool is_specialized = __base::is_specialized;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) static constexpr type min() noexcept {return __base::min();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) static constexpr type max() noexcept {return __base::max();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) static constexpr type lowest() noexcept {return __base::lowest();}

    static constexpr const int digits = __base::digits;
    static constexpr const int digits10 = __base::digits10;
    static constexpr const int max_digits10 = __base::max_digits10;
    static constexpr const bool is_signed = __base::is_signed;
    static constexpr const bool is_integer = __base::is_integer;
    static constexpr const bool is_exact = __base::is_exact;
    static constexpr const int radix = __base::radix;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) static constexpr type epsilon() noexcept {return __base::epsilon();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) static constexpr type round_error() noexcept {return __base::round_error();}

    static constexpr const int min_exponent = __base::min_exponent;
    static constexpr const int min_exponent10 = __base::min_exponent10;
    static constexpr const int max_exponent = __base::max_exponent;
    static constexpr const int max_exponent10 = __base::max_exponent10;

    static constexpr const bool has_infinity = __base::has_infinity;
    static constexpr const bool has_quiet_NaN = __base::has_quiet_NaN;
    static constexpr const bool has_signaling_NaN = __base::has_signaling_NaN;
    static constexpr const float_denorm_style has_denorm = __base::has_denorm;
    static constexpr const bool has_denorm_loss = __base::has_denorm_loss;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) static constexpr type infinity() noexcept {return __base::infinity();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) static constexpr type quiet_NaN() noexcept {return __base::quiet_NaN();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) static constexpr type signaling_NaN() noexcept {return __base::signaling_NaN();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) static constexpr type denorm_min() noexcept {return __base::denorm_min();}

    static constexpr const bool is_iec559 = __base::is_iec559;
    static constexpr const bool is_bounded = __base::is_bounded;
    static constexpr const bool is_modulo = __base::is_modulo;

    static constexpr const bool traps = __base::traps;
    static constexpr const bool tinyness_before = __base::tinyness_before;
    static constexpr const float_round_style round_style = __base::round_style;
};

template <class _Tp>
    constexpr const bool numeric_limits<const volatile _Tp>::is_specialized;
template <class _Tp>
    constexpr const int numeric_limits<const volatile _Tp>::digits;
template <class _Tp>
    constexpr const int numeric_limits<const volatile _Tp>::digits10;
template <class _Tp>
    constexpr const int numeric_limits<const volatile _Tp>::max_digits10;
template <class _Tp>
    constexpr const bool numeric_limits<const volatile _Tp>::is_signed;
template <class _Tp>
    constexpr const bool numeric_limits<const volatile _Tp>::is_integer;
template <class _Tp>
    constexpr const bool numeric_limits<const volatile _Tp>::is_exact;
template <class _Tp>
    constexpr const int numeric_limits<const volatile _Tp>::radix;
template <class _Tp>
    constexpr const int numeric_limits<const volatile _Tp>::min_exponent;
template <class _Tp>
    constexpr const int numeric_limits<const volatile _Tp>::min_exponent10;
template <class _Tp>
    constexpr const int numeric_limits<const volatile _Tp>::max_exponent;
template <class _Tp>
    constexpr const int numeric_limits<const volatile _Tp>::max_exponent10;
template <class _Tp>
    constexpr const bool numeric_limits<const volatile _Tp>::has_infinity;
template <class _Tp>
    constexpr const bool numeric_limits<const volatile _Tp>::has_quiet_NaN;
template <class _Tp>
    constexpr const bool numeric_limits<const volatile _Tp>::has_signaling_NaN;
template <class _Tp>
    constexpr const float_denorm_style numeric_limits<const volatile _Tp>::has_denorm;
template <class _Tp>
    constexpr const bool numeric_limits<const volatile _Tp>::has_denorm_loss;
template <class _Tp>
    constexpr const bool numeric_limits<const volatile _Tp>::is_iec559;
template <class _Tp>
    constexpr const bool numeric_limits<const volatile _Tp>::is_bounded;
template <class _Tp>
    constexpr const bool numeric_limits<const volatile _Tp>::is_modulo;
template <class _Tp>
    constexpr const bool numeric_limits<const volatile _Tp>::traps;
template <class _Tp>
    constexpr const bool numeric_limits<const volatile _Tp>::tinyness_before;
template <class _Tp>
    constexpr const float_round_style numeric_limits<const volatile _Tp>::round_style;

} }
# 311 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/math.h" 2 3





template <class _A1>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
__libcpp_signbit(_A1 __lcpp_x) noexcept
{

    return __builtin_signbit(__lcpp_x);



}



template <class _A1>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename std::enable_if<std::is_floating_point<_A1>::value, bool>::type
signbit(_A1 __lcpp_x) noexcept
{
    return __libcpp_signbit((typename std::__promote<_A1>::type)__lcpp_x);
}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename std::enable_if<
    std::is_integral<_A1>::value && std::is_signed<_A1>::value, bool>::type
signbit(_A1 __lcpp_x) noexcept
{ return __lcpp_x < 0; }

template <class _A1>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename std::enable_if<
    std::is_integral<_A1>::value && !std::is_signed<_A1>::value, bool>::type
signbit(_A1) noexcept
{ return false; }
# 382 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/math.h" 3
template <class _A1>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
int
__libcpp_fpclassify(_A1 __lcpp_x) noexcept
{

  return __builtin_fpclassify(1, 2, 4, 5,
                                3, __lcpp_x);



}



template <class _A1>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename std::enable_if<std::is_floating_point<_A1>::value, int>::type
fpclassify(_A1 __lcpp_x) noexcept
{
    return __libcpp_fpclassify((typename std::__promote<_A1>::type)__lcpp_x);
}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename std::enable_if<std::is_integral<_A1>::value, int>::type
fpclassify(_A1 __lcpp_x) noexcept
{ return __lcpp_x == 0 ? 3 : 4; }
# 433 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/math.h" 3
template <class _A1>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
__libcpp_isfinite(_A1 __lcpp_x) noexcept
{

    return __builtin_isfinite(__lcpp_x);



}



template <class _A1>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename std::enable_if<
    std::is_arithmetic<_A1>::value && std::numeric_limits<_A1>::has_infinity,
    bool>::type
isfinite(_A1 __lcpp_x) noexcept
{
    return __libcpp_isfinite((typename std::__promote<_A1>::type)__lcpp_x);
}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename std::enable_if<
    std::is_arithmetic<_A1>::value && !std::numeric_limits<_A1>::has_infinity,
    bool>::type
isfinite(_A1) noexcept
{ return true; }







template <class _A1>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
__libcpp_isinf(_A1 __lcpp_x) noexcept
{

    return __builtin_isinf(__lcpp_x);



}



template <class _A1>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename std::enable_if<
    std::is_arithmetic<_A1>::value && std::numeric_limits<_A1>::has_infinity,
    bool>::type
isinf(_A1 __lcpp_x) noexcept
{
    return __libcpp_isinf((typename std::__promote<_A1>::type)__lcpp_x);
}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename std::enable_if<
    std::is_arithmetic<_A1>::value && !std::numeric_limits<_A1>::has_infinity,
    bool>::type
isinf(_A1) noexcept
{ return false; }


inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
isinf(float __lcpp_x) noexcept { return __libcpp_isinf(__lcpp_x); }

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) __attribute__ ((__enable_if__(true, "")))
bool
isinf(double __lcpp_x) noexcept { return __libcpp_isinf(__lcpp_x); }

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
isinf(long double __lcpp_x) noexcept { return __libcpp_isinf(__lcpp_x); }
# 523 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/math.h" 3
template <class _A1>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
__libcpp_isnan(_A1 __lcpp_x) noexcept
{

    return __builtin_isnan(__lcpp_x);



}



template <class _A1>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename std::enable_if<std::is_floating_point<_A1>::value, bool>::type
isnan(_A1 __lcpp_x) noexcept
{
    return __libcpp_isnan((typename std::__promote<_A1>::type)__lcpp_x);
}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename std::enable_if<std::is_integral<_A1>::value, bool>::type
isnan(_A1) noexcept
{ return false; }


inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
isnan(float __lcpp_x) noexcept { return __libcpp_isnan(__lcpp_x); }

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) __attribute__ ((__enable_if__(true, "")))
bool
isnan(double __lcpp_x) noexcept { return __libcpp_isnan(__lcpp_x); }

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
isnan(long double __lcpp_x) noexcept { return __libcpp_isnan(__lcpp_x); }
# 571 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/math.h" 3
template <class _A1>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
__libcpp_isnormal(_A1 __lcpp_x) noexcept
{

    return __builtin_isnormal(__lcpp_x);



}



template <class _A1>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename std::enable_if<std::is_floating_point<_A1>::value, bool>::type
isnormal(_A1 __lcpp_x) noexcept
{
    return __libcpp_isnormal((typename std::__promote<_A1>::type)__lcpp_x);
}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename std::enable_if<std::is_integral<_A1>::value, bool>::type
isnormal(_A1 __lcpp_x) noexcept
{ return __lcpp_x != 0; }







template <class _A1, class _A2>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
__libcpp_isgreater(_A1 __lcpp_x, _A2 __lcpp_y) noexcept
{
    return __builtin_isgreater((__lcpp_x),(__lcpp_y));
}



template <class _A1, class _A2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename std::enable_if
<
    std::is_arithmetic<_A1>::value &&
    std::is_arithmetic<_A2>::value,
    bool
>::type
isgreater(_A1 __lcpp_x, _A2 __lcpp_y) noexcept
{
    typedef typename std::__promote<_A1, _A2>::type type;
    return __libcpp_isgreater((type)__lcpp_x, (type)__lcpp_y);
}







template <class _A1, class _A2>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
__libcpp_isgreaterequal(_A1 __lcpp_x, _A2 __lcpp_y) noexcept
{
    return __builtin_isgreaterequal((__lcpp_x),(__lcpp_y));
}



template <class _A1, class _A2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename std::enable_if
<
    std::is_arithmetic<_A1>::value &&
    std::is_arithmetic<_A2>::value,
    bool
>::type
isgreaterequal(_A1 __lcpp_x, _A2 __lcpp_y) noexcept
{
    typedef typename std::__promote<_A1, _A2>::type type;
    return __libcpp_isgreaterequal((type)__lcpp_x, (type)__lcpp_y);
}







template <class _A1, class _A2>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
__libcpp_isless(_A1 __lcpp_x, _A2 __lcpp_y) noexcept
{
    return __builtin_isless((__lcpp_x),(__lcpp_y));
}



template <class _A1, class _A2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename std::enable_if
<
    std::is_arithmetic<_A1>::value &&
    std::is_arithmetic<_A2>::value,
    bool
>::type
isless(_A1 __lcpp_x, _A2 __lcpp_y) noexcept
{
    typedef typename std::__promote<_A1, _A2>::type type;
    return __libcpp_isless((type)__lcpp_x, (type)__lcpp_y);
}







template <class _A1, class _A2>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
__libcpp_islessequal(_A1 __lcpp_x, _A2 __lcpp_y) noexcept
{
    return __builtin_islessequal((__lcpp_x),(__lcpp_y));
}



template <class _A1, class _A2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename std::enable_if
<
    std::is_arithmetic<_A1>::value &&
    std::is_arithmetic<_A2>::value,
    bool
>::type
islessequal(_A1 __lcpp_x, _A2 __lcpp_y) noexcept
{
    typedef typename std::__promote<_A1, _A2>::type type;
    return __libcpp_islessequal((type)__lcpp_x, (type)__lcpp_y);
}







template <class _A1, class _A2>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
__libcpp_islessgreater(_A1 __lcpp_x, _A2 __lcpp_y) noexcept
{
    return __builtin_islessgreater((__lcpp_x),(__lcpp_y));
}



template <class _A1, class _A2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename std::enable_if
<
    std::is_arithmetic<_A1>::value &&
    std::is_arithmetic<_A2>::value,
    bool
>::type
islessgreater(_A1 __lcpp_x, _A2 __lcpp_y) noexcept
{
    typedef typename std::__promote<_A1, _A2>::type type;
    return __libcpp_islessgreater((type)__lcpp_x, (type)__lcpp_y);
}







template <class _A1, class _A2>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
__libcpp_isunordered(_A1 __lcpp_x, _A2 __lcpp_y) noexcept
{
    return __builtin_isunordered((__lcpp_x),(__lcpp_y));
}



template <class _A1, class _A2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename std::enable_if
<
    std::is_arithmetic<_A1>::value &&
    std::is_arithmetic<_A2>::value,
    bool
>::type
isunordered(_A1 __lcpp_x, _A2 __lcpp_y) noexcept
{
    typedef typename std::__promote<_A1, _A2>::type type;
    return __libcpp_isunordered((type)__lcpp_x, (type)__lcpp_y);
}
# 792 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/math.h" 3
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) float acos(float __lcpp_x) noexcept {return ::acosf(__lcpp_x);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) long double acos(long double __lcpp_x) noexcept {return ::acosl(__lcpp_x);}


template <class _A1>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
acos(_A1 __lcpp_x) noexcept {return ::acos((double)__lcpp_x);}




inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) float asin(float __lcpp_x) noexcept {return ::asinf(__lcpp_x);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) long double asin(long double __lcpp_x) noexcept {return ::asinl(__lcpp_x);}


template <class _A1>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
asin(_A1 __lcpp_x) noexcept {return ::asin((double)__lcpp_x);}




inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) float atan(float __lcpp_x) noexcept {return ::atanf(__lcpp_x);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) long double atan(long double __lcpp_x) noexcept {return ::atanl(__lcpp_x);}


template <class _A1>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
atan(_A1 __lcpp_x) noexcept {return ::atan((double)__lcpp_x);}




inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) float atan2(float __lcpp_y, float __lcpp_x) noexcept {return ::atan2f(__lcpp_y, __lcpp_x);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) long double atan2(long double __lcpp_y, long double __lcpp_x) noexcept {return ::atan2l(__lcpp_y, __lcpp_x);}


template <class _A1, class _A2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename std::_EnableIf
<
    std::is_arithmetic<_A1>::value &&
    std::is_arithmetic<_A2>::value,
    std::__promote<_A1, _A2>
>::type
atan2(_A1 __lcpp_y, _A2 __lcpp_x) noexcept
{
    typedef typename std::__promote<_A1, _A2>::type __result_type;
    static_assert((!(std::_IsSame<_A1, __result_type>::value &&
                     std::_IsSame<_A2, __result_type>::value)), "");
    return ::atan2((__result_type)__lcpp_y, (__result_type)__lcpp_x);
}




inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) float ceil(float __lcpp_x) noexcept {return ::ceilf(__lcpp_x);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) long double ceil(long double __lcpp_x) noexcept {return ::ceill(__lcpp_x);}


template <class _A1>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
ceil(_A1 __lcpp_x) noexcept {return ::ceil((double)__lcpp_x);}




inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) float cos(float __lcpp_x) noexcept {return ::cosf(__lcpp_x);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) long double cos(long double __lcpp_x) noexcept {return ::cosl(__lcpp_x);}


template <class _A1>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
cos(_A1 __lcpp_x) noexcept {return ::cos((double)__lcpp_x);}




inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) float cosh(float __lcpp_x) noexcept {return ::coshf(__lcpp_x);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) long double cosh(long double __lcpp_x) noexcept {return ::coshl(__lcpp_x);}


template <class _A1>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
cosh(_A1 __lcpp_x) noexcept {return ::cosh((double)__lcpp_x);}




inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) float exp(float __lcpp_x) noexcept {return ::expf(__lcpp_x);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) long double exp(long double __lcpp_x) noexcept {return ::expl(__lcpp_x);}


template <class _A1>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
exp(_A1 __lcpp_x) noexcept {return ::exp((double)__lcpp_x);}




inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) float fabs(float __lcpp_x) noexcept {return ::fabsf(__lcpp_x);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) long double fabs(long double __lcpp_x) noexcept {return ::fabsl(__lcpp_x);}


template <class _A1>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
fabs(_A1 __lcpp_x) noexcept {return ::fabs((double)__lcpp_x);}




inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) float floor(float __lcpp_x) noexcept {return ::floorf(__lcpp_x);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) long double floor(long double __lcpp_x) noexcept {return ::floorl(__lcpp_x);}


template <class _A1>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
floor(_A1 __lcpp_x) noexcept {return ::floor((double)__lcpp_x);}




inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) float fmod(float __lcpp_x, float __lcpp_y) noexcept {return ::fmodf(__lcpp_x, __lcpp_y);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) long double fmod(long double __lcpp_x, long double __lcpp_y) noexcept {return ::fmodl(__lcpp_x, __lcpp_y);}


template <class _A1, class _A2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename std::_EnableIf
<
    std::is_arithmetic<_A1>::value &&
    std::is_arithmetic<_A2>::value,
    std::__promote<_A1, _A2>
>::type
fmod(_A1 __lcpp_x, _A2 __lcpp_y) noexcept
{
    typedef typename std::__promote<_A1, _A2>::type __result_type;
    static_assert((!(std::_IsSame<_A1, __result_type>::value &&
                     std::_IsSame<_A2, __result_type>::value)), "");
    return ::fmod((__result_type)__lcpp_x, (__result_type)__lcpp_y);
}




inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) float frexp(float __lcpp_x, int* __lcpp_e) noexcept {return ::frexpf(__lcpp_x, __lcpp_e);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) long double frexp(long double __lcpp_x, int* __lcpp_e) noexcept {return ::frexpl(__lcpp_x, __lcpp_e);}


template <class _A1>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
frexp(_A1 __lcpp_x, int* __lcpp_e) noexcept {return ::frexp((double)__lcpp_x, __lcpp_e);}




inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) float ldexp(float __lcpp_x, int __lcpp_e) noexcept {return ::ldexpf(__lcpp_x, __lcpp_e);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) long double ldexp(long double __lcpp_x, int __lcpp_e) noexcept {return ::ldexpl(__lcpp_x, __lcpp_e);}


template <class _A1>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
ldexp(_A1 __lcpp_x, int __lcpp_e) noexcept {return ::ldexp((double)__lcpp_x, __lcpp_e);}




inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) float log(float __lcpp_x) noexcept {return ::logf(__lcpp_x);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) long double log(long double __lcpp_x) noexcept {return ::logl(__lcpp_x);}


template <class _A1>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
log(_A1 __lcpp_x) noexcept {return ::log((double)__lcpp_x);}




inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) float log10(float __lcpp_x) noexcept {return ::log10f(__lcpp_x);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) long double log10(long double __lcpp_x) noexcept {return ::log10l(__lcpp_x);}


template <class _A1>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
log10(_A1 __lcpp_x) noexcept {return ::log10((double)__lcpp_x);}




inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) float modf(float __lcpp_x, float* __lcpp_y) noexcept {return ::modff(__lcpp_x, __lcpp_y);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) long double modf(long double __lcpp_x, long double* __lcpp_y) noexcept {return ::modfl(__lcpp_x, __lcpp_y);}





inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) float pow(float __lcpp_x, float __lcpp_y) noexcept {return ::powf(__lcpp_x, __lcpp_y);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) long double pow(long double __lcpp_x, long double __lcpp_y) noexcept {return ::powl(__lcpp_x, __lcpp_y);}


template <class _A1, class _A2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename std::_EnableIf
<
    std::is_arithmetic<_A1>::value &&
    std::is_arithmetic<_A2>::value,
    std::__promote<_A1, _A2>
>::type
pow(_A1 __lcpp_x, _A2 __lcpp_y) noexcept
{
    typedef typename std::__promote<_A1, _A2>::type __result_type;
    static_assert((!(std::_IsSame<_A1, __result_type>::value &&
                     std::_IsSame<_A2, __result_type>::value)), "");
    return ::pow((__result_type)__lcpp_x, (__result_type)__lcpp_y);
}




inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) float sin(float __lcpp_x) noexcept {return ::sinf(__lcpp_x);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) long double sin(long double __lcpp_x) noexcept {return ::sinl(__lcpp_x);}


template <class _A1>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
sin(_A1 __lcpp_x) noexcept {return ::sin((double)__lcpp_x);}




inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) float sinh(float __lcpp_x) noexcept {return ::sinhf(__lcpp_x);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) long double sinh(long double __lcpp_x) noexcept {return ::sinhl(__lcpp_x);}


template <class _A1>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
sinh(_A1 __lcpp_x) noexcept {return ::sinh((double)__lcpp_x);}




inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) float sqrt(float __lcpp_x) noexcept {return ::sqrtf(__lcpp_x);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) long double sqrt(long double __lcpp_x) noexcept {return ::sqrtl(__lcpp_x);}


template <class _A1>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
sqrt(_A1 __lcpp_x) noexcept {return ::sqrt((double)__lcpp_x);}




inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) float tan(float __lcpp_x) noexcept {return ::tanf(__lcpp_x);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) long double tan(long double __lcpp_x) noexcept {return ::tanl(__lcpp_x);}


template <class _A1>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
tan(_A1 __lcpp_x) noexcept {return ::tan((double)__lcpp_x);}




inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) float tanh(float __lcpp_x) noexcept {return ::tanhf(__lcpp_x);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) long double tanh(long double __lcpp_x) noexcept {return ::tanhl(__lcpp_x);}


template <class _A1>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
tanh(_A1 __lcpp_x) noexcept {return ::tanh((double)__lcpp_x);}



inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) float acosh(float __lcpp_x) noexcept {return ::acoshf(__lcpp_x);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) long double acosh(long double __lcpp_x) noexcept {return ::acoshl(__lcpp_x);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
acosh(_A1 __lcpp_x) noexcept {return ::acosh((double)__lcpp_x);}



inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) float asinh(float __lcpp_x) noexcept {return ::asinhf(__lcpp_x);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) long double asinh(long double __lcpp_x) noexcept {return ::asinhl(__lcpp_x);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
asinh(_A1 __lcpp_x) noexcept {return ::asinh((double)__lcpp_x);}



inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) float atanh(float __lcpp_x) noexcept {return ::atanhf(__lcpp_x);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) long double atanh(long double __lcpp_x) noexcept {return ::atanhl(__lcpp_x);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
atanh(_A1 __lcpp_x) noexcept {return ::atanh((double)__lcpp_x);}



inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) float cbrt(float __lcpp_x) noexcept {return ::cbrtf(__lcpp_x);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) long double cbrt(long double __lcpp_x) noexcept {return ::cbrtl(__lcpp_x);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
cbrt(_A1 __lcpp_x) noexcept {return ::cbrt((double)__lcpp_x);}




constexpr

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) float __libcpp_copysign(float __lcpp_x, float __lcpp_y) noexcept {

  return __builtin_copysignf(__lcpp_x, __lcpp_y);



}


constexpr

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) double __libcpp_copysign(double __lcpp_x, double __lcpp_y) noexcept {

  return __builtin_copysign(__lcpp_x, __lcpp_y);



}


constexpr

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) long double __libcpp_copysign(long double __lcpp_x, long double __lcpp_y) noexcept {

  return __builtin_copysignl(__lcpp_x, __lcpp_y);



}

template <class _A1, class _A2>

constexpr

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename std::_EnableIf
<
    std::is_arithmetic<_A1>::value &&
    std::is_arithmetic<_A2>::value,
    std::__promote<_A1, _A2>
>::type
__libcpp_copysign(_A1 __lcpp_x, _A2 __lcpp_y) noexcept {
    typedef typename std::__promote<_A1, _A2>::type __result_type;
    static_assert((!(std::_IsSame<_A1, __result_type>::value &&
                     std::_IsSame<_A2, __result_type>::value)), "");

    return __builtin_copysign((__result_type)__lcpp_x, (__result_type)__lcpp_y);



}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) float copysign(float __lcpp_x, float __lcpp_y) noexcept {
  return ::__libcpp_copysign(__lcpp_x, __lcpp_y);
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) long double copysign(long double __lcpp_x, long double __lcpp_y) noexcept {
  return ::__libcpp_copysign(__lcpp_x, __lcpp_y);
}

template <class _A1, class _A2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename std::_EnableIf
<
    std::is_arithmetic<_A1>::value &&
    std::is_arithmetic<_A2>::value,
    std::__promote<_A1, _A2>
>::type
    copysign(_A1 __lcpp_x, _A2 __lcpp_y) noexcept {
  return ::__libcpp_copysign(__lcpp_x, __lcpp_y);
}



inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) float erf(float __lcpp_x) noexcept {return ::erff(__lcpp_x);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) long double erf(long double __lcpp_x) noexcept {return ::erfl(__lcpp_x);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
erf(_A1 __lcpp_x) noexcept {return ::erf((double)__lcpp_x);}



inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) float erfc(float __lcpp_x) noexcept {return ::erfcf(__lcpp_x);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) long double erfc(long double __lcpp_x) noexcept {return ::erfcl(__lcpp_x);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
erfc(_A1 __lcpp_x) noexcept {return ::erfc((double)__lcpp_x);}



inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) float exp2(float __lcpp_x) noexcept {return ::exp2f(__lcpp_x);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) long double exp2(long double __lcpp_x) noexcept {return ::exp2l(__lcpp_x);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
exp2(_A1 __lcpp_x) noexcept {return ::exp2((double)__lcpp_x);}



inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) float expm1(float __lcpp_x) noexcept {return ::expm1f(__lcpp_x);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) long double expm1(long double __lcpp_x) noexcept {return ::expm1l(__lcpp_x);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
expm1(_A1 __lcpp_x) noexcept {return ::expm1((double)__lcpp_x);}



inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) float fdim(float __lcpp_x, float __lcpp_y) noexcept {return ::fdimf(__lcpp_x, __lcpp_y);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) long double fdim(long double __lcpp_x, long double __lcpp_y) noexcept {return ::fdiml(__lcpp_x, __lcpp_y);}

template <class _A1, class _A2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename std::_EnableIf
<
    std::is_arithmetic<_A1>::value &&
    std::is_arithmetic<_A2>::value,
    std::__promote<_A1, _A2>
>::type
fdim(_A1 __lcpp_x, _A2 __lcpp_y) noexcept
{
    typedef typename std::__promote<_A1, _A2>::type __result_type;
    static_assert((!(std::_IsSame<_A1, __result_type>::value &&
                     std::_IsSame<_A2, __result_type>::value)), "");
    return ::fdim((__result_type)__lcpp_x, (__result_type)__lcpp_y);
}



inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) float fma(float __lcpp_x, float __lcpp_y, float __lcpp_z) noexcept
{

    return __builtin_fmaf(__lcpp_x, __lcpp_y, __lcpp_z);



}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) long double fma(long double __lcpp_x, long double __lcpp_y, long double __lcpp_z) noexcept
{

    return __builtin_fmal(__lcpp_x, __lcpp_y, __lcpp_z);



}

template <class _A1, class _A2, class _A3>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename std::_EnableIf
<
    std::is_arithmetic<_A1>::value &&
    std::is_arithmetic<_A2>::value &&
    std::is_arithmetic<_A3>::value,
    std::__promote<_A1, _A2, _A3>
>::type
fma(_A1 __lcpp_x, _A2 __lcpp_y, _A3 __lcpp_z) noexcept
{
    typedef typename std::__promote<_A1, _A2, _A3>::type __result_type;
    static_assert((!(std::_IsSame<_A1, __result_type>::value &&
                     std::_IsSame<_A2, __result_type>::value &&
                     std::_IsSame<_A3, __result_type>::value)), "");

    return __builtin_fma((__result_type)__lcpp_x, (__result_type)__lcpp_y, (__result_type)__lcpp_z);



}



inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) float fmax(float __lcpp_x, float __lcpp_y) noexcept {return ::fmaxf(__lcpp_x, __lcpp_y);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) long double fmax(long double __lcpp_x, long double __lcpp_y) noexcept {return ::fmaxl(__lcpp_x, __lcpp_y);}

template <class _A1, class _A2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename std::_EnableIf
<
    std::is_arithmetic<_A1>::value &&
    std::is_arithmetic<_A2>::value,
    std::__promote<_A1, _A2>
>::type
fmax(_A1 __lcpp_x, _A2 __lcpp_y) noexcept
{
    typedef typename std::__promote<_A1, _A2>::type __result_type;
    static_assert((!(std::_IsSame<_A1, __result_type>::value &&
                     std::_IsSame<_A2, __result_type>::value)), "");
    return ::fmax((__result_type)__lcpp_x, (__result_type)__lcpp_y);
}



inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) float fmin(float __lcpp_x, float __lcpp_y) noexcept {return ::fminf(__lcpp_x, __lcpp_y);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) long double fmin(long double __lcpp_x, long double __lcpp_y) noexcept {return ::fminl(__lcpp_x, __lcpp_y);}

template <class _A1, class _A2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename std::_EnableIf
<
    std::is_arithmetic<_A1>::value &&
    std::is_arithmetic<_A2>::value,
    std::__promote<_A1, _A2>
>::type
fmin(_A1 __lcpp_x, _A2 __lcpp_y) noexcept
{
    typedef typename std::__promote<_A1, _A2>::type __result_type;
    static_assert((!(std::_IsSame<_A1, __result_type>::value &&
                     std::_IsSame<_A2, __result_type>::value)), "");
    return ::fmin((__result_type)__lcpp_x, (__result_type)__lcpp_y);
}



inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) float hypot(float __lcpp_x, float __lcpp_y) noexcept {return ::hypotf(__lcpp_x, __lcpp_y);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) long double hypot(long double __lcpp_x, long double __lcpp_y) noexcept {return ::hypotl(__lcpp_x, __lcpp_y);}

template <class _A1, class _A2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename std::_EnableIf
<
    std::is_arithmetic<_A1>::value &&
    std::is_arithmetic<_A2>::value,
    std::__promote<_A1, _A2>
>::type
hypot(_A1 __lcpp_x, _A2 __lcpp_y) noexcept
{
    typedef typename std::__promote<_A1, _A2>::type __result_type;
    static_assert((!(std::_IsSame<_A1, __result_type>::value &&
                     std::_IsSame<_A2, __result_type>::value)), "");
    return ::hypot((__result_type)__lcpp_x, (__result_type)__lcpp_y);
}



inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) int ilogb(float __lcpp_x) noexcept {return ::ilogbf(__lcpp_x);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) int ilogb(long double __lcpp_x) noexcept {return ::ilogbl(__lcpp_x);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename std::enable_if<std::is_integral<_A1>::value, int>::type
ilogb(_A1 __lcpp_x) noexcept {return ::ilogb((double)__lcpp_x);}



inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) float lgamma(float __lcpp_x) noexcept {return ::lgammaf(__lcpp_x);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) long double lgamma(long double __lcpp_x) noexcept {return ::lgammal(__lcpp_x);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
lgamma(_A1 __lcpp_x) noexcept {return ::lgamma((double)__lcpp_x);}



inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) long long llrint(float __lcpp_x) noexcept
{

    return __builtin_llrintf(__lcpp_x);



}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) long long llrint(long double __lcpp_x) noexcept
{

    return __builtin_llrintl(__lcpp_x);



}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename std::enable_if<std::is_integral<_A1>::value, long long>::type
llrint(_A1 __lcpp_x) noexcept
{

    return __builtin_llrint((double)__lcpp_x);



}



inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) long long llround(float __lcpp_x) noexcept
{

    return __builtin_llroundf(__lcpp_x);



}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) long long llround(long double __lcpp_x) noexcept
{

    return __builtin_llroundl(__lcpp_x);



}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename std::enable_if<std::is_integral<_A1>::value, long long>::type
llround(_A1 __lcpp_x) noexcept
{

    return __builtin_llround((double)__lcpp_x);



}



inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) float log1p(float __lcpp_x) noexcept {return ::log1pf(__lcpp_x);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) long double log1p(long double __lcpp_x) noexcept {return ::log1pl(__lcpp_x);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
log1p(_A1 __lcpp_x) noexcept {return ::log1p((double)__lcpp_x);}



inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) float log2(float __lcpp_x) noexcept {return ::log2f(__lcpp_x);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) long double log2(long double __lcpp_x) noexcept {return ::log2l(__lcpp_x);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
log2(_A1 __lcpp_x) noexcept {return ::log2((double)__lcpp_x);}



inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) float logb(float __lcpp_x) noexcept {return ::logbf(__lcpp_x);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) long double logb(long double __lcpp_x) noexcept {return ::logbl(__lcpp_x);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
logb(_A1 __lcpp_x) noexcept {return ::logb((double)__lcpp_x);}



inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) long lrint(float __lcpp_x) noexcept
{

    return __builtin_lrintf(__lcpp_x);



}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) long lrint(long double __lcpp_x) noexcept
{

    return __builtin_lrintl(__lcpp_x);



}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename std::enable_if<std::is_integral<_A1>::value, long>::type
lrint(_A1 __lcpp_x) noexcept
{

    return __builtin_lrint((double)__lcpp_x);



}



inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) long lround(float __lcpp_x) noexcept
{

    return __builtin_lroundf(__lcpp_x);



}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) long lround(long double __lcpp_x) noexcept
{

    return __builtin_lroundl(__lcpp_x);



}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename std::enable_if<std::is_integral<_A1>::value, long>::type
lround(_A1 __lcpp_x) noexcept
{

    return __builtin_lround((double)__lcpp_x);



}





inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) float nearbyint(float __lcpp_x) noexcept {return ::nearbyintf(__lcpp_x);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) long double nearbyint(long double __lcpp_x) noexcept {return ::nearbyintl(__lcpp_x);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
nearbyint(_A1 __lcpp_x) noexcept {return ::nearbyint((double)__lcpp_x);}



inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) float nextafter(float __lcpp_x, float __lcpp_y) noexcept {return ::nextafterf(__lcpp_x, __lcpp_y);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) long double nextafter(long double __lcpp_x, long double __lcpp_y) noexcept {return ::nextafterl(__lcpp_x, __lcpp_y);}

template <class _A1, class _A2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename std::_EnableIf
<
    std::is_arithmetic<_A1>::value &&
    std::is_arithmetic<_A2>::value,
    std::__promote<_A1, _A2>
>::type
nextafter(_A1 __lcpp_x, _A2 __lcpp_y) noexcept
{
    typedef typename std::__promote<_A1, _A2>::type __result_type;
    static_assert((!(std::_IsSame<_A1, __result_type>::value &&
                     std::_IsSame<_A2, __result_type>::value)), "");
    return ::nextafter((__result_type)__lcpp_x, (__result_type)__lcpp_y);
}



inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) float nexttoward(float __lcpp_x, long double __lcpp_y) noexcept {return ::nexttowardf(__lcpp_x, __lcpp_y);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) long double nexttoward(long double __lcpp_x, long double __lcpp_y) noexcept {return ::nexttowardl(__lcpp_x, __lcpp_y);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
nexttoward(_A1 __lcpp_x, long double __lcpp_y) noexcept {return ::nexttoward((double)__lcpp_x, __lcpp_y);}



inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) float remainder(float __lcpp_x, float __lcpp_y) noexcept {return ::remainderf(__lcpp_x, __lcpp_y);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) long double remainder(long double __lcpp_x, long double __lcpp_y) noexcept {return ::remainderl(__lcpp_x, __lcpp_y);}

template <class _A1, class _A2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename std::_EnableIf
<
    std::is_arithmetic<_A1>::value &&
    std::is_arithmetic<_A2>::value,
    std::__promote<_A1, _A2>
>::type
remainder(_A1 __lcpp_x, _A2 __lcpp_y) noexcept
{
    typedef typename std::__promote<_A1, _A2>::type __result_type;
    static_assert((!(std::_IsSame<_A1, __result_type>::value &&
                     std::_IsSame<_A2, __result_type>::value)), "");
    return ::remainder((__result_type)__lcpp_x, (__result_type)__lcpp_y);
}



inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) float remquo(float __lcpp_x, float __lcpp_y, int* __lcpp_z) noexcept {return ::remquof(__lcpp_x, __lcpp_y, __lcpp_z);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) long double remquo(long double __lcpp_x, long double __lcpp_y, int* __lcpp_z) noexcept {return ::remquol(__lcpp_x, __lcpp_y, __lcpp_z);}

template <class _A1, class _A2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename std::_EnableIf
<
    std::is_arithmetic<_A1>::value &&
    std::is_arithmetic<_A2>::value,
    std::__promote<_A1, _A2>
>::type
remquo(_A1 __lcpp_x, _A2 __lcpp_y, int* __lcpp_z) noexcept
{
    typedef typename std::__promote<_A1, _A2>::type __result_type;
    static_assert((!(std::_IsSame<_A1, __result_type>::value &&
                     std::_IsSame<_A2, __result_type>::value)), "");
    return ::remquo((__result_type)__lcpp_x, (__result_type)__lcpp_y, __lcpp_z);
}



inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) float rint(float __lcpp_x) noexcept
{

    return __builtin_rintf(__lcpp_x);



}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) long double rint(long double __lcpp_x) noexcept
{

    return __builtin_rintl(__lcpp_x);



}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
rint(_A1 __lcpp_x) noexcept
{

    return __builtin_rint((double)__lcpp_x);



}



inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) float round(float __lcpp_x) noexcept
{

    return __builtin_round(__lcpp_x);



}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) long double round(long double __lcpp_x) noexcept
{

    return __builtin_roundl(__lcpp_x);



}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
round(_A1 __lcpp_x) noexcept
{

    return __builtin_round((double)__lcpp_x);



}



inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) float scalbln(float __lcpp_x, long __lcpp_y) noexcept {return ::scalblnf(__lcpp_x, __lcpp_y);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) long double scalbln(long double __lcpp_x, long __lcpp_y) noexcept {return ::scalblnl(__lcpp_x, __lcpp_y);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
scalbln(_A1 __lcpp_x, long __lcpp_y) noexcept {return ::scalbln((double)__lcpp_x, __lcpp_y);}



inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) float scalbn(float __lcpp_x, int __lcpp_y) noexcept {return ::scalbnf(__lcpp_x, __lcpp_y);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) long double scalbn(long double __lcpp_x, int __lcpp_y) noexcept {return ::scalbnl(__lcpp_x, __lcpp_y);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
scalbn(_A1 __lcpp_x, int __lcpp_y) noexcept {return ::scalbn((double)__lcpp_x, __lcpp_y);}



inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) float tgamma(float __lcpp_x) noexcept {return ::tgammaf(__lcpp_x);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) long double tgamma(long double __lcpp_x) noexcept {return ::tgammal(__lcpp_x);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
tgamma(_A1 __lcpp_x) noexcept {return ::tgamma((double)__lcpp_x);}



inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) float trunc(float __lcpp_x) noexcept
{

    return __builtin_trunc(__lcpp_x);



}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) long double trunc(long double __lcpp_x) noexcept
{

    return __builtin_truncl(__lcpp_x);



}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
trunc(_A1 __lcpp_x) noexcept
{

    return __builtin_trunc((double)__lcpp_x);



}

}
# 309 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cmath" 2 3

# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 1 3
# 311 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cmath" 2 3
# 314 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cmath" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 318 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cmath" 2 3

namespace std { inline namespace __1 {

using ::signbit __attribute__((using_if_exists));
using ::fpclassify __attribute__((using_if_exists));
using ::isfinite __attribute__((using_if_exists));
using ::isinf __attribute__((using_if_exists));
using ::isnan __attribute__((using_if_exists));
using ::isnormal __attribute__((using_if_exists));
using ::isgreater __attribute__((using_if_exists));
using ::isgreaterequal __attribute__((using_if_exists));
using ::isless __attribute__((using_if_exists));
using ::islessequal __attribute__((using_if_exists));
using ::islessgreater __attribute__((using_if_exists));
using ::isunordered __attribute__((using_if_exists));
using ::isunordered __attribute__((using_if_exists));

using ::float_t __attribute__((using_if_exists));
using ::double_t __attribute__((using_if_exists));

using ::abs __attribute__((using_if_exists));

using ::acos __attribute__((using_if_exists));
using ::acosf __attribute__((using_if_exists));
using ::asin __attribute__((using_if_exists));
using ::asinf __attribute__((using_if_exists));
using ::atan __attribute__((using_if_exists));
using ::atanf __attribute__((using_if_exists));
using ::atan2 __attribute__((using_if_exists));
using ::atan2f __attribute__((using_if_exists));
using ::ceil __attribute__((using_if_exists));
using ::ceilf __attribute__((using_if_exists));
using ::cos __attribute__((using_if_exists));
using ::cosf __attribute__((using_if_exists));
using ::cosh __attribute__((using_if_exists));
using ::coshf __attribute__((using_if_exists));

using ::exp __attribute__((using_if_exists));
using ::expf __attribute__((using_if_exists));

using ::fabs __attribute__((using_if_exists));
using ::fabsf __attribute__((using_if_exists));
using ::floor __attribute__((using_if_exists));
using ::floorf __attribute__((using_if_exists));

using ::fmod __attribute__((using_if_exists));
using ::fmodf __attribute__((using_if_exists));

using ::frexp __attribute__((using_if_exists));
using ::frexpf __attribute__((using_if_exists));
using ::ldexp __attribute__((using_if_exists));
using ::ldexpf __attribute__((using_if_exists));

using ::log __attribute__((using_if_exists));
using ::logf __attribute__((using_if_exists));

using ::log10 __attribute__((using_if_exists));
using ::log10f __attribute__((using_if_exists));
using ::modf __attribute__((using_if_exists));
using ::modff __attribute__((using_if_exists));

using ::pow __attribute__((using_if_exists));
using ::powf __attribute__((using_if_exists));

using ::sin __attribute__((using_if_exists));
using ::sinf __attribute__((using_if_exists));
using ::sinh __attribute__((using_if_exists));
using ::sinhf __attribute__((using_if_exists));

using ::sqrt __attribute__((using_if_exists));
using ::sqrtf __attribute__((using_if_exists));
using ::tan __attribute__((using_if_exists));
using ::tanf __attribute__((using_if_exists));

using ::tanh __attribute__((using_if_exists));
using ::tanhf __attribute__((using_if_exists));

using ::acosh __attribute__((using_if_exists));
using ::acoshf __attribute__((using_if_exists));
using ::asinh __attribute__((using_if_exists));
using ::asinhf __attribute__((using_if_exists));
using ::atanh __attribute__((using_if_exists));
using ::atanhf __attribute__((using_if_exists));
using ::cbrt __attribute__((using_if_exists));
using ::cbrtf __attribute__((using_if_exists));

using ::copysign __attribute__((using_if_exists));
using ::copysignf __attribute__((using_if_exists));

using ::erf __attribute__((using_if_exists));
using ::erff __attribute__((using_if_exists));
using ::erfc __attribute__((using_if_exists));
using ::erfcf __attribute__((using_if_exists));
using ::exp2 __attribute__((using_if_exists));
using ::exp2f __attribute__((using_if_exists));
using ::expm1 __attribute__((using_if_exists));
using ::expm1f __attribute__((using_if_exists));
using ::fdim __attribute__((using_if_exists));
using ::fdimf __attribute__((using_if_exists));
using ::fmaf __attribute__((using_if_exists));
using ::fma __attribute__((using_if_exists));
using ::fmax __attribute__((using_if_exists));
using ::fmaxf __attribute__((using_if_exists));
using ::fmin __attribute__((using_if_exists));
using ::fminf __attribute__((using_if_exists));
using ::hypot __attribute__((using_if_exists));
using ::hypotf __attribute__((using_if_exists));
using ::ilogb __attribute__((using_if_exists));
using ::ilogbf __attribute__((using_if_exists));
using ::lgamma __attribute__((using_if_exists));
using ::lgammaf __attribute__((using_if_exists));
using ::llrint __attribute__((using_if_exists));
using ::llrintf __attribute__((using_if_exists));
using ::llround __attribute__((using_if_exists));
using ::llroundf __attribute__((using_if_exists));
using ::log1p __attribute__((using_if_exists));
using ::log1pf __attribute__((using_if_exists));
using ::log2 __attribute__((using_if_exists));
using ::log2f __attribute__((using_if_exists));
using ::logb __attribute__((using_if_exists));
using ::logbf __attribute__((using_if_exists));
using ::lrint __attribute__((using_if_exists));
using ::lrintf __attribute__((using_if_exists));
using ::lround __attribute__((using_if_exists));
using ::lroundf __attribute__((using_if_exists));

using ::nan __attribute__((using_if_exists));
using ::nanf __attribute__((using_if_exists));

using ::nearbyint __attribute__((using_if_exists));
using ::nearbyintf __attribute__((using_if_exists));
using ::nextafter __attribute__((using_if_exists));
using ::nextafterf __attribute__((using_if_exists));
using ::nexttoward __attribute__((using_if_exists));
using ::nexttowardf __attribute__((using_if_exists));
using ::remainder __attribute__((using_if_exists));
using ::remainderf __attribute__((using_if_exists));
using ::remquo __attribute__((using_if_exists));
using ::remquof __attribute__((using_if_exists));
using ::rint __attribute__((using_if_exists));
using ::rintf __attribute__((using_if_exists));
using ::round __attribute__((using_if_exists));
using ::roundf __attribute__((using_if_exists));
using ::scalbln __attribute__((using_if_exists));
using ::scalblnf __attribute__((using_if_exists));
using ::scalbn __attribute__((using_if_exists));
using ::scalbnf __attribute__((using_if_exists));
using ::tgamma __attribute__((using_if_exists));
using ::tgammaf __attribute__((using_if_exists));
using ::trunc __attribute__((using_if_exists));
using ::truncf __attribute__((using_if_exists));

using ::acosl __attribute__((using_if_exists));
using ::asinl __attribute__((using_if_exists));
using ::atanl __attribute__((using_if_exists));
using ::atan2l __attribute__((using_if_exists));
using ::ceill __attribute__((using_if_exists));
using ::cosl __attribute__((using_if_exists));
using ::coshl __attribute__((using_if_exists));
using ::expl __attribute__((using_if_exists));
using ::fabsl __attribute__((using_if_exists));
using ::floorl __attribute__((using_if_exists));
using ::fmodl __attribute__((using_if_exists));
using ::frexpl __attribute__((using_if_exists));
using ::ldexpl __attribute__((using_if_exists));
using ::logl __attribute__((using_if_exists));
using ::log10l __attribute__((using_if_exists));
using ::modfl __attribute__((using_if_exists));
using ::powl __attribute__((using_if_exists));
using ::sinl __attribute__((using_if_exists));
using ::sinhl __attribute__((using_if_exists));
using ::sqrtl __attribute__((using_if_exists));
using ::tanl __attribute__((using_if_exists));

using ::tanhl __attribute__((using_if_exists));
using ::acoshl __attribute__((using_if_exists));
using ::asinhl __attribute__((using_if_exists));
using ::atanhl __attribute__((using_if_exists));
using ::cbrtl __attribute__((using_if_exists));

using ::copysignl __attribute__((using_if_exists));

using ::erfl __attribute__((using_if_exists));
using ::erfcl __attribute__((using_if_exists));
using ::exp2l __attribute__((using_if_exists));
using ::expm1l __attribute__((using_if_exists));
using ::fdiml __attribute__((using_if_exists));
using ::fmal __attribute__((using_if_exists));
using ::fmaxl __attribute__((using_if_exists));
using ::fminl __attribute__((using_if_exists));
using ::hypotl __attribute__((using_if_exists));
using ::ilogbl __attribute__((using_if_exists));
using ::lgammal __attribute__((using_if_exists));
using ::llrintl __attribute__((using_if_exists));
using ::llroundl __attribute__((using_if_exists));
using ::log1pl __attribute__((using_if_exists));
using ::log2l __attribute__((using_if_exists));
using ::logbl __attribute__((using_if_exists));
using ::lrintl __attribute__((using_if_exists));
using ::lroundl __attribute__((using_if_exists));
using ::nanl __attribute__((using_if_exists));
using ::nearbyintl __attribute__((using_if_exists));
using ::nextafterl __attribute__((using_if_exists));
using ::nexttowardl __attribute__((using_if_exists));
using ::remainderl __attribute__((using_if_exists));
using ::remquol __attribute__((using_if_exists));
using ::rintl __attribute__((using_if_exists));
using ::roundl __attribute__((using_if_exists));
using ::scalblnl __attribute__((using_if_exists));
using ::scalbnl __attribute__((using_if_exists));
using ::tgammal __attribute__((using_if_exists));
using ::truncl __attribute__((using_if_exists));


inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) float hypot( float x, float y, float z ) { return sqrt(x*x + y*y + z*z); }
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) double hypot( double x, double y, double z ) { return sqrt(x*x + y*y + z*z); }
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) long double hypot( long double x, long double y, long double z ) { return sqrt(x*x + y*y + z*z); }

template <class _A1, class _A2, class _A3>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename _EnableIf
<
    is_arithmetic<_A1>::value &&
    is_arithmetic<_A2>::value &&
    is_arithmetic<_A3>::value,
    __promote<_A1, _A2, _A3>
>::type
hypot(_A1 __lcpp_x, _A2 __lcpp_y, _A3 __lcpp_z) noexcept
{
    typedef typename __promote<_A1, _A2, _A3>::type __result_type;
    static_assert((!(is_same<_A1, __result_type>::value &&
                     is_same<_A2, __result_type>::value &&
                     is_same<_A3, __result_type>::value)), "");
    return hypot((__result_type)__lcpp_x, (__result_type)__lcpp_y, (__result_type)__lcpp_z);
}


template <class _A1>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
constexpr typename enable_if<is_floating_point<_A1>::value, bool>::type
__libcpp_isnan_or_builtin(_A1 __lcpp_x) noexcept
{

    return __builtin_isnan(__lcpp_x);



}

template <class _A1>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
constexpr typename enable_if<!is_floating_point<_A1>::value, bool>::type
__libcpp_isnan_or_builtin(_A1 __lcpp_x) noexcept
{
    return isnan(__lcpp_x);
}

template <class _A1>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
constexpr typename enable_if<is_floating_point<_A1>::value, bool>::type
__libcpp_isinf_or_builtin(_A1 __lcpp_x) noexcept
{

    return __builtin_isinf(__lcpp_x);



}

template <class _A1>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
constexpr typename enable_if<!is_floating_point<_A1>::value, bool>::type
__libcpp_isinf_or_builtin(_A1 __lcpp_x) noexcept
{
    return isinf(__lcpp_x);
}

template <class _A1>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
constexpr typename enable_if<is_floating_point<_A1>::value, bool>::type
__libcpp_isfinite_or_builtin(_A1 __lcpp_x) noexcept
{

    return __builtin_isfinite(__lcpp_x);



}

template <class _A1>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
constexpr typename enable_if<!is_floating_point<_A1>::value, bool>::type
__libcpp_isfinite_or_builtin(_A1 __lcpp_x) noexcept
{
    return isfinite(__lcpp_x);
}
# 641 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cmath" 3
template <class _IntT, class _FloatT,
    bool _FloatBigger = (numeric_limits<_FloatT>::digits > numeric_limits<_IntT>::digits),
    int _Bits = (numeric_limits<_IntT>::digits - numeric_limits<_FloatT>::digits)>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
constexpr _IntT __max_representable_int_for_float() noexcept {
  static_assert(is_floating_point<_FloatT>::value, "must be a floating point type");
  static_assert(is_integral<_IntT>::value, "must be an integral type");
  static_assert(numeric_limits<_FloatT>::radix == 2, "FloatT has incorrect radix");
  static_assert((_IsSame<_FloatT, float>::value || _IsSame<_FloatT, double>::value
                 || _IsSame<_FloatT,long double>::value), "unsupported floating point type");
  return _FloatBigger ? numeric_limits<_IntT>::max() : (numeric_limits<_IntT>::max() >> _Bits << _Bits);
}





template <class _IntT, class _RealT>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
_IntT __clamp_to_integral(_RealT __r) noexcept {
  using _Lim = numeric_limits<_IntT>;
  const _IntT _MaxVal = __max_representable_int_for_float<_IntT, _RealT>();
  if (__r >= ::nextafter(static_cast<_RealT>(_MaxVal), __builtin_huge_valf())) {
    return _Lim::max();
  } else if (__r <= _Lim::lowest()) {
    return _Lim::min();
  }
  return static_cast<_IntT>(__r);
}

} }
# 57 "/usr/local/include/bits/stdc++.h" 2


# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/csetjmp" 1 3
# 34 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/csetjmp" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/setjmp.h" 1 3
# 32 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/setjmp.h" 3


# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/setjmp.h" 1 3 4
# 79 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/setjmp.h" 3 4
typedef int jmp_buf[((14 + 8 + 2) * 2)];
typedef int sigjmp_buf[((14 + 8 + 2) * 2) + 1];





extern "C" {
extern int setjmp(jmp_buf);
extern void longjmp(jmp_buf, int) __attribute__((__noreturn__));


int _setjmp(jmp_buf);
void _longjmp(jmp_buf, int) __attribute__((__noreturn__));
int sigsetjmp(sigjmp_buf, int);
void siglongjmp(sigjmp_buf, int) __attribute__((__noreturn__));



void longjmperror(void);

}
# 35 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/setjmp.h" 2 3
# 35 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/csetjmp" 2 3
# 38 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/csetjmp" 3


namespace std { inline namespace __1 {

using ::jmp_buf __attribute__((using_if_exists));
using ::longjmp __attribute__((using_if_exists));

} }
# 60 "/usr/local/include/bits/stdc++.h" 2


# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/csignal" 1 3
# 43 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/csignal" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/signal.h" 1 3 4
# 66 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/signal.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_pthread/_pthread_t.h" 1 3 4
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_pthread/_pthread_t.h" 3 4
typedef __darwin_pthread_t pthread_t;
# 67 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/signal.h" 2 3 4


extern const char *const sys_signame[32];
extern const char *const sys_siglist[32];


extern "C" {
int raise(int);
}


extern "C" {
void (* _Nullable bsd_signal(int, void (* _Nullable)(int)))(int);
int kill(pid_t, int) __asm("_" "kill" );
int killpg(pid_t, int) __asm("_" "killpg" );
int pthread_kill(pthread_t, int);
int pthread_sigmask(int, const sigset_t *, sigset_t *) __asm("_" "pthread_sigmask" );
int sigaction(int, const struct sigaction * ,
     struct sigaction * );
int sigaddset(sigset_t *, int);
int sigaltstack(const stack_t * , stack_t * ) __asm("_" "sigaltstack" ) __attribute__((availability(watchos,unavailable))) __attribute__((availability(tvos,unavailable)));
int sigdelset(sigset_t *, int);
int sigemptyset(sigset_t *);
int sigfillset(sigset_t *);
int sighold(int);
int sigignore(int);
int siginterrupt(int, int);
int sigismember(const sigset_t *, int);
int sigpause(int) __asm("_" "sigpause" );
int sigpending(sigset_t *);
int sigprocmask(int, const sigset_t * , sigset_t * );
int sigrelse(int);
void (* _Nullable sigset(int, void (* _Nullable)(int)))(int);
int sigsuspend(const sigset_t *) __asm("_" "sigsuspend" );
int sigwait(const sigset_t * , int * ) __asm("_" "sigwait" );

void psignal(unsigned int, const char *);
int sigblock(int);
int sigsetmask(int);
int sigvec(int, struct sigvec *, struct sigvec *);

}


inline __attribute__ ((__always_inline__)) int
__sigbits(int __signo)
{
    return __signo > 32 ? 0 : (1 << (__signo - 1));
}
# 44 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/csignal" 2 3
# 47 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/csignal" 3


namespace std { inline namespace __1 {

using ::sig_atomic_t __attribute__((using_if_exists));
using ::signal __attribute__((using_if_exists));
using ::raise __attribute__((using_if_exists));

} }
# 63 "/usr/local/include/bits/stdc++.h" 2


# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cstdarg" 1 3
# 35 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cstdarg" 3
# 1 "/Library/Developer/CommandLineTools/usr/lib/clang/13.1.6/include/stdarg.h" 1 3
# 14 "/Library/Developer/CommandLineTools/usr/lib/clang/13.1.6/include/stdarg.h" 3
typedef __builtin_va_list va_list;
# 32 "/Library/Developer/CommandLineTools/usr/lib/clang/13.1.6/include/stdarg.h" 3
typedef __builtin_va_list __gnuc_va_list;
# 36 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cstdarg" 2 3
# 39 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cstdarg" 3


namespace std { inline namespace __1 {

using ::va_list __attribute__((using_if_exists));

} }
# 66 "/usr/local/include/bits/stdc++.h" 2





# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cstdio" 1 3
# 99 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cstdio" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/stdio.h" 1 3
# 105 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/stdio.h" 3


# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/stdio.h" 1 3 4
# 64 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/stdio.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/_stdio.h" 1 3 4
# 75 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/_stdio.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_va_list.h" 1 3 4
# 32 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_va_list.h" 3 4
typedef __darwin_va_list va_list;
# 76 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/_stdio.h" 2 3 4



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/stdio.h" 1 3 4
# 45 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/stdio.h" 3 4
extern "C" {

int renameat(int, const char *, int, const char *) __attribute__((availability(macosx,introduced=10.10)));



int renamex_np(const char *, const char *, unsigned int) __attribute__((availability(macosx,introduced=10.12))) __attribute__((availability(ios,introduced=10.0))) __attribute__((availability(tvos,introduced=10.0))) __attribute__((availability(watchos,introduced=3.0)));
int renameatx_np(int, const char *, int, const char *, unsigned int) __attribute__((availability(macosx,introduced=10.12))) __attribute__((availability(ios,introduced=10.0))) __attribute__((availability(tvos,introduced=10.0))) __attribute__((availability(watchos,introduced=3.0)));



}
# 80 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/_stdio.h" 2 3 4

typedef __darwin_off_t fpos_t;
# 92 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/_stdio.h" 3 4
struct __sbuf {
 unsigned char *_base;
 int _size;
};


struct __sFILEX;
# 126 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/_stdio.h" 3 4
typedef struct __sFILE {
 unsigned char *_p;
 int _r;
 int _w;
 short _flags;
 short _file;
 struct __sbuf _bf;
 int _lbfsize;


 void *_cookie;
 int (* _Nullable _close)(void *);
 int (* _Nullable _read) (void *, char *, int);
 fpos_t (* _Nullable _seek) (void *, fpos_t, int);
 int (* _Nullable _write)(void *, const char *, int);


 struct __sbuf _ub;
 struct __sFILEX *_extra;
 int _ur;


 unsigned char _ubuf[3];
 unsigned char _nbuf[1];


 struct __sbuf _lb;


 int _blksize;
 fpos_t _offset;
} FILE;
# 65 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/stdio.h" 2 3 4

extern "C" {
extern FILE *__stdinp;
extern FILE *__stdoutp;
extern FILE *__stderrp;
}
# 141 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/stdio.h" 3 4
extern "C" {
void clearerr(FILE *);
int fclose(FILE *);
int feof(FILE *);
int ferror(FILE *);
int fflush(FILE *);
int fgetc(FILE *);
int fgetpos(FILE * , fpos_t *);
char *fgets(char * , int, FILE *);



FILE *fopen(const char * __filename, const char * __mode) __asm("_" "fopen" );

int fprintf(FILE * , const char * , ...) __attribute__((__format__ (__printf__, 2, 3)));
int fputc(int, FILE *);
int fputs(const char * , FILE * ) __asm("_" "fputs" );
size_t fread(void * __ptr, size_t __size, size_t __nitems, FILE * __stream);
FILE *freopen(const char * , const char * ,
                 FILE * ) __asm("_" "freopen" );
int fscanf(FILE * , const char * , ...) __attribute__((__format__ (__scanf__, 2, 3)));
int fseek(FILE *, long, int);
int fsetpos(FILE *, const fpos_t *);
long ftell(FILE *);
size_t fwrite(const void * __ptr, size_t __size, size_t __nitems, FILE * __stream) __asm("_" "fwrite" );
int getc(FILE *);
int getchar(void);
char *gets(char *);
void perror(const char *) __attribute__((__cold__));
int printf(const char * , ...) __attribute__((__format__ (__printf__, 1, 2)));
int putc(int, FILE *);
int putchar(int);
int puts(const char *);
int remove(const char *);
int rename (const char *__old, const char *__new);
void rewind(FILE *);
int scanf(const char * , ...) __attribute__((__format__ (__scanf__, 1, 2)));
void setbuf(FILE * , char * );
int setvbuf(FILE * , char * , int, size_t);
int sprintf(char * , const char * , ...) __attribute__((__format__ (__printf__, 2, 3))) __attribute__((__availability__(swift, unavailable, message="Use snprintf instead.")));
int sscanf(const char * , const char * , ...) __attribute__((__format__ (__scanf__, 2, 3)));
FILE *tmpfile(void);

__attribute__((__availability__(swift, unavailable, message="Use mkstemp(3) instead.")))

__attribute__((__deprecated__("This function is provided for compatibility reasons only.  Due to security concerns inherent in the design of tmpnam(3), it is highly recommended that you use mkstemp(3) instead.")))

char *tmpnam(char *);
int ungetc(int, FILE *);
int vfprintf(FILE * , const char * , va_list) __attribute__((__format__ (__printf__, 2, 0)));
int vprintf(const char * , va_list) __attribute__((__format__ (__printf__, 1, 0)));
int vsprintf(char * , const char * , va_list) __attribute__((__format__ (__printf__, 2, 0))) __attribute__((__availability__(swift, unavailable, message="Use vsnprintf instead.")));
}
# 204 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/stdio.h" 3 4
extern "C" {
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/_ctermid.h" 1 3 4
# 29 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/_ctermid.h" 3 4
extern "C" {

char *ctermid(char *);

}
# 206 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/stdio.h" 2 3 4




FILE *fdopen(int, const char *) __asm("_" "fdopen" );

int fileno(FILE *);
}
# 222 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/stdio.h" 3 4
extern "C" {
int pclose(FILE *) __attribute__((__availability__(swift, unavailable, message="Use posix_spawn APIs or NSTask instead. (On iOS, process spawning is unavailable.)")));



FILE *popen(const char *, const char *) __asm("_" "popen" ) __attribute__((__availability__(swift, unavailable, message="Use posix_spawn APIs or NSTask instead. (On iOS, process spawning is unavailable.)")));

}
# 241 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/stdio.h" 3 4
extern "C" {
int __srget(FILE *);
int __svfscanf(FILE *, const char *, va_list) __attribute__((__format__ (__scanf__, 2, 0)));
int __swbuf(int, FILE *);
}







inline __attribute__ ((__always_inline__)) int __sputc(int _c, FILE *_p) {
 if (--_p->_w >= 0 || (_p->_w >= _p->_lbfsize && (char)_c != '\n'))
  return (*_p->_p++ = _c);
 else
  return (__swbuf(_c, _p));
}
# 278 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/stdio.h" 3 4
extern "C" {
void flockfile(FILE *);
int ftrylockfile(FILE *);
void funlockfile(FILE *);
int getc_unlocked(FILE *);
int getchar_unlocked(void);
int putc_unlocked(int, FILE *);
int putchar_unlocked(int);



int getw(FILE *);
int putw(int, FILE *);


__attribute__((__availability__(swift, unavailable, message="Use mkstemp(3) instead.")))

__attribute__((__deprecated__("This function is provided for compatibility reasons only.  Due to security concerns inherent in the design of tempnam(3), it is highly recommended that you use mkstemp(3) instead.")))

char *tempnam(const char *__dir, const char *__prefix) __asm("_" "tempnam" );
}
# 317 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/stdio.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_off_t.h" 1 3 4
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_off_t.h" 3 4
typedef __darwin_off_t off_t;
# 318 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/stdio.h" 2 3 4

extern "C" {
int fseeko(FILE * __stream, off_t __offset, int __whence);
off_t ftello(FILE * __stream);
}



extern "C" {
int snprintf(char * __str, size_t __size, const char * __format, ...) __attribute__((__format__ (__printf__, 3, 4)));
int vfscanf(FILE * __stream, const char * __format, va_list) __attribute__((__format__ (__scanf__, 2, 0)));
int vscanf(const char * __format, va_list) __attribute__((__format__ (__scanf__, 1, 0)));
int vsnprintf(char * __str, size_t __size, const char * __format, va_list) __attribute__((__format__ (__printf__, 3, 0)));
int vsscanf(const char * __str, const char * __format, va_list) __attribute__((__format__ (__scanf__, 2, 0)));
}
# 342 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/stdio.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_ssize_t.h" 1 3 4
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_ssize_t.h" 3 4
typedef __darwin_ssize_t ssize_t;
# 343 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/stdio.h" 2 3 4

extern "C" {
int dprintf(int, const char * , ...) __attribute__((__format__ (__printf__, 2, 3))) __attribute__((availability(macosx,introduced=10.7)));
int vdprintf(int, const char * , va_list) __attribute__((__format__ (__printf__, 2, 0))) __attribute__((availability(macosx,introduced=10.7)));
ssize_t getdelim(char ** __linep, size_t * __linecapp, int __delimiter, FILE * __stream) __attribute__((availability(macosx,introduced=10.7)));
ssize_t getline(char ** __linep, size_t * __linecapp, FILE * __stream) __attribute__((availability(macosx,introduced=10.7)));
FILE *fmemopen(void * __buf, size_t __size, const char * __mode) __attribute__((availability(macos,introduced=10.13))) __attribute__((availability(ios,introduced=11.0))) __attribute__((availability(tvos,introduced=11.0))) __attribute__((availability(watchos,introduced=4.0)));
FILE *open_memstream(char **__bufp, size_t *__sizep) __attribute__((availability(macos,introduced=10.13))) __attribute__((availability(ios,introduced=11.0))) __attribute__((availability(tvos,introduced=11.0))) __attribute__((availability(watchos,introduced=4.0)));
}







extern "C" {
extern const int sys_nerr;
extern const char *const sys_errlist[];

int asprintf(char ** , const char * , ...) __attribute__((__format__ (__printf__, 2, 3)));
char *ctermid_r(char *);
char *fgetln(FILE *, size_t *);
const char *fmtcheck(const char *, const char *);
int fpurge(FILE *);
void setbuffer(FILE *, char *, int);
int setlinebuf(FILE *);
int vasprintf(char ** , const char * , va_list) __attribute__((__format__ (__printf__, 2, 0)));





FILE *funopen(const void *,
                 int (* _Nullable)(void *, char *, int),
                 int (* _Nullable)(void *, const char *, int),
                 fpos_t (* _Nullable)(void *, fpos_t, int),
                 int (* _Nullable)(void *));
}
# 108 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/stdio.h" 2 3
# 100 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cstdio" 2 3
# 103 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cstdio" 3


namespace std { inline namespace __1 {

using ::FILE __attribute__((using_if_exists));
using ::fpos_t __attribute__((using_if_exists));
using ::size_t __attribute__((using_if_exists));

using ::fclose __attribute__((using_if_exists));
using ::fflush __attribute__((using_if_exists));
using ::setbuf __attribute__((using_if_exists));
using ::setvbuf __attribute__((using_if_exists));
using ::fprintf __attribute__((using_if_exists));
using ::fscanf __attribute__((using_if_exists));
using ::snprintf __attribute__((using_if_exists));
using ::sprintf __attribute__((using_if_exists));
using ::sscanf __attribute__((using_if_exists));
using ::vfprintf __attribute__((using_if_exists));
using ::vfscanf __attribute__((using_if_exists));
using ::vsscanf __attribute__((using_if_exists));
using ::vsnprintf __attribute__((using_if_exists));
using ::vsprintf __attribute__((using_if_exists));
using ::fgetc __attribute__((using_if_exists));
using ::fgets __attribute__((using_if_exists));
using ::fputc __attribute__((using_if_exists));
using ::fputs __attribute__((using_if_exists));
using ::getc __attribute__((using_if_exists));
using ::putc __attribute__((using_if_exists));
using ::ungetc __attribute__((using_if_exists));
using ::fread __attribute__((using_if_exists));
using ::fwrite __attribute__((using_if_exists));

using ::fgetpos __attribute__((using_if_exists));

using ::fseek __attribute__((using_if_exists));

using ::fsetpos __attribute__((using_if_exists));

using ::ftell __attribute__((using_if_exists));
using ::rewind __attribute__((using_if_exists));
using ::clearerr __attribute__((using_if_exists));
using ::feof __attribute__((using_if_exists));
using ::ferror __attribute__((using_if_exists));
using ::perror __attribute__((using_if_exists));


using ::fopen __attribute__((using_if_exists));
using ::freopen __attribute__((using_if_exists));

using ::remove __attribute__((using_if_exists));

using ::rename __attribute__((using_if_exists));
using ::tmpfile __attribute__((using_if_exists));
using ::tmpnam __attribute__((using_if_exists));



using ::getchar __attribute__((using_if_exists));



using ::scanf __attribute__((using_if_exists));
using ::vscanf __attribute__((using_if_exists));



using ::printf __attribute__((using_if_exists));
using ::putchar __attribute__((using_if_exists));
using ::puts __attribute__((using_if_exists));
using ::vprintf __attribute__((using_if_exists));


} }
# 72 "/usr/local/include/bits/stdc++.h" 2


# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cstdlib" 1 3
# 85 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cstdlib" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/stdlib.h" 1 3
# 86 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cstdlib" 2 3
# 89 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cstdlib" 3








namespace std { inline namespace __1 {

using ::size_t __attribute__((using_if_exists));
using ::div_t __attribute__((using_if_exists));
using ::ldiv_t __attribute__((using_if_exists));

using ::lldiv_t __attribute__((using_if_exists));

using ::atof __attribute__((using_if_exists));
using ::atoi __attribute__((using_if_exists));
using ::atol __attribute__((using_if_exists));

using ::atoll __attribute__((using_if_exists));

using ::strtod __attribute__((using_if_exists));
using ::strtof __attribute__((using_if_exists));
using ::strtold __attribute__((using_if_exists));
using ::strtol __attribute__((using_if_exists));

using ::strtoll __attribute__((using_if_exists));

using ::strtoul __attribute__((using_if_exists));

using ::strtoull __attribute__((using_if_exists));

using ::rand __attribute__((using_if_exists));
using ::srand __attribute__((using_if_exists));
using ::calloc __attribute__((using_if_exists));
using ::free __attribute__((using_if_exists));
using ::malloc __attribute__((using_if_exists));
using ::realloc __attribute__((using_if_exists));
using ::abort __attribute__((using_if_exists));
using ::atexit __attribute__((using_if_exists));
using ::exit __attribute__((using_if_exists));
using ::_Exit __attribute__((using_if_exists));

using ::getenv __attribute__((using_if_exists));
using ::system __attribute__((using_if_exists));

using ::bsearch __attribute__((using_if_exists));
using ::qsort __attribute__((using_if_exists));
using ::abs __attribute__((using_if_exists));
using ::labs __attribute__((using_if_exists));

using ::llabs __attribute__((using_if_exists));

using ::div __attribute__((using_if_exists));
using ::ldiv __attribute__((using_if_exists));

using ::lldiv __attribute__((using_if_exists));

using ::mblen __attribute__((using_if_exists));
using ::mbtowc __attribute__((using_if_exists));
using ::wctomb __attribute__((using_if_exists));
using ::mbstowcs __attribute__((using_if_exists));
using ::wcstombs __attribute__((using_if_exists));

using ::at_quick_exit __attribute__((using_if_exists));
using ::quick_exit __attribute__((using_if_exists));


using ::aligned_alloc __attribute__((using_if_exists));


} }
# 75 "/usr/local/include/bits/stdc++.h" 2


# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cstring" 1 3
# 60 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cstring" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/string.h" 1 3
# 58 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/string.h" 3


# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/string.h" 1 3 4
# 69 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/string.h" 3 4
extern "C" {
void *memchr(const void *__s, int __c, size_t __n);
int memcmp(const void *__s1, const void *__s2, size_t __n);
void *memcpy(void *__dst, const void *__src, size_t __n);
void *memmove(void *__dst, const void *__src, size_t __len);
void *memset(void *__b, int __c, size_t __len);
char *strcat(char *__s1, const char *__s2);
char *strchr(const char *__s, int __c);
int strcmp(const char *__s1, const char *__s2);
int strcoll(const char *__s1, const char *__s2);
char *strcpy(char *__dst, const char *__src);
size_t strcspn(const char *__s, const char *__charset);
char *strerror(int __errnum) __asm("_" "strerror" );
size_t strlen(const char *__s);
char *strncat(char *__s1, const char *__s2, size_t __n);
int strncmp(const char *__s1, const char *__s2, size_t __n);
char *strncpy(char *__dst, const char *__src, size_t __n);
char *strpbrk(const char *__s, const char *__charset);
char *strrchr(const char *__s, int __c);
size_t strspn(const char *__s, const char *__charset);
char *strstr(const char *__big, const char *__little);
char *strtok(char *__str, const char *__sep);
size_t strxfrm(char *__s1, const char *__s2, size_t __n);
}
# 103 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/string.h" 3 4
extern "C" {
char *strtok_r(char *__str, const char *__sep, char **__lasts);
}
# 115 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/string.h" 3 4
extern "C" {
int strerror_r(int __errnum, char *__strerrbuf, size_t __buflen);
char *strdup(const char *__s1);
void *memccpy(void *__dst, const void *__src, int __c, size_t __n);
}
# 129 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/string.h" 3 4
extern "C" {
char *stpcpy(char *__dst, const char *__src);
char *stpncpy(char *__dst, const char *__src, size_t __n) __attribute__((availability(macosx,introduced=10.7)));
char *strndup(const char *__s1, size_t __n) __attribute__((availability(macosx,introduced=10.7)));
size_t strnlen(const char *__s1, size_t __n) __attribute__((availability(macosx,introduced=10.7)));
char *strsignal(int __sig);
}
# 154 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/string.h" 3 4
extern "C" {
void *memmem(const void *__big, size_t __big_len, const void *__little, size_t __little_len) __attribute__((availability(macosx,introduced=10.7)));
void memset_pattern4(void *__b, const void *__pattern4, size_t __len) __attribute__((availability(macosx,introduced=10.5)));
void memset_pattern8(void *__b, const void *__pattern8, size_t __len) __attribute__((availability(macosx,introduced=10.5)));
void memset_pattern16(void *__b, const void *__pattern16, size_t __len) __attribute__((availability(macosx,introduced=10.5)));

char *strcasestr(const char *__big, const char *__little);
char *strnstr(const char *__big, const char *__little, size_t __len);
size_t strlcat(char *__dst, const char *__source, size_t __size);
size_t strlcpy(char *__dst, const char *__source, size_t __size);
void strmode(int __mode, char *__bp);
char *strsep(char **__stringp, const char *__delim);


void swab(const void * , void * , ssize_t);

__attribute__((availability(macosx,introduced=10.12.1))) __attribute__((availability(ios,introduced=10.1)))
__attribute__((availability(tvos,introduced=10.0.1))) __attribute__((availability(watchos,introduced=3.1)))
int timingsafe_bcmp(const void *__b1, const void *__b2, size_t __len);

__attribute__((availability(macosx,introduced=11.0))) __attribute__((availability(ios,introduced=14.0)))
__attribute__((availability(tvos,introduced=14.0))) __attribute__((availability(watchos,introduced=7.0)))
int strsignal_r(int __sig, char *__strsignalbuf, size_t __buflen);
}






# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/strings.h" 1 3 4
# 67 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/strings.h" 3 4
extern "C" {


int bcmp(const void *, const void *, size_t) ;
void bcopy(const void *, void *, size_t) ;
void bzero(void *, size_t) ;
char *index(const char *, int) ;
char *rindex(const char *, int) ;


int ffs(int);
int strcasecmp(const char *, const char *);
int strncasecmp(const char *, const char *, size_t);
}



extern "C" {
int ffsl(long) __attribute__((availability(macosx,introduced=10.5)));
int ffsll(long long) __attribute__((availability(macosx,introduced=10.9)));
int fls(int) __attribute__((availability(macosx,introduced=10.5)));
int flsl(long) __attribute__((availability(macosx,introduced=10.5)));
int flsll(long long) __attribute__((availability(macosx,introduced=10.9)));
}

# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/string.h" 1 3 4
# 93 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/strings.h" 2 3 4
# 185 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/string.h" 2 3 4
# 61 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/string.h" 2 3
# 71 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/string.h" 3
extern "C++" {
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
char* __libcpp_strchr(const char* __s, int __c) {return (char*)strchr(__s, __c);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) __attribute__ ((__enable_if__(true, "")))
const char* strchr(const char* __s, int __c) {return __libcpp_strchr(__s, __c);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) __attribute__ ((__enable_if__(true, "")))
      char* strchr( char* __s, int __c) {return __libcpp_strchr(__s, __c);}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
char* __libcpp_strpbrk(const char* __s1, const char* __s2) {return (char*)strpbrk(__s1, __s2);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) __attribute__ ((__enable_if__(true, "")))
const char* strpbrk(const char* __s1, const char* __s2) {return __libcpp_strpbrk(__s1, __s2);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) __attribute__ ((__enable_if__(true, "")))
      char* strpbrk( char* __s1, const char* __s2) {return __libcpp_strpbrk(__s1, __s2);}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
char* __libcpp_strrchr(const char* __s, int __c) {return (char*)strrchr(__s, __c);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) __attribute__ ((__enable_if__(true, "")))
const char* strrchr(const char* __s, int __c) {return __libcpp_strrchr(__s, __c);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) __attribute__ ((__enable_if__(true, "")))
      char* strrchr( char* __s, int __c) {return __libcpp_strrchr(__s, __c);}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void* __libcpp_memchr(const void* __s, int __c, size_t __n) {return (void*)memchr(__s, __c, __n);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) __attribute__ ((__enable_if__(true, "")))
const void* memchr(const void* __s, int __c, size_t __n) {return __libcpp_memchr(__s, __c, __n);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) __attribute__ ((__enable_if__(true, "")))
      void* memchr( void* __s, int __c, size_t __n) {return __libcpp_memchr(__s, __c, __n);}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
char* __libcpp_strstr(const char* __s1, const char* __s2) {return (char*)strstr(__s1, __s2);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) __attribute__ ((__enable_if__(true, "")))
const char* strstr(const char* __s1, const char* __s2) {return __libcpp_strstr(__s1, __s2);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) __attribute__ ((__enable_if__(true, "")))
      char* strstr( char* __s1, const char* __s2) {return __libcpp_strstr(__s1, __s2);}
}
# 61 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cstring" 2 3
# 64 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cstring" 3


namespace std { inline namespace __1 {

using ::size_t __attribute__((using_if_exists));
using ::memcpy __attribute__((using_if_exists));
using ::memmove __attribute__((using_if_exists));
using ::strcpy __attribute__((using_if_exists));
using ::strncpy __attribute__((using_if_exists));
using ::strcat __attribute__((using_if_exists));
using ::strncat __attribute__((using_if_exists));
using ::memcmp __attribute__((using_if_exists));
using ::strcmp __attribute__((using_if_exists));
using ::strncmp __attribute__((using_if_exists));
using ::strcoll __attribute__((using_if_exists));
using ::strxfrm __attribute__((using_if_exists));
using ::memchr __attribute__((using_if_exists));
using ::strchr __attribute__((using_if_exists));
using ::strcspn __attribute__((using_if_exists));
using ::strpbrk __attribute__((using_if_exists));
using ::strrchr __attribute__((using_if_exists));
using ::strspn __attribute__((using_if_exists));
using ::strstr __attribute__((using_if_exists));

using ::strtok __attribute__((using_if_exists));

using ::memset __attribute__((using_if_exists));
using ::strerror __attribute__((using_if_exists));
using ::strlen __attribute__((using_if_exists));

} }
# 78 "/usr/local/include/bits/stdc++.h" 2


# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/ctime" 1 3
# 49 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/ctime" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/time.h" 1 3 4
# 69 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/time.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_clock_t.h" 1 3 4
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_clock_t.h" 3 4
typedef __darwin_clock_t clock_t;
# 70 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/time.h" 2 3 4


# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_time_t.h" 1 3 4
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_time_t.h" 3 4
typedef __darwin_time_t time_t;
# 73 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/time.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_timespec.h" 1 3 4
# 33 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_timespec.h" 3 4
struct timespec
{
 __darwin_time_t tv_sec;
 long tv_nsec;
};
# 74 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/time.h" 2 3 4

struct tm {
 int tm_sec;
 int tm_min;
 int tm_hour;
 int tm_mday;
 int tm_mon;
 int tm_year;
 int tm_wday;
 int tm_yday;
 int tm_isdst;
 long tm_gmtoff;
 char *tm_zone;
};
# 98 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/time.h" 3 4
extern char *tzname[];


extern int getdate_err;

extern long timezone __asm("_" "timezone" );

extern int daylight;

extern "C" {
char *asctime(const struct tm *);
clock_t clock(void) __asm("_" "clock" );
char *ctime(const time_t *);
double difftime(time_t, time_t);
struct tm *getdate(const char *);
struct tm *gmtime(const time_t *);
struct tm *localtime(const time_t *);
time_t mktime(struct tm *) __asm("_" "mktime" );
size_t strftime(char * , size_t, const char * , const struct tm * ) __asm("_" "strftime" );
char *strptime(const char * , const char * , struct tm * ) __asm("_" "strptime" );
time_t time(time_t *);


void tzset(void);



char *asctime_r(const struct tm * , char * );
char *ctime_r(const time_t *, char *);
struct tm *gmtime_r(const time_t * , struct tm * );
struct tm *localtime_r(const time_t * , struct tm * );


time_t posix2time(time_t);



void tzsetwall(void);
time_t time2posix(time_t);
time_t timelocal(struct tm * const);
time_t timegm(struct tm * const);



int nanosleep(const struct timespec *__rqtp, struct timespec *__rmtp) __asm("_" "nanosleep" );
# 153 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/time.h" 3 4
typedef enum {
_CLOCK_REALTIME __attribute__((availability(macosx,introduced=10.12))) __attribute__((availability(ios,introduced=10.0))) __attribute__((availability(tvos,introduced=10.0))) __attribute__((availability(watchos,introduced=3.0))) = 0,

_CLOCK_MONOTONIC __attribute__((availability(macosx,introduced=10.12))) __attribute__((availability(ios,introduced=10.0))) __attribute__((availability(tvos,introduced=10.0))) __attribute__((availability(watchos,introduced=3.0))) = 6,


_CLOCK_MONOTONIC_RAW __attribute__((availability(macosx,introduced=10.12))) __attribute__((availability(ios,introduced=10.0))) __attribute__((availability(tvos,introduced=10.0))) __attribute__((availability(watchos,introduced=3.0))) = 4,

_CLOCK_MONOTONIC_RAW_APPROX __attribute__((availability(macosx,introduced=10.12))) __attribute__((availability(ios,introduced=10.0))) __attribute__((availability(tvos,introduced=10.0))) __attribute__((availability(watchos,introduced=3.0))) = 5,

_CLOCK_UPTIME_RAW __attribute__((availability(macosx,introduced=10.12))) __attribute__((availability(ios,introduced=10.0))) __attribute__((availability(tvos,introduced=10.0))) __attribute__((availability(watchos,introduced=3.0))) = 8,

_CLOCK_UPTIME_RAW_APPROX __attribute__((availability(macosx,introduced=10.12))) __attribute__((availability(ios,introduced=10.0))) __attribute__((availability(tvos,introduced=10.0))) __attribute__((availability(watchos,introduced=3.0))) = 9,


_CLOCK_PROCESS_CPUTIME_ID __attribute__((availability(macosx,introduced=10.12))) __attribute__((availability(ios,introduced=10.0))) __attribute__((availability(tvos,introduced=10.0))) __attribute__((availability(watchos,introduced=3.0))) = 12,

_CLOCK_THREAD_CPUTIME_ID __attribute__((availability(macosx,introduced=10.12))) __attribute__((availability(ios,introduced=10.0))) __attribute__((availability(tvos,introduced=10.0))) __attribute__((availability(watchos,introduced=3.0))) = 16

} clockid_t;

__attribute__((availability(macosx,introduced=10.12))) __attribute__((availability(ios,introduced=10.0))) __attribute__((availability(tvos,introduced=10.0))) __attribute__((availability(watchos,introduced=3.0)))
int clock_getres(clockid_t __clock_id, struct timespec *__res);

__attribute__((availability(macosx,introduced=10.12))) __attribute__((availability(ios,introduced=10.0))) __attribute__((availability(tvos,introduced=10.0))) __attribute__((availability(watchos,introduced=3.0)))
int clock_gettime(clockid_t __clock_id, struct timespec *__tp);


__attribute__((availability(macosx,introduced=10.12))) __attribute__((availability(ios,introduced=10.0))) __attribute__((availability(tvos,introduced=10.0))) __attribute__((availability(watchos,introduced=3.0)))
__uint64_t clock_gettime_nsec_np(clockid_t __clock_id);


__attribute__((availability(macosx,introduced=10.12))) __attribute__((availability(ios,unavailable)))
__attribute__((availability(tvos,unavailable))) __attribute__((availability(watchos,unavailable)))
int clock_settime(clockid_t __clock_id, const struct timespec *__tp);
# 198 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/time.h" 3 4
__attribute__((availability(macosx,introduced=10.15))) __attribute__((availability(ios,introduced=13.0))) __attribute__((availability(tvos,introduced=13.0))) __attribute__((availability(watchos,introduced=6.0)))
int timespec_get(struct timespec *ts, int base);


}
# 50 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/ctime" 2 3
# 53 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/ctime" 3
# 73 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/ctime" 3
namespace std { inline namespace __1 {

using ::clock_t __attribute__((using_if_exists));

using ::size_t __attribute__((using_if_exists));

using ::time_t __attribute__((using_if_exists));
using ::tm __attribute__((using_if_exists));

using ::timespec __attribute__((using_if_exists));

using ::clock __attribute__((using_if_exists));
using ::difftime __attribute__((using_if_exists));
using ::mktime __attribute__((using_if_exists));
using ::time __attribute__((using_if_exists));

using ::asctime __attribute__((using_if_exists));
using ::ctime __attribute__((using_if_exists));
using ::gmtime __attribute__((using_if_exists));
using ::localtime __attribute__((using_if_exists));

using ::strftime __attribute__((using_if_exists));

using ::timespec_get __attribute__((using_if_exists));


} }
# 81 "/usr/local/include/bits/stdc++.h" 2


# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cwchar" 1 3
# 106 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cwchar" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cwctype" 1 3
# 54 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cwctype" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/wctype.h" 1 3
# 55 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/wctype.h" 3
# 67 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/wctype.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/wctype.h" 1 3 4
# 36 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/wctype.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/_types/_wctrans_t.h" 1 3 4
# 32 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/_types/_wctrans_t.h" 3 4
typedef __darwin_wctrans_t wctrans_t;
# 37 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/wctype.h" 2 3 4



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/_wctype.h" 1 3 4
# 42 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/_wctype.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/__wctype.h" 1 3 4
# 62 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/__wctype.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/_types/_wctype_t.h" 1 3 4
# 32 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/_types/_wctype_t.h" 3 4
typedef __darwin_wctype_t wctype_t;
# 63 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/__wctype.h" 2 3 4
# 43 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/_wctype.h" 2 3 4







inline int
iswalnum(wint_t _wc)
{
 return (__istype(_wc, 0x00000100L|0x00000400L));
}

inline int
iswalpha(wint_t _wc)
{
 return (__istype(_wc, 0x00000100L));
}

inline int
iswcntrl(wint_t _wc)
{
 return (__istype(_wc, 0x00000200L));
}

inline int
iswctype(wint_t _wc, wctype_t _charclass)
{
 return (__istype(_wc, _charclass));
}

inline int
iswdigit(wint_t _wc)
{
 return (__isctype(_wc, 0x00000400L));
}

inline int
iswgraph(wint_t _wc)
{
 return (__istype(_wc, 0x00000800L));
}

inline int
iswlower(wint_t _wc)
{
 return (__istype(_wc, 0x00001000L));
}

inline int
iswprint(wint_t _wc)
{
 return (__istype(_wc, 0x00040000L));
}

inline int
iswpunct(wint_t _wc)
{
 return (__istype(_wc, 0x00002000L));
}

inline int
iswspace(wint_t _wc)
{
 return (__istype(_wc, 0x00004000L));
}

inline int
iswupper(wint_t _wc)
{
 return (__istype(_wc, 0x00008000L));
}

inline int
iswxdigit(wint_t _wc)
{
 return (__isctype(_wc, 0x00010000L));
}

inline wint_t
towlower(wint_t _wc)
{
        return (__tolower(_wc));
}

inline wint_t
towupper(wint_t _wc)
{
        return (__toupper(_wc));
}
# 155 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/_wctype.h" 3 4
extern "C" {
wctype_t
 wctype(const char *);
}
# 41 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/wctype.h" 2 3 4








inline int
iswblank(wint_t _wc)
{
 return (__istype(_wc, 0x00020000L));
}


inline int
iswascii(wint_t _wc)
{
 return ((_wc & ~0x7F) == 0);
}

inline int
iswhexnumber(wint_t _wc)
{
 return (__istype(_wc, 0x00010000L));
}

inline int
iswideogram(wint_t _wc)
{
 return (__istype(_wc, 0x00080000L));
}

inline int
iswnumber(wint_t _wc)
{
 return (__istype(_wc, 0x00000400L));
}

inline int
iswphonogram(wint_t _wc)
{
 return (__istype(_wc, 0x00200000L));
}

inline int
iswrune(wint_t _wc)
{
 return (__istype(_wc, 0xFFFFFFF0L));
}

inline int
iswspecial(wint_t _wc)
{
 return (__istype(_wc, 0x00100000L));
}
# 117 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/wctype.h" 3 4
extern "C" {

wint_t nextwctype(wint_t, wctype_t);

wint_t towctrans(wint_t, wctrans_t);
wctrans_t
 wctrans(const char *);
}
# 68 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/wctype.h" 2 3
# 55 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cwctype" 2 3
# 58 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cwctype" 3


namespace std { inline namespace __1 {


using ::wint_t __attribute__((using_if_exists));
using ::wctrans_t __attribute__((using_if_exists));
using ::wctype_t __attribute__((using_if_exists));
using ::iswalnum __attribute__((using_if_exists));
using ::iswalpha __attribute__((using_if_exists));
using ::iswblank __attribute__((using_if_exists));
using ::iswcntrl __attribute__((using_if_exists));
using ::iswdigit __attribute__((using_if_exists));
using ::iswgraph __attribute__((using_if_exists));
using ::iswlower __attribute__((using_if_exists));
using ::iswprint __attribute__((using_if_exists));
using ::iswpunct __attribute__((using_if_exists));
using ::iswspace __attribute__((using_if_exists));
using ::iswupper __attribute__((using_if_exists));
using ::iswxdigit __attribute__((using_if_exists));
using ::iswctype __attribute__((using_if_exists));
using ::wctype __attribute__((using_if_exists));
using ::towlower __attribute__((using_if_exists));
using ::towupper __attribute__((using_if_exists));
using ::towctrans __attribute__((using_if_exists));
using ::wctrans __attribute__((using_if_exists));


} }
# 107 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cwchar" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/wchar.h" 1 3
# 109 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/wchar.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/stddef.h" 1 3
# 43 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/stddef.h" 3


# 1 "/Library/Developer/CommandLineTools/usr/lib/clang/13.1.6/include/stddef.h" 1 3
# 46 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/stddef.h" 2 3



extern "C++" {

using std::nullptr_t;
}
# 110 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/wchar.h" 2 3
# 117 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/wchar.h" 3






# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/wchar.h" 1 3 4
# 76 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/wchar.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_mbstate_t.h" 1 3 4
# 32 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_mbstate_t.h" 3 4
typedef __darwin_mbstate_t mbstate_t;
# 77 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/wchar.h" 2 3 4


# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_wchar_t.h" 1 3 4
# 80 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/wchar.h" 2 3 4
# 90 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/wchar.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/stdio.h" 1 3 4
# 91 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/wchar.h" 2 3 4





extern "C" {
wint_t btowc(int);
wint_t fgetwc(FILE *);
wchar_t *fgetws(wchar_t * , int, FILE * );
wint_t fputwc(wchar_t, FILE *);
int fputws(const wchar_t * , FILE * );
int fwide(FILE *, int);
int fwprintf(FILE * , const wchar_t * , ...);
int fwscanf(FILE * , const wchar_t * , ...);
wint_t getwc(FILE *);
wint_t getwchar(void);
size_t mbrlen(const char * , size_t, mbstate_t * );
size_t mbrtowc(wchar_t * , const char * , size_t,
     mbstate_t * );
int mbsinit(const mbstate_t *);
size_t mbsrtowcs(wchar_t * , const char ** , size_t,
     mbstate_t * );
wint_t putwc(wchar_t, FILE *);
wint_t putwchar(wchar_t);
int swprintf(wchar_t * , size_t, const wchar_t * , ...);
int swscanf(const wchar_t * , const wchar_t * , ...);
wint_t ungetwc(wint_t, FILE *);
int vfwprintf(FILE * , const wchar_t * ,
     __darwin_va_list);
int vswprintf(wchar_t * , size_t, const wchar_t * ,
     __darwin_va_list);
int vwprintf(const wchar_t * , __darwin_va_list);
size_t wcrtomb(char * , wchar_t, mbstate_t * );
wchar_t *wcscat(wchar_t * , const wchar_t * );
wchar_t *wcschr(const wchar_t *, wchar_t);
int wcscmp(const wchar_t *, const wchar_t *);
int wcscoll(const wchar_t *, const wchar_t *);
wchar_t *wcscpy(wchar_t * , const wchar_t * );
size_t wcscspn(const wchar_t *, const wchar_t *);
size_t wcsftime(wchar_t * , size_t, const wchar_t * ,
     const struct tm * ) __asm("_" "wcsftime" );
size_t wcslen(const wchar_t *);
wchar_t *wcsncat(wchar_t * , const wchar_t * , size_t);
int wcsncmp(const wchar_t *, const wchar_t *, size_t);
wchar_t *wcsncpy(wchar_t * , const wchar_t * , size_t);
wchar_t *wcspbrk(const wchar_t *, const wchar_t *);
wchar_t *wcsrchr(const wchar_t *, wchar_t);
size_t wcsrtombs(char * , const wchar_t ** , size_t,
     mbstate_t * );
size_t wcsspn(const wchar_t *, const wchar_t *);
wchar_t *wcsstr(const wchar_t * , const wchar_t * );
size_t wcsxfrm(wchar_t * , const wchar_t * , size_t);
int wctob(wint_t);
double wcstod(const wchar_t * , wchar_t ** );
wchar_t *wcstok(wchar_t * , const wchar_t * ,
     wchar_t ** );
long wcstol(const wchar_t * , wchar_t ** , int);
unsigned long
  wcstoul(const wchar_t * , wchar_t ** , int);
wchar_t *wmemchr(const wchar_t *, wchar_t, size_t);
int wmemcmp(const wchar_t *, const wchar_t *, size_t);
wchar_t *wmemcpy(wchar_t * , const wchar_t * , size_t);
wchar_t *wmemmove(wchar_t *, const wchar_t *, size_t);
wchar_t *wmemset(wchar_t *, wchar_t, size_t);
int wprintf(const wchar_t * , ...);
int wscanf(const wchar_t * , ...);
int wcswidth(const wchar_t *, size_t);
int wcwidth(wchar_t);
}
# 169 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/wchar.h" 3 4
extern "C" {
int vfwscanf(FILE * , const wchar_t * ,
     __darwin_va_list);
int vswscanf(const wchar_t * , const wchar_t * ,
     __darwin_va_list);
int vwscanf(const wchar_t * , __darwin_va_list);
float wcstof(const wchar_t * , wchar_t ** );
long double
 wcstold(const wchar_t * , wchar_t ** );

long long
 wcstoll(const wchar_t * , wchar_t ** , int);
unsigned long long
 wcstoull(const wchar_t * , wchar_t ** , int);

}
# 194 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/wchar.h" 3 4
extern "C" {
size_t mbsnrtowcs(wchar_t * , const char ** , size_t,
            size_t, mbstate_t * );
wchar_t *wcpcpy(wchar_t * , const wchar_t * ) __attribute__((availability(macosx,introduced=10.7)));
wchar_t *wcpncpy(wchar_t * , const wchar_t * , size_t) __attribute__((availability(macosx,introduced=10.7)));
wchar_t *wcsdup(const wchar_t *) __attribute__((availability(macosx,introduced=10.7)));
int wcscasecmp(const wchar_t *, const wchar_t *) __attribute__((availability(macosx,introduced=10.7)));
int wcsncasecmp(const wchar_t *, const wchar_t *, size_t n) __attribute__((availability(macosx,introduced=10.7)));
size_t wcsnlen(const wchar_t *, size_t) __attribute__((availability(macosx,introduced=10.7)));
size_t wcsnrtombs(char * , const wchar_t ** , size_t,
            size_t, mbstate_t * );
FILE *open_wmemstream(wchar_t ** __bufp, size_t * __sizep) __attribute__((availability(macos,introduced=10.13))) __attribute__((availability(ios,introduced=11.0))) __attribute__((availability(tvos,introduced=11.0))) __attribute__((availability(watchos,introduced=4.0)));
}







extern "C" {
wchar_t *fgetwln(FILE * , size_t *) __attribute__((availability(macosx,introduced=10.7)));
size_t wcslcat(wchar_t *, const wchar_t *, size_t);
size_t wcslcpy(wchar_t *, const wchar_t *, size_t);
}
# 124 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/wchar.h" 2 3
# 139 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/wchar.h" 3
extern "C++" {
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
wchar_t* __libcpp_wcschr(const wchar_t* __s, wchar_t __c) {return (wchar_t*)wcschr(__s, __c);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) __attribute__ ((__enable_if__(true, "")))
const wchar_t* wcschr(const wchar_t* __s, wchar_t __c) {return __libcpp_wcschr(__s, __c);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) __attribute__ ((__enable_if__(true, "")))
      wchar_t* wcschr( wchar_t* __s, wchar_t __c) {return __libcpp_wcschr(__s, __c);}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
wchar_t* __libcpp_wcspbrk(const wchar_t* __s1, const wchar_t* __s2) {return (wchar_t*)wcspbrk(__s1, __s2);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) __attribute__ ((__enable_if__(true, "")))
const wchar_t* wcspbrk(const wchar_t* __s1, const wchar_t* __s2) {return __libcpp_wcspbrk(__s1, __s2);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) __attribute__ ((__enable_if__(true, "")))
      wchar_t* wcspbrk( wchar_t* __s1, const wchar_t* __s2) {return __libcpp_wcspbrk(__s1, __s2);}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
wchar_t* __libcpp_wcsrchr(const wchar_t* __s, wchar_t __c) {return (wchar_t*)wcsrchr(__s, __c);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) __attribute__ ((__enable_if__(true, "")))
const wchar_t* wcsrchr(const wchar_t* __s, wchar_t __c) {return __libcpp_wcsrchr(__s, __c);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) __attribute__ ((__enable_if__(true, "")))
      wchar_t* wcsrchr( wchar_t* __s, wchar_t __c) {return __libcpp_wcsrchr(__s, __c);}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
wchar_t* __libcpp_wcsstr(const wchar_t* __s1, const wchar_t* __s2) {return (wchar_t*)wcsstr(__s1, __s2);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) __attribute__ ((__enable_if__(true, "")))
const wchar_t* wcsstr(const wchar_t* __s1, const wchar_t* __s2) {return __libcpp_wcsstr(__s1, __s2);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) __attribute__ ((__enable_if__(true, "")))
      wchar_t* wcsstr( wchar_t* __s1, const wchar_t* __s2) {return __libcpp_wcsstr(__s1, __s2);}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
wchar_t* __libcpp_wmemchr(const wchar_t* __s, wchar_t __c, size_t __n) {return (wchar_t*)wmemchr(__s, __c, __n);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) __attribute__ ((__enable_if__(true, "")))
const wchar_t* wmemchr(const wchar_t* __s, wchar_t __c, size_t __n) {return __libcpp_wmemchr(__s, __c, __n);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) __attribute__ ((__enable_if__(true, "")))
      wchar_t* wmemchr( wchar_t* __s, wchar_t __c, size_t __n) {return __libcpp_wmemchr(__s, __c, __n);}
}
# 108 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cwchar" 2 3
# 111 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cwchar" 3


namespace std { inline namespace __1 {

using ::mbstate_t __attribute__((using_if_exists));
using ::size_t __attribute__((using_if_exists));
using ::tm __attribute__((using_if_exists));
using ::wint_t __attribute__((using_if_exists));
using ::FILE __attribute__((using_if_exists));
using ::fwprintf __attribute__((using_if_exists));
using ::fwscanf __attribute__((using_if_exists));
using ::swprintf __attribute__((using_if_exists));
using ::vfwprintf __attribute__((using_if_exists));
using ::vswprintf __attribute__((using_if_exists));
using ::swscanf __attribute__((using_if_exists));
using ::vfwscanf __attribute__((using_if_exists));
using ::vswscanf __attribute__((using_if_exists));
using ::fgetwc __attribute__((using_if_exists));
using ::fgetws __attribute__((using_if_exists));
using ::fputwc __attribute__((using_if_exists));
using ::fputws __attribute__((using_if_exists));
using ::fwide __attribute__((using_if_exists));
using ::getwc __attribute__((using_if_exists));
using ::putwc __attribute__((using_if_exists));
using ::ungetwc __attribute__((using_if_exists));
using ::wcstod __attribute__((using_if_exists));
using ::wcstof __attribute__((using_if_exists));
using ::wcstold __attribute__((using_if_exists));
using ::wcstol __attribute__((using_if_exists));

using ::wcstoll __attribute__((using_if_exists));

using ::wcstoul __attribute__((using_if_exists));

using ::wcstoull __attribute__((using_if_exists));

using ::wcscpy __attribute__((using_if_exists));
using ::wcsncpy __attribute__((using_if_exists));
using ::wcscat __attribute__((using_if_exists));
using ::wcsncat __attribute__((using_if_exists));
using ::wcscmp __attribute__((using_if_exists));
using ::wcscoll __attribute__((using_if_exists));
using ::wcsncmp __attribute__((using_if_exists));
using ::wcsxfrm __attribute__((using_if_exists));
using ::wcschr __attribute__((using_if_exists));
using ::wcspbrk __attribute__((using_if_exists));
using ::wcsrchr __attribute__((using_if_exists));
using ::wcsstr __attribute__((using_if_exists));
using ::wmemchr __attribute__((using_if_exists));
using ::wcscspn __attribute__((using_if_exists));
using ::wcslen __attribute__((using_if_exists));
using ::wcsspn __attribute__((using_if_exists));
using ::wcstok __attribute__((using_if_exists));
using ::wmemcmp __attribute__((using_if_exists));
using ::wmemcpy __attribute__((using_if_exists));
using ::wmemmove __attribute__((using_if_exists));
using ::wmemset __attribute__((using_if_exists));
using ::wcsftime __attribute__((using_if_exists));
using ::btowc __attribute__((using_if_exists));
using ::wctob __attribute__((using_if_exists));
using ::mbsinit __attribute__((using_if_exists));
using ::mbrlen __attribute__((using_if_exists));
using ::mbrtowc __attribute__((using_if_exists));
using ::wcrtomb __attribute__((using_if_exists));
using ::mbsrtowcs __attribute__((using_if_exists));
using ::wcsrtombs __attribute__((using_if_exists));


using ::getwchar __attribute__((using_if_exists));
using ::vwscanf __attribute__((using_if_exists));
using ::wscanf __attribute__((using_if_exists));



using ::putwchar __attribute__((using_if_exists));
using ::vwprintf __attribute__((using_if_exists));
using ::wprintf __attribute__((using_if_exists));


} }
# 84 "/usr/local/include/bits/stdc++.h" 2







# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/ccomplex" 1 3
# 20 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/ccomplex" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/complex" 1 3
# 236 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/complex" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/iosfwd" 1 3
# 98 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/iosfwd" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__mbstate_t.h" 1 3
# 17 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__mbstate_t.h" 3
# 29 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__mbstate_t.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/wchar.h" 1 3
# 30 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__mbstate_t.h" 2 3
# 40 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__mbstate_t.h" 3
namespace std { inline namespace __1 {

using ::mbstate_t __attribute__((using_if_exists));

} }
# 99 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/iosfwd" 2 3
# 102 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/iosfwd" 3


namespace std { inline namespace __1 {

class __attribute__ ((__visibility__("default"))) ios_base;

template<class _CharT> struct __attribute__ ((__type_visibility__("default"))) char_traits;
template<> struct char_traits<char>;



template<> struct char_traits<char16_t>;
template<> struct char_traits<char32_t>;

template<> struct char_traits<wchar_t>;


template<class _Tp> class __attribute__ ((__type_visibility__("default"))) allocator;

template <class _CharT, class _Traits = char_traits<_CharT> >
    class __attribute__ ((__type_visibility__("default"))) basic_ios;

template <class _CharT, class _Traits = char_traits<_CharT> >
    class __attribute__ ((__type_visibility__("default"))) basic_streambuf;
template <class _CharT, class _Traits = char_traits<_CharT> >
    class __attribute__ ((__type_visibility__("default"))) basic_istream;
template <class _CharT, class _Traits = char_traits<_CharT> >
    class __attribute__ ((__type_visibility__("default"))) basic_ostream;
template <class _CharT, class _Traits = char_traits<_CharT> >
    class __attribute__ ((__type_visibility__("default"))) basic_iostream;

template <class _CharT, class _Traits = char_traits<_CharT>,
          class _Allocator = allocator<_CharT> >
    class __attribute__ ((__type_visibility__("default"))) basic_stringbuf;
template <class _CharT, class _Traits = char_traits<_CharT>,
          class _Allocator = allocator<_CharT> >
    class __attribute__ ((__type_visibility__("default"))) basic_istringstream;
template <class _CharT, class _Traits = char_traits<_CharT>,
          class _Allocator = allocator<_CharT> >
    class __attribute__ ((__type_visibility__("default"))) basic_ostringstream;
template <class _CharT, class _Traits = char_traits<_CharT>,
          class _Allocator = allocator<_CharT> >
    class __attribute__ ((__type_visibility__("default"))) basic_stringstream;

template <class _CharT, class _Traits = char_traits<_CharT> >
    class __attribute__ ((__type_visibility__("default"))) basic_filebuf;
template <class _CharT, class _Traits = char_traits<_CharT> >
    class __attribute__ ((__type_visibility__("default"))) basic_ifstream;
template <class _CharT, class _Traits = char_traits<_CharT> >
    class __attribute__ ((__type_visibility__("default"))) basic_ofstream;
template <class _CharT, class _Traits = char_traits<_CharT> >
    class __attribute__ ((__type_visibility__("default"))) basic_fstream;

template <class _CharT, class _Traits = char_traits<_CharT> >
    class __attribute__ ((__type_visibility__("default"))) istreambuf_iterator;
template <class _CharT, class _Traits = char_traits<_CharT> >
    class __attribute__ ((__type_visibility__("default"))) ostreambuf_iterator;

typedef basic_ios<char> ios;

typedef basic_ios<wchar_t> wios;


typedef basic_streambuf<char> streambuf;
typedef basic_istream<char> istream;
typedef basic_ostream<char> ostream;
typedef basic_iostream<char> iostream;

typedef basic_stringbuf<char> stringbuf;
typedef basic_istringstream<char> istringstream;
typedef basic_ostringstream<char> ostringstream;
typedef basic_stringstream<char> stringstream;

typedef basic_filebuf<char> filebuf;
typedef basic_ifstream<char> ifstream;
typedef basic_ofstream<char> ofstream;
typedef basic_fstream<char> fstream;


typedef basic_streambuf<wchar_t> wstreambuf;
typedef basic_istream<wchar_t> wistream;
typedef basic_ostream<wchar_t> wostream;
typedef basic_iostream<wchar_t> wiostream;

typedef basic_stringbuf<wchar_t> wstringbuf;
typedef basic_istringstream<wchar_t> wistringstream;
typedef basic_ostringstream<wchar_t> wostringstream;
typedef basic_stringstream<wchar_t> wstringstream;

typedef basic_filebuf<wchar_t> wfilebuf;
typedef basic_ifstream<wchar_t> wifstream;
typedef basic_ofstream<wchar_t> wofstream;
typedef basic_fstream<wchar_t> wfstream;


template <class _CharT, class _Traits>
    class __attribute__((__preferred_name__(ios))) __attribute__((__preferred_name__(wios))) basic_ios;

template <class _CharT, class _Traits>
    class __attribute__((__preferred_name__(streambuf))) __attribute__((__preferred_name__(wstreambuf))) basic_streambuf;
template <class _CharT, class _Traits>
    class __attribute__((__preferred_name__(istream))) __attribute__((__preferred_name__(wistream))) basic_istream;
template <class _CharT, class _Traits>
    class __attribute__((__preferred_name__(ostream))) __attribute__((__preferred_name__(wostream))) basic_ostream;
template <class _CharT, class _Traits>
    class __attribute__((__preferred_name__(iostream))) __attribute__((__preferred_name__(wiostream))) basic_iostream;

template <class _CharT, class _Traits, class _Allocator>
    class __attribute__((__preferred_name__(stringbuf))) __attribute__((__preferred_name__(wstringbuf))) basic_stringbuf;
template <class _CharT, class _Traits, class _Allocator>
    class __attribute__((__preferred_name__(istringstream))) __attribute__((__preferred_name__(wistringstream))) basic_istringstream;
template <class _CharT, class _Traits, class _Allocator>
    class __attribute__((__preferred_name__(ostringstream))) __attribute__((__preferred_name__(wostringstream))) basic_ostringstream;
template <class _CharT, class _Traits, class _Allocator>
    class __attribute__((__preferred_name__(stringstream))) __attribute__((__preferred_name__(wstringstream))) basic_stringstream;

template <class _CharT, class _Traits>
    class __attribute__((__preferred_name__(filebuf))) __attribute__((__preferred_name__(wfilebuf))) basic_filebuf;
template <class _CharT, class _Traits>
    class __attribute__((__preferred_name__(ifstream))) __attribute__((__preferred_name__(wifstream))) basic_ifstream;
template <class _CharT, class _Traits>
    class __attribute__((__preferred_name__(ofstream))) __attribute__((__preferred_name__(wofstream))) basic_ofstream;
template <class _CharT, class _Traits>
    class __attribute__((__preferred_name__(fstream))) __attribute__((__preferred_name__(wfstream))) basic_fstream;

template <class _State> class __attribute__ ((__type_visibility__("default"))) fpos;
typedef fpos<mbstate_t> streampos;
typedef fpos<mbstate_t> wstreampos;




typedef fpos<mbstate_t> u16streampos;
typedef fpos<mbstate_t> u32streampos;






typedef long long streamoff;


template <class _CharT,
          class _Traits = char_traits<_CharT>,
          class _Allocator = allocator<_CharT> >
    class __attribute__ ((__type_visibility__("default"))) basic_string;
typedef basic_string<char, char_traits<char>, allocator<char> > string;

typedef basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> > wstring;


template <class _CharT, class _Traits, class _Allocator>
    class __attribute__((__preferred_name__(string))) __attribute__((__preferred_name__(wstring))) basic_string;


template <class _Tp, class _Alloc = allocator<_Tp> >
class __attribute__ ((__type_visibility__("default"))) vector;

template <class _CharT, class _Traits>
class __save_flags
{
    typedef basic_ios<_CharT, _Traits> __stream_type;
    typedef typename __stream_type::fmtflags fmtflags;

    __stream_type& __stream_;
    fmtflags __fmtflags_;
    _CharT __fill_;

    __save_flags(const __save_flags&);
    __save_flags& operator=(const __save_flags&);
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit __save_flags(__stream_type& __stream)
        : __stream_(__stream),
          __fmtflags_(__stream.flags()),
          __fill_(__stream.fill())
        {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    ~__save_flags()
    {
        __stream_.flags(__fmtflags_);
        __stream_.fill(__fill_);
    }
};

} }
# 237 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/complex" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/stdexcept" 1 3
# 45 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/stdexcept" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/exception" 1 3
# 79 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/exception" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__availability" 1 3
# 17 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__availability" 3
# 80 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/exception" 2 3

# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/addressof.h" 1 3
# 17 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/addressof.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 21 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/addressof.h" 2 3

namespace std { inline namespace __1 {



template <class _Tp>
inline constexpr
__attribute__((__no_sanitize__("cfi"))) __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
_Tp*
addressof(_Tp& __x) noexcept
{
    return __builtin_addressof(__x);
}
# 89 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/addressof.h" 3
template <class _Tp> _Tp* addressof(const _Tp&&) noexcept = delete;


} }
# 82 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/exception" 2 3


# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 1 3
# 85 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/exception" 2 3
# 93 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/exception" 3


namespace std
{


class __attribute__ ((__visibility__("default"))) exception
{
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) exception() noexcept {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) exception(const exception&) noexcept = default;

    virtual ~exception() noexcept;
    virtual const char* what() const noexcept;
};

class __attribute__ ((__visibility__("default"))) bad_exception
    : public exception
{
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) bad_exception() noexcept {}
    virtual ~bad_exception() noexcept;
    virtual const char* what() const noexcept;
};
# 128 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/exception" 3
typedef void (*terminate_handler)();
__attribute__ ((__visibility__("default"))) terminate_handler set_terminate(terminate_handler) noexcept;
__attribute__ ((__visibility__("default"))) terminate_handler get_terminate() noexcept;
[[noreturn]] __attribute__ ((__visibility__("default"))) void terminate() noexcept;

__attribute__ ((__visibility__("default"))) bool uncaught_exception() noexcept;
__attribute__ ((__visibility__("default"))) __attribute__((availability(macosx,strict,introduced=10.12))) __attribute__((availability(ios,strict,introduced=10.0))) __attribute__((availability(tvos,strict,introduced=10.0))) __attribute__((availability(watchos,strict,introduced=3.0))) int uncaught_exceptions() noexcept;

class __attribute__ ((__visibility__("default"))) exception_ptr;

__attribute__ ((__visibility__("default"))) exception_ptr current_exception() noexcept;
[[noreturn]] __attribute__ ((__visibility__("default"))) void rethrow_exception(exception_ptr);



class __attribute__ ((__visibility__("default"))) exception_ptr
{
    void* __ptr_;
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) exception_ptr() noexcept : __ptr_() {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) exception_ptr(nullptr_t) noexcept : __ptr_() {}

    exception_ptr(const exception_ptr&) noexcept;
    exception_ptr& operator=(const exception_ptr&) noexcept;
    ~exception_ptr() noexcept;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) explicit operator bool() const noexcept
    {return __ptr_ != nullptr;}

    friend __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    bool operator==(const exception_ptr& __x, const exception_ptr& __y) noexcept
        {return __x.__ptr_ == __y.__ptr_;}

    friend __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    bool operator!=(const exception_ptr& __x, const exception_ptr& __y) noexcept
        {return !(__x == __y);}

    friend __attribute__ ((__visibility__("default"))) exception_ptr current_exception() noexcept;
    friend __attribute__ ((__visibility__("default"))) void rethrow_exception(exception_ptr);
};

template<class _Ep>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) exception_ptr
make_exception_ptr(_Ep __e) noexcept
{

    try
    {
        throw __e;
    }
    catch (...)
    {
        return current_exception();
    }




}
# 238 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/exception" 3
class __attribute__ ((__visibility__("default"))) nested_exception
{
    exception_ptr __ptr_;
public:
    nested_exception() noexcept;


    virtual ~nested_exception() noexcept;


    [[noreturn]] void rethrow_nested() const;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) exception_ptr nested_ptr() const noexcept {return __ptr_;}
};

template <class _Tp>
struct __nested
    : public _Tp,
      public nested_exception
{
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) explicit __nested(const _Tp& __t) : _Tp(__t) {}
};


template <class _Tp, class _Up, bool>
struct __throw_with_nested;

template <class _Tp, class _Up>
struct __throw_with_nested<_Tp, _Up, true> {
    [[noreturn]] static inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) void
    __do_throw(_Tp&& __t)
    {
        throw __nested<_Up>(static_cast<_Tp&&>(__t));
    }
};

template <class _Tp, class _Up>
struct __throw_with_nested<_Tp, _Up, false> {
    [[noreturn]] static inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) void

    __do_throw(_Tp&& __t)



    {
        throw static_cast<_Tp&&>(__t);
    }
};


template <class _Tp>
[[noreturn]]
void
throw_with_nested(_Tp&& __t)
{

    typedef typename decay<_Tp>::type _Up;
    static_assert( is_copy_constructible<_Up>::value, "type thrown must be CopyConstructible");
    __throw_with_nested<_Tp, _Up,
        is_class<_Up>::value &&
        !is_base_of<nested_exception, _Up>::value &&
        !__libcpp_is_final<_Up>::value>::
            __do_throw(static_cast<_Tp&&>(__t));




}

template <class _From, class _To>
struct __can_dynamic_cast : public bool_constant<(is_polymorphic<_From>::value && (!is_base_of<_To, _From>::value || is_convertible<const _From*, const _To*>::value))> {};




template <class _Ep>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void
rethrow_if_nested(const _Ep& __e,
                  typename enable_if< __can_dynamic_cast<_Ep, nested_exception>::value>::type* = 0)
{
    const nested_exception* __nep = dynamic_cast<const nested_exception*>(std::__1::addressof(__e));
    if (__nep)
        __nep->rethrow_nested();
}

template <class _Ep>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void
rethrow_if_nested(const _Ep&,
                  typename enable_if<!__can_dynamic_cast<_Ep, nested_exception>::value>::type* = 0)
{
}

}
# 46 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/stdexcept" 2 3
# 51 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/stdexcept" 3


namespace std { inline namespace __1 {


class __attribute__ ((__visibility__("hidden"))) __libcpp_refstring
{
    const char* __imp_;

    bool __uses_refcount() const;
public:
    explicit __libcpp_refstring(const char* __msg);
    __libcpp_refstring(const __libcpp_refstring& __s) noexcept;
    __libcpp_refstring& operator=(const __libcpp_refstring& __s) noexcept;
    ~__libcpp_refstring();

    const char* c_str() const noexcept {return __imp_;}
};


} }

namespace std
{

class __attribute__ ((__visibility__("default"))) logic_error
    : public exception
{

private:
    std::__1::__libcpp_refstring __imp_;
public:
    explicit logic_error(const string&);
    explicit logic_error(const char*);

    logic_error(const logic_error&) noexcept;
    logic_error& operator=(const logic_error&) noexcept;

    virtual ~logic_error() noexcept;

    virtual const char* what() const noexcept;





};

class __attribute__ ((__visibility__("default"))) runtime_error
    : public exception
{

private:
    std::__1::__libcpp_refstring __imp_;
public:
    explicit runtime_error(const string&);
    explicit runtime_error(const char*);

    runtime_error(const runtime_error&) noexcept;
    runtime_error& operator=(const runtime_error&) noexcept;

    virtual ~runtime_error() noexcept;

    virtual const char* what() const noexcept;





};

class __attribute__ ((__visibility__("default"))) domain_error
    : public logic_error
{
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) explicit domain_error(const string& __s) : logic_error(__s) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) explicit domain_error(const char* __s) : logic_error(__s) {}


    domain_error(const domain_error&) noexcept = default;
    virtual ~domain_error() noexcept;

};

class __attribute__ ((__visibility__("default"))) invalid_argument
    : public logic_error
{
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) explicit invalid_argument(const string& __s) : logic_error(__s) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) explicit invalid_argument(const char* __s) : logic_error(__s) {}


    invalid_argument(const invalid_argument&) noexcept = default;
    virtual ~invalid_argument() noexcept;

};

class __attribute__ ((__visibility__("default"))) length_error
    : public logic_error
{
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) explicit length_error(const string& __s) : logic_error(__s) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) explicit length_error(const char* __s) : logic_error(__s) {}

    length_error(const length_error&) noexcept = default;
    virtual ~length_error() noexcept;

};

class __attribute__ ((__visibility__("default"))) out_of_range
    : public logic_error
{
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) explicit out_of_range(const string& __s) : logic_error(__s) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) explicit out_of_range(const char* __s) : logic_error(__s) {}


    out_of_range(const out_of_range&) noexcept = default;
    virtual ~out_of_range() noexcept;

};

class __attribute__ ((__visibility__("default"))) range_error
    : public runtime_error
{
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) explicit range_error(const string& __s) : runtime_error(__s) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) explicit range_error(const char* __s) : runtime_error(__s) {}


    range_error(const range_error&) noexcept = default;
    virtual ~range_error() noexcept;

};

class __attribute__ ((__visibility__("default"))) overflow_error
    : public runtime_error
{
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) explicit overflow_error(const string& __s) : runtime_error(__s) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) explicit overflow_error(const char* __s) : runtime_error(__s) {}


    overflow_error(const overflow_error&) noexcept = default;
    virtual ~overflow_error() noexcept;

};

class __attribute__ ((__visibility__("default"))) underflow_error
    : public runtime_error
{
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) explicit underflow_error(const string& __s) : runtime_error(__s) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) explicit underflow_error(const char* __s) : runtime_error(__s) {}


    underflow_error(const underflow_error&) noexcept = default;
    virtual ~underflow_error() noexcept;

};

}

namespace std { inline namespace __1 {


[[noreturn]] __attribute__ ((__visibility__("default"))) void __throw_runtime_error(const char*);

[[noreturn]] inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void __throw_logic_error(const char*__msg)
{

    throw logic_error(__msg);




}

[[noreturn]] inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void __throw_domain_error(const char*__msg)
{

    throw domain_error(__msg);




}

[[noreturn]] inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void __throw_invalid_argument(const char*__msg)
{

    throw invalid_argument(__msg);




}

[[noreturn]] inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void __throw_length_error(const char*__msg)
{

    throw length_error(__msg);




}

[[noreturn]] inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void __throw_out_of_range(const char*__msg)
{

    throw out_of_range(__msg);




}

[[noreturn]] inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void __throw_range_error(const char*__msg)
{

    throw range_error(__msg);




}

[[noreturn]] inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void __throw_overflow_error(const char*__msg)
{

    throw overflow_error(__msg);




}

[[noreturn]] inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void __throw_underflow_error(const char*__msg)
{

    throw underflow_error(__msg);




}

} }
# 238 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/complex" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 1 3
# 239 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/complex" 2 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/sstream" 1 3
# 184 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/sstream" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/istream" 1 3
# 163 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/istream" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/ostream" 1 3
# 137 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/ostream" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/bitset" 1 3
# 116 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/bitset" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__bit_reference" 1 3
# 14 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__bit_reference" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__bits" 1 3
# 17 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__bits" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 21 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__bits" 2 3


namespace std { inline namespace __1 {



inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
int __libcpp_ctz(unsigned __x) noexcept { return __builtin_ctz(__x); }

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
int __libcpp_ctz(unsigned long __x) noexcept { return __builtin_ctzl(__x); }

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
int __libcpp_ctz(unsigned long long __x) noexcept { return __builtin_ctzll(__x); }


inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
int __libcpp_clz(unsigned __x) noexcept { return __builtin_clz(__x); }

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
int __libcpp_clz(unsigned long __x) noexcept { return __builtin_clzl(__x); }

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
int __libcpp_clz(unsigned long long __x) noexcept { return __builtin_clzll(__x); }


inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
int __libcpp_popcount(unsigned __x) noexcept { return __builtin_popcount(__x); }

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
int __libcpp_popcount(unsigned long __x) noexcept { return __builtin_popcountl(__x); }

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
int __libcpp_popcount(unsigned long long __x) noexcept { return __builtin_popcountll(__x); }
# 141 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__bits" 3
} }
# 15 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__bit_reference" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/algorithm" 1 3
# 649 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/algorithm" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__debug" 1 3
# 18 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__debug" 3
# 47 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__debug" 3
namespace std { inline namespace __1 {

struct __attribute__ ((__type_visibility__("default"))) __libcpp_debug_info {
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
  __libcpp_debug_info()
      : __file_(nullptr), __line_(-1), __pred_(nullptr), __msg_(nullptr) {}
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
  __libcpp_debug_info(const char* __f, int __l, const char* __p, const char* __m)
    : __file_(__f), __line_(__l), __pred_(__p), __msg_(__m) {}

  __attribute__ ((__visibility__("default"))) string what() const;

  const char* __file_;
  int __line_;
  const char* __pred_;
  const char* __msg_;
};


typedef void(*__libcpp_debug_function_type)(__libcpp_debug_info const&);



extern __attribute__((__visibility__("default"))) __libcpp_debug_function_type __libcpp_debug_function;


[[noreturn]] __attribute__ ((__visibility__("default")))
void __libcpp_abort_debug_function(__libcpp_debug_info const&);



__attribute__ ((__visibility__("default")))
bool __libcpp_set_debug_function(__libcpp_debug_function_type __func);
# 271 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__debug" 3
} }
# 650 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/algorithm" 2 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/functional" 1 3
# 490 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/functional" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/search.h" 1 3
# 13 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/search.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/comp.h" 1 3
# 16 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/comp.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 20 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/comp.h" 2 3

namespace std { inline namespace __1 {




template <class _T1, class _T2 = _T1>
struct __equal_to
{
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr bool operator()(const _T1& __x, const _T1& __y) const {return __x == __y;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr bool operator()(const _T1& __x, const _T2& __y) const {return __x == __y;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr bool operator()(const _T2& __x, const _T1& __y) const {return __x == __y;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr bool operator()(const _T2& __x, const _T2& __y) const {return __x == __y;}
};

template <class _T1>
struct __equal_to<_T1, _T1>
{
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
    bool operator()(const _T1& __x, const _T1& __y) const {return __x == __y;}
};

template <class _T1>
struct __equal_to<const _T1, _T1>
{
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
    bool operator()(const _T1& __x, const _T1& __y) const {return __x == __y;}
};

template <class _T1>
struct __equal_to<_T1, const _T1>
{
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
    bool operator()(const _T1& __x, const _T1& __y) const {return __x == __y;}
};

template <class _T1, class _T2 = _T1>
struct __less
{
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
    bool operator()(const _T1& __x, const _T1& __y) const {return __x < __y;}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
    bool operator()(const _T1& __x, const _T2& __y) const {return __x < __y;}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
    bool operator()(const _T2& __x, const _T1& __y) const {return __x < __y;}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
    bool operator()(const _T2& __x, const _T2& __y) const {return __x < __y;}
};

template <class _T1>
struct __less<_T1, _T1>
{
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
    bool operator()(const _T1& __x, const _T1& __y) const {return __x < __y;}
};

template <class _T1>
struct __less<const _T1, _T1>
{
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
    bool operator()(const _T1& __x, const _T1& __y) const {return __x < __y;}
};

template <class _T1>
struct __less<_T1, const _T1>
{
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
    bool operator()(const _T1& __x, const _T1& __y) const {return __x < __y;}
};

} }
# 14 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/search.h" 2 3

# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/iterator_traits.h" 1 3
# 14 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/iterator_traits.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/incrementable_traits.h" 1 3
# 14 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/incrementable_traits.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/concepts" 1 3
# 133 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/concepts" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/invoke.h" 1 3
# 14 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/invoke.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/weak_result_type.h" 1 3
# 14 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/weak_result_type.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/binary_function.h" 1 3
# 17 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/binary_function.h" 3


namespace std { inline namespace __1 {

template <class _Arg1, class _Arg2, class _Result>
struct __attribute__ ((__type_visibility__("default"))) binary_function
{
    typedef _Arg1 first_argument_type;
    typedef _Arg2 second_argument_type;
    typedef _Result result_type;
};

} }
# 15 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/weak_result_type.h" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/unary_function.h" 1 3
# 16 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/unary_function.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 20 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/unary_function.h" 2 3

namespace std { inline namespace __1 {

template <class _Arg, class _Result>
struct __attribute__ ((__type_visibility__("default"))) unary_function
{
    typedef _Arg argument_type;
    typedef _Result result_type;
};

} }
# 16 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/weak_result_type.h" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 1 3
# 17 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/weak_result_type.h" 2 3
# 20 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/weak_result_type.h" 3


namespace std { inline namespace __1 {

template <class _Tp>
struct __has_result_type
{
private:
    struct __two {char __lx; char __lxx;};
    template <class _Up> static __two __test(...);
    template <class _Up> static char __test(typename _Up::result_type* = 0);
public:
    static const bool value = sizeof(__test<_Tp>(0)) == 1;
};



template <class _Tp>
struct __derives_from_unary_function
{
private:
    struct __two {char __lx; char __lxx;};
    static __two __test(...);
    template <class _Ap, class _Rp>
        static unary_function<_Ap, _Rp>
        __test(const volatile unary_function<_Ap, _Rp>*);
public:
    static const bool value = !is_same<decltype(__test((_Tp*)0)), __two>::value;
    typedef decltype(__test((_Tp*)0)) type;
};

template <class _Tp>
struct __derives_from_binary_function
{
private:
    struct __two {char __lx; char __lxx;};
    static __two __test(...);
    template <class _A1, class _A2, class _Rp>
        static binary_function<_A1, _A2, _Rp>
        __test(const volatile binary_function<_A1, _A2, _Rp>*);
public:
    static const bool value = !is_same<decltype(__test((_Tp*)0)), __two>::value;
    typedef decltype(__test((_Tp*)0)) type;
};

template <class _Tp, bool = __derives_from_unary_function<_Tp>::value>
struct __maybe_derive_from_unary_function
    : public __derives_from_unary_function<_Tp>::type
{
};

template <class _Tp>
struct __maybe_derive_from_unary_function<_Tp, false>
{
};

template <class _Tp, bool = __derives_from_binary_function<_Tp>::value>
struct __maybe_derive_from_binary_function
    : public __derives_from_binary_function<_Tp>::type
{
};

template <class _Tp>
struct __maybe_derive_from_binary_function<_Tp, false>
{
};

template <class _Tp, bool = __has_result_type<_Tp>::value>
struct __weak_result_type_imp
    : public __maybe_derive_from_unary_function<_Tp>,
      public __maybe_derive_from_binary_function<_Tp>
{
    typedef typename _Tp::result_type result_type;
};

template <class _Tp>
struct __weak_result_type_imp<_Tp, false>
    : public __maybe_derive_from_unary_function<_Tp>,
      public __maybe_derive_from_binary_function<_Tp>
{
};

template <class _Tp>
struct __weak_result_type
    : public __weak_result_type_imp<_Tp>
{
};



template <class _Rp>
struct __weak_result_type<_Rp ()>
{
    typedef _Rp result_type;
};

template <class _Rp>
struct __weak_result_type<_Rp (&)()>
{
    typedef _Rp result_type;
};

template <class _Rp>
struct __weak_result_type<_Rp (*)()>
{
    typedef _Rp result_type;
};



template <class _Rp, class _A1>
struct __weak_result_type<_Rp (_A1)>
    : public unary_function<_A1, _Rp>
{
};

template <class _Rp, class _A1>
struct __weak_result_type<_Rp (&)(_A1)>
    : public unary_function<_A1, _Rp>
{
};

template <class _Rp, class _A1>
struct __weak_result_type<_Rp (*)(_A1)>
    : public unary_function<_A1, _Rp>
{
};

template <class _Rp, class _Cp>
struct __weak_result_type<_Rp (_Cp::*)()>
    : public unary_function<_Cp*, _Rp>
{
};

template <class _Rp, class _Cp>
struct __weak_result_type<_Rp (_Cp::*)() const>
    : public unary_function<const _Cp*, _Rp>
{
};

template <class _Rp, class _Cp>
struct __weak_result_type<_Rp (_Cp::*)() volatile>
    : public unary_function<volatile _Cp*, _Rp>
{
};

template <class _Rp, class _Cp>
struct __weak_result_type<_Rp (_Cp::*)() const volatile>
    : public unary_function<const volatile _Cp*, _Rp>
{
};



template <class _Rp, class _A1, class _A2>
struct __weak_result_type<_Rp (_A1, _A2)>
    : public binary_function<_A1, _A2, _Rp>
{
};

template <class _Rp, class _A1, class _A2>
struct __weak_result_type<_Rp (*)(_A1, _A2)>
    : public binary_function<_A1, _A2, _Rp>
{
};

template <class _Rp, class _A1, class _A2>
struct __weak_result_type<_Rp (&)(_A1, _A2)>
    : public binary_function<_A1, _A2, _Rp>
{
};

template <class _Rp, class _Cp, class _A1>
struct __weak_result_type<_Rp (_Cp::*)(_A1)>
    : public binary_function<_Cp*, _A1, _Rp>
{
};

template <class _Rp, class _Cp, class _A1>
struct __weak_result_type<_Rp (_Cp::*)(_A1) const>
    : public binary_function<const _Cp*, _A1, _Rp>
{
};

template <class _Rp, class _Cp, class _A1>
struct __weak_result_type<_Rp (_Cp::*)(_A1) volatile>
    : public binary_function<volatile _Cp*, _A1, _Rp>
{
};

template <class _Rp, class _Cp, class _A1>
struct __weak_result_type<_Rp (_Cp::*)(_A1) const volatile>
    : public binary_function<const volatile _Cp*, _A1, _Rp>
{
};





template <class _Rp, class _A1, class _A2, class _A3, class ..._A4>
struct __weak_result_type<_Rp (_A1, _A2, _A3, _A4...)>
{
    typedef _Rp result_type;
};

template <class _Rp, class _A1, class _A2, class _A3, class ..._A4>
struct __weak_result_type<_Rp (&)(_A1, _A2, _A3, _A4...)>
{
    typedef _Rp result_type;
};

template <class _Rp, class _A1, class _A2, class _A3, class ..._A4>
struct __weak_result_type<_Rp (*)(_A1, _A2, _A3, _A4...)>
{
    typedef _Rp result_type;
};

template <class _Rp, class _Cp, class _A1, class _A2, class ..._A3>
struct __weak_result_type<_Rp (_Cp::*)(_A1, _A2, _A3...)>
{
    typedef _Rp result_type;
};

template <class _Rp, class _Cp, class _A1, class _A2, class ..._A3>
struct __weak_result_type<_Rp (_Cp::*)(_A1, _A2, _A3...) const>
{
    typedef _Rp result_type;
};

template <class _Rp, class _Cp, class _A1, class _A2, class ..._A3>
struct __weak_result_type<_Rp (_Cp::*)(_A1, _A2, _A3...) volatile>
{
    typedef _Rp result_type;
};

template <class _Rp, class _Cp, class _A1, class _A2, class ..._A3>
struct __weak_result_type<_Rp (_Cp::*)(_A1, _A2, _A3...) const volatile>
{
    typedef _Rp result_type;
};

template <class _Tp, class ..._Args>
struct __invoke_return
{
    typedef decltype(std::__1::__invoke(declval<_Tp>(), declval<_Args>()...)) type;
};
# 479 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/weak_result_type.h" 3
} }
# 15 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/invoke.h" 2 3

# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 1 3
# 17 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/invoke.h" 2 3
# 20 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/invoke.h" 3


namespace std { inline namespace __1 {

template <class _Ret, bool = is_void<_Ret>::value>
struct __invoke_void_return_wrapper
{

    template <class ..._Args>
    static _Ret __call(_Args&&... __args) {
        return std::__1::__invoke(std::__1::forward<_Args>(__args)...);
    }
# 53 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/invoke.h" 3
};

template <class _Ret>
struct __invoke_void_return_wrapper<_Ret, true>
{

    template <class ..._Args>
    static void __call(_Args&&... __args) {
        std::__1::__invoke(std::__1::forward<_Args>(__args)...);
    }
# 84 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/invoke.h" 3
};



template <class _Fn, class ..._Args>
                              invoke_result_t<_Fn, _Args...>
invoke(_Fn&& __f, _Args&&... __args)
    noexcept(is_nothrow_invocable_v<_Fn, _Args...>)
{
    return std::__1::__invoke(std::__1::forward<_Fn>(__f), std::__1::forward<_Args>(__args)...);
}



} }
# 134 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/concepts" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional_base" 1 3
# 16 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional_base" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/operations.h" 1 3
# 20 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/operations.h" 3


namespace std { inline namespace __1 {



#pragma GCC diagnostic push
# 26 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/operations.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated"
# 26 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/operations.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"

template <class _Tp = void>



struct __attribute__ ((__type_visibility__("default"))) plus

    : binary_function<_Tp, _Tp, _Tp>

{
#pragma GCC diagnostic pop
    typedef _Tp __result_type;

    __attribute__ ((deprecated)) typedef _Tp result_type;
    __attribute__ ((deprecated)) typedef _Tp first_argument_type;
    __attribute__ ((deprecated)) typedef _Tp second_argument_type;

    constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    _Tp operator()(const _Tp& __x, const _Tp& __y) const
        {return __x + __y;}
};


template <>
struct __attribute__ ((__type_visibility__("default"))) plus<void>
{
    template <class _T1, class _T2>
    constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    auto operator()(_T1&& __t, _T2&& __u) const
    noexcept(noexcept(std::__1::forward<_T1>(__t) + std::__1::forward<_T2>(__u)))
    -> decltype (std::__1::forward<_T1>(__t) + std::__1::forward<_T2>(__u))
        { return std::__1::forward<_T1>(__t) + std::__1::forward<_T2>(__u); }
    typedef void is_transparent;
};


#pragma GCC diagnostic push
# 63 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/operations.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated"
# 63 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/operations.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"

template <class _Tp = void>



struct __attribute__ ((__type_visibility__("default"))) minus

    : binary_function<_Tp, _Tp, _Tp>

{
#pragma GCC diagnostic pop
    typedef _Tp __result_type;

    __attribute__ ((deprecated)) typedef _Tp result_type;
    __attribute__ ((deprecated)) typedef _Tp first_argument_type;
    __attribute__ ((deprecated)) typedef _Tp second_argument_type;

    constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    _Tp operator()(const _Tp& __x, const _Tp& __y) const
        {return __x - __y;}
};


template <>
struct __attribute__ ((__type_visibility__("default"))) minus<void>
{
    template <class _T1, class _T2>
    constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    auto operator()(_T1&& __t, _T2&& __u) const
    noexcept(noexcept(std::__1::forward<_T1>(__t) - std::__1::forward<_T2>(__u)))
    -> decltype (std::__1::forward<_T1>(__t) - std::__1::forward<_T2>(__u))
        { return std::__1::forward<_T1>(__t) - std::__1::forward<_T2>(__u); }
    typedef void is_transparent;
};


#pragma GCC diagnostic push
# 100 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/operations.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated"
# 100 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/operations.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"

template <class _Tp = void>



struct __attribute__ ((__type_visibility__("default"))) multiplies

    : binary_function<_Tp, _Tp, _Tp>

{
#pragma GCC diagnostic pop
    typedef _Tp __result_type;

    __attribute__ ((deprecated)) typedef _Tp result_type;
    __attribute__ ((deprecated)) typedef _Tp first_argument_type;
    __attribute__ ((deprecated)) typedef _Tp second_argument_type;

    constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    _Tp operator()(const _Tp& __x, const _Tp& __y) const
        {return __x * __y;}
};


template <>
struct __attribute__ ((__type_visibility__("default"))) multiplies<void>
{
    template <class _T1, class _T2>
    constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    auto operator()(_T1&& __t, _T2&& __u) const
    noexcept(noexcept(std::__1::forward<_T1>(__t) * std::__1::forward<_T2>(__u)))
    -> decltype (std::__1::forward<_T1>(__t) * std::__1::forward<_T2>(__u))
        { return std::__1::forward<_T1>(__t) * std::__1::forward<_T2>(__u); }
    typedef void is_transparent;
};


#pragma GCC diagnostic push
# 137 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/operations.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated"
# 137 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/operations.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"

template <class _Tp = void>



struct __attribute__ ((__type_visibility__("default"))) divides

    : binary_function<_Tp, _Tp, _Tp>

{
#pragma GCC diagnostic pop
    typedef _Tp __result_type;

    __attribute__ ((deprecated)) typedef _Tp result_type;
    __attribute__ ((deprecated)) typedef _Tp first_argument_type;
    __attribute__ ((deprecated)) typedef _Tp second_argument_type;

    constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    _Tp operator()(const _Tp& __x, const _Tp& __y) const
        {return __x / __y;}
};


template <>
struct __attribute__ ((__type_visibility__("default"))) divides<void>
{
    template <class _T1, class _T2>
    constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    auto operator()(_T1&& __t, _T2&& __u) const
    noexcept(noexcept(std::__1::forward<_T1>(__t) / std::__1::forward<_T2>(__u)))
    -> decltype (std::__1::forward<_T1>(__t) / std::__1::forward<_T2>(__u))
        { return std::__1::forward<_T1>(__t) / std::__1::forward<_T2>(__u); }
    typedef void is_transparent;
};


#pragma GCC diagnostic push
# 174 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/operations.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated"
# 174 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/operations.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"

template <class _Tp = void>



struct __attribute__ ((__type_visibility__("default"))) modulus

    : binary_function<_Tp, _Tp, _Tp>

{
#pragma GCC diagnostic pop
    typedef _Tp __result_type;

    __attribute__ ((deprecated)) typedef _Tp result_type;
    __attribute__ ((deprecated)) typedef _Tp first_argument_type;
    __attribute__ ((deprecated)) typedef _Tp second_argument_type;

    constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    _Tp operator()(const _Tp& __x, const _Tp& __y) const
        {return __x % __y;}
};


template <>
struct __attribute__ ((__type_visibility__("default"))) modulus<void>
{
    template <class _T1, class _T2>
    constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    auto operator()(_T1&& __t, _T2&& __u) const
    noexcept(noexcept(std::__1::forward<_T1>(__t) % std::__1::forward<_T2>(__u)))
    -> decltype (std::__1::forward<_T1>(__t) % std::__1::forward<_T2>(__u))
        { return std::__1::forward<_T1>(__t) % std::__1::forward<_T2>(__u); }
    typedef void is_transparent;
};


#pragma GCC diagnostic push
# 211 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/operations.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated"
# 211 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/operations.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"

template <class _Tp = void>



struct __attribute__ ((__type_visibility__("default"))) negate

    : unary_function<_Tp, _Tp>

{
#pragma GCC diagnostic pop
    typedef _Tp __result_type;

    __attribute__ ((deprecated)) typedef _Tp result_type;
    __attribute__ ((deprecated)) typedef _Tp argument_type;

    constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    _Tp operator()(const _Tp& __x) const
        {return -__x;}
};


template <>
struct __attribute__ ((__type_visibility__("default"))) negate<void>
{
    template <class _Tp>
    constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    auto operator()(_Tp&& __x) const
    noexcept(noexcept(- std::__1::forward<_Tp>(__x)))
    -> decltype (- std::__1::forward<_Tp>(__x))
        { return - std::__1::forward<_Tp>(__x); }
    typedef void is_transparent;
};




#pragma GCC diagnostic push
# 249 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/operations.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated"
# 249 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/operations.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"

template <class _Tp = void>



struct __attribute__ ((__type_visibility__("default"))) bit_and

    : binary_function<_Tp, _Tp, _Tp>

{
#pragma GCC diagnostic pop
    typedef _Tp __result_type;

    __attribute__ ((deprecated)) typedef _Tp result_type;
    __attribute__ ((deprecated)) typedef _Tp first_argument_type;
    __attribute__ ((deprecated)) typedef _Tp second_argument_type;

    constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    _Tp operator()(const _Tp& __x, const _Tp& __y) const
        {return __x & __y;}
};


template <>
struct __attribute__ ((__type_visibility__("default"))) bit_and<void>
{
    template <class _T1, class _T2>
    constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    auto operator()(_T1&& __t, _T2&& __u) const
    noexcept(noexcept(std::__1::forward<_T1>(__t) & std::__1::forward<_T2>(__u)))
    -> decltype (std::__1::forward<_T1>(__t) & std::__1::forward<_T2>(__u))
        { return std::__1::forward<_T1>(__t) & std::__1::forward<_T2>(__u); }
    typedef void is_transparent;
};



#pragma GCC diagnostic push
# 287 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/operations.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated"
# 287 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/operations.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
template <class _Tp = void>
struct __attribute__ ((__type_visibility__("default"))) bit_not

    : unary_function<_Tp, _Tp>

{
#pragma GCC diagnostic pop

    __attribute__ ((deprecated)) typedef _Tp result_type;
    __attribute__ ((deprecated)) typedef _Tp argument_type;

    constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    _Tp operator()(const _Tp& __x) const
        {return ~__x;}
};

template <>
struct __attribute__ ((__type_visibility__("default"))) bit_not<void>
{
    template <class _Tp>
    constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    auto operator()(_Tp&& __x) const
    noexcept(noexcept(~std::__1::forward<_Tp>(__x)))
    -> decltype (~std::__1::forward<_Tp>(__x))
        { return ~std::__1::forward<_Tp>(__x); }
    typedef void is_transparent;
};


#pragma GCC diagnostic push
# 317 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/operations.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated"
# 317 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/operations.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"

template <class _Tp = void>



struct __attribute__ ((__type_visibility__("default"))) bit_or

    : binary_function<_Tp, _Tp, _Tp>

{
#pragma GCC diagnostic pop
    typedef _Tp __result_type;

    __attribute__ ((deprecated)) typedef _Tp result_type;
    __attribute__ ((deprecated)) typedef _Tp first_argument_type;
    __attribute__ ((deprecated)) typedef _Tp second_argument_type;

    constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    _Tp operator()(const _Tp& __x, const _Tp& __y) const
        {return __x | __y;}
};


template <>
struct __attribute__ ((__type_visibility__("default"))) bit_or<void>
{
    template <class _T1, class _T2>
    constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    auto operator()(_T1&& __t, _T2&& __u) const
    noexcept(noexcept(std::__1::forward<_T1>(__t) | std::__1::forward<_T2>(__u)))
    -> decltype (std::__1::forward<_T1>(__t) | std::__1::forward<_T2>(__u))
        { return std::__1::forward<_T1>(__t) | std::__1::forward<_T2>(__u); }
    typedef void is_transparent;
};


#pragma GCC diagnostic push
# 354 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/operations.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated"
# 354 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/operations.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"

template <class _Tp = void>



struct __attribute__ ((__type_visibility__("default"))) bit_xor

    : binary_function<_Tp, _Tp, _Tp>

{
#pragma GCC diagnostic pop
    typedef _Tp __result_type;

    __attribute__ ((deprecated)) typedef _Tp result_type;
    __attribute__ ((deprecated)) typedef _Tp first_argument_type;
    __attribute__ ((deprecated)) typedef _Tp second_argument_type;

    constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    _Tp operator()(const _Tp& __x, const _Tp& __y) const
        {return __x ^ __y;}
};


template <>
struct __attribute__ ((__type_visibility__("default"))) bit_xor<void>
{
    template <class _T1, class _T2>
    constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    auto operator()(_T1&& __t, _T2&& __u) const
    noexcept(noexcept(std::__1::forward<_T1>(__t) ^ std::__1::forward<_T2>(__u)))
    -> decltype (std::__1::forward<_T1>(__t) ^ std::__1::forward<_T2>(__u))
        { return std::__1::forward<_T1>(__t) ^ std::__1::forward<_T2>(__u); }
    typedef void is_transparent;
};




#pragma GCC diagnostic push
# 393 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/operations.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated"
# 393 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/operations.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"

template <class _Tp = void>



struct __attribute__ ((__type_visibility__("default"))) equal_to

    : binary_function<_Tp, _Tp, bool>

{
#pragma GCC diagnostic pop
    typedef bool __result_type;

    __attribute__ ((deprecated)) typedef bool result_type;
    __attribute__ ((deprecated)) typedef _Tp first_argument_type;
    __attribute__ ((deprecated)) typedef _Tp second_argument_type;

    constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    bool operator()(const _Tp& __x, const _Tp& __y) const
        {return __x == __y;}
};


template <>
struct __attribute__ ((__type_visibility__("default"))) equal_to<void>
{
    template <class _T1, class _T2>
    constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    auto operator()(_T1&& __t, _T2&& __u) const
    noexcept(noexcept(std::__1::forward<_T1>(__t) == std::__1::forward<_T2>(__u)))
    -> decltype (std::__1::forward<_T1>(__t) == std::__1::forward<_T2>(__u))
        { return std::__1::forward<_T1>(__t) == std::__1::forward<_T2>(__u); }
    typedef void is_transparent;
};


#pragma GCC diagnostic push
# 430 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/operations.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated"
# 430 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/operations.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"

template <class _Tp = void>



struct __attribute__ ((__type_visibility__("default"))) not_equal_to

    : binary_function<_Tp, _Tp, bool>

{
#pragma GCC diagnostic pop
    typedef bool __result_type;

    __attribute__ ((deprecated)) typedef bool result_type;
    __attribute__ ((deprecated)) typedef _Tp first_argument_type;
    __attribute__ ((deprecated)) typedef _Tp second_argument_type;

    constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    bool operator()(const _Tp& __x, const _Tp& __y) const
        {return __x != __y;}
};


template <>
struct __attribute__ ((__type_visibility__("default"))) not_equal_to<void>
{
    template <class _T1, class _T2>
    constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    auto operator()(_T1&& __t, _T2&& __u) const
    noexcept(noexcept(std::__1::forward<_T1>(__t) != std::__1::forward<_T2>(__u)))
    -> decltype (std::__1::forward<_T1>(__t) != std::__1::forward<_T2>(__u))
        { return std::__1::forward<_T1>(__t) != std::__1::forward<_T2>(__u); }
    typedef void is_transparent;
};


#pragma GCC diagnostic push
# 467 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/operations.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated"
# 467 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/operations.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"

template <class _Tp = void>



struct __attribute__ ((__type_visibility__("default"))) less

    : binary_function<_Tp, _Tp, bool>

{
#pragma GCC diagnostic pop
    typedef bool __result_type;

    __attribute__ ((deprecated)) typedef bool result_type;
    __attribute__ ((deprecated)) typedef _Tp first_argument_type;
    __attribute__ ((deprecated)) typedef _Tp second_argument_type;

    constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    bool operator()(const _Tp& __x, const _Tp& __y) const
        {return __x < __y;}
};


template <>
struct __attribute__ ((__type_visibility__("default"))) less<void>
{
    template <class _T1, class _T2>
    constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    auto operator()(_T1&& __t, _T2&& __u) const
    noexcept(noexcept(std::__1::forward<_T1>(__t) < std::__1::forward<_T2>(__u)))
    -> decltype (std::__1::forward<_T1>(__t) < std::__1::forward<_T2>(__u))
        { return std::__1::forward<_T1>(__t) < std::__1::forward<_T2>(__u); }
    typedef void is_transparent;
};


#pragma GCC diagnostic push
# 504 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/operations.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated"
# 504 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/operations.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"

template <class _Tp = void>



struct __attribute__ ((__type_visibility__("default"))) less_equal

    : binary_function<_Tp, _Tp, bool>

{
#pragma GCC diagnostic pop
    typedef bool __result_type;

    __attribute__ ((deprecated)) typedef bool result_type;
    __attribute__ ((deprecated)) typedef _Tp first_argument_type;
    __attribute__ ((deprecated)) typedef _Tp second_argument_type;

    constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    bool operator()(const _Tp& __x, const _Tp& __y) const
        {return __x <= __y;}
};


template <>
struct __attribute__ ((__type_visibility__("default"))) less_equal<void>
{
    template <class _T1, class _T2>
    constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    auto operator()(_T1&& __t, _T2&& __u) const
    noexcept(noexcept(std::__1::forward<_T1>(__t) <= std::__1::forward<_T2>(__u)))
    -> decltype (std::__1::forward<_T1>(__t) <= std::__1::forward<_T2>(__u))
        { return std::__1::forward<_T1>(__t) <= std::__1::forward<_T2>(__u); }
    typedef void is_transparent;
};


#pragma GCC diagnostic push
# 541 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/operations.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated"
# 541 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/operations.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"

template <class _Tp = void>



struct __attribute__ ((__type_visibility__("default"))) greater_equal

    : binary_function<_Tp, _Tp, bool>

{
#pragma GCC diagnostic pop
    typedef bool __result_type;

    __attribute__ ((deprecated)) typedef bool result_type;
    __attribute__ ((deprecated)) typedef _Tp first_argument_type;
    __attribute__ ((deprecated)) typedef _Tp second_argument_type;

    constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    bool operator()(const _Tp& __x, const _Tp& __y) const
        {return __x >= __y;}
};


template <>
struct __attribute__ ((__type_visibility__("default"))) greater_equal<void>
{
    template <class _T1, class _T2>
    constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    auto operator()(_T1&& __t, _T2&& __u) const
    noexcept(noexcept(std::__1::forward<_T1>(__t) >= std::__1::forward<_T2>(__u)))
    -> decltype (std::__1::forward<_T1>(__t) >= std::__1::forward<_T2>(__u))
        { return std::__1::forward<_T1>(__t) >= std::__1::forward<_T2>(__u); }
    typedef void is_transparent;
};


#pragma GCC diagnostic push
# 578 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/operations.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated"
# 578 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/operations.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"

template <class _Tp = void>



struct __attribute__ ((__type_visibility__("default"))) greater

    : binary_function<_Tp, _Tp, bool>

{
#pragma GCC diagnostic pop
    typedef bool __result_type;

    __attribute__ ((deprecated)) typedef bool result_type;
    __attribute__ ((deprecated)) typedef _Tp first_argument_type;
    __attribute__ ((deprecated)) typedef _Tp second_argument_type;

    constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    bool operator()(const _Tp& __x, const _Tp& __y) const
        {return __x > __y;}
};


template <>
struct __attribute__ ((__type_visibility__("default"))) greater<void>
{
    template <class _T1, class _T2>
    constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    auto operator()(_T1&& __t, _T2&& __u) const
    noexcept(noexcept(std::__1::forward<_T1>(__t) > std::__1::forward<_T2>(__u)))
    -> decltype (std::__1::forward<_T1>(__t) > std::__1::forward<_T2>(__u))
        { return std::__1::forward<_T1>(__t) > std::__1::forward<_T2>(__u); }
    typedef void is_transparent;
};




#pragma GCC diagnostic push
# 617 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/operations.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated"
# 617 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/operations.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"

template <class _Tp = void>



struct __attribute__ ((__type_visibility__("default"))) logical_and

    : binary_function<_Tp, _Tp, bool>

{
#pragma GCC diagnostic pop
    typedef bool __result_type;

    __attribute__ ((deprecated)) typedef bool result_type;
    __attribute__ ((deprecated)) typedef _Tp first_argument_type;
    __attribute__ ((deprecated)) typedef _Tp second_argument_type;

    constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    bool operator()(const _Tp& __x, const _Tp& __y) const
        {return __x && __y;}
};


template <>
struct __attribute__ ((__type_visibility__("default"))) logical_and<void>
{
    template <class _T1, class _T2>
    constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    auto operator()(_T1&& __t, _T2&& __u) const
    noexcept(noexcept(std::__1::forward<_T1>(__t) && std::__1::forward<_T2>(__u)))
    -> decltype (std::__1::forward<_T1>(__t) && std::__1::forward<_T2>(__u))
        { return std::__1::forward<_T1>(__t) && std::__1::forward<_T2>(__u); }
    typedef void is_transparent;
};


#pragma GCC diagnostic push
# 654 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/operations.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated"
# 654 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/operations.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"

template <class _Tp = void>



struct __attribute__ ((__type_visibility__("default"))) logical_not

    : unary_function<_Tp, bool>

{
#pragma GCC diagnostic pop
    typedef bool __result_type;

    __attribute__ ((deprecated)) typedef bool result_type;
    __attribute__ ((deprecated)) typedef _Tp argument_type;

    constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    bool operator()(const _Tp& __x) const
        {return !__x;}
};


template <>
struct __attribute__ ((__type_visibility__("default"))) logical_not<void>
{
    template <class _Tp>
    constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    auto operator()(_Tp&& __x) const
    noexcept(noexcept(!std::__1::forward<_Tp>(__x)))
    -> decltype (!std::__1::forward<_Tp>(__x))
        { return !std::__1::forward<_Tp>(__x); }
    typedef void is_transparent;
};


#pragma GCC diagnostic push
# 690 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/operations.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated"
# 690 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/operations.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"

template <class _Tp = void>



struct __attribute__ ((__type_visibility__("default"))) logical_or

    : binary_function<_Tp, _Tp, bool>

{
#pragma GCC diagnostic pop
    typedef bool __result_type;

    __attribute__ ((deprecated)) typedef bool result_type;
    __attribute__ ((deprecated)) typedef _Tp first_argument_type;
    __attribute__ ((deprecated)) typedef _Tp second_argument_type;

    constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    bool operator()(const _Tp& __x, const _Tp& __y) const
        {return __x || __y;}
};


template <>
struct __attribute__ ((__type_visibility__("default"))) logical_or<void>
{
    template <class _T1, class _T2>
    constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    auto operator()(_T1&& __t, _T2&& __u) const
    noexcept(noexcept(std::__1::forward<_T1>(__t) || std::__1::forward<_T2>(__u)))
    -> decltype (std::__1::forward<_T1>(__t) || std::__1::forward<_T2>(__u))
        { return std::__1::forward<_T1>(__t) || std::__1::forward<_T2>(__u); }
    typedef void is_transparent;
};


} }
# 17 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional_base" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/reference_wrapper.h" 1 3
# 17 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/reference_wrapper.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 1 3
# 18 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/reference_wrapper.h" 2 3
# 21 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/reference_wrapper.h" 3


namespace std { inline namespace __1 {

template <class _Tp>
class __attribute__ ((__type_visibility__("default"))) reference_wrapper

    : public __weak_result_type<_Tp>

{
public:

    typedef _Tp type;
private:
    type* __f_;


    static void __fun(_Tp&) noexcept;
    static void __fun(_Tp&&) = delete;


public:






    template <class _Up, class = _EnableIf<!__is_same_uncvref<_Up, reference_wrapper>::value, decltype(__fun(declval<_Up>())) >>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    reference_wrapper(_Up&& __u) noexcept(noexcept(__fun(declval<_Up>()))) {
        type& __f = static_cast<_Up&&>(__u);
        __f_ = std::__1::addressof(__f);
    }



    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    operator type&() const noexcept {return *__f_;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    type& get() const noexcept {return *__f_;}



    template <class... _ArgTypes>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    typename __invoke_of<type&, _ArgTypes...>::type
    operator() (_ArgTypes&&... __args) const {
        return std::__1::__invoke(get(), std::__1::forward<_ArgTypes>(__args)...);
    }
# 177 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/reference_wrapper.h" 3
};


template <class _Tp>
reference_wrapper(_Tp&) -> reference_wrapper<_Tp>;


template <class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
reference_wrapper<_Tp>
ref(_Tp& __t) noexcept
{
    return reference_wrapper<_Tp>(__t);
}

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
reference_wrapper<_Tp>
ref(reference_wrapper<_Tp> __t) noexcept
{
    return std::__1::ref(__t.get());
}

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
reference_wrapper<const _Tp>
cref(const _Tp& __t) noexcept
{
    return reference_wrapper<const _Tp>(__t);
}

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
reference_wrapper<const _Tp>
cref(reference_wrapper<_Tp> __t) noexcept
{
    return std::__1::cref(__t.get());
}


template <class _Tp> void ref(const _Tp&&) = delete;
template <class _Tp> void cref(const _Tp&&) = delete;


} }
# 18 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional_base" 2 3


# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/allocator_arg_t.h" 1 3
# 14 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/allocator_arg_t.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/uses_allocator.h" 1 3
# 15 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/uses_allocator.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 1 3
# 16 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/uses_allocator.h" 2 3
# 19 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/uses_allocator.h" 3


namespace std { inline namespace __1 {

template <class _Tp>
struct __has_allocator_type
{
private:
    struct __two {char __lx; char __lxx;};
    template <class _Up> static __two __test(...);
    template <class _Up> static char __test(typename _Up::allocator_type* = 0);
public:
    static const bool value = sizeof(__test<_Tp>(0)) == 1;
};

template <class _Tp, class _Alloc, bool = __has_allocator_type<_Tp>::value>
struct __uses_allocator
    : public integral_constant<bool,
        is_convertible<_Alloc, typename _Tp::allocator_type>::value>
{
};

template <class _Tp, class _Alloc>
struct __uses_allocator<_Tp, _Alloc, false>
    : public false_type
{
};

template <class _Tp, class _Alloc>
struct __attribute__ ((__type_visibility__("default"))) uses_allocator
    : public __uses_allocator<_Tp, _Alloc>
{
};


template <class _Tp, class _Alloc>
inline constexpr size_t uses_allocator_v = uses_allocator<_Tp, _Alloc>::value;


} }
# 15 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/allocator_arg_t.h" 2 3

# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 1 3
# 17 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/allocator_arg_t.h" 2 3
# 20 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/allocator_arg_t.h" 3


namespace std { inline namespace __1 {

struct __attribute__ ((__type_visibility__("default"))) allocator_arg_t { explicit allocator_arg_t() = default; };




                         constexpr allocator_arg_t allocator_arg = allocator_arg_t();






template <class _Tp, class _Alloc, class ..._Args>
struct __uses_alloc_ctor_imp
{
    typedef typename __uncvref<_Alloc>::type _RawAlloc;
    static const bool __ua = uses_allocator<_Tp, _RawAlloc>::value;
    static const bool __ic =
        is_constructible<_Tp, allocator_arg_t, _Alloc, _Args...>::value;
    static const int value = __ua ? 2 - __ic : 0;
};

template <class _Tp, class _Alloc, class ..._Args>
struct __uses_alloc_ctor
    : integral_constant<int, __uses_alloc_ctor_imp<_Tp, _Alloc, _Args...>::value>
    {};

template <class _Tp, class _Allocator, class... _Args>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void __user_alloc_construct_impl (integral_constant<int, 0>, _Tp *__storage, const _Allocator &, _Args &&... __args )
{
    new (__storage) _Tp (std::__1::forward<_Args>(__args)...);
}


template <class _Tp, class _Allocator, class... _Args>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void __user_alloc_construct_impl (integral_constant<int, 1>, _Tp *__storage, const _Allocator &__a, _Args &&... __args )
{
    new (__storage) _Tp (allocator_arg, __a, std::__1::forward<_Args>(__args)...);
}


template <class _Tp, class _Allocator, class... _Args>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void __user_alloc_construct_impl (integral_constant<int, 2>, _Tp *__storage, const _Allocator &__a, _Args &&... __args )
{
    new (__storage) _Tp (std::__1::forward<_Args>(__args)..., __a);
}



} }
# 21 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional_base" 2 3


# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/new" 1 3
# 94 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/new" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 1 3
# 95 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/new" 2 3
# 103 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/new" 3
# 119 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/new" 3
namespace std
{


struct __attribute__ ((__visibility__("default"))) nothrow_t { explicit nothrow_t() = default; };
extern __attribute__ ((__visibility__("default"))) const nothrow_t nothrow;

class __attribute__ ((__visibility__("default"))) bad_alloc
    : public exception
{
public:
    bad_alloc() noexcept;
    virtual ~bad_alloc() noexcept;
    virtual const char* what() const noexcept;
};

class __attribute__ ((__visibility__("default"))) bad_array_new_length
    : public bad_alloc
{
public:
    bad_array_new_length() noexcept;
    virtual ~bad_array_new_length() noexcept;
    virtual const char* what() const noexcept;
};

typedef void (*new_handler)();
__attribute__ ((__visibility__("default"))) new_handler set_new_handler(new_handler) noexcept;
__attribute__ ((__visibility__("default"))) new_handler get_new_handler() noexcept;



[[noreturn]] __attribute__ ((__visibility__("default"))) void __throw_bad_alloc();




enum class __attribute__ ((__type_visibility__("default"))) align_val_t : size_t { };
# 170 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/new" 3
}
# 180 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/new" 3
                              __attribute__ ((__visibility__("default"))) void* operator new(std::size_t __sz) ;
                              __attribute__ ((__visibility__("default"))) void* operator new(std::size_t __sz, const std::nothrow_t&) noexcept __attribute__((__malloc__));
__attribute__ ((__visibility__("default"))) void operator delete(void* __p) noexcept;
__attribute__ ((__visibility__("default"))) void operator delete(void* __p, const std::nothrow_t&) noexcept;

__attribute__ ((__visibility__("default"))) __attribute__((availability(macosx,strict,introduced=10.12))) __attribute__((availability(ios,strict,introduced=10.0))) __attribute__((availability(tvos,strict,introduced=10.0))) __attribute__((availability(watchos,strict,introduced=3.0))) void operator delete(void* __p, std::size_t __sz) noexcept;


                              __attribute__ ((__visibility__("default"))) void* operator new[](std::size_t __sz) ;
                              __attribute__ ((__visibility__("default"))) void* operator new[](std::size_t __sz, const std::nothrow_t&) noexcept __attribute__((__malloc__));
__attribute__ ((__visibility__("default"))) void operator delete[](void* __p) noexcept;
__attribute__ ((__visibility__("default"))) void operator delete[](void* __p, const std::nothrow_t&) noexcept;

__attribute__ ((__visibility__("default"))) __attribute__((availability(macosx,strict,introduced=10.12))) __attribute__((availability(ios,strict,introduced=10.0))) __attribute__((availability(tvos,strict,introduced=10.0))) __attribute__((availability(watchos,strict,introduced=3.0))) void operator delete[](void* __p, std::size_t __sz) noexcept;



                              __attribute__ ((__visibility__("default"))) void* operator new(std::size_t __sz, std::align_val_t) ;
                              __attribute__ ((__visibility__("default"))) void* operator new(std::size_t __sz, std::align_val_t, const std::nothrow_t&) noexcept __attribute__((__malloc__));
__attribute__ ((__visibility__("default"))) void operator delete(void* __p, std::align_val_t) noexcept;
__attribute__ ((__visibility__("default"))) void operator delete(void* __p, std::align_val_t, const std::nothrow_t&) noexcept;

__attribute__ ((__visibility__("default"))) __attribute__((availability(macosx,strict,introduced=10.12))) __attribute__((availability(ios,strict,introduced=10.0))) __attribute__((availability(tvos,strict,introduced=10.0))) __attribute__((availability(watchos,strict,introduced=3.0))) void operator delete(void* __p, std::size_t __sz, std::align_val_t) noexcept;


                              __attribute__ ((__visibility__("default"))) void* operator new[](std::size_t __sz, std::align_val_t) ;
                              __attribute__ ((__visibility__("default"))) void* operator new[](std::size_t __sz, std::align_val_t, const std::nothrow_t&) noexcept __attribute__((__malloc__));
__attribute__ ((__visibility__("default"))) void operator delete[](void* __p, std::align_val_t) noexcept;
__attribute__ ((__visibility__("default"))) void operator delete[](void* __p, std::align_val_t, const std::nothrow_t&) noexcept;

__attribute__ ((__visibility__("default"))) __attribute__((availability(macosx,strict,introduced=10.12))) __attribute__((availability(ios,strict,introduced=10.0))) __attribute__((availability(tvos,strict,introduced=10.0))) __attribute__((availability(watchos,strict,introduced=3.0))) void operator delete[](void* __p, std::size_t __sz, std::align_val_t) noexcept;



                              inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) void* operator new (std::size_t, void* __p) noexcept {return __p;}
                              inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) void* operator new[](std::size_t, void* __p) noexcept {return __p;}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) void operator delete (void*, void*) noexcept {}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) void operator delete[](void*, void*) noexcept {}



namespace std { inline namespace __1 {

constexpr inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) bool __is_overaligned_for_new(size_t __align) noexcept {

  return __align > 16UL;



}

template <class ..._Args>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void* __libcpp_operator_new(_Args ...__args) {

  return __builtin_operator_new(__args...);



}

template <class ..._Args>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void __libcpp_operator_delete(_Args ...__args) {

  __builtin_operator_delete(__args...);



}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void *__libcpp_allocate(size_t __size, size_t __align) {

  if (__is_overaligned_for_new(__align)) {
    const align_val_t __align_val = static_cast<align_val_t>(__align);
    return __libcpp_operator_new(__size, __align_val);
  }


  (void)__align;
  return __libcpp_operator_new(__size);
}

template <class ..._Args>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void __do_deallocate_handle_size(void *__ptr, size_t __size, _Args ...__args) {

  (void)__size;
  return __libcpp_operator_delete(__ptr, __args...);



}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void __libcpp_deallocate(void* __ptr, size_t __size, size_t __align) {




    if (__is_overaligned_for_new(__align)) {
      const align_val_t __align_val = static_cast<align_val_t>(__align);
      return __do_deallocate_handle_size(__ptr, __size, __align_val);
    } else {
      return __do_deallocate_handle_size(__ptr, __size);
    }

}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) void __libcpp_deallocate_unsized(void* __ptr, size_t __align) {




    if (__is_overaligned_for_new(__align)) {
      const align_val_t __align_val = static_cast<align_val_t>(__align);
      return __libcpp_operator_delete(__ptr, __align_val);
    } else {
      return __libcpp_operator_delete(__ptr);
    }

}
# 311 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/new" 3
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void* __libcpp_aligned_alloc(std::size_t __alignment, std::size_t __size) {





  void* __result = nullptr;
  (void)::posix_memalign(&__result, __alignment, __size);

  return __result;

}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void __libcpp_aligned_free(void* __ptr) {



  ::free(__ptr);

}



template <class _Tp>
                              inline
constexpr _Tp* __launder(_Tp* __p) noexcept
{
    static_assert (!(is_function<_Tp>::value), "can't launder functions" );
    static_assert (!(is_same<void, typename remove_cv<_Tp>::type>::value), "can't launder cv-void" );

    return __builtin_launder(__p);



}



template <class _Tp>
                              inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
constexpr _Tp* launder(_Tp* __p) noexcept
{
    return std::__1::__launder(__p);
}


} }
# 24 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional_base" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 1 3
# 25 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional_base" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/typeinfo" 1 3
# 62 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/typeinfo" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cstdint" 1 3
# 148 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cstdint" 3


namespace std { inline namespace __1 {

using ::int8_t __attribute__((using_if_exists));
using ::int16_t __attribute__((using_if_exists));
using ::int32_t __attribute__((using_if_exists));
using ::int64_t __attribute__((using_if_exists));

using ::uint8_t __attribute__((using_if_exists));
using ::uint16_t __attribute__((using_if_exists));
using ::uint32_t __attribute__((using_if_exists));
using ::uint64_t __attribute__((using_if_exists));

using ::int_least8_t __attribute__((using_if_exists));
using ::int_least16_t __attribute__((using_if_exists));
using ::int_least32_t __attribute__((using_if_exists));
using ::int_least64_t __attribute__((using_if_exists));

using ::uint_least8_t __attribute__((using_if_exists));
using ::uint_least16_t __attribute__((using_if_exists));
using ::uint_least32_t __attribute__((using_if_exists));
using ::uint_least64_t __attribute__((using_if_exists));

using ::int_fast8_t __attribute__((using_if_exists));
using ::int_fast16_t __attribute__((using_if_exists));
using ::int_fast32_t __attribute__((using_if_exists));
using ::int_fast64_t __attribute__((using_if_exists));

using ::uint_fast8_t __attribute__((using_if_exists));
using ::uint_fast16_t __attribute__((using_if_exists));
using ::uint_fast32_t __attribute__((using_if_exists));
using ::uint_fast64_t __attribute__((using_if_exists));

using ::intptr_t __attribute__((using_if_exists));
using ::uintptr_t __attribute__((using_if_exists));

using ::intmax_t __attribute__((using_if_exists));
using ::uintmax_t __attribute__((using_if_exists));

} }
# 63 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/typeinfo" 2 3

# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 1 3
# 65 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/typeinfo" 2 3
# 72 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/typeinfo" 3






namespace std
{
# 190 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/typeinfo" 3
struct __type_info_implementations {
  struct __string_impl_base {
    typedef const char* __type_name_t;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) __attribute__ ((__always_inline__))
    constexpr static const char* __type_name_to_string(__type_name_t __v) noexcept {
      return __v;
    }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) __attribute__ ((__always_inline__))
    constexpr static __type_name_t __string_to_type_name(const char* __v) noexcept {
      return __v;
    }
  };

  struct __unique_impl : __string_impl_base {
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) __attribute__ ((__always_inline__))
    static size_t __hash(__type_name_t __v) noexcept {
      return reinterpret_cast<size_t>(__v);
    }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) __attribute__ ((__always_inline__))
    static bool __eq(__type_name_t __lhs, __type_name_t __rhs) noexcept {
      return __lhs == __rhs;
    }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) __attribute__ ((__always_inline__))
    static bool __lt(__type_name_t __lhs, __type_name_t __rhs) noexcept {
      return __lhs < __rhs;
    }
  };

  struct __non_unique_impl : __string_impl_base {
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) __attribute__ ((__always_inline__))
    static size_t __hash(__type_name_t __ptr) noexcept {
      size_t __hash = 5381;
      while (unsigned char __c = static_cast<unsigned char>(*__ptr++))
        __hash = (__hash * 33) ^ __c;
      return __hash;
    }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) __attribute__ ((__always_inline__))
    static bool __eq(__type_name_t __lhs, __type_name_t __rhs) noexcept {
      return __lhs == __rhs || __builtin_strcmp(__lhs, __rhs) == 0;
    }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) __attribute__ ((__always_inline__))
    static bool __lt(__type_name_t __lhs, __type_name_t __rhs) noexcept {
      return __builtin_strcmp(__lhs, __rhs) < 0;
    }
  };

  struct __non_unique_arm_rtti_bit_impl {
    typedef uintptr_t __type_name_t;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) __attribute__ ((__always_inline__))
    static const char* __type_name_to_string(__type_name_t __v) noexcept {
      return reinterpret_cast<const char*>(__v &
          ~__non_unique_rtti_bit::value);
    }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) __attribute__ ((__always_inline__))
    static __type_name_t __string_to_type_name(const char* __v) noexcept {
      return reinterpret_cast<__type_name_t>(__v);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) __attribute__ ((__always_inline__))
    static size_t __hash(__type_name_t __v) noexcept {
      if (__is_type_name_unique(__v))
        return __v;
      return __non_unique_impl::__hash(__type_name_to_string(__v));
    }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) __attribute__ ((__always_inline__))
    static bool __eq(__type_name_t __lhs, __type_name_t __rhs) noexcept {
      if (__lhs == __rhs)
        return true;
      if (__is_type_name_unique(__lhs) || __is_type_name_unique(__rhs))


        return false;
      return __builtin_strcmp(__type_name_to_string(__lhs), __type_name_to_string(__rhs)) == 0;
    }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) __attribute__ ((__always_inline__))
    static bool __lt(__type_name_t __lhs, __type_name_t __rhs) noexcept {
      if (__is_type_name_unique(__lhs) || __is_type_name_unique(__rhs))
        return __lhs < __rhs;
      return __builtin_strcmp(__type_name_to_string(__lhs), __type_name_to_string(__rhs)) < 0;
    }

   private:


    typedef integral_constant<__type_name_t,
      (1ULL << ((8 * sizeof(__type_name_t)) - 1))> __non_unique_rtti_bit;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    static bool __is_type_name_unique(__type_name_t __lhs) noexcept {
      return !(__lhs & __non_unique_rtti_bit::value);
    }
  };

  typedef





    __non_unique_arm_rtti_bit_impl



     __impl;
};
# 305 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/typeinfo" 3
class __attribute__ ((__visibility__("default"))) [[clang::ptrauth_vtable_pointer(process_independent, no_address_discrimination, no_extra_discrimination)]] type_info
{
  type_info& operator=(const type_info&);
  type_info(const type_info&);

 protected:
    typedef __type_info_implementations::__impl __impl;

    __impl::__type_name_t __type_name;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit type_info(const char* __n)
      : __type_name(__impl::__string_to_type_name(__n)) {}

public:
    __attribute__((availability(macosx,strict,introduced=10.9))) __attribute__((availability(ios,strict,introduced=7.0)))
    virtual ~type_info();

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const char* name() const noexcept
    {
      return __impl::__type_name_to_string(__type_name);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    bool before(const type_info& __arg) const noexcept
    {
      return __impl::__lt(__type_name, __arg.__type_name);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_t hash_code() const noexcept
    {
      return __impl::__hash(__type_name);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    bool operator==(const type_info& __arg) const noexcept
    {
      return __impl::__eq(__type_name, __arg.__type_name);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    bool operator!=(const type_info& __arg) const noexcept
    { return !operator==(__arg); }
};


class __attribute__ ((__visibility__("default"))) bad_cast
    : public exception
{
 public:
  bad_cast() noexcept;
  bad_cast(const bad_cast&) noexcept = default;
  virtual ~bad_cast() noexcept;
  virtual const char* what() const noexcept;
};

class __attribute__ ((__visibility__("default"))) bad_typeid
    : public exception
{
 public:
  bad_typeid() noexcept;
  virtual ~bad_typeid() noexcept;
  virtual const char* what() const noexcept;
};

}



namespace std { inline namespace __1 {
[[noreturn]] inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void __throw_bad_cast()
{

    throw bad_cast();



}
} }
# 26 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional_base" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/utility" 1 3
# 212 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/utility" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__tuple" 1 3
# 15 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__tuple" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 1 3
# 16 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__tuple" 2 3
# 19 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__tuple" 3



namespace std { inline namespace __1 {

template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) tuple_size;


template <class _Tp, class...>
using __enable_if_tuple_size_imp = _Tp;

template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) tuple_size<__enable_if_tuple_size_imp<
    const _Tp,
    typename enable_if<!is_volatile<_Tp>::value>::type,
    integral_constant<size_t, sizeof(tuple_size<_Tp>)>>>
    : public integral_constant<size_t, tuple_size<_Tp>::value> {};

template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) tuple_size<__enable_if_tuple_size_imp<
    volatile _Tp,
    typename enable_if<!is_const<_Tp>::value>::type,
    integral_constant<size_t, sizeof(tuple_size<_Tp>)>>>
    : public integral_constant<size_t, tuple_size<_Tp>::value> {};

template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) tuple_size<__enable_if_tuple_size_imp<
    const volatile _Tp,
    integral_constant<size_t, sizeof(tuple_size<_Tp>)>>>
    : public integral_constant<size_t, tuple_size<_Tp>::value> {};







template <size_t _Ip, class _Tp> struct __attribute__ ((__type_visibility__("default"))) tuple_element;

template <size_t _Ip, class _Tp>
struct __attribute__ ((__type_visibility__("default"))) tuple_element<_Ip, const _Tp>
{
    typedef typename add_const<typename tuple_element<_Ip, _Tp>::type>::type type;
};

template <size_t _Ip, class _Tp>
struct __attribute__ ((__type_visibility__("default"))) tuple_element<_Ip, volatile _Tp>
{
    typedef typename add_volatile<typename tuple_element<_Ip, _Tp>::type>::type type;
};

template <size_t _Ip, class _Tp>
struct __attribute__ ((__type_visibility__("default"))) tuple_element<_Ip, const volatile _Tp>
{
    typedef typename add_cv<typename tuple_element<_Ip, _Tp>::type>::type type;
};

template <class _Tp> struct __tuple_like : false_type {};

template <class _Tp> struct __tuple_like<const _Tp> : public __tuple_like<_Tp> {};
template <class _Tp> struct __tuple_like<volatile _Tp> : public __tuple_like<_Tp> {};
template <class _Tp> struct __tuple_like<const volatile _Tp> : public __tuple_like<_Tp> {};





template <size_t...> struct __tuple_indices {};

template <class _IdxType, _IdxType... _Values>
struct __integer_sequence {
  template <template <class _OIdxType, _OIdxType...> class _ToIndexSeq, class _ToIndexType>
  using __convert = _ToIndexSeq<_ToIndexType, _Values...>;

  template <size_t _Sp>
  using __to_tuple_indices = __tuple_indices<(_Values + _Sp)...>;
};
# 140 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__tuple" 3
template <size_t _Ep, size_t _Sp>
using __make_indices_imp =
    typename __make_integer_seq<__integer_sequence, size_t, _Ep - _Sp>::template
    __to_tuple_indices<_Sp>;







template <size_t _Ep, size_t _Sp = 0>
struct __make_tuple_indices
{
    static_assert(_Sp <= _Ep, "__make_tuple_indices input error");
    typedef __make_indices_imp<_Ep, _Sp> type;
};


template <class ..._Tp> class __attribute__ ((__type_visibility__("default"))) tuple;

template <class... _Tp> struct __tuple_like<tuple<_Tp...> > : true_type {};

template <class ..._Tp>
struct __attribute__ ((__type_visibility__("default"))) tuple_size<tuple<_Tp...> >
    : public integral_constant<size_t, sizeof...(_Tp)>
{
};

template <size_t _Ip, class ..._Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
typename tuple_element<_Ip, tuple<_Tp...> >::type&
get(tuple<_Tp...>&) noexcept;

template <size_t _Ip, class ..._Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
const typename tuple_element<_Ip, tuple<_Tp...> >::type&
get(const tuple<_Tp...>&) noexcept;

template <size_t _Ip, class ..._Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
typename tuple_element<_Ip, tuple<_Tp...> >::type&&
get(tuple<_Tp...>&&) noexcept;

template <size_t _Ip, class ..._Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
const typename tuple_element<_Ip, tuple<_Tp...> >::type&&
get(const tuple<_Tp...>&&) noexcept;





template <class _T1, class _T2> struct __tuple_like<pair<_T1, _T2> > : true_type {};

template <size_t _Ip, class _T1, class _T2>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
typename tuple_element<_Ip, pair<_T1, _T2> >::type&
get(pair<_T1, _T2>&) noexcept;

template <size_t _Ip, class _T1, class _T2>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
const typename tuple_element<_Ip, pair<_T1, _T2> >::type&
get(const pair<_T1, _T2>&) noexcept;


template <size_t _Ip, class _T1, class _T2>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
typename tuple_element<_Ip, pair<_T1, _T2> >::type&&
get(pair<_T1, _T2>&&) noexcept;

template <size_t _Ip, class _T1, class _T2>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
const typename tuple_element<_Ip, pair<_T1, _T2> >::type&&
get(const pair<_T1, _T2>&&) noexcept;




template <class _Tp, size_t _Size> struct __attribute__ ((__type_visibility__("default"))) array;

template <class _Tp, size_t _Size> struct __tuple_like<array<_Tp, _Size> > : true_type {};

template <size_t _Ip, class _Tp, size_t _Size>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
_Tp&
get(array<_Tp, _Size>&) noexcept;

template <size_t _Ip, class _Tp, size_t _Size>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
const _Tp&
get(const array<_Tp, _Size>&) noexcept;


template <size_t _Ip, class _Tp, size_t _Size>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
_Tp&&
get(array<_Tp, _Size>&&) noexcept;

template <size_t _Ip, class _Tp, size_t _Size>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
const _Tp&&
get(const array<_Tp, _Size>&&) noexcept;






template <class ..._Tp> struct __tuple_types {};
# 280 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__tuple" 3
template <size_t _Ip, class ..._Types>
struct __attribute__ ((__type_visibility__("default"))) tuple_element<_Ip, __tuple_types<_Types...>>
{
    static_assert(_Ip < sizeof...(_Types), "tuple_element index out of range");
    typedef __type_pack_element<_Ip, _Types...> type;
};


template <class ..._Tp>
struct __attribute__ ((__type_visibility__("default"))) tuple_size<__tuple_types<_Tp...> >
    : public integral_constant<size_t, sizeof...(_Tp)>
{
};

template <class... _Tp> struct __tuple_like<__tuple_types<_Tp...> > : true_type {};

template <bool _ApplyLV, bool _ApplyConst, bool _ApplyVolatile>
struct __apply_cv_mf;
template <>
struct __apply_cv_mf<false, false, false> {
  template <class _Tp> using __apply = _Tp;
};
template <>
struct __apply_cv_mf<false, true, false> {
  template <class _Tp> using __apply = const _Tp;
};
template <>
struct __apply_cv_mf<false, false, true> {
  template <class _Tp> using __apply = volatile _Tp;
};
template <>
struct __apply_cv_mf<false, true, true> {
  template <class _Tp> using __apply = const volatile _Tp;
};
template <>
struct __apply_cv_mf<true, false, false> {
  template <class _Tp> using __apply = _Tp&;
};
template <>
struct __apply_cv_mf<true, true, false> {
  template <class _Tp> using __apply = const _Tp&;
};
template <>
struct __apply_cv_mf<true, false, true> {
  template <class _Tp> using __apply = volatile _Tp&;
};
template <>
struct __apply_cv_mf<true, true, true> {
  template <class _Tp> using __apply = const volatile _Tp&;
};
template <class _Tp, class _RawTp = typename remove_reference<_Tp>::type>
using __apply_cv_t = __apply_cv_mf<
    is_lvalue_reference<_Tp>::value,
    is_const<_RawTp>::value,
    is_volatile<_RawTp>::value>;
# 343 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__tuple" 3
template <class _TupleTypes, class _TupleIndices>
struct __make_tuple_types_flat;

template <template <class...> class _Tuple, class ..._Types, size_t ..._Idx>
struct __make_tuple_types_flat<_Tuple<_Types...>, __tuple_indices<_Idx...>> {

  template <class _Tp, class _ApplyFn = __apply_cv_t<_Tp>>
  using __apply_quals = __tuple_types<
      typename _ApplyFn::template __apply<__type_pack_element<_Idx, _Types...>>...
    >;
};

template <class _Vt, size_t _Np, size_t ..._Idx>
struct __make_tuple_types_flat<array<_Vt, _Np>, __tuple_indices<_Idx...>> {
  template <size_t>
  using __value_type = _Vt;
  template <class _Tp, class _ApplyFn = __apply_cv_t<_Tp>>
  using __apply_quals = __tuple_types<
      typename _ApplyFn::template __apply<__value_type<_Idx>>...
    >;
};

template <class _Tp, size_t _Ep = tuple_size<typename remove_reference<_Tp>::type>::value,
          size_t _Sp = 0,
          bool _SameSize = (_Ep == tuple_size<typename remove_reference<_Tp>::type>::value)>
struct __make_tuple_types
{
    static_assert(_Sp <= _Ep, "__make_tuple_types input error");
    using _RawTp = typename remove_cv<typename remove_reference<_Tp>::type>::type;
    using _Maker = __make_tuple_types_flat<_RawTp, typename __make_tuple_indices<_Ep, _Sp>::type>;
    using type = typename _Maker::template __apply_quals<_Tp>;
};

template <class ..._Types, size_t _Ep>
struct __make_tuple_types<tuple<_Types...>, _Ep, 0, true> {
  typedef __tuple_types<_Types...> type;
};

template <class ..._Types, size_t _Ep>
struct __make_tuple_types<__tuple_types<_Types...>, _Ep, 0, true> {
  typedef __tuple_types<_Types...> type;
};

template <bool ..._Preds>
struct __all_dummy;

template <bool ..._Pred>
using __all = _IsSame<__all_dummy<_Pred...>, __all_dummy<((void)_Pred, true)...>>;

struct __tuple_sfinae_base {
  template <template <class, class...> class _Trait,
            class ..._LArgs, class ..._RArgs>
  static auto __do_test(__tuple_types<_LArgs...>, __tuple_types<_RArgs...>)
    -> __all<typename enable_if<_Trait<_LArgs, _RArgs>::value, bool>::type{true}...>;
  template <template <class...> class>
  static auto __do_test(...) -> false_type;

  template <class _FromArgs, class _ToArgs>
  using __constructible = decltype(__do_test<is_constructible>(_ToArgs{}, _FromArgs{}));
  template <class _FromArgs, class _ToArgs>
  using __convertible = decltype(__do_test<is_convertible>(_FromArgs{}, _ToArgs{}));
  template <class _FromArgs, class _ToArgs>
  using __assignable = decltype(__do_test<is_assignable>(_ToArgs{}, _FromArgs{}));
};



template <class _Tp, class _Up, bool = __tuple_like<typename remove_reference<_Tp>::type>::value,
                                bool = __tuple_like<_Up>::value>
struct __tuple_convertible
    : public false_type {};

template <class _Tp, class _Up>
struct __tuple_convertible<_Tp, _Up, true, true>
    : public __tuple_sfinae_base::__convertible<
      typename __make_tuple_types<_Tp>::type
    , typename __make_tuple_types<_Up>::type
    >
{};



template <class _Tp, class _Up, bool = __tuple_like<typename remove_reference<_Tp>::type>::value,
                                bool = __tuple_like<_Up>::value>
struct __tuple_constructible
    : public false_type {};

template <class _Tp, class _Up>
struct __tuple_constructible<_Tp, _Up, true, true>
    : public __tuple_sfinae_base::__constructible<
      typename __make_tuple_types<_Tp>::type
    , typename __make_tuple_types<_Up>::type
    >
{};



template <class _Tp, class _Up, bool = __tuple_like<typename remove_reference<_Tp>::type>::value,
                                bool = __tuple_like<_Up>::value>
struct __tuple_assignable
    : public false_type {};

template <class _Tp, class _Up>
struct __tuple_assignable<_Tp, _Up, true, true>
    : public __tuple_sfinae_base::__assignable<
      typename __make_tuple_types<_Tp>::type
    , typename __make_tuple_types<_Up&>::type
    >
{};


template <size_t _Ip, class ..._Tp>
struct __attribute__ ((__type_visibility__("default"))) tuple_element<_Ip, tuple<_Tp...> >
{
    typedef typename tuple_element<_Ip, __tuple_types<_Tp...> >::type type;
};


template <size_t _Ip, class ..._Tp>
using tuple_element_t = typename tuple_element <_Ip, _Tp...>::type;


template <bool _IsTuple, class _SizeTrait, size_t _Expected>
struct __tuple_like_with_size_imp : false_type {};

template <class _SizeTrait, size_t _Expected>
struct __tuple_like_with_size_imp<true, _SizeTrait, _Expected>
    : integral_constant<bool, _SizeTrait::value == _Expected> {};

template <class _Tuple, size_t _ExpectedSize,
          class _RawTuple = typename __uncvref<_Tuple>::type>
using __tuple_like_with_size = __tuple_like_with_size_imp<
                                   __tuple_like<_RawTuple>::value,
                                   tuple_size<_RawTuple>, _ExpectedSize
                              >;

struct __attribute__ ((__visibility__("default"))) __check_tuple_constructor_fail {

    static constexpr bool __enable_explicit_default() { return false; }
    static constexpr bool __enable_implicit_default() { return false; }
    template <class ...>
    static constexpr bool __enable_explicit() { return false; }
    template <class ...>
    static constexpr bool __enable_implicit() { return false; }
    template <class ...>
    static constexpr bool __enable_assign() { return false; }
};




template <bool _CanCopy, bool _CanMove>
struct __sfinae_ctor_base {};
template <>
struct __sfinae_ctor_base<false, false> {
  __sfinae_ctor_base() = default;
  __sfinae_ctor_base(__sfinae_ctor_base const&) = delete;
  __sfinae_ctor_base(__sfinae_ctor_base &&) = delete;
  __sfinae_ctor_base& operator=(__sfinae_ctor_base const&) = default;
  __sfinae_ctor_base& operator=(__sfinae_ctor_base&&) = default;
};
template <>
struct __sfinae_ctor_base<true, false> {
  __sfinae_ctor_base() = default;
  __sfinae_ctor_base(__sfinae_ctor_base const&) = default;
  __sfinae_ctor_base(__sfinae_ctor_base &&) = delete;
  __sfinae_ctor_base& operator=(__sfinae_ctor_base const&) = default;
  __sfinae_ctor_base& operator=(__sfinae_ctor_base&&) = default;
};
template <>
struct __sfinae_ctor_base<false, true> {
  __sfinae_ctor_base() = default;
  __sfinae_ctor_base(__sfinae_ctor_base const&) = delete;
  __sfinae_ctor_base(__sfinae_ctor_base &&) = default;
  __sfinae_ctor_base& operator=(__sfinae_ctor_base const&) = default;
  __sfinae_ctor_base& operator=(__sfinae_ctor_base&&) = default;
};

template <bool _CanCopy, bool _CanMove>
struct __sfinae_assign_base {};
template <>
struct __sfinae_assign_base<false, false> {
  __sfinae_assign_base() = default;
  __sfinae_assign_base(__sfinae_assign_base const&) = default;
  __sfinae_assign_base(__sfinae_assign_base &&) = default;
  __sfinae_assign_base& operator=(__sfinae_assign_base const&) = delete;
  __sfinae_assign_base& operator=(__sfinae_assign_base&&) = delete;
};
template <>
struct __sfinae_assign_base<true, false> {
  __sfinae_assign_base() = default;
  __sfinae_assign_base(__sfinae_assign_base const&) = default;
  __sfinae_assign_base(__sfinae_assign_base &&) = default;
  __sfinae_assign_base& operator=(__sfinae_assign_base const&) = default;
  __sfinae_assign_base& operator=(__sfinae_assign_base&&) = delete;
};
template <>
struct __sfinae_assign_base<false, true> {
  __sfinae_assign_base() = default;
  __sfinae_assign_base(__sfinae_assign_base const&) = default;
  __sfinae_assign_base(__sfinae_assign_base &&) = default;
  __sfinae_assign_base& operator=(__sfinae_assign_base const&) = delete;
  __sfinae_assign_base& operator=(__sfinae_assign_base&&) = default;
};


} }
# 213 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/utility" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__utility/as_const.h" 1 3
# 15 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__utility/as_const.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 1 3
# 16 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__utility/as_const.h" 2 3
# 19 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__utility/as_const.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 23 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__utility/as_const.h" 2 3

namespace std { inline namespace __1 {


template <class _Tp>
                      constexpr add_const_t<_Tp>& as_const(_Tp& __t) noexcept { return __t; }

template <class _Tp>
void as_const(const _Tp&&) = delete;


} }
# 214 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/utility" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__utility/cmp.h" 1 3
# 16 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__utility/cmp.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 1 3
# 17 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__utility/cmp.h" 2 3
# 20 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__utility/cmp.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 24 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__utility/cmp.h" 2 3

namespace std { inline namespace __1 {
# 106 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__utility/cmp.h" 3
} }
# 215 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/utility" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__utility/declval.h" 1 3
# 16 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__utility/declval.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 20 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__utility/declval.h" 2 3

namespace std { inline namespace __1 {



#pragma GCC diagnostic push
# 25 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__utility/declval.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated"
# 25 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__utility/declval.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
template <class _Tp>
_Tp&& __declval(int);
template <class _Tp>
_Tp __declval(long);
#pragma GCC diagnostic pop

template <class _Tp>
decltype(__declval<_Tp>(0)) declval() noexcept;

} }
# 216 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/utility" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__utility/exchange.h" 1 3
# 18 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__utility/exchange.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 22 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__utility/exchange.h" 2 3

namespace std { inline namespace __1 {


template<class _T1, class _T2 = _T1>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
_T1 exchange(_T1& __obj, _T2 && __new_value)
{
    _T1 __old_value = std::__1::move(__obj);
    __obj = std::__1::forward<_T2>(__new_value);
    return __old_value;
}


} }
# 217 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/utility" 2 3

# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__utility/in_place.h" 1 3
# 13 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__utility/in_place.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 1 3
# 14 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__utility/in_place.h" 2 3
# 17 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__utility/in_place.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 21 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__utility/in_place.h" 2 3

namespace std { inline namespace __1 {



struct __attribute__ ((__visibility__("default"))) in_place_t {
    explicit in_place_t() = default;
};
inline constexpr in_place_t in_place{};

template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) in_place_type_t {
    explicit in_place_type_t() = default;
};
template <class _Tp>
inline constexpr in_place_type_t<_Tp> in_place_type{};

template <size_t _Idx>
struct __attribute__ ((__type_visibility__("default"))) in_place_index_t {
    explicit in_place_index_t() = default;
};
template <size_t _Idx>
inline constexpr in_place_index_t<_Idx> in_place_index{};

template <class _Tp> struct __is_inplace_type_imp : false_type {};
template <class _Tp> struct __is_inplace_type_imp<in_place_type_t<_Tp>> : true_type {};

template <class _Tp>
using __is_inplace_type = __is_inplace_type_imp<__uncvref_t<_Tp>>;

template <class _Tp> struct __is_inplace_index_imp : false_type {};
template <size_t _Idx> struct __is_inplace_index_imp<in_place_index_t<_Idx>> : true_type {};

template <class _Tp>
using __is_inplace_index = __is_inplace_index_imp<__uncvref_t<_Tp>>;



} }
# 219 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/utility" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__utility/integer_sequence.h" 1 3
# 13 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__utility/integer_sequence.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 1 3
# 14 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__utility/integer_sequence.h" 2 3
# 17 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__utility/integer_sequence.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 21 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__utility/integer_sequence.h" 2 3

namespace std { inline namespace __1 {



template<class _Tp, _Tp... _Ip>
struct __attribute__ ((__type_visibility__("default"))) integer_sequence
{
    typedef _Tp value_type;
    static_assert( is_integral<_Tp>::value,
                  "std::integer_sequence can only be instantiated with an integral type" );
    static
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    constexpr
    size_t
    size() noexcept { return sizeof...(_Ip); }
};

template<size_t... _Ip>
    using index_sequence = integer_sequence<size_t, _Ip...>;



template <class _Tp, _Tp _Ep>
using __make_integer_sequence = __make_integer_seq<integer_sequence, _Tp, _Ep>;
# 68 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__utility/integer_sequence.h" 3
template<class _Tp, _Tp _Np>
    using make_integer_sequence = __make_integer_sequence<_Tp, _Np>;

template<size_t _Np>
    using make_index_sequence = make_integer_sequence<size_t, _Np>;

template<class... _Tp>
    using index_sequence_for = make_index_sequence<sizeof...(_Tp)>;



} }
# 220 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/utility" 2 3

# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__utility/pair.h" 1 3
# 13 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__utility/pair.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/unwrap_ref.h" 1 3
# 16 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/unwrap_ref.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 20 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/unwrap_ref.h" 2 3

namespace std { inline namespace __1 {

template <class _Tp>
struct __unwrap_reference { typedef _Tp type; };

template <class _Tp>
class reference_wrapper;

template <class _Tp>
struct __unwrap_reference<reference_wrapper<_Tp> > { typedef _Tp& type; };

template <class _Tp>
struct decay;
# 49 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/unwrap_ref.h" 3
template <class _Tp>
struct __unwrap_ref_decay



    : __unwrap_reference<typename decay<_Tp>::type>

{ };

} }
# 14 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__utility/pair.h" 2 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__utility/piecewise_construct.h" 1 3
# 16 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__utility/piecewise_construct.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 20 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__utility/piecewise_construct.h" 2 3

namespace std { inline namespace __1 {

struct __attribute__ ((__type_visibility__("default"))) piecewise_construct_t { explicit piecewise_construct_t() = default; };



                         constexpr piecewise_construct_t piecewise_construct = piecewise_construct_t();


} }
# 18 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__utility/pair.h" 2 3

# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 1 3
# 20 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__utility/pair.h" 2 3
# 23 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__utility/pair.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 27 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__utility/pair.h" 2 3

namespace std { inline namespace __1 {
# 41 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__utility/pair.h" 3
template <class _T1, class _T2>
struct __attribute__ ((__type_visibility__("default"))) pair



{
    typedef _T1 first_type;
    typedef _T2 second_type;

    _T1 first;
    _T2 second;


    pair(pair const&) = default;
    pair(pair&&) = default;
# 78 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__utility/pair.h" 3
    template <bool _Val>
    using _EnableB = typename enable_if<_Val, bool>::type;

    struct _CheckArgs {
      template <int&...>
      static constexpr bool __enable_explicit_default() {
          return is_default_constructible<_T1>::value
              && is_default_constructible<_T2>::value
              && !__enable_implicit_default<>();
      }

      template <int&...>
      static constexpr bool __enable_implicit_default() {
          return __is_implicitly_default_constructible<_T1>::value
              && __is_implicitly_default_constructible<_T2>::value;
      }

      template <class _U1, class _U2>
      static constexpr bool __enable_explicit() {
          return is_constructible<first_type, _U1>::value
              && is_constructible<second_type, _U2>::value
              && (!is_convertible<_U1, first_type>::value
                  || !is_convertible<_U2, second_type>::value);
      }

      template <class _U1, class _U2>
      static constexpr bool __enable_implicit() {
          return is_constructible<first_type, _U1>::value
              && is_constructible<second_type, _U2>::value
              && is_convertible<_U1, first_type>::value
              && is_convertible<_U2, second_type>::value;
      }
    };

    template <bool _MaybeEnable>
    using _CheckArgsDep = typename conditional<
      _MaybeEnable, _CheckArgs, __check_tuple_constructor_fail>::type;

    struct _CheckTupleLikeConstructor {
        template <class _Tuple>
        static constexpr bool __enable_implicit() {
            return __tuple_convertible<_Tuple, pair>::value;
        }

        template <class _Tuple>
        static constexpr bool __enable_explicit() {
            return __tuple_constructible<_Tuple, pair>::value
               && !__tuple_convertible<_Tuple, pair>::value;
        }

        template <class _Tuple>
        static constexpr bool __enable_assign() {
            return __tuple_assignable<_Tuple, pair>::value;
        }
    };

    template <class _Tuple>
    using _CheckTLC = typename conditional<
        __tuple_like_with_size<_Tuple, 2>::value
            && !is_same<typename decay<_Tuple>::type, pair>::value,
        _CheckTupleLikeConstructor,
        __check_tuple_constructor_fail
    >::type;

    template<bool _Dummy = true, _EnableB<
            _CheckArgsDep<_Dummy>::__enable_explicit_default()
    > = false>
    explicit __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
    pair() noexcept(is_nothrow_default_constructible<first_type>::value && is_nothrow_default_constructible<second_type>::value)

        : first(), second() {}

    template<bool _Dummy = true, _EnableB<
            _CheckArgsDep<_Dummy>::__enable_implicit_default()
    > = false>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
    pair() noexcept(is_nothrow_default_constructible<first_type>::value && is_nothrow_default_constructible<second_type>::value)

        : first(), second() {}

    template <bool _Dummy = true, _EnableB<
             _CheckArgsDep<_Dummy>::template __enable_explicit<_T1 const&, _T2 const&>()
    > = false>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
    explicit pair(_T1 const& __t1, _T2 const& __t2)
        noexcept(is_nothrow_copy_constructible<first_type>::value && is_nothrow_copy_constructible<second_type>::value)

        : first(__t1), second(__t2) {}

    template<bool _Dummy = true, _EnableB<
            _CheckArgsDep<_Dummy>::template __enable_implicit<_T1 const&, _T2 const&>()
    > = false>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
    pair(_T1 const& __t1, _T2 const& __t2)
        noexcept(is_nothrow_copy_constructible<first_type>::value && is_nothrow_copy_constructible<second_type>::value)

        : first(__t1), second(__t2) {}

    template<class _U1, class _U2, _EnableB<
             _CheckArgs::template __enable_explicit<_U1, _U2>()
    > = false>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
    explicit pair(_U1&& __u1, _U2&& __u2)
        noexcept((is_nothrow_constructible<first_type, _U1>::value && is_nothrow_constructible<second_type, _U2>::value))

        : first(std::__1::forward<_U1>(__u1)), second(std::__1::forward<_U2>(__u2)) {}

    template<class _U1, class _U2, _EnableB<
            _CheckArgs::template __enable_implicit<_U1, _U2>()
    > = false>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
    pair(_U1&& __u1, _U2&& __u2)
        noexcept((is_nothrow_constructible<first_type, _U1>::value && is_nothrow_constructible<second_type, _U2>::value))

        : first(std::__1::forward<_U1>(__u1)), second(std::__1::forward<_U2>(__u2)) {}

    template<class _U1, class _U2, _EnableB<
            _CheckArgs::template __enable_explicit<_U1 const&, _U2 const&>()
    > = false>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
    explicit pair(pair<_U1, _U2> const& __p)
        noexcept((is_nothrow_constructible<first_type, _U1 const&>::value && is_nothrow_constructible<second_type, _U2 const&>::value))

        : first(__p.first), second(__p.second) {}

    template<class _U1, class _U2, _EnableB<
            _CheckArgs::template __enable_implicit<_U1 const&, _U2 const&>()
    > = false>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
    pair(pair<_U1, _U2> const& __p)
        noexcept((is_nothrow_constructible<first_type, _U1 const&>::value && is_nothrow_constructible<second_type, _U2 const&>::value))

        : first(__p.first), second(__p.second) {}

    template<class _U1, class _U2, _EnableB<
            _CheckArgs::template __enable_explicit<_U1, _U2>()
    > = false>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
    explicit pair(pair<_U1, _U2>&&__p)
        noexcept((is_nothrow_constructible<first_type, _U1&&>::value && is_nothrow_constructible<second_type, _U2&&>::value))

        : first(std::__1::forward<_U1>(__p.first)), second(std::__1::forward<_U2>(__p.second)) {}

    template<class _U1, class _U2, _EnableB<
            _CheckArgs::template __enable_implicit<_U1, _U2>()
    > = false>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
    pair(pair<_U1, _U2>&& __p)
        noexcept((is_nothrow_constructible<first_type, _U1&&>::value && is_nothrow_constructible<second_type, _U2&&>::value))

        : first(std::__1::forward<_U1>(__p.first)), second(std::__1::forward<_U2>(__p.second)) {}

    template<class _Tuple, _EnableB<
            _CheckTLC<_Tuple>::template __enable_explicit<_Tuple>()
    > = false>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
    explicit pair(_Tuple&& __p)
        : first(std::__1::get<0>(std::__1::forward<_Tuple>(__p))),
          second(std::__1::get<1>(std::__1::forward<_Tuple>(__p))) {}

    template<class _Tuple, _EnableB<
            _CheckTLC<_Tuple>::template __enable_implicit<_Tuple>()
    > = false>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
    pair(_Tuple&& __p)
        : first(std::__1::get<0>(std::__1::forward<_Tuple>(__p))),
          second(std::__1::get<1>(std::__1::forward<_Tuple>(__p))) {}

    template <class... _Args1, class... _Args2>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    pair(piecewise_construct_t __pc,
         tuple<_Args1...> __first_args, tuple<_Args2...> __second_args)
        noexcept((is_nothrow_constructible<first_type, _Args1...>::value && is_nothrow_constructible<second_type, _Args2...>::value))

        : pair(__pc, __first_args, __second_args,
                typename __make_tuple_indices<sizeof...(_Args1)>::type(),
                typename __make_tuple_indices<sizeof...(_Args2) >::type()) {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    pair& operator=(typename conditional<
                        is_copy_assignable<first_type>::value &&
                        is_copy_assignable<second_type>::value,
                    pair, __nat>::type const& __p)
        noexcept(is_nothrow_copy_assignable<first_type>::value && is_nothrow_copy_assignable<second_type>::value)

    {
        first = __p.first;
        second = __p.second;
        return *this;
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    pair& operator=(typename conditional<
                        is_move_assignable<first_type>::value &&
                        is_move_assignable<second_type>::value,
                    pair, __nat>::type&& __p)
        noexcept(is_nothrow_move_assignable<first_type>::value && is_nothrow_move_assignable<second_type>::value)

    {
        first = std::__1::forward<first_type>(__p.first);
        second = std::__1::forward<second_type>(__p.second);
        return *this;
    }

    template <class _Tuple, _EnableB<
            _CheckTLC<_Tuple>::template __enable_assign<_Tuple>()
     > = false>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    pair& operator=(_Tuple&& __p) {
        first = std::__1::get<0>(std::__1::forward<_Tuple>(__p));
        second = std::__1::get<1>(std::__1::forward<_Tuple>(__p));
        return *this;
    }


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void
    swap(pair& __p) noexcept(__is_nothrow_swappable<first_type>::value && __is_nothrow_swappable<second_type>::value)

    {
        using std::__1::swap;
        swap(first, __p.first);
        swap(second, __p.second);
    }
private:


    template <class... _Args1, class... _Args2, size_t... _I1, size_t... _I2>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    pair(piecewise_construct_t,
         tuple<_Args1...>& __first_args, tuple<_Args2...>& __second_args,
         __tuple_indices<_I1...>, __tuple_indices<_I2...>);

};


template<class _T1, class _T2>
pair(_T1, _T2) -> pair<_T1, _T2>;


template <class _T1, class _T2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
bool
operator==(const pair<_T1,_T2>& __x, const pair<_T1,_T2>& __y)
{
    return __x.first == __y.first && __x.second == __y.second;
}

template <class _T1, class _T2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
bool
operator!=(const pair<_T1,_T2>& __x, const pair<_T1,_T2>& __y)
{
    return !(__x == __y);
}

template <class _T1, class _T2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
bool
operator< (const pair<_T1,_T2>& __x, const pair<_T1,_T2>& __y)
{
    return __x.first < __y.first || (!(__y.first < __x.first) && __x.second < __y.second);
}

template <class _T1, class _T2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
bool
operator> (const pair<_T1,_T2>& __x, const pair<_T1,_T2>& __y)
{
    return __y < __x;
}

template <class _T1, class _T2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
bool
operator>=(const pair<_T1,_T2>& __x, const pair<_T1,_T2>& __y)
{
    return !(__x < __y);
}

template <class _T1, class _T2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
bool
operator<=(const pair<_T1,_T2>& __x, const pair<_T1,_T2>& __y)
{
    return !(__y < __x);
}

template <class _T1, class _T2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename enable_if
<
    __is_swappable<_T1>::value &&
    __is_swappable<_T2>::value,
    void
>::type
swap(pair<_T1, _T2>& __x, pair<_T1, _T2>& __y)
                     noexcept((__is_nothrow_swappable<_T1>::value && __is_nothrow_swappable<_T2>::value))

{
    __x.swap(__y);
}



template <class _T1, class _T2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
pair<typename __unwrap_ref_decay<_T1>::type, typename __unwrap_ref_decay<_T2>::type>
make_pair(_T1&& __t1, _T2&& __t2)
{
    return pair<typename __unwrap_ref_decay<_T1>::type, typename __unwrap_ref_decay<_T2>::type>
               (std::__1::forward<_T1>(__t1), std::__1::forward<_T2>(__t2));
}
# 404 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__utility/pair.h" 3
template <class _T1, class _T2>
  struct __attribute__ ((__type_visibility__("default"))) tuple_size<pair<_T1, _T2> >
    : public integral_constant<size_t, 2> {};

template <size_t _Ip, class _T1, class _T2>
struct __attribute__ ((__type_visibility__("default"))) tuple_element<_Ip, pair<_T1, _T2> >
{
    static_assert(_Ip < 2, "Index out of bounds in std::tuple_element<std::pair<T1, T2>>");
};

template <class _T1, class _T2>
struct __attribute__ ((__type_visibility__("default"))) tuple_element<0, pair<_T1, _T2> >
{
    typedef _T1 type;
};

template <class _T1, class _T2>
struct __attribute__ ((__type_visibility__("default"))) tuple_element<1, pair<_T1, _T2> >
{
    typedef _T2 type;
};

template <size_t _Ip> struct __get_pair;

template <>
struct __get_pair<0>
{
    template <class _T1, class _T2>
    static
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
    _T1&
    get(pair<_T1, _T2>& __p) noexcept {return __p.first;}

    template <class _T1, class _T2>
    static
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
    const _T1&
    get(const pair<_T1, _T2>& __p) noexcept {return __p.first;}


    template <class _T1, class _T2>
    static
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
    _T1&&
    get(pair<_T1, _T2>&& __p) noexcept {return std::__1::forward<_T1>(__p.first);}

    template <class _T1, class _T2>
    static
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
    const _T1&&
    get(const pair<_T1, _T2>&& __p) noexcept {return std::__1::forward<const _T1>(__p.first);}

};

template <>
struct __get_pair<1>
{
    template <class _T1, class _T2>
    static
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
    _T2&
    get(pair<_T1, _T2>& __p) noexcept {return __p.second;}

    template <class _T1, class _T2>
    static
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
    const _T2&
    get(const pair<_T1, _T2>& __p) noexcept {return __p.second;}


    template <class _T1, class _T2>
    static
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
    _T2&&
    get(pair<_T1, _T2>&& __p) noexcept {return std::__1::forward<_T2>(__p.second);}

    template <class _T1, class _T2>
    static
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
    const _T2&&
    get(const pair<_T1, _T2>&& __p) noexcept {return std::__1::forward<const _T2>(__p.second);}

};

template <size_t _Ip, class _T1, class _T2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
typename tuple_element<_Ip, pair<_T1, _T2> >::type&
get(pair<_T1, _T2>& __p) noexcept
{
    return __get_pair<_Ip>::get(__p);
}

template <size_t _Ip, class _T1, class _T2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
const typename tuple_element<_Ip, pair<_T1, _T2> >::type&
get(const pair<_T1, _T2>& __p) noexcept
{
    return __get_pair<_Ip>::get(__p);
}


template <size_t _Ip, class _T1, class _T2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
typename tuple_element<_Ip, pair<_T1, _T2> >::type&&
get(pair<_T1, _T2>&& __p) noexcept
{
    return __get_pair<_Ip>::get(std::__1::move(__p));
}

template <size_t _Ip, class _T1, class _T2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
const typename tuple_element<_Ip, pair<_T1, _T2> >::type&&
get(const pair<_T1, _T2>&& __p) noexcept
{
    return __get_pair<_Ip>::get(std::__1::move(__p));
}



template <class _T1, class _T2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
constexpr _T1 & get(pair<_T1, _T2>& __p) noexcept
{
    return __get_pair<0>::get(__p);
}

template <class _T1, class _T2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
constexpr _T1 const & get(pair<_T1, _T2> const& __p) noexcept
{
    return __get_pair<0>::get(__p);
}

template <class _T1, class _T2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
constexpr _T1 && get(pair<_T1, _T2>&& __p) noexcept
{
    return __get_pair<0>::get(std::__1::move(__p));
}

template <class _T1, class _T2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
constexpr _T1 const && get(pair<_T1, _T2> const&& __p) noexcept
{
    return __get_pair<0>::get(std::__1::move(__p));
}

template <class _T1, class _T2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
constexpr _T1 & get(pair<_T2, _T1>& __p) noexcept
{
    return __get_pair<1>::get(__p);
}

template <class _T1, class _T2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
constexpr _T1 const & get(pair<_T2, _T1> const& __p) noexcept
{
    return __get_pair<1>::get(__p);
}

template <class _T1, class _T2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
constexpr _T1 && get(pair<_T2, _T1>&& __p) noexcept
{
    return __get_pair<1>::get(std::__1::move(__p));
}

template <class _T1, class _T2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
constexpr _T1 const && get(pair<_T2, _T1> const&& __p) noexcept
{
    return __get_pair<1>::get(std::__1::move(__p));
}



} }
# 222 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/utility" 2 3

# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__utility/rel_ops.h" 1 3
# 15 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__utility/rel_ops.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 1 3
# 16 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__utility/rel_ops.h" 2 3
# 19 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__utility/rel_ops.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 23 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__utility/rel_ops.h" 2 3

namespace std { inline namespace __1 {

namespace rel_ops
{

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator!=(const _Tp& __x, const _Tp& __y)
{
    return !(__x == __y);
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator> (const _Tp& __x, const _Tp& __y)
{
    return __y < __x;
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator<=(const _Tp& __x, const _Tp& __y)
{
    return !(__y < __x);
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator>=(const _Tp& __x, const _Tp& __y)
{
    return !(__x < __y);
}

}

} }
# 224 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/utility" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__utility/swap.h" 1 3
# 15 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__utility/swap.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 1 3
# 16 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__utility/swap.h" 2 3
# 20 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__utility/swap.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 24 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__utility/swap.h" 2 3

namespace std { inline namespace __1 {


template <class _Tp>
using __swap_result_t = typename enable_if<is_move_constructible<_Tp>::value && is_move_assignable<_Tp>::value>::type;





template <class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) __swap_result_t<_Tp> swap(_Tp& __x, _Tp& __y)
    noexcept(is_nothrow_move_constructible<_Tp>::value&& is_nothrow_move_assignable<_Tp>::value) {
  _Tp __t(std::__1::move(__x));
  __x = std::__1::move(__y);
  __y = std::__1::move(__t);
}

template <class _Tp, size_t _Np>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) typename enable_if<__is_swappable<_Tp>::value>::type
swap(_Tp (&__a)[_Np], _Tp (&__b)[_Np]) noexcept(__is_nothrow_swappable<_Tp>::value) {
  for (size_t __i = 0; __i != _Np; ++__i) {
    swap(__a[__i], __b[__i]);
  }
}

} }
# 225 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/utility" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__utility/to_underlying.h" 1 3
# 14 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__utility/to_underlying.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 1 3
# 15 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__utility/to_underlying.h" 2 3
# 18 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__utility/to_underlying.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 22 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__utility/to_underlying.h" 2 3

namespace std { inline namespace __1 {


template <class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr typename underlying_type<_Tp>::type
__to_underlying(_Tp __val) noexcept {
  return static_cast<typename underlying_type<_Tp>::type>(__val);
}
# 41 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__utility/to_underlying.h" 3
} }
# 226 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/utility" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/compare" 1 3
# 124 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/compare" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 1 3
# 125 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/compare" 2 3
# 128 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/compare" 3


namespace std { inline namespace __1 {
# 487 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/compare" 3
} }
# 227 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/utility" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/initializer_list" 1 3
# 50 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/initializer_list" 3


namespace std
{



template<class _Ep>
class __attribute__ ((__type_visibility__("default"))) initializer_list
{
    const _Ep* __begin_;
    size_t __size_;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    constexpr
    initializer_list(const _Ep* __b, size_t __s) noexcept
        : __begin_(__b),
          __size_(__s)
        {}
public:
    typedef _Ep value_type;
    typedef const _Ep& reference;
    typedef const _Ep& const_reference;
    typedef size_t size_type;

    typedef const _Ep* iterator;
    typedef const _Ep* const_iterator;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    constexpr
    initializer_list() noexcept : __begin_(nullptr), __size_(0) {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    constexpr
    size_t size() const noexcept {return __size_;}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    constexpr
    const _Ep* begin() const noexcept {return __begin_;}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    constexpr
    const _Ep* end() const noexcept {return __begin_ + __size_;}
};

template<class _Ep>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
constexpr
const _Ep*
begin(initializer_list<_Ep> __il) noexcept
{
    return __il.begin();
}

template<class _Ep>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
constexpr
const _Ep*
end(initializer_list<_Ep> __il) noexcept
{
    return __il.end();
}



}
# 228 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/utility" 2 3
# 27 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional_base" 2 3
# 30 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional_base" 3
# 135 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/concepts" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 1 3
# 136 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/concepts" 2 3
# 141 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/concepts" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 145 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/concepts" 2 3

namespace std { inline namespace __1 {
# 451 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/concepts" 3
} }
# 15 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/incrementable_traits.h" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 1 3
# 16 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/incrementable_traits.h" 2 3
# 19 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/incrementable_traits.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 23 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/incrementable_traits.h" 2 3

namespace std { inline namespace __1 {
# 73 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/incrementable_traits.h" 3
} }
# 15 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/iterator_traits.h" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/readable_traits.h" 1 3
# 15 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/readable_traits.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 1 3
# 16 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/readable_traits.h" 2 3
# 19 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/readable_traits.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 23 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/readable_traits.h" 2 3

namespace std { inline namespace __1 {
# 87 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/readable_traits.h" 3
} }
# 16 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/iterator_traits.h" 2 3

# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 1 3
# 18 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/iterator_traits.h" 2 3
# 21 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/iterator_traits.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 25 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/iterator_traits.h" 2 3

namespace std { inline namespace __1 {
# 49 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/iterator_traits.h" 3
template <class _Iter>
struct __attribute__ ((__type_visibility__("default"))) iterator_traits;

struct __attribute__ ((__type_visibility__("default"))) input_iterator_tag {};
struct __attribute__ ((__type_visibility__("default"))) output_iterator_tag {};
struct __attribute__ ((__type_visibility__("default"))) forward_iterator_tag : public input_iterator_tag {};
struct __attribute__ ((__type_visibility__("default"))) bidirectional_iterator_tag : public forward_iterator_tag {};
struct __attribute__ ((__type_visibility__("default"))) random_access_iterator_tag : public bidirectional_iterator_tag {};




template <class _Iter>
struct __iter_traits_cache {
  using type = _If<
    __is_primary_template<iterator_traits<_Iter> >::value,
    _Iter,
    iterator_traits<_Iter>
  >;
};
template <class _Iter>
using _ITER_TRAITS = typename __iter_traits_cache<_Iter>::type;

struct __iter_concept_concept_test {
  template <class _Iter>
  using _Apply = typename _ITER_TRAITS<_Iter>::iterator_concept;
};
struct __iter_concept_category_test {
  template <class _Iter>
  using _Apply = typename _ITER_TRAITS<_Iter>::iterator_category;
};
struct __iter_concept_random_fallback {
  template <class _Iter>
  using _Apply = _EnableIf<
                          __is_primary_template<iterator_traits<_Iter> >::value,
                          random_access_iterator_tag
                        >;
};

template <class _Iter, class _Tester> struct __test_iter_concept
    : _IsValidExpansion<_Tester::template _Apply, _Iter>,
      _Tester
{
};

template <class _Iter>
struct __iter_concept_cache {
  using type = _Or<
    __test_iter_concept<_Iter, __iter_concept_concept_test>,
    __test_iter_concept<_Iter, __iter_concept_category_test>,
    __test_iter_concept<_Iter, __iter_concept_random_fallback>
  >;
};

template <class _Iter>
using _ITER_CONCEPT = typename __iter_concept_cache<_Iter>::type::template _Apply<_Iter>;


template <class _Tp>
struct __has_iterator_typedefs
{
private:
    struct __two {char __lx; char __lxx;};
    template <class _Up> static __two __test(...);
    template <class _Up> static char __test(typename __void_t<typename _Up::iterator_category>::type* = 0,
                                            typename __void_t<typename _Up::difference_type>::type* = 0,
                                            typename __void_t<typename _Up::value_type>::type* = 0,
                                            typename __void_t<typename _Up::reference>::type* = 0,
                                            typename __void_t<typename _Up::pointer>::type* = 0);
public:
    static const bool value = sizeof(__test<_Tp>(0,0,0,0,0)) == 1;
};


template <class _Tp>
struct __has_iterator_category
{
private:
    struct __two {char __lx; char __lxx;};
    template <class _Up> static __two __test(...);
    template <class _Up> static char __test(typename _Up::iterator_category* = nullptr);
public:
    static const bool value = sizeof(__test<_Tp>(nullptr)) == 1;
};

template <class _Tp>
struct __has_iterator_concept
{
private:
    struct __two {char __lx; char __lxx;};
    template <class _Up> static __two __test(...);
    template <class _Up> static char __test(typename _Up::iterator_concept* = nullptr);
public:
    static const bool value = sizeof(__test<_Tp>(nullptr)) == 1;
};
# 370 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/iterator_traits.h" 3
template <class _Iter, bool> struct __iterator_traits {};

template <class _Iter, bool> struct __iterator_traits_impl {};

template <class _Iter>
struct __iterator_traits_impl<_Iter, true>
{
    typedef typename _Iter::difference_type difference_type;
    typedef typename _Iter::value_type value_type;
    typedef typename _Iter::pointer pointer;
    typedef typename _Iter::reference reference;
    typedef typename _Iter::iterator_category iterator_category;
};

template <class _Iter>
struct __iterator_traits<_Iter, true>
    : __iterator_traits_impl
      <
        _Iter,
        is_convertible<typename _Iter::iterator_category, input_iterator_tag>::value ||
        is_convertible<typename _Iter::iterator_category, output_iterator_tag>::value
      >
{};






template <class _Iter>
struct __attribute__ ((__type_visibility__("default"))) iterator_traits
    : __iterator_traits<_Iter, __has_iterator_typedefs<_Iter>::value> {

  using __primary_template = iterator_traits;
};


template<class _Tp>



struct __attribute__ ((__type_visibility__("default"))) iterator_traits<_Tp*>
{
    typedef ptrdiff_t difference_type;
    typedef typename remove_cv<_Tp>::type value_type;
    typedef _Tp* pointer;
    typedef _Tp& reference;
    typedef random_access_iterator_tag iterator_category;



};

template <class _Tp, class _Up, bool = __has_iterator_category<iterator_traits<_Tp> >::value>
struct __has_iterator_category_convertible_to
    : is_convertible<typename iterator_traits<_Tp>::iterator_category, _Up>
{};

template <class _Tp, class _Up>
struct __has_iterator_category_convertible_to<_Tp, _Up, false> : false_type {};

template <class _Tp, class _Up, bool = __has_iterator_concept<_Tp>::value>
struct __has_iterator_concept_convertible_to
    : is_convertible<typename _Tp::iterator_concept, _Up>
{};

template <class _Tp, class _Up>
struct __has_iterator_concept_convertible_to<_Tp, _Up, false> : false_type {};

template <class _Tp>
struct __is_cpp17_input_iterator : public __has_iterator_category_convertible_to<_Tp, input_iterator_tag> {};

template <class _Tp>
struct __is_cpp17_forward_iterator : public __has_iterator_category_convertible_to<_Tp, forward_iterator_tag> {};

template <class _Tp>
struct __is_cpp17_bidirectional_iterator : public __has_iterator_category_convertible_to<_Tp, bidirectional_iterator_tag> {};

template <class _Tp>
struct __is_cpp17_random_access_iterator : public __has_iterator_category_convertible_to<_Tp, random_access_iterator_tag> {};
# 465 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/iterator_traits.h" 3
template <class _Tp>
struct __is_cpp17_contiguous_iterator : false_type {};



template <class _Up>
struct __is_cpp17_contiguous_iterator<_Up*> : true_type {};


template <class _Tp>
struct __is_exactly_cpp17_input_iterator
    : public integral_constant<bool,
         __has_iterator_category_convertible_to<_Tp, input_iterator_tag>::value &&
        !__has_iterator_category_convertible_to<_Tp, forward_iterator_tag>::value> {};


template<class _InputIterator>
using __iter_value_type = typename iterator_traits<_InputIterator>::value_type;

template<class _InputIterator>
using __iter_key_type = remove_const_t<typename iterator_traits<_InputIterator>::value_type::first_type>;

template<class _InputIterator>
using __iter_mapped_type = typename iterator_traits<_InputIterator>::value_type::second_type;

template<class _InputIterator>
using __iter_to_alloc_type = pair<
    add_const_t<typename iterator_traits<_InputIterator>::value_type::first_type>,
    typename iterator_traits<_InputIterator>::value_type::second_type>;


} }
# 16 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/search.h" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 1 3
# 17 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/search.h" 2 3
# 21 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/search.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 25 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/search.h" 2 3

namespace std { inline namespace __1 {

template <class _BinaryPredicate, class _ForwardIterator1, class _ForwardIterator2>
pair<_ForwardIterator1, _ForwardIterator1>
    constexpr __search(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
                                           _ForwardIterator2 __first2, _ForwardIterator2 __last2,
                                           _BinaryPredicate __pred, forward_iterator_tag, forward_iterator_tag) {
  if (__first2 == __last2)
    return std::__1::make_pair(__first1, __first1);
  while (true) {

    while (true) {
      if (__first1 == __last1)
        return std::__1::make_pair(__last1, __last1);
      if (__pred(*__first1, *__first2))
        break;
      ++__first1;
    }

    _ForwardIterator1 __m1 = __first1;
    _ForwardIterator2 __m2 = __first2;
    while (true) {
      if (++__m2 == __last2)
        return std::__1::make_pair(__first1, __m1);
      if (++__m1 == __last1)
        return std::__1::make_pair(__last1, __last1);
      if (!__pred(*__m1, *__m2))
      {
        ++__first1;
        break;
      }
    }
  }
}

template <class _BinaryPredicate, class _RandomAccessIterator1, class _RandomAccessIterator2>
constexpr pair<_RandomAccessIterator1, _RandomAccessIterator1>
__search(_RandomAccessIterator1 __first1, _RandomAccessIterator1 __last1, _RandomAccessIterator2 __first2,
         _RandomAccessIterator2 __last2, _BinaryPredicate __pred, random_access_iterator_tag,
         random_access_iterator_tag) {
  typedef typename iterator_traits<_RandomAccessIterator1>::difference_type _D1;
  typedef typename iterator_traits<_RandomAccessIterator2>::difference_type _D2;

  const _D2 __len2 = __last2 - __first2;
  if (__len2 == 0)
    return std::__1::make_pair(__first1, __first1);
  const _D1 __len1 = __last1 - __first1;
  if (__len1 < __len2)
    return std::__1::make_pair(__last1, __last1);
  const _RandomAccessIterator1 __s = __last1 - (__len2 - 1);

  while (true) {
    while (true) {
      if (__first1 == __s)
        return std::__1::make_pair(__last1, __last1);
      if (__pred(*__first1, *__first2))
        break;
      ++__first1;
    }

    _RandomAccessIterator1 __m1 = __first1;
    _RandomAccessIterator2 __m2 = __first2;
    while (true) {
      if (++__m2 == __last2)
        return std::__1::make_pair(__first1, __first1 + __len2);
      ++__m1;
      if (!__pred(*__m1, *__m2)) {
        ++__first1;
        break;
      }
    }
  }
}

template <class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate>
                      inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) _ForwardIterator1
search(_ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2, _ForwardIterator2 __last2,
       _BinaryPredicate __pred) {
  return std::__1::__search<typename add_lvalue_reference<_BinaryPredicate>::type>(
             __first1, __last1, __first2, __last2, __pred,
             typename iterator_traits<_ForwardIterator1>::iterator_category(),
             typename iterator_traits<_ForwardIterator2>::iterator_category()).first;
}

template <class _ForwardIterator1, class _ForwardIterator2>
                      inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) _ForwardIterator1
search(_ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2, _ForwardIterator2 __last2) {
  typedef typename iterator_traits<_ForwardIterator1>::value_type __v1;
  typedef typename iterator_traits<_ForwardIterator2>::value_type __v2;
  return std::__1::search(__first1, __last1, __first2, __last2, __equal_to<__v1, __v2>());
}


template <class _ForwardIterator, class _Searcher>
                      __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) _ForwardIterator
search(_ForwardIterator __f, _ForwardIterator __l, const _Searcher& __s) {
  return __s(__f, __l).first;
}



} }
# 491 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/functional" 2 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/binary_negate.h" 1 3
# 18 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/binary_negate.h" 3


namespace std { inline namespace __1 {



template <class _Predicate>
class __attribute__ ((__type_visibility__("default"))) __attribute__ ((deprecated)) binary_negate
    : public binary_function<typename _Predicate::first_argument_type,
                             typename _Predicate::second_argument_type,
                             bool>
{
    _Predicate __pred_;
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) explicit constexpr
    binary_negate(const _Predicate& __pred) : __pred_(__pred) {}

    constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    bool operator()(const typename _Predicate::first_argument_type& __x,
                    const typename _Predicate::second_argument_type& __y) const
        {return !__pred_(__x, __y);}
};

template <class _Predicate>
__attribute__ ((deprecated)) inline constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
binary_negate<_Predicate>
not2(const _Predicate& __pred) {return binary_negate<_Predicate>(__pred);}



} }
# 495 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/functional" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/bind_front.h" 1 3
# 14 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/bind_front.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/perfect_forward.h" 1 3
# 14 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/perfect_forward.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/tuple" 1 3
# 162 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/tuple" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 1 3
# 163 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/tuple" 2 3
# 168 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/tuple" 3


namespace std { inline namespace __1 {






template <size_t _Ip, class _Hp,
          bool=is_empty<_Hp>::value && !__libcpp_is_final<_Hp>::value
         >
class __tuple_leaf;

template <size_t _Ip, class _Hp, bool _Ep>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
void swap(__tuple_leaf<_Ip, _Hp, _Ep>& __x, __tuple_leaf<_Ip, _Hp, _Ep>& __y)
    noexcept(__is_nothrow_swappable<_Hp>::value)
{
    swap(__x.get(), __y.get());
}

template <size_t _Ip, class _Hp, bool>
class __tuple_leaf
{
    _Hp __value_;

    template <class _Tp>
    static constexpr bool __can_bind_reference() {

      return !__reference_binds_to_temporary(_Hp, _Tp);



    }

    constexpr
    __tuple_leaf& operator=(const __tuple_leaf&);
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr __tuple_leaf()
             noexcept(is_nothrow_default_constructible<_Hp>::value) : __value_()
       {static_assert(!is_reference<_Hp>::value,
              "Attempted to default construct a reference element in a tuple");}

    template <class _Alloc>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
        __tuple_leaf(integral_constant<int, 0>, const _Alloc&)
            : __value_()
        {static_assert(!is_reference<_Hp>::value,
              "Attempted to default construct a reference element in a tuple");}

    template <class _Alloc>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
        __tuple_leaf(integral_constant<int, 1>, const _Alloc& __a)
            : __value_(allocator_arg_t(), __a)
        {static_assert(!is_reference<_Hp>::value,
              "Attempted to default construct a reference element in a tuple");}

    template <class _Alloc>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
        __tuple_leaf(integral_constant<int, 2>, const _Alloc& __a)
            : __value_(__a)
        {static_assert(!is_reference<_Hp>::value,
              "Attempted to default construct a reference element in a tuple");}

    template <class _Tp,
              class = _EnableIf<
                  _And<
                      _IsNotSame<__uncvref_t<_Tp>, __tuple_leaf>,
                      is_constructible<_Hp, _Tp>
                    >::value
                >
            >
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
        explicit __tuple_leaf(_Tp&& __t) noexcept((is_nothrow_constructible<_Hp, _Tp>::value))
            : __value_(std::__1::forward<_Tp>(__t))
        {static_assert(__can_bind_reference<_Tp&&>(),
       "Attempted construction of reference element binds to a temporary whose lifetime has ended");}

    template <class _Tp, class _Alloc>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
        explicit __tuple_leaf(integral_constant<int, 0>, const _Alloc&, _Tp&& __t)
            : __value_(std::__1::forward<_Tp>(__t))
        {static_assert(__can_bind_reference<_Tp&&>(),
       "Attempted construction of reference element binds to a temporary whose lifetime has ended");}

    template <class _Tp, class _Alloc>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
        explicit __tuple_leaf(integral_constant<int, 1>, const _Alloc& __a, _Tp&& __t)
            : __value_(allocator_arg_t(), __a, std::__1::forward<_Tp>(__t))
        {static_assert(!is_reference<_Hp>::value,
            "Attempted to uses-allocator construct a reference element in a tuple");}

    template <class _Tp, class _Alloc>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
        explicit __tuple_leaf(integral_constant<int, 2>, const _Alloc& __a, _Tp&& __t)
            : __value_(std::__1::forward<_Tp>(__t), __a)
        {static_assert(!is_reference<_Hp>::value,
           "Attempted to uses-allocator construct a reference element in a tuple");}

    __tuple_leaf(const __tuple_leaf& __t) = default;
    __tuple_leaf(__tuple_leaf&& __t) = default;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
    int swap(__tuple_leaf& __t) noexcept(__is_nothrow_swappable<__tuple_leaf>::value)
    {
        std::__1::swap(*this, __t);
        return 0;
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr _Hp& get() noexcept {return __value_;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr const _Hp& get() const noexcept {return __value_;}
};

template <size_t _Ip, class _Hp>
class __tuple_leaf<_Ip, _Hp, true>
    : private _Hp
{
    constexpr
    __tuple_leaf& operator=(const __tuple_leaf&);
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr __tuple_leaf()
             noexcept(is_nothrow_default_constructible<_Hp>::value) {}

    template <class _Alloc>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
        __tuple_leaf(integral_constant<int, 0>, const _Alloc&) {}

    template <class _Alloc>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
        __tuple_leaf(integral_constant<int, 1>, const _Alloc& __a)
            : _Hp(allocator_arg_t(), __a) {}

    template <class _Alloc>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
        __tuple_leaf(integral_constant<int, 2>, const _Alloc& __a)
            : _Hp(__a) {}

    template <class _Tp,
              class = _EnableIf<
                  _And<
                    _IsNotSame<__uncvref_t<_Tp>, __tuple_leaf>,
                    is_constructible<_Hp, _Tp>
                  >::value
                >
            >
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
        explicit __tuple_leaf(_Tp&& __t) noexcept((is_nothrow_constructible<_Hp, _Tp>::value))
            : _Hp(std::__1::forward<_Tp>(__t)) {}

    template <class _Tp, class _Alloc>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
        explicit __tuple_leaf(integral_constant<int, 0>, const _Alloc&, _Tp&& __t)
            : _Hp(std::__1::forward<_Tp>(__t)) {}

    template <class _Tp, class _Alloc>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
        explicit __tuple_leaf(integral_constant<int, 1>, const _Alloc& __a, _Tp&& __t)
            : _Hp(allocator_arg_t(), __a, std::__1::forward<_Tp>(__t)) {}

    template <class _Tp, class _Alloc>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
        explicit __tuple_leaf(integral_constant<int, 2>, const _Alloc& __a, _Tp&& __t)
            : _Hp(std::__1::forward<_Tp>(__t), __a) {}

    __tuple_leaf(__tuple_leaf const &) = default;
    __tuple_leaf(__tuple_leaf &&) = default;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
    int
    swap(__tuple_leaf& __t) noexcept(__is_nothrow_swappable<__tuple_leaf>::value)
    {
        std::__1::swap(*this, __t);
        return 0;
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr _Hp& get() noexcept {return static_cast<_Hp&>(*this);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr const _Hp& get() const noexcept {return static_cast<const _Hp&>(*this);}
};

template <class ..._Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
void __swallow(_Tp&&...) noexcept {}

template <class _Tp>
struct __all_default_constructible;

template <class ..._Tp>
struct __all_default_constructible<__tuple_types<_Tp...>>
    : __all<is_default_constructible<_Tp>::value...>
{ };



template<class _Indx, class ..._Tp> struct __tuple_impl;

template<size_t ..._Indx, class ..._Tp>
struct __tuple_impl<__tuple_indices<_Indx...>, _Tp...>
    : public __tuple_leaf<_Indx, _Tp>...
{
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    constexpr __tuple_impl()
        noexcept(__all<is_nothrow_default_constructible<_Tp>::value...>::value) {}

    template <size_t ..._Uf, class ..._Tf,
              size_t ..._Ul, class ..._Tl, class ..._Up>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
        explicit
        __tuple_impl(__tuple_indices<_Uf...>, __tuple_types<_Tf...>,
                     __tuple_indices<_Ul...>, __tuple_types<_Tl...>,
                     _Up&&... __u)
                     noexcept((__all<is_nothrow_constructible<_Tf, _Up>::value...>::value && __all<is_nothrow_default_constructible<_Tl>::value...>::value)) :

            __tuple_leaf<_Uf, _Tf>(std::__1::forward<_Up>(__u))...,
            __tuple_leaf<_Ul, _Tl>()...
            {}

    template <class _Alloc, size_t ..._Uf, class ..._Tf,
              size_t ..._Ul, class ..._Tl, class ..._Up>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
        explicit
        __tuple_impl(allocator_arg_t, const _Alloc& __a,
                     __tuple_indices<_Uf...>, __tuple_types<_Tf...>,
                     __tuple_indices<_Ul...>, __tuple_types<_Tl...>,
                     _Up&&... __u) :
            __tuple_leaf<_Uf, _Tf>(__uses_alloc_ctor<_Tf, _Alloc, _Up>(), __a,
            std::__1::forward<_Up>(__u))...,
            __tuple_leaf<_Ul, _Tl>(__uses_alloc_ctor<_Tl, _Alloc>(), __a)...
            {}

    template <class _Tuple,
              class = typename enable_if
                      <
                         __tuple_constructible<_Tuple, tuple<_Tp...> >::value
                      >::type
             >
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
        __tuple_impl(_Tuple&& __t) noexcept((__all<is_nothrow_constructible<_Tp, typename tuple_element<_Indx, typename __make_tuple_types<_Tuple>::type>::type>::value...>::value))

            : __tuple_leaf<_Indx, _Tp>(std::__1::forward<typename tuple_element<_Indx,
                                       typename __make_tuple_types<_Tuple>::type>::type>(std::__1::get<_Indx>(__t)))...
            {}

    template <class _Alloc, class _Tuple,
              class = typename enable_if
                      <
                         __tuple_constructible<_Tuple, tuple<_Tp...> >::value
                      >::type
             >
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
        __tuple_impl(allocator_arg_t, const _Alloc& __a, _Tuple&& __t)
            : __tuple_leaf<_Indx, _Tp>(__uses_alloc_ctor<_Tp, _Alloc, typename tuple_element<_Indx,
                                       typename __make_tuple_types<_Tuple>::type>::type>(), __a,
                                       std::__1::forward<typename tuple_element<_Indx,
                                       typename __make_tuple_types<_Tuple>::type>::type>(std::__1::get<_Indx>(__t)))...
            {}

    __tuple_impl(const __tuple_impl&) = default;
    __tuple_impl(__tuple_impl&&) = default;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
    void swap(__tuple_impl& __t)
        noexcept(__all<__is_nothrow_swappable<_Tp>::value...>::value)
    {
        std::__1::__swallow(__tuple_leaf<_Indx, _Tp>::swap(static_cast<__tuple_leaf<_Indx, _Tp>&>(__t))...);
    }
};

template<class _Dest, class _Source, size_t ..._Np>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
void __memberwise_copy_assign(_Dest& __dest, _Source const& __source, __tuple_indices<_Np...>) {
    std::__1::__swallow(((std::__1::get<_Np>(__dest) = std::__1::get<_Np>(__source)), void(), 0)...);
}

template<class _Dest, class _Source, class ..._Up, size_t ..._Np>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
void __memberwise_forward_assign(_Dest& __dest, _Source&& __source, __tuple_types<_Up...>, __tuple_indices<_Np...>) {
    std::__1::__swallow(((
        std::__1::get<_Np>(__dest) = std::__1::forward<_Up>(std::__1::get<_Np>(__source))
    ), void(), 0)...);
}

template <class ..._Tp>
class __attribute__ ((__type_visibility__("default"))) tuple
{
    typedef __tuple_impl<typename __make_tuple_indices<sizeof...(_Tp)>::type, _Tp...> _BaseT;

    _BaseT __base_;

    template <size_t _Jp, class ..._Up> friend constexpr
        typename tuple_element<_Jp, tuple<_Up...> >::type& get(tuple<_Up...>&) noexcept;
    template <size_t _Jp, class ..._Up> friend constexpr
        const typename tuple_element<_Jp, tuple<_Up...> >::type& get(const tuple<_Up...>&) noexcept;
    template <size_t _Jp, class ..._Up> friend constexpr
        typename tuple_element<_Jp, tuple<_Up...> >::type&& get(tuple<_Up...>&&) noexcept;
    template <size_t _Jp, class ..._Up> friend constexpr
        const typename tuple_element<_Jp, tuple<_Up...> >::type&& get(const tuple<_Up...>&&) noexcept;
public:



    template <template<class...> class _IsImpDefault = __is_implicitly_default_constructible, _EnableIf<
        _And<
            _IsImpDefault<_Tp>...
        >::value
    , int> = 0>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
    tuple()
        noexcept(_And<is_nothrow_default_constructible<_Tp>...>::value)
    { }

    template <template<class...> class _IsImpDefault = __is_implicitly_default_constructible,
              template<class...> class _IsDefault = is_default_constructible, _EnableIf<
        _And<
            _IsDefault<_Tp>...,
            _Not<_Lazy<_And, _IsImpDefault<_Tp>...> >
        >::value
    , int> = 0>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
    explicit tuple()
        noexcept(_And<is_nothrow_default_constructible<_Tp>...>::value)
    { }

    template <class _Alloc, template<class...> class _IsImpDefault = __is_implicitly_default_constructible, _EnableIf<
        _And<
            _IsImpDefault<_Tp>...
        >::value
    , int> = 0>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    tuple(allocator_arg_t, _Alloc const& __a)
      : __base_(allocator_arg_t(), __a,
                    __tuple_indices<>(), __tuple_types<>(),
                    typename __make_tuple_indices<sizeof...(_Tp), 0>::type(),
                    __tuple_types<_Tp...>()) {}

    template <class _Alloc,
              template<class...> class _IsImpDefault = __is_implicitly_default_constructible,
              template<class...> class _IsDefault = is_default_constructible, _EnableIf<
        _And<
            _IsDefault<_Tp>...,
            _Not<_Lazy<_And, _IsImpDefault<_Tp>...> >
        >::value
    , int> = 0>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit tuple(allocator_arg_t, _Alloc const& __a)
      : __base_(allocator_arg_t(), __a,
                    __tuple_indices<>(), __tuple_types<>(),
                    typename __make_tuple_indices<sizeof...(_Tp), 0>::type(),
                    __tuple_types<_Tp...>()) {}


    template <template<class...> class _And = _And, _EnableIf<
        _And<
            _BoolConstant<sizeof...(_Tp) >= 1>,
            is_copy_constructible<_Tp>...,
            is_convertible<const _Tp&, _Tp>...
        >::value
    , int> = 0>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
    tuple(const _Tp& ... __t)
        noexcept(_And<is_nothrow_copy_constructible<_Tp>...>::value)
        : __base_(typename __make_tuple_indices<sizeof...(_Tp)>::type(),
                typename __make_tuple_types<tuple, sizeof...(_Tp)>::type(),
                typename __make_tuple_indices<0>::type(),
                typename __make_tuple_types<tuple, 0>::type(),
                __t...
               ) {}

    template <template<class...> class _And = _And, _EnableIf<
        _And<
            _BoolConstant<sizeof...(_Tp) >= 1>,
            is_copy_constructible<_Tp>...,
            _Not<_Lazy<_And, is_convertible<const _Tp&, _Tp>...> >
        >::value
    , int> = 0>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
    explicit tuple(const _Tp& ... __t)
        noexcept(_And<is_nothrow_copy_constructible<_Tp>...>::value)
        : __base_(typename __make_tuple_indices<sizeof...(_Tp)>::type(),
                typename __make_tuple_types<tuple, sizeof...(_Tp)>::type(),
                typename __make_tuple_indices<0>::type(),
                typename __make_tuple_types<tuple, 0>::type(),
                __t...
               ) {}

    template <class _Alloc, template<class...> class _And = _And, _EnableIf<
        _And<
            _BoolConstant<sizeof...(_Tp) >= 1>,
            is_copy_constructible<_Tp>...,
            is_convertible<const _Tp&, _Tp>...
        >::value
    , int> = 0>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    tuple(allocator_arg_t, const _Alloc& __a, const _Tp& ... __t)
        : __base_(allocator_arg_t(), __a,
                typename __make_tuple_indices<sizeof...(_Tp)>::type(),
                typename __make_tuple_types<tuple, sizeof...(_Tp)>::type(),
                typename __make_tuple_indices<0>::type(),
                typename __make_tuple_types<tuple, 0>::type(),
                __t...
               ) {}

    template <class _Alloc, template<class...> class _And = _And, _EnableIf<
        _And<
            _BoolConstant<sizeof...(_Tp) >= 1>,
            is_copy_constructible<_Tp>...,
            _Not<_Lazy<_And, is_convertible<const _Tp&, _Tp>...> >
        >::value
    , int> = 0>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit tuple(allocator_arg_t, const _Alloc& __a, const _Tp& ... __t)
        : __base_(allocator_arg_t(), __a,
                typename __make_tuple_indices<sizeof...(_Tp)>::type(),
                typename __make_tuple_types<tuple, sizeof...(_Tp)>::type(),
                typename __make_tuple_indices<0>::type(),
                typename __make_tuple_types<tuple, 0>::type(),
                __t...
               ) {}


    template <class ..._Up> struct _IsThisTuple : false_type { };
    template <class _Up> struct _IsThisTuple<_Up> : is_same<__uncvref_t<_Up>, tuple> { };

    template <class ..._Up>
    struct _EnableUTypesCtor : _And<
        _BoolConstant<sizeof...(_Tp) >= 1>,
        _Not<_IsThisTuple<_Up...> >,
        is_constructible<_Tp, _Up>...
    > { };

    template <class ..._Up, _EnableIf<
        _And<
            _BoolConstant<sizeof...(_Up) == sizeof...(_Tp)>,
            _EnableUTypesCtor<_Up...>,
            is_convertible<_Up, _Tp>...
        >::value
    , int> = 0>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
    tuple(_Up&&... __u)
        noexcept((_And<is_nothrow_constructible<_Tp, _Up>...>::value))
        : __base_(typename __make_tuple_indices<sizeof...(_Up)>::type(),
                    typename __make_tuple_types<tuple, sizeof...(_Up)>::type(),
                    typename __make_tuple_indices<sizeof...(_Tp), sizeof...(_Up)>::type(),
                    typename __make_tuple_types<tuple, sizeof...(_Tp), sizeof...(_Up)>::type(),
                    std::__1::forward<_Up>(__u)...) {}

    template <class ..._Up, _EnableIf<
        _And<
            _BoolConstant<sizeof...(_Up) == sizeof...(_Tp)>,
            _EnableUTypesCtor<_Up...>,
            _Not<_Lazy<_And, is_convertible<_Up, _Tp>...> >
        >::value
    , int> = 0>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
    explicit tuple(_Up&&... __u)
        noexcept((_And<is_nothrow_constructible<_Tp, _Up>...>::value))
        : __base_(typename __make_tuple_indices<sizeof...(_Up)>::type(),
                    typename __make_tuple_types<tuple, sizeof...(_Up)>::type(),
                    typename __make_tuple_indices<sizeof...(_Tp), sizeof...(_Up)>::type(),
                    typename __make_tuple_types<tuple, sizeof...(_Tp), sizeof...(_Up)>::type(),
                    std::__1::forward<_Up>(__u)...) {}

    template <class _Alloc, class ..._Up, _EnableIf<
        _And<
            _BoolConstant<sizeof...(_Up) == sizeof...(_Tp)>,
            _EnableUTypesCtor<_Up...>,
            is_convertible<_Up, _Tp>...
        >::value
    , int> = 0>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    tuple(allocator_arg_t, const _Alloc& __a, _Up&&... __u)
        : __base_(allocator_arg_t(), __a,
                    typename __make_tuple_indices<sizeof...(_Up)>::type(),
                    typename __make_tuple_types<tuple, sizeof...(_Up)>::type(),
                    typename __make_tuple_indices<sizeof...(_Tp), sizeof...(_Up)>::type(),
                    typename __make_tuple_types<tuple, sizeof...(_Tp), sizeof...(_Up)>::type(),
                    std::__1::forward<_Up>(__u)...) {}

    template <class _Alloc, class ..._Up, _EnableIf<
        _And<
            _BoolConstant<sizeof...(_Up) == sizeof...(_Tp)>,
            _EnableUTypesCtor<_Up...>,
            _Not<_Lazy<_And, is_convertible<_Up, _Tp>...> >
        >::value
    , int> = 0>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit tuple(allocator_arg_t, const _Alloc& __a, _Up&&... __u)
        : __base_(allocator_arg_t(), __a,
                    typename __make_tuple_indices<sizeof...(_Up)>::type(),
                    typename __make_tuple_types<tuple, sizeof...(_Up)>::type(),
                    typename __make_tuple_indices<sizeof...(_Tp), sizeof...(_Up)>::type(),
                    typename __make_tuple_types<tuple, sizeof...(_Tp), sizeof...(_Up)>::type(),
                    std::__1::forward<_Up>(__u)...) {}


    tuple(const tuple&) = default;
    tuple(tuple&&) = default;

    template <class _Alloc, template<class...> class _And = _And, _EnableIf<
        _And<is_copy_constructible<_Tp>...>::value
    , int> = 0>
    tuple(allocator_arg_t, const _Alloc& __alloc, const tuple& __t)
        : __base_(allocator_arg_t(), __alloc, __t)
    { }

    template <class _Alloc, template<class...> class _And = _And, _EnableIf<
        _And<is_move_constructible<_Tp>...>::value
    , int> = 0>
    tuple(allocator_arg_t, const _Alloc& __alloc, tuple&& __t)
        : __base_(allocator_arg_t(), __alloc, std::__1::move(__t))
    { }


    template <class ..._Up>
    struct _EnableCopyFromOtherTuple : _And<
        _Not<is_same<tuple<_Tp...>, tuple<_Up...> > >,
        _Lazy<_Or,
            _BoolConstant<sizeof...(_Tp) != 1>,


            _Lazy<_And,
                _Not<is_convertible<const tuple<_Up>&, _Tp> >...,
                _Not<is_constructible<_Tp, const tuple<_Up>&> >...
            >
        >,
        is_constructible<_Tp, const _Up&>...
    > { };

    template <class ..._Up, _EnableIf<
        _And<
            _BoolConstant<sizeof...(_Up) == sizeof...(_Tp)>,
            _EnableCopyFromOtherTuple<_Up...>,
            is_convertible<const _Up&, _Tp>...
        >::value
    , int> = 0>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
    tuple(const tuple<_Up...>& __t)
        noexcept((_And<is_nothrow_constructible<_Tp, const _Up&>...>::value))
        : __base_(__t)
    { }

    template <class ..._Up, _EnableIf<
        _And<
            _BoolConstant<sizeof...(_Up) == sizeof...(_Tp)>,
            _EnableCopyFromOtherTuple<_Up...>,
            _Not<_Lazy<_And, is_convertible<const _Up&, _Tp>...> >
        >::value
    , int> = 0>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
    explicit tuple(const tuple<_Up...>& __t)
        noexcept((_And<is_nothrow_constructible<_Tp, const _Up&>...>::value))
        : __base_(__t)
    { }

    template <class ..._Up, class _Alloc, _EnableIf<
        _And<
            _BoolConstant<sizeof...(_Up) == sizeof...(_Tp)>,
            _EnableCopyFromOtherTuple<_Up...>,
            is_convertible<const _Up&, _Tp>...
        >::value
    , int> = 0>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    tuple(allocator_arg_t, const _Alloc& __a, const tuple<_Up...>& __t)
        : __base_(allocator_arg_t(), __a, __t)
    { }

    template <class ..._Up, class _Alloc, _EnableIf<
        _And<
            _BoolConstant<sizeof...(_Up) == sizeof...(_Tp)>,
            _EnableCopyFromOtherTuple<_Up...>,
            _Not<_Lazy<_And, is_convertible<const _Up&, _Tp>...> >
        >::value
    , int> = 0>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit tuple(allocator_arg_t, const _Alloc& __a, const tuple<_Up...>& __t)
        : __base_(allocator_arg_t(), __a, __t)
    { }


    template <class ..._Up>
    struct _EnableMoveFromOtherTuple : _And<
        _Not<is_same<tuple<_Tp...>, tuple<_Up...> > >,
        _Lazy<_Or,
            _BoolConstant<sizeof...(_Tp) != 1>,


            _Lazy<_And,
                _Not<is_convertible<tuple<_Up>, _Tp> >...,
                _Not<is_constructible<_Tp, tuple<_Up> > >...
            >
        >,
        is_constructible<_Tp, _Up>...
    > { };

    template <class ..._Up, _EnableIf<
        _And<
            _BoolConstant<sizeof...(_Up) == sizeof...(_Tp)>,
            _EnableMoveFromOtherTuple<_Up...>,
            is_convertible<_Up, _Tp>...
        >::value
    , int> = 0>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
    tuple(tuple<_Up...>&& __t)
        noexcept((_And<is_nothrow_constructible<_Tp, _Up>...>::value))
        : __base_(std::__1::move(__t))
    { }

    template <class ..._Up, _EnableIf<
        _And<
            _BoolConstant<sizeof...(_Up) == sizeof...(_Tp)>,
            _EnableMoveFromOtherTuple<_Up...>,
            _Not<_Lazy<_And, is_convertible<_Up, _Tp>...> >
        >::value
    , int> = 0>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
    explicit tuple(tuple<_Up...>&& __t)
        noexcept((_And<is_nothrow_constructible<_Tp, _Up>...>::value))
        : __base_(std::__1::move(__t))
    { }

    template <class _Alloc, class ..._Up, _EnableIf<
        _And<
            _BoolConstant<sizeof...(_Up) == sizeof...(_Tp)>,
            _EnableMoveFromOtherTuple<_Up...>,
            is_convertible<_Up, _Tp>...
        >::value
    , int> = 0>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    tuple(allocator_arg_t, const _Alloc& __a, tuple<_Up...>&& __t)
        : __base_(allocator_arg_t(), __a, std::__1::move(__t))
    { }

    template <class _Alloc, class ..._Up, _EnableIf<
        _And<
            _BoolConstant<sizeof...(_Up) == sizeof...(_Tp)>,
            _EnableMoveFromOtherTuple<_Up...>,
            _Not<_Lazy<_And, is_convertible<_Up, _Tp>...> >
        >::value
    , int> = 0>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit tuple(allocator_arg_t, const _Alloc& __a, tuple<_Up...>&& __t)
        : __base_(allocator_arg_t(), __a, std::__1::move(__t))
    { }


    template <class _Up1, class _Up2, class ..._DependentTp>
    struct _EnableImplicitCopyFromPair : _And<
        is_constructible<_FirstType<_DependentTp...>, const _Up1&>,
        is_constructible<_SecondType<_DependentTp...>, const _Up2&>,
        is_convertible<const _Up1&, _FirstType<_DependentTp...> >,
        is_convertible<const _Up2&, _SecondType<_DependentTp...> >
    > { };

    template <class _Up1, class _Up2, class ..._DependentTp>
    struct _EnableExplicitCopyFromPair : _And<
        is_constructible<_FirstType<_DependentTp...>, const _Up1&>,
        is_constructible<_SecondType<_DependentTp...>, const _Up2&>,
        _Not<is_convertible<const _Up1&, _FirstType<_DependentTp...> > >,
        _Not<is_convertible<const _Up2&, _SecondType<_DependentTp...> > >
    > { };

    template <class _Up1, class _Up2, template<class...> class _And = _And, _EnableIf<
        _And<
            _BoolConstant<sizeof...(_Tp) == 2>,
            _EnableImplicitCopyFromPair<_Up1, _Up2, _Tp...>
        >::value
    , int> = 0>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
    tuple(const pair<_Up1, _Up2>& __p)
        noexcept((_And< is_nothrow_constructible<_FirstType<_Tp...>, const _Up1&>, is_nothrow_constructible<_SecondType<_Tp...>, const _Up2&> >::value))



        : __base_(__p)
    { }

    template <class _Up1, class _Up2, template<class...> class _And = _And, _EnableIf<
        _And<
            _BoolConstant<sizeof...(_Tp) == 2>,
            _EnableExplicitCopyFromPair<_Up1, _Up2, _Tp...>
        >::value
    , int> = 0>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
    explicit tuple(const pair<_Up1, _Up2>& __p)
        noexcept((_And< is_nothrow_constructible<_FirstType<_Tp...>, const _Up1&>, is_nothrow_constructible<_SecondType<_Tp...>, const _Up2&> >::value))



        : __base_(__p)
    { }

    template <class _Alloc, class _Up1, class _Up2, template<class...> class _And = _And, _EnableIf<
        _And<
            _BoolConstant<sizeof...(_Tp) == 2>,
            _EnableImplicitCopyFromPair<_Up1, _Up2, _Tp...>
        >::value
    , int> = 0>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    tuple(allocator_arg_t, const _Alloc& __a, const pair<_Up1, _Up2>& __p)
        : __base_(allocator_arg_t(), __a, __p)
    { }

    template <class _Alloc, class _Up1, class _Up2, template<class...> class _And = _And, _EnableIf<
        _And<
            _BoolConstant<sizeof...(_Tp) == 2>,
            _EnableExplicitCopyFromPair<_Up1, _Up2, _Tp...>
        >::value
    , int> = 0>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit tuple(allocator_arg_t, const _Alloc& __a, const pair<_Up1, _Up2>& __p)
        : __base_(allocator_arg_t(), __a, __p)
    { }


    template <class _Up1, class _Up2, class ..._DependentTp>
    struct _EnableImplicitMoveFromPair : _And<
        is_constructible<_FirstType<_DependentTp...>, _Up1>,
        is_constructible<_SecondType<_DependentTp...>, _Up2>,
        is_convertible<_Up1, _FirstType<_DependentTp...> >,
        is_convertible<_Up2, _SecondType<_DependentTp...> >
    > { };

    template <class _Up1, class _Up2, class ..._DependentTp>
    struct _EnableExplicitMoveFromPair : _And<
        is_constructible<_FirstType<_DependentTp...>, _Up1>,
        is_constructible<_SecondType<_DependentTp...>, _Up2>,
        _Not<is_convertible<_Up1, _FirstType<_DependentTp...> > >,
        _Not<is_convertible<_Up2, _SecondType<_DependentTp...> > >
    > { };

    template <class _Up1, class _Up2, template<class...> class _And = _And, _EnableIf<
        _And<
            _BoolConstant<sizeof...(_Tp) == 2>,
            _EnableImplicitMoveFromPair<_Up1, _Up2, _Tp...>
        >::value
    , int> = 0>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
    tuple(pair<_Up1, _Up2>&& __p)
        noexcept((_And< is_nothrow_constructible<_FirstType<_Tp...>, _Up1>, is_nothrow_constructible<_SecondType<_Tp...>, _Up2> >::value))



        : __base_(std::__1::move(__p))
    { }

    template <class _Up1, class _Up2, template<class...> class _And = _And, _EnableIf<
        _And<
            _BoolConstant<sizeof...(_Tp) == 2>,
            _EnableExplicitMoveFromPair<_Up1, _Up2, _Tp...>
        >::value
    , int> = 0>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
    explicit tuple(pair<_Up1, _Up2>&& __p)
        noexcept((_And< is_nothrow_constructible<_FirstType<_Tp...>, _Up1>, is_nothrow_constructible<_SecondType<_Tp...>, _Up2> >::value))



        : __base_(std::__1::move(__p))
    { }

    template <class _Alloc, class _Up1, class _Up2, template<class...> class _And = _And, _EnableIf<
        _And<
            _BoolConstant<sizeof...(_Tp) == 2>,
            _EnableImplicitMoveFromPair<_Up1, _Up2, _Tp...>
        >::value
    , int> = 0>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    tuple(allocator_arg_t, const _Alloc& __a, pair<_Up1, _Up2>&& __p)
        : __base_(allocator_arg_t(), __a, std::__1::move(__p))
    { }

    template <class _Alloc, class _Up1, class _Up2, template<class...> class _And = _And, _EnableIf<
        _And<
            _BoolConstant<sizeof...(_Tp) == 2>,
            _EnableExplicitMoveFromPair<_Up1, _Up2, _Tp...>
        >::value
    , int> = 0>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit tuple(allocator_arg_t, const _Alloc& __a, pair<_Up1, _Up2>&& __p)
        : __base_(allocator_arg_t(), __a, std::__1::move(__p))
    { }


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    tuple& operator=(_If<_And<is_copy_assignable<_Tp>...>::value, tuple, __nat> const& __tuple)
        noexcept((_And<is_nothrow_copy_assignable<_Tp>...>::value))
    {
        std::__1::__memberwise_copy_assign(*this, __tuple,
            typename __make_tuple_indices<sizeof...(_Tp)>::type());
        return *this;
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    tuple& operator=(_If<_And<is_move_assignable<_Tp>...>::value, tuple, __nat>&& __tuple)
        noexcept((_And<is_nothrow_move_assignable<_Tp>...>::value))
    {
        std::__1::__memberwise_forward_assign(*this, std::__1::move(__tuple),
            __tuple_types<_Tp...>(),
            typename __make_tuple_indices<sizeof...(_Tp)>::type());
        return *this;
    }

    template<class... _Up, _EnableIf<
        _And<
            _BoolConstant<sizeof...(_Tp) == sizeof...(_Up)>,
            is_assignable<_Tp&, _Up const&>...
        >::value
    ,int> = 0>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    tuple& operator=(tuple<_Up...> const& __tuple)
        noexcept((_And<is_nothrow_assignable<_Tp&, _Up const&>...>::value))
    {
        std::__1::__memberwise_copy_assign(*this, __tuple,
            typename __make_tuple_indices<sizeof...(_Tp)>::type());
        return *this;
    }

    template<class... _Up, _EnableIf<
        _And<
            _BoolConstant<sizeof...(_Tp) == sizeof...(_Up)>,
            is_assignable<_Tp&, _Up>...
        >::value
    ,int> = 0>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    tuple& operator=(tuple<_Up...>&& __tuple)
        noexcept((_And<is_nothrow_assignable<_Tp&, _Up>...>::value))
    {
        std::__1::__memberwise_forward_assign(*this, std::__1::move(__tuple),
            __tuple_types<_Up...>(),
            typename __make_tuple_indices<sizeof...(_Tp)>::type());
        return *this;
    }

    template<class _Up1, class _Up2, class _Dep = true_type, _EnableIf<
        _And<_Dep,
            _BoolConstant<sizeof...(_Tp) == 2>,
            is_assignable<_FirstType<_Tp..., _Dep>&, _Up1 const&>,
            is_assignable<_SecondType<_Tp..., _Dep>&, _Up2 const&>
        >::value
    ,int> = 0>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    tuple& operator=(pair<_Up1, _Up2> const& __pair)
        noexcept((_And< is_nothrow_assignable<_FirstType<_Tp...>&, _Up1 const&>, is_nothrow_assignable<_SecondType<_Tp...>&, _Up2 const&> >::value))



    {
        std::__1::get<0>(*this) = __pair.first;
        std::__1::get<1>(*this) = __pair.second;
        return *this;
    }

    template<class _Up1, class _Up2, class _Dep = true_type, _EnableIf<
        _And<_Dep,
            _BoolConstant<sizeof...(_Tp) == 2>,
            is_assignable<_FirstType<_Tp..., _Dep>&, _Up1>,
            is_assignable<_SecondType<_Tp..., _Dep>&, _Up2>
        >::value
    ,int> = 0>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    tuple& operator=(pair<_Up1, _Up2>&& __pair)
        noexcept((_And< is_nothrow_assignable<_FirstType<_Tp...>&, _Up1>, is_nothrow_assignable<_SecondType<_Tp...>&, _Up2> >::value))



    {
        std::__1::get<0>(*this) = std::__1::forward<_Up1>(__pair.first);
        std::__1::get<1>(*this) = std::__1::forward<_Up2>(__pair.second);
        return *this;
    }


    template<class _Up, size_t _Np, class = _EnableIf<
        _And<
            _BoolConstant<_Np == sizeof...(_Tp)>,
            is_assignable<_Tp&, _Up const&>...
        >::value
    > >
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    tuple& operator=(array<_Up, _Np> const& __array)
        noexcept((_And<is_nothrow_assignable<_Tp&, _Up const&>...>::value))
    {
        std::__1::__memberwise_copy_assign(*this, __array,
            typename __make_tuple_indices<sizeof...(_Tp)>::type());
        return *this;
    }


    template<class _Up, size_t _Np, class = void, class = _EnableIf<
        _And<
            _BoolConstant<_Np == sizeof...(_Tp)>,
            is_assignable<_Tp&, _Up>...
        >::value
    > >
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    tuple& operator=(array<_Up, _Np>&& __array)
        noexcept((_And<is_nothrow_assignable<_Tp&, _Up>...>::value))
    {
        std::__1::__memberwise_forward_assign(*this, std::__1::move(__array),
            __tuple_types<_If<true, _Up, _Tp>...>(),
            typename __make_tuple_indices<sizeof...(_Tp)>::type());
        return *this;
    }


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void swap(tuple& __t) noexcept(__all<__is_nothrow_swappable<_Tp>::value...>::value)
        {__base_.swap(__t.__base_);}
};

template <>
class __attribute__ ((__type_visibility__("default"))) tuple<>
{
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
        tuple() noexcept = default;
    template <class _Alloc>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        tuple(allocator_arg_t, const _Alloc&) noexcept {}
    template <class _Alloc>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        tuple(allocator_arg_t, const _Alloc&, const tuple&) noexcept {}
    template <class _Up>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        tuple(array<_Up, 0>) noexcept {}
    template <class _Alloc, class _Up>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        tuple(allocator_arg_t, const _Alloc&, array<_Up, 0>) noexcept {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void swap(tuple&) noexcept {}
};


template <class ..._Tp>
tuple(_Tp...) -> tuple<_Tp...>;
template <class _Tp1, class _Tp2>
tuple(pair<_Tp1, _Tp2>) -> tuple<_Tp1, _Tp2>;
template <class _Alloc, class ..._Tp>
tuple(allocator_arg_t, _Alloc, _Tp...) -> tuple<_Tp...>;
template <class _Alloc, class _Tp1, class _Tp2>
tuple(allocator_arg_t, _Alloc, pair<_Tp1, _Tp2>) -> tuple<_Tp1, _Tp2>;
template <class _Alloc, class ..._Tp>
tuple(allocator_arg_t, _Alloc, tuple<_Tp...>) -> tuple<_Tp...>;


template <class ..._Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename enable_if
<
    __all<__is_swappable<_Tp>::value...>::value,
    void
>::type
swap(tuple<_Tp...>& __t, tuple<_Tp...>& __u)
                 noexcept(__all<__is_nothrow_swappable<_Tp>::value...>::value)
    {__t.swap(__u);}



template <size_t _Ip, class ..._Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
typename tuple_element<_Ip, tuple<_Tp...> >::type&
get(tuple<_Tp...>& __t) noexcept
{
    typedef typename tuple_element<_Ip, tuple<_Tp...> >::type type;
    return static_cast<__tuple_leaf<_Ip, type>&>(__t.__base_).get();
}

template <size_t _Ip, class ..._Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
const typename tuple_element<_Ip, tuple<_Tp...> >::type&
get(const tuple<_Tp...>& __t) noexcept
{
    typedef typename tuple_element<_Ip, tuple<_Tp...> >::type type;
    return static_cast<const __tuple_leaf<_Ip, type>&>(__t.__base_).get();
}

template <size_t _Ip, class ..._Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
typename tuple_element<_Ip, tuple<_Tp...> >::type&&
get(tuple<_Tp...>&& __t) noexcept
{
    typedef typename tuple_element<_Ip, tuple<_Tp...> >::type type;
    return static_cast<type&&>(
             static_cast<__tuple_leaf<_Ip, type>&&>(__t.__base_).get());
}

template <size_t _Ip, class ..._Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
const typename tuple_element<_Ip, tuple<_Tp...> >::type&&
get(const tuple<_Tp...>&& __t) noexcept
{
    typedef typename tuple_element<_Ip, tuple<_Tp...> >::type type;
    return static_cast<const type&&>(
             static_cast<const __tuple_leaf<_Ip, type>&&>(__t.__base_).get());
}



namespace __find_detail {

static constexpr size_t __not_found = static_cast<size_t>(-1);
static constexpr size_t __ambiguous = __not_found - 1;

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
constexpr size_t __find_idx_return(size_t __curr_i, size_t __res, bool __matches) {
    return !__matches ? __res :
        (__res == __not_found ? __curr_i : __ambiguous);
}

template <size_t _Nx>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
constexpr size_t __find_idx(size_t __i, const bool (&__matches)[_Nx]) {
  return __i == _Nx ? __not_found :
      __find_idx_return(__i, __find_idx(__i + 1, __matches), __matches[__i]);
}

template <class _T1, class ..._Args>
struct __find_exactly_one_checked {
    static constexpr bool __matches[sizeof...(_Args)] = {is_same<_T1, _Args>::value...};
    static constexpr size_t value = __find_detail::__find_idx(0, __matches);
    static_assert(value != __not_found, "type not found in type list" );
    static_assert(value != __ambiguous, "type occurs more than once in type list");
};

template <class _T1>
struct __find_exactly_one_checked<_T1> {
    static_assert(!is_same<_T1, _T1>::value, "type not in empty type list");
};

}

template <typename _T1, typename... _Args>
struct __find_exactly_one_t
    : public __find_detail::__find_exactly_one_checked<_T1, _Args...> {
};

template <class _T1, class... _Args>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
constexpr _T1& get(tuple<_Args...>& __tup) noexcept
{
    return std::__1::get<__find_exactly_one_t<_T1, _Args...>::value>(__tup);
}

template <class _T1, class... _Args>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
constexpr _T1 const& get(tuple<_Args...> const& __tup) noexcept
{
    return std::__1::get<__find_exactly_one_t<_T1, _Args...>::value>(__tup);
}

template <class _T1, class... _Args>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
constexpr _T1&& get(tuple<_Args...>&& __tup) noexcept
{
    return std::__1::get<__find_exactly_one_t<_T1, _Args...>::value>(std::__1::move(__tup));
}

template <class _T1, class... _Args>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
constexpr _T1 const&& get(tuple<_Args...> const&& __tup) noexcept
{
    return std::__1::get<__find_exactly_one_t<_T1, _Args...>::value>(std::__1::move(__tup));
}





template <class ..._Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
tuple<_Tp&...>
tie(_Tp&... __t) noexcept
{
    return tuple<_Tp&...>(__t...);
}

template <class _Up>
struct __ignore_t
{
    template <class _Tp>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
    const __ignore_t& operator=(_Tp&&) const {return *this;}
};

namespace {
  inline constexpr __ignore_t<unsigned char> ignore = __ignore_t<unsigned char>();
}

template <class... _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
tuple<typename __unwrap_ref_decay<_Tp>::type...>
make_tuple(_Tp&&... __t)
{
    return tuple<typename __unwrap_ref_decay<_Tp>::type...>(std::__1::forward<_Tp>(__t)...);
}

template <class... _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
tuple<_Tp&&...>
forward_as_tuple(_Tp&&... __t) noexcept
{
    return tuple<_Tp&&...>(std::__1::forward<_Tp>(__t)...);
}

template <size_t _Ip>
struct __tuple_equal
{
    template <class _Tp, class _Up>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
    bool operator()(const _Tp& __x, const _Up& __y)
    {
        return __tuple_equal<_Ip - 1>()(__x, __y) && std::__1::get<_Ip-1>(__x) == std::__1::get<_Ip-1>(__y);
    }
};

template <>
struct __tuple_equal<0>
{
    template <class _Tp, class _Up>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
    bool operator()(const _Tp&, const _Up&)
    {
        return true;
    }
};

template <class ..._Tp, class ..._Up>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
bool
operator==(const tuple<_Tp...>& __x, const tuple<_Up...>& __y)
{
    static_assert (sizeof...(_Tp) == sizeof...(_Up), "Can't compare tuples of different sizes");
    return __tuple_equal<sizeof...(_Tp)>()(__x, __y);
}

template <class ..._Tp, class ..._Up>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
bool
operator!=(const tuple<_Tp...>& __x, const tuple<_Up...>& __y)
{
    return !(__x == __y);
}

template <size_t _Ip>
struct __tuple_less
{
    template <class _Tp, class _Up>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
    bool operator()(const _Tp& __x, const _Up& __y)
    {
        const size_t __idx = tuple_size<_Tp>::value - _Ip;
        if (std::__1::get<__idx>(__x) < std::__1::get<__idx>(__y))
            return true;
        if (std::__1::get<__idx>(__y) < std::__1::get<__idx>(__x))
            return false;
        return __tuple_less<_Ip-1>()(__x, __y);
    }
};

template <>
struct __tuple_less<0>
{
    template <class _Tp, class _Up>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
    bool operator()(const _Tp&, const _Up&)
    {
        return false;
    }
};

template <class ..._Tp, class ..._Up>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
bool
operator<(const tuple<_Tp...>& __x, const tuple<_Up...>& __y)
{
    static_assert (sizeof...(_Tp) == sizeof...(_Up), "Can't compare tuples of different sizes");
    return __tuple_less<sizeof...(_Tp)>()(__x, __y);
}

template <class ..._Tp, class ..._Up>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
bool
operator>(const tuple<_Tp...>& __x, const tuple<_Up...>& __y)
{
    return __y < __x;
}

template <class ..._Tp, class ..._Up>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
bool
operator>=(const tuple<_Tp...>& __x, const tuple<_Up...>& __y)
{
    return !(__x < __y);
}

template <class ..._Tp, class ..._Up>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
bool
operator<=(const tuple<_Tp...>& __x, const tuple<_Up...>& __y)
{
    return !(__y < __x);
}



template <class _Tp, class _Up> struct __tuple_cat_type;

template <class ..._Ttypes, class ..._Utypes>
struct __tuple_cat_type<tuple<_Ttypes...>, __tuple_types<_Utypes...> >
{
    typedef tuple<_Ttypes..., _Utypes...> type;
};

template <class _ResultTuple, bool _Is_Tuple0TupleLike, class ..._Tuples>
struct __tuple_cat_return_1
{
};

template <class ..._Types, class _Tuple0>
struct __tuple_cat_return_1<tuple<_Types...>, true, _Tuple0>
{
    typedef typename __tuple_cat_type<tuple<_Types...>,
            typename __make_tuple_types<typename __uncvref<_Tuple0>::type>::type>::type
                                                                           type;
};

template <class ..._Types, class _Tuple0, class _Tuple1, class ..._Tuples>
struct __tuple_cat_return_1<tuple<_Types...>, true, _Tuple0, _Tuple1, _Tuples...>
    : public __tuple_cat_return_1<
                 typename __tuple_cat_type<
                     tuple<_Types...>,
                     typename __make_tuple_types<typename __uncvref<_Tuple0>::type>::type
                 >::type,
                 __tuple_like<typename remove_reference<_Tuple1>::type>::value,
                 _Tuple1, _Tuples...>
{
};

template <class ..._Tuples> struct __tuple_cat_return;

template <class _Tuple0, class ..._Tuples>
struct __tuple_cat_return<_Tuple0, _Tuples...>
    : public __tuple_cat_return_1<tuple<>,
         __tuple_like<typename remove_reference<_Tuple0>::type>::value, _Tuple0,
                                                                     _Tuples...>
{
};

template <>
struct __tuple_cat_return<>
{
    typedef tuple<> type;
};

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
tuple<>
tuple_cat()
{
    return tuple<>();
}

template <class _Rp, class _Indices, class _Tuple0, class ..._Tuples>
struct __tuple_cat_return_ref_imp;

template <class ..._Types, size_t ..._I0, class _Tuple0>
struct __tuple_cat_return_ref_imp<tuple<_Types...>, __tuple_indices<_I0...>, _Tuple0>
{
    typedef typename remove_reference<_Tuple0>::type _T0;
    typedef tuple<_Types..., typename __apply_cv<_Tuple0,
                          typename tuple_element<_I0, _T0>::type>::type&&...> type;
};

template <class ..._Types, size_t ..._I0, class _Tuple0, class _Tuple1, class ..._Tuples>
struct __tuple_cat_return_ref_imp<tuple<_Types...>, __tuple_indices<_I0...>,
                                  _Tuple0, _Tuple1, _Tuples...>
    : public __tuple_cat_return_ref_imp<
         tuple<_Types..., typename __apply_cv<_Tuple0,
               typename tuple_element<_I0,
                  typename remove_reference<_Tuple0>::type>::type>::type&&...>,
         typename __make_tuple_indices<tuple_size<typename
                                 remove_reference<_Tuple1>::type>::value>::type,
         _Tuple1, _Tuples...>
{
};

template <class _Tuple0, class ..._Tuples>
struct __tuple_cat_return_ref
    : public __tuple_cat_return_ref_imp<tuple<>,
               typename __make_tuple_indices<
                        tuple_size<typename remove_reference<_Tuple0>::type>::value
               >::type, _Tuple0, _Tuples...>
{
};

template <class _Types, class _I0, class _J0>
struct __tuple_cat;

template <class ..._Types, size_t ..._I0, size_t ..._J0>
struct __tuple_cat<tuple<_Types...>, __tuple_indices<_I0...>, __tuple_indices<_J0...> >
{
    template <class _Tuple0>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
    typename __tuple_cat_return_ref<tuple<_Types...>&&, _Tuple0&&>::type
    operator()(tuple<_Types...> __t, _Tuple0&& __t0)
    {
        return std::__1::forward_as_tuple(
            std::__1::forward<_Types>(std::__1::get<_I0>(__t))...,
            std::__1::get<_J0>(std::__1::forward<_Tuple0>(__t0))...);
    }

    template <class _Tuple0, class _Tuple1, class ..._Tuples>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
    typename __tuple_cat_return_ref<tuple<_Types...>&&, _Tuple0&&, _Tuple1&&, _Tuples&&...>::type
    operator()(tuple<_Types...> __t, _Tuple0&& __t0, _Tuple1&& __t1, _Tuples&& ...__tpls)
    {
        typedef typename remove_reference<_Tuple0>::type _T0;
        typedef typename remove_reference<_Tuple1>::type _T1;
        return __tuple_cat<
            tuple<_Types...,
                  typename __apply_cv<_Tuple0, typename tuple_element<
                                                   _J0, _T0>::type>::type&&...>,
            typename __make_tuple_indices<sizeof...(_Types) +
                                          tuple_size<_T0>::value>::type,
            typename __make_tuple_indices<tuple_size<_T1>::value>::type>()(
            std::__1::forward_as_tuple(
                std::__1::forward<_Types>(std::__1::get<_I0>(__t))...,
                std::__1::get<_J0>(std::__1::forward<_Tuple0>(__t0))...),
            std::__1::forward<_Tuple1>(__t1), std::__1::forward<_Tuples>(__tpls)...);
    }
};

template <class _Tuple0, class... _Tuples>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
typename __tuple_cat_return<_Tuple0, _Tuples...>::type
tuple_cat(_Tuple0&& __t0, _Tuples&&... __tpls)
{
    typedef typename remove_reference<_Tuple0>::type _T0;
    return __tuple_cat<tuple<>, __tuple_indices<>,
                  typename __make_tuple_indices<tuple_size<_T0>::value>::type>()
                  (tuple<>(), std::__1::forward<_Tuple0>(__t0),
                                            std::__1::forward<_Tuples>(__tpls)...);
}

template <class ..._Tp, class _Alloc>
struct __attribute__ ((__type_visibility__("default"))) uses_allocator<tuple<_Tp...>, _Alloc>
    : true_type {};

template <class _T1, class _T2>
template <class... _Args1, class... _Args2, size_t ..._I1, size_t ..._I2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
pair<_T1, _T2>::pair(piecewise_construct_t,
                     tuple<_Args1...>& __first_args, tuple<_Args2...>& __second_args,
                     __tuple_indices<_I1...>, __tuple_indices<_I2...>)
    : first(std::__1::forward<_Args1>(std::__1::get<_I1>( __first_args))...),
      second(std::__1::forward<_Args2>(std::__1::get<_I2>(__second_args))...)
{
}


template <class _Tp>
inline constexpr size_t tuple_size_v = tuple_size<_Tp>::value;



template <class _Fn, class _Tuple, size_t ..._Id>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
constexpr decltype(auto) __apply_tuple_impl(_Fn && __f, _Tuple && __t,
                                            __tuple_indices<_Id...>)
noexcept(noexcept(std::__1::__invoke_constexpr( std::__1::forward<_Fn>(__f), std::__1::get<_Id>(std::__1::forward<_Tuple>(__t))...))) { return std::__1::__invoke_constexpr( std::__1::forward<_Fn>(__f), std::__1::get<_Id>(std::__1::forward<_Tuple>(__t))...); }





template <class _Fn, class _Tuple>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
constexpr decltype(auto) apply(_Fn && __f, _Tuple && __t)
noexcept(noexcept(std::__1::__apply_tuple_impl( std::__1::forward<_Fn>(__f), std::__1::forward<_Tuple>(__t), typename __make_tuple_indices<tuple_size_v<remove_reference_t<_Tuple>>>::type{}))) { return std::__1::__apply_tuple_impl( std::__1::forward<_Fn>(__f), std::__1::forward<_Tuple>(__t), typename __make_tuple_indices<tuple_size_v<remove_reference_t<_Tuple>>>::type{}); }





template <class _Tp, class _Tuple, size_t... _Idx>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
constexpr _Tp __make_from_tuple_impl(_Tuple&& __t, __tuple_indices<_Idx...>)
noexcept(noexcept(_Tp(std::__1::get<_Idx>(std::__1::forward<_Tuple>(__t))...))) { return _Tp(std::__1::get<_Idx>(std::__1::forward<_Tuple>(__t))...); }



template <class _Tp, class _Tuple>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
constexpr _Tp make_from_tuple(_Tuple&& __t)
noexcept(noexcept(std::__1::__make_from_tuple_impl<_Tp>(std::__1::forward<_Tuple>(__t), typename __make_tuple_indices<tuple_size_v<remove_reference_t<_Tuple>>>::type{}))) { return std::__1::__make_from_tuple_impl<_Tp>(std::__1::forward<_Tuple>(__t), typename __make_tuple_indices<tuple_size_v<remove_reference_t<_Tuple>>>::type{}); }
# 1572 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/tuple" 3
} }
# 15 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/perfect_forward.h" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 1 3
# 16 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/perfect_forward.h" 2 3
# 20 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/perfect_forward.h" 3


namespace std { inline namespace __1 {



template<class _Op, class _Tuple,
         class _Idxs = typename __make_tuple_indices<tuple_size<_Tuple>::value>::type>
struct __perfect_forward_impl;

template<class _Op, class... _Bound, size_t... _Idxs>
struct __perfect_forward_impl<_Op, __tuple_types<_Bound...>, __tuple_indices<_Idxs...>>
{
    tuple<_Bound...> __bound_;

    template<class... _Args>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr auto operator()(_Args&&... __args) &
    noexcept(noexcept(_Op::__call(std::__1::get<_Idxs>(__bound_)..., std::__1::forward<_Args>(__args)...)))
    -> decltype( _Op::__call(std::__1::get<_Idxs>(__bound_)..., std::__1::forward<_Args>(__args)...))
    {return _Op::__call(std::__1::get<_Idxs>(__bound_)..., std::__1::forward<_Args>(__args)...);}

    template<class... _Args>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr auto operator()(_Args&&... __args) const&
    noexcept(noexcept(_Op::__call(std::__1::get<_Idxs>(__bound_)..., std::__1::forward<_Args>(__args)...)))
    -> decltype( _Op::__call(std::__1::get<_Idxs>(__bound_)..., std::__1::forward<_Args>(__args)...))
    {return _Op::__call(std::__1::get<_Idxs>(__bound_)..., std::__1::forward<_Args>(__args)...);}

    template<class... _Args>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr auto operator()(_Args&&... __args) &&
    noexcept(noexcept(_Op::__call(std::__1::get<_Idxs>(std::__1::move(__bound_))...,
                                  std::__1::forward<_Args>(__args)...)))
    -> decltype( _Op::__call(std::__1::get<_Idxs>(std::__1::move(__bound_))...,
                                  std::__1::forward<_Args>(__args)...))
    {return _Op::__call(std::__1::get<_Idxs>(std::__1::move(__bound_))...,
                                  std::__1::forward<_Args>(__args)...);}

    template<class... _Args>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr auto operator()(_Args&&... __args) const&&
    noexcept(noexcept(_Op::__call(std::__1::get<_Idxs>(std::__1::move(__bound_))...,
                                  std::__1::forward<_Args>(__args)...)))
    -> decltype( _Op::__call(std::__1::get<_Idxs>(std::__1::move(__bound_))...,
                                  std::__1::forward<_Args>(__args)...))
    {return _Op::__call(std::__1::get<_Idxs>(std::__1::move(__bound_))...,
                                  std::__1::forward<_Args>(__args)...);}

    template<class _Fn = typename tuple_element<0, tuple<_Bound...>>::type,
             class = _EnableIf<is_copy_constructible_v<_Fn>>>
    constexpr __perfect_forward_impl(__perfect_forward_impl const& __other)
        : __bound_(__other.__bound_) {}

    template<class _Fn = typename tuple_element<0, tuple<_Bound...>>::type,
             class = _EnableIf<is_move_constructible_v<_Fn>>>
    constexpr __perfect_forward_impl(__perfect_forward_impl && __other)
        : __bound_(std::__1::move(__other.__bound_)) {}

    template<class... _BoundArgs>
    explicit constexpr __perfect_forward_impl(_BoundArgs&&... __bound) :
        __bound_(std::__1::forward<_BoundArgs>(__bound)...) { }
};

template<class _Op, class... _Args>
using __perfect_forward =
    __perfect_forward_impl<_Op, __tuple_types<decay_t<_Args>...>>;



} }
# 15 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/bind_front.h" 2 3

# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 1 3
# 17 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/bind_front.h" 2 3
# 21 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/bind_front.h" 3


namespace std { inline namespace __1 {
# 50 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/bind_front.h" 3
} }
# 496 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/functional" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/bind.h" 1 3
# 18 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/bind.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 1 3
# 19 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/bind.h" 2 3
# 22 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/bind.h" 3


namespace std { inline namespace __1 {

template<class _Tp> struct __is_bind_expression : public false_type {};
template<class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_bind_expression
    : public __is_bind_expression<typename remove_cv<_Tp>::type> {};


template <class _Tp>
inline constexpr size_t is_bind_expression_v = is_bind_expression<_Tp>::value;


template<class _Tp> struct __is_placeholder : public integral_constant<int, 0> {};
template<class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_placeholder
    : public __is_placeholder<typename remove_cv<_Tp>::type> {};


template <class _Tp>
inline constexpr size_t is_placeholder_v = is_placeholder<_Tp>::value;


namespace placeholders
{

template <int _Np> struct __ph {};
# 61 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/bind.h" 3
                         constexpr __ph<1> _1{};
                         constexpr __ph<2> _2{};
                         constexpr __ph<3> _3{};
                         constexpr __ph<4> _4{};
                         constexpr __ph<5> _5{};
                         constexpr __ph<6> _6{};
                         constexpr __ph<7> _7{};
                         constexpr __ph<8> _8{};
                         constexpr __ph<9> _9{};
                         constexpr __ph<10> _10{};


}

template<int _Np>
struct __is_placeholder<placeholders::__ph<_Np> >
    : public integral_constant<int, _Np> {};




template <class _Tp, class _Uj>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
_Tp&
__mu(reference_wrapper<_Tp> __t, _Uj&)
{
    return __t.get();
}

template <class _Ti, class ..._Uj, size_t ..._Indx>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename __invoke_of<_Ti&, _Uj...>::type
__mu_expand(_Ti& __ti, tuple<_Uj...>& __uj, __tuple_indices<_Indx...>)
{
    return __ti(std::__1::forward<_Uj>(std::__1::get<_Indx>(__uj))...);
}

template <class _Ti, class ..._Uj>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename _EnableIf
<
    is_bind_expression<_Ti>::value,
    __invoke_of<_Ti&, _Uj...>
>::type
__mu(_Ti& __ti, tuple<_Uj...>& __uj)
{
    typedef typename __make_tuple_indices<sizeof...(_Uj)>::type __indices;
    return std::__1::__mu_expand(__ti, __uj, __indices());
}

template <bool IsPh, class _Ti, class _Uj>
struct __mu_return2 {};

template <class _Ti, class _Uj>
struct __mu_return2<true, _Ti, _Uj>
{
    typedef typename tuple_element<is_placeholder<_Ti>::value - 1, _Uj>::type type;
};

template <class _Ti, class _Uj>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename enable_if
<
    0 < is_placeholder<_Ti>::value,
    typename __mu_return2<0 < is_placeholder<_Ti>::value, _Ti, _Uj>::type
>::type
__mu(_Ti&, _Uj& __uj)
{
    const size_t _Indx = is_placeholder<_Ti>::value - 1;
    return std::__1::forward<typename tuple_element<_Indx, _Uj>::type>(std::__1::get<_Indx>(__uj));
}

template <class _Ti, class _Uj>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename enable_if
<
    !is_bind_expression<_Ti>::value &&
    is_placeholder<_Ti>::value == 0 &&
    !__is_reference_wrapper<_Ti>::value,
    _Ti&
>::type
__mu(_Ti& __ti, _Uj&)
{
    return __ti;
}

template <class _Ti, bool IsReferenceWrapper, bool IsBindEx, bool IsPh,
          class _TupleUj>
struct __mu_return_impl;

template <bool _Invokable, class _Ti, class ..._Uj>
struct __mu_return_invokable
{
    typedef __nat type;
};

template <class _Ti, class ..._Uj>
struct __mu_return_invokable<true, _Ti, _Uj...>
{
    typedef typename __invoke_of<_Ti&, _Uj...>::type type;
};

template <class _Ti, class ..._Uj>
struct __mu_return_impl<_Ti, false, true, false, tuple<_Uj...> >
    : public __mu_return_invokable<__invokable<_Ti&, _Uj...>::value, _Ti, _Uj...>
{
};

template <class _Ti, class _TupleUj>
struct __mu_return_impl<_Ti, false, false, true, _TupleUj>
{
    typedef typename tuple_element<is_placeholder<_Ti>::value - 1,
                                   _TupleUj>::type&& type;
};

template <class _Ti, class _TupleUj>
struct __mu_return_impl<_Ti, true, false, false, _TupleUj>
{
    typedef typename _Ti::type& type;
};

template <class _Ti, class _TupleUj>
struct __mu_return_impl<_Ti, false, false, false, _TupleUj>
{
    typedef _Ti& type;
};

template <class _Ti, class _TupleUj>
struct __mu_return
    : public __mu_return_impl<_Ti,
                              __is_reference_wrapper<_Ti>::value,
                              is_bind_expression<_Ti>::value,
                              0 < is_placeholder<_Ti>::value &&
                              is_placeholder<_Ti>::value <= tuple_size<_TupleUj>::value,
                              _TupleUj>
{
};

template <class _Fp, class _BoundArgs, class _TupleUj>
struct __is_valid_bind_return
{
    static const bool value = false;
};

template <class _Fp, class ..._BoundArgs, class _TupleUj>
struct __is_valid_bind_return<_Fp, tuple<_BoundArgs...>, _TupleUj>
{
    static const bool value = __invokable<_Fp,
                    typename __mu_return<_BoundArgs, _TupleUj>::type...>::value;
};

template <class _Fp, class ..._BoundArgs, class _TupleUj>
struct __is_valid_bind_return<_Fp, const tuple<_BoundArgs...>, _TupleUj>
{
    static const bool value = __invokable<_Fp,
                    typename __mu_return<const _BoundArgs, _TupleUj>::type...>::value;
};

template <class _Fp, class _BoundArgs, class _TupleUj,
          bool = __is_valid_bind_return<_Fp, _BoundArgs, _TupleUj>::value>
struct __bind_return;

template <class _Fp, class ..._BoundArgs, class _TupleUj>
struct __bind_return<_Fp, tuple<_BoundArgs...>, _TupleUj, true>
{
    typedef typename __invoke_of
    <
        _Fp&,
        typename __mu_return
        <
            _BoundArgs,
            _TupleUj
        >::type...
    >::type type;
};

template <class _Fp, class ..._BoundArgs, class _TupleUj>
struct __bind_return<_Fp, const tuple<_BoundArgs...>, _TupleUj, true>
{
    typedef typename __invoke_of
    <
        _Fp&,
        typename __mu_return
        <
            const _BoundArgs,
            _TupleUj
        >::type...
    >::type type;
};

template <class _Fp, class _BoundArgs, size_t ..._Indx, class _Args>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename __bind_return<_Fp, _BoundArgs, _Args>::type
__apply_functor(_Fp& __f, _BoundArgs& __bound_args, __tuple_indices<_Indx...>,
                _Args&& __args)
{
    return std::__1::__invoke(__f, std::__1::__mu(std::__1::get<_Indx>(__bound_args), __args)...);
}

template<class _Fp, class ..._BoundArgs>
class __bind

    : public __weak_result_type<typename decay<_Fp>::type>

{
protected:
    typedef typename decay<_Fp>::type _Fd;
    typedef tuple<typename decay<_BoundArgs>::type...> _Td;
private:
    _Fd __f_;
    _Td __bound_args_;

    typedef typename __make_tuple_indices<sizeof...(_BoundArgs)>::type __indices;
public:
    template <class _Gp, class ..._BA,
              class = typename enable_if
                               <
                                  is_constructible<_Fd, _Gp>::value &&
                                  !is_same<typename remove_reference<_Gp>::type,
                                           __bind>::value
                               >::type>
      __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
      explicit __bind(_Gp&& __f, _BA&& ...__bound_args)
        : __f_(std::__1::forward<_Gp>(__f)),
          __bound_args_(std::__1::forward<_BA>(__bound_args)...) {}

    template <class ..._Args>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        typename __bind_return<_Fd, _Td, tuple<_Args&&...> >::type
        operator()(_Args&& ...__args)
        {
            return std::__1::__apply_functor(__f_, __bound_args_, __indices(),
                                  tuple<_Args&&...>(std::__1::forward<_Args>(__args)...));
        }

    template <class ..._Args>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        typename __bind_return<const _Fd, const _Td, tuple<_Args&&...> >::type
        operator()(_Args&& ...__args) const
        {
            return std::__1::__apply_functor(__f_, __bound_args_, __indices(),
                                   tuple<_Args&&...>(std::__1::forward<_Args>(__args)...));
        }
};

template<class _Fp, class ..._BoundArgs>
struct __is_bind_expression<__bind<_Fp, _BoundArgs...> > : public true_type {};

template<class _Rp, class _Fp, class ..._BoundArgs>
class __bind_r
    : public __bind<_Fp, _BoundArgs...>
{
    typedef __bind<_Fp, _BoundArgs...> base;
    typedef typename base::_Fd _Fd;
    typedef typename base::_Td _Td;
public:
    typedef _Rp result_type;


    template <class _Gp, class ..._BA,
              class = typename enable_if
                               <
                                  is_constructible<_Fd, _Gp>::value &&
                                  !is_same<typename remove_reference<_Gp>::type,
                                           __bind_r>::value
                               >::type>
      __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
      explicit __bind_r(_Gp&& __f, _BA&& ...__bound_args)
        : base(std::__1::forward<_Gp>(__f),
               std::__1::forward<_BA>(__bound_args)...) {}

    template <class ..._Args>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        typename enable_if
        <
            is_convertible<typename __bind_return<_Fd, _Td, tuple<_Args&&...> >::type,
                           result_type>::value || is_void<_Rp>::value,
            result_type
        >::type
        operator()(_Args&& ...__args)
        {
            typedef __invoke_void_return_wrapper<_Rp> _Invoker;
            return _Invoker::__call(static_cast<base&>(*this), std::__1::forward<_Args>(__args)...);
        }

    template <class ..._Args>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        typename enable_if
        <
            is_convertible<typename __bind_return<const _Fd, const _Td, tuple<_Args&&...> >::type,
                           result_type>::value || is_void<_Rp>::value,
            result_type
        >::type
        operator()(_Args&& ...__args) const
        {
            typedef __invoke_void_return_wrapper<_Rp> _Invoker;
            return _Invoker::__call(static_cast<base const&>(*this), std::__1::forward<_Args>(__args)...);
        }
};

template<class _Rp, class _Fp, class ..._BoundArgs>
struct __is_bind_expression<__bind_r<_Rp, _Fp, _BoundArgs...> > : public true_type {};

template<class _Fp, class ..._BoundArgs>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
__bind<_Fp, _BoundArgs...>
bind(_Fp&& __f, _BoundArgs&&... __bound_args)
{
    typedef __bind<_Fp, _BoundArgs...> type;
    return type(std::__1::forward<_Fp>(__f), std::__1::forward<_BoundArgs>(__bound_args)...);
}

template<class _Rp, class _Fp, class ..._BoundArgs>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
__bind_r<_Rp, _Fp, _BoundArgs...>
bind(_Fp&& __f, _BoundArgs&&... __bound_args)
{
    typedef __bind_r<_Rp, _Fp, _BoundArgs...> type;
    return type(std::__1::forward<_Fp>(__f), std::__1::forward<_BoundArgs>(__bound_args)...);
}



} }
# 497 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/functional" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/binder1st.h" 1 3
# 18 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/binder1st.h" 3


namespace std { inline namespace __1 {
# 52 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/binder1st.h" 3
} }
# 498 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/functional" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/binder2nd.h" 1 3
# 18 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/binder2nd.h" 3


namespace std { inline namespace __1 {
# 52 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/binder2nd.h" 3
} }
# 499 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/functional" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/default_searcher.h" 1 3
# 21 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/default_searcher.h" 3


namespace std { inline namespace __1 {




template<class _ForwardIterator, class _BinaryPredicate = equal_to<>>
class __attribute__ ((__type_visibility__("default"))) default_searcher {
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    default_searcher(_ForwardIterator __f, _ForwardIterator __l,
                       _BinaryPredicate __p = _BinaryPredicate())
        : __first_(__f), __last_(__l), __pred_(__p) {}

    template <typename _ForwardIterator2>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    pair<_ForwardIterator2, _ForwardIterator2>
    operator () (_ForwardIterator2 __f, _ForwardIterator2 __l) const
    {
        return std::__1::__search(__f, __l, __first_, __last_, __pred_,
            typename iterator_traits<_ForwardIterator>::iterator_category(),
            typename iterator_traits<_ForwardIterator2>::iterator_category());
    }

private:
    _ForwardIterator __first_;
    _ForwardIterator __last_;
    _BinaryPredicate __pred_;
    };



} }
# 500 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/functional" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/function.h" 1 3
# 18 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/function.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/allocator_traits.h" 1 3
# 14 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/allocator_traits.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/construct_at.h" 1 3
# 20 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/construct_at.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 24 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/construct_at.h" 2 3

namespace std { inline namespace __1 {
# 46 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/construct_at.h" 3
template <class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void destroy_at(_Tp* __loc) {
    ((void)0);
    __loc->~_Tp();
}



} }
# 15 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/allocator_traits.h" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/pointer_traits.h" 1 3
# 15 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/pointer_traits.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 1 3
# 16 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/pointer_traits.h" 2 3
# 19 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/pointer_traits.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 23 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/pointer_traits.h" 2 3

namespace std { inline namespace __1 {

template <class _Tp, class = void>
struct __has_element_type : false_type {};

template <class _Tp>
struct __has_element_type<_Tp,
              typename __void_t<typename _Tp::element_type>::type> : true_type {};

template <class _Ptr, bool = __has_element_type<_Ptr>::value>
struct __pointer_traits_element_type;

template <class _Ptr>
struct __pointer_traits_element_type<_Ptr, true>
{
    typedef typename _Ptr::element_type type;
};

template <template <class, class...> class _Sp, class _Tp, class ..._Args>
struct __pointer_traits_element_type<_Sp<_Tp, _Args...>, true>
{
    typedef typename _Sp<_Tp, _Args...>::element_type type;
};

template <template <class, class...> class _Sp, class _Tp, class ..._Args>
struct __pointer_traits_element_type<_Sp<_Tp, _Args...>, false>
{
    typedef _Tp type;
};

template <class _Tp, class = void>
struct __has_difference_type : false_type {};

template <class _Tp>
struct __has_difference_type<_Tp,
            typename __void_t<typename _Tp::difference_type>::type> : true_type {};

template <class _Ptr, bool = __has_difference_type<_Ptr>::value>
struct __pointer_traits_difference_type
{
    typedef ptrdiff_t type;
};

template <class _Ptr>
struct __pointer_traits_difference_type<_Ptr, true>
{
    typedef typename _Ptr::difference_type type;
};

template <class _Tp, class _Up>
struct __has_rebind
{
private:
    struct __two {char __lx; char __lxx;};
    template <class _Xp> static __two __test(...);
#pragma GCC diagnostic push
# 79 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/pointer_traits.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated"
# 79 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/pointer_traits.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
    template <class _Xp> static char __test(typename _Xp::template rebind<_Up>* = 0);
#pragma GCC diagnostic pop
public:
    static const bool value = sizeof(__test<_Tp>(0)) == 1;
};

template <class _Tp, class _Up, bool = __has_rebind<_Tp, _Up>::value>
struct __pointer_traits_rebind
{

    typedef typename _Tp::template rebind<_Up> type;



};

template <template <class, class...> class _Sp, class _Tp, class ..._Args, class _Up>
struct __pointer_traits_rebind<_Sp<_Tp, _Args...>, _Up, true>
{

    typedef typename _Sp<_Tp, _Args...>::template rebind<_Up> type;



};

template <template <class, class...> class _Sp, class _Tp, class ..._Args, class _Up>
struct __pointer_traits_rebind<_Sp<_Tp, _Args...>, _Up, false>
{
    typedef _Sp<_Up, _Args...> type;
};

template <class _Ptr>
struct __attribute__ ((__type_visibility__("default"))) pointer_traits
{
    typedef _Ptr pointer;
    typedef typename __pointer_traits_element_type<pointer>::type element_type;
    typedef typename __pointer_traits_difference_type<pointer>::type difference_type;


    template <class _Up> using rebind = typename __pointer_traits_rebind<pointer, _Up>::type;





private:
    struct __nat {};
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    static pointer pointer_to(typename conditional<is_void<element_type>::value,
                                           __nat, element_type>::type& __r)
        {return pointer::pointer_to(__r);}
};

template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) pointer_traits<_Tp*>
{
    typedef _Tp* pointer;
    typedef _Tp element_type;
    typedef ptrdiff_t difference_type;


    template <class _Up> using rebind = _Up*;




private:
    struct __nat {};
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    static pointer pointer_to(typename conditional<is_void<element_type>::value,
                                      __nat, element_type>::type& __r) noexcept
        {return std::__1::addressof(__r);}
};

template <class _From, class _To>
struct __rebind_pointer {

    typedef typename pointer_traits<_From>::template rebind<_To> type;



};



template <class _Pointer, class = void>
struct __to_address_helper;

template <class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
_Tp* __to_address(_Tp* __p) noexcept {
    static_assert(!is_function<_Tp>::value, "_Tp is a function type");
    return __p;
}


template <class _Pointer, class = _EnableIf<!is_pointer<_Pointer>::value> >
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
typename decay<decltype(__to_address_helper<_Pointer>::__call(declval<const _Pointer&>()))>::type
__to_address(const _Pointer& __p) noexcept {
    return __to_address_helper<_Pointer>::__call(__p);
}

template <class _Pointer, class>
struct __to_address_helper {
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
    static decltype(std::__1::__to_address(declval<const _Pointer&>().operator->()))
    __call(const _Pointer&__p) noexcept {
        return std::__1::__to_address(__p.operator->());
    }
};

template <class _Pointer>
struct __to_address_helper<_Pointer, decltype((void)pointer_traits<_Pointer>::to_address(declval<const _Pointer&>()))> {
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
    static decltype(pointer_traits<_Pointer>::to_address(declval<const _Pointer&>()))
    __call(const _Pointer&__p) noexcept {
        return pointer_traits<_Pointer>::to_address(__p);
    }
};
# 212 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/pointer_traits.h" 3
} }
# 16 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/allocator_traits.h" 2 3


# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 1 3
# 19 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/allocator_traits.h" 2 3
# 22 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/allocator_traits.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 26 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/allocator_traits.h" 2 3

namespace std { inline namespace __1 {






template <class _Tp, class = void> struct __has_pointer : false_type { }; template <class _Tp> struct __has_pointer<_Tp, typename __void_t<typename _Tp:: pointer >::type> : true_type { };
template <class _Tp, class _Alloc,
          class _RawAlloc = typename remove_reference<_Alloc>::type,
          bool = __has_pointer<_RawAlloc>::value>
struct __pointer {
    using type = typename _RawAlloc::pointer;
};
template <class _Tp, class _Alloc, class _RawAlloc>
struct __pointer<_Tp, _Alloc, _RawAlloc, false> {
    using type = _Tp*;
};


template <class _Tp, class = void> struct __has_const_pointer : false_type { }; template <class _Tp> struct __has_const_pointer<_Tp, typename __void_t<typename _Tp:: const_pointer >::type> : true_type { };
template <class _Tp, class _Ptr, class _Alloc,
          bool = __has_const_pointer<_Alloc>::value>
struct __const_pointer {
    using type = typename _Alloc::const_pointer;
};
template <class _Tp, class _Ptr, class _Alloc>
struct __const_pointer<_Tp, _Ptr, _Alloc, false> {



    using type = typename pointer_traits<_Ptr>::template rebind<const _Tp>;

};


template <class _Tp, class = void> struct __has_void_pointer : false_type { }; template <class _Tp> struct __has_void_pointer<_Tp, typename __void_t<typename _Tp:: void_pointer >::type> : true_type { };
template <class _Ptr, class _Alloc,
          bool = __has_void_pointer<_Alloc>::value>
struct __void_pointer {
    using type = typename _Alloc::void_pointer;
};
template <class _Ptr, class _Alloc>
struct __void_pointer<_Ptr, _Alloc, false> {



    using type = typename pointer_traits<_Ptr>::template rebind<void>;

};


template <class _Tp, class = void> struct __has_const_void_pointer : false_type { }; template <class _Tp> struct __has_const_void_pointer<_Tp, typename __void_t<typename _Tp:: const_void_pointer >::type> : true_type { };
template <class _Ptr, class _Alloc,
          bool = __has_const_void_pointer<_Alloc>::value>
struct __const_void_pointer {
    using type = typename _Alloc::const_void_pointer;
};
template <class _Ptr, class _Alloc>
struct __const_void_pointer<_Ptr, _Alloc, false> {



    using type = typename pointer_traits<_Ptr>::template rebind<const void>;

};


template <class _Tp, class = void> struct __has_size_type : false_type { }; template <class _Tp> struct __has_size_type<_Tp, typename __void_t<typename _Tp:: size_type >::type> : true_type { };
template <class _Alloc, class _DiffType, bool = __has_size_type<_Alloc>::value>
struct __size_type : make_unsigned<_DiffType> { };
template <class _Alloc, class _DiffType>
struct __size_type<_Alloc, _DiffType, true> {
    using type = typename _Alloc::size_type;
};


template <class _Tp, class = void> struct __has_alloc_traits_difference_type : false_type { }; template <class _Tp> struct __has_alloc_traits_difference_type<_Tp, typename __void_t<typename _Tp:: difference_type >::type> : true_type { };
template <class _Alloc, class _Ptr, bool = __has_alloc_traits_difference_type<_Alloc>::value>
struct __alloc_traits_difference_type {
    using type = typename pointer_traits<_Ptr>::difference_type;
};
template <class _Alloc, class _Ptr>
struct __alloc_traits_difference_type<_Alloc, _Ptr, true> {
    using type = typename _Alloc::difference_type;
};


template <class _Tp, class = void> struct __has_propagate_on_container_copy_assignment : false_type { }; template <class _Tp> struct __has_propagate_on_container_copy_assignment<_Tp, typename __void_t<typename _Tp:: propagate_on_container_copy_assignment >::type> : true_type { };
template <class _Alloc, bool = __has_propagate_on_container_copy_assignment<_Alloc>::value>
struct __propagate_on_container_copy_assignment : false_type { };
template <class _Alloc>
struct __propagate_on_container_copy_assignment<_Alloc, true> {
    using type = typename _Alloc::propagate_on_container_copy_assignment;
};


template <class _Tp, class = void> struct __has_propagate_on_container_move_assignment : false_type { }; template <class _Tp> struct __has_propagate_on_container_move_assignment<_Tp, typename __void_t<typename _Tp:: propagate_on_container_move_assignment >::type> : true_type { };
template <class _Alloc, bool = __has_propagate_on_container_move_assignment<_Alloc>::value>
struct __propagate_on_container_move_assignment : false_type { };
template <class _Alloc>
struct __propagate_on_container_move_assignment<_Alloc, true> {
    using type = typename _Alloc::propagate_on_container_move_assignment;
};


template <class _Tp, class = void> struct __has_propagate_on_container_swap : false_type { }; template <class _Tp> struct __has_propagate_on_container_swap<_Tp, typename __void_t<typename _Tp:: propagate_on_container_swap >::type> : true_type { };
template <class _Alloc, bool = __has_propagate_on_container_swap<_Alloc>::value>
struct __propagate_on_container_swap : false_type { };
template <class _Alloc>
struct __propagate_on_container_swap<_Alloc, true> {
    using type = typename _Alloc::propagate_on_container_swap;
};


template <class _Tp, class = void> struct __has_is_always_equal : false_type { }; template <class _Tp> struct __has_is_always_equal<_Tp, typename __void_t<typename _Tp:: is_always_equal >::type> : true_type { };
template <class _Alloc, bool = __has_is_always_equal<_Alloc>::value>
struct __is_always_equal : is_empty<_Alloc> { };
template <class _Alloc>
struct __is_always_equal<_Alloc, true> {
    using type = typename _Alloc::is_always_equal;
};


#pragma GCC diagnostic push
# 151 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/allocator_traits.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated"
# 151 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/allocator_traits.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
template <class _Tp, class _Up, class = void>
struct __has_rebind_other : false_type { };
template <class _Tp, class _Up>
struct __has_rebind_other<_Tp, _Up, typename __void_t<
    typename _Tp::template rebind<_Up>::other
>::type> : true_type { };

template <class _Tp, class _Up, bool = __has_rebind_other<_Tp, _Up>::value>
struct __allocator_traits_rebind {
    using type = typename _Tp::template rebind<_Up>::other;
};
template <template <class, class...> class _Alloc, class _Tp, class ..._Args, class _Up>
struct __allocator_traits_rebind<_Alloc<_Tp, _Args...>, _Up, true> {
    using type = typename _Alloc<_Tp, _Args...>::template rebind<_Up>::other;
};
template <template <class, class...> class _Alloc, class _Tp, class ..._Args, class _Up>
struct __allocator_traits_rebind<_Alloc<_Tp, _Args...>, _Up, false> {
    using type = _Alloc<_Up, _Args...>;
};
#pragma GCC diagnostic pop

template<class _Alloc, class _Tp>
using __allocator_traits_rebind_t = typename __allocator_traits_rebind<_Alloc, _Tp>::type;

#pragma GCC diagnostic push
# 176 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/allocator_traits.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated"
# 176 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/allocator_traits.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"


template <class _Alloc, class _SizeType, class _ConstVoidPtr, class = void>
struct __has_allocate_hint : false_type { };

template <class _Alloc, class _SizeType, class _ConstVoidPtr>
struct __has_allocate_hint<_Alloc, _SizeType, _ConstVoidPtr, decltype(
    (void)declval<_Alloc>().allocate(declval<_SizeType>(), declval<_ConstVoidPtr>())
)> : true_type { };


template <class, class _Alloc, class ..._Args>
struct __has_construct_impl : false_type { };

template <class _Alloc, class ..._Args>
struct __has_construct_impl<decltype(
    (void)declval<_Alloc>().construct(declval<_Args>()...)
), _Alloc, _Args...> : true_type { };

template <class _Alloc, class ..._Args>
struct __has_construct : __has_construct_impl<void, _Alloc, _Args...> { };


template <class _Alloc, class _Pointer, class = void>
struct __has_destroy : false_type { };

template <class _Alloc, class _Pointer>
struct __has_destroy<_Alloc, _Pointer, decltype(
    (void)declval<_Alloc>().destroy(declval<_Pointer>())
)> : true_type { };


template <class _Alloc, class = void>
struct __has_max_size : false_type { };

template <class _Alloc>
struct __has_max_size<_Alloc, decltype(
    (void)declval<_Alloc&>().max_size()
)> : true_type { };


template <class _Alloc, class = void>
struct __has_select_on_container_copy_construction : false_type { };

template <class _Alloc>
struct __has_select_on_container_copy_construction<_Alloc, decltype(
    (void)declval<_Alloc>().select_on_container_copy_construction()
)> : true_type { };

#pragma GCC diagnostic pop

template <class _Alloc>
struct __attribute__ ((__type_visibility__("default"))) allocator_traits
{
    using allocator_type = _Alloc;
    using value_type = typename allocator_type::value_type;
    using pointer = typename __pointer<value_type, allocator_type>::type;
    using const_pointer = typename __const_pointer<value_type, pointer, allocator_type>::type;
    using void_pointer = typename __void_pointer<pointer, allocator_type>::type;
    using const_void_pointer = typename __const_void_pointer<pointer, allocator_type>::type;
    using difference_type = typename __alloc_traits_difference_type<allocator_type, pointer>::type;
    using size_type = typename __size_type<allocator_type, difference_type>::type;
    using propagate_on_container_copy_assignment = typename __propagate_on_container_copy_assignment<allocator_type>::type;
    using propagate_on_container_move_assignment = typename __propagate_on_container_move_assignment<allocator_type>::type;
    using propagate_on_container_swap = typename __propagate_on_container_swap<allocator_type>::type;
    using is_always_equal = typename __is_always_equal<allocator_type>::type;


    template <class _Tp>
    using rebind_alloc = __allocator_traits_rebind_t<allocator_type, _Tp>;
    template <class _Tp>
    using rebind_traits = allocator_traits<rebind_alloc<_Tp> >;
# 260 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/allocator_traits.h" 3
                                  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    static pointer allocate(allocator_type& __a, size_type __n) {
        return __a.allocate(__n);
    }

    template <class _Ap = _Alloc, class =
        _EnableIf<__has_allocate_hint<_Ap, size_type, const_void_pointer>::value> >
                                  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    static pointer allocate(allocator_type& __a, size_type __n, const_void_pointer __hint) {
#pragma GCC diagnostic push
# 269 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/allocator_traits.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated"
# 269 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/allocator_traits.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
        return __a.allocate(__n, __hint);
#pragma GCC diagnostic pop
    }
    template <class _Ap = _Alloc, class = void, class =
        _EnableIf<!__has_allocate_hint<_Ap, size_type, const_void_pointer>::value> >
                                  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    static pointer allocate(allocator_type& __a, size_type __n, const_void_pointer) {
        return __a.allocate(__n);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    static void deallocate(allocator_type& __a, pointer __p, size_type __n) noexcept {
        __a.deallocate(__p, __n);
    }

    template <class _Tp, class... _Args, class =
        _EnableIf<__has_construct<allocator_type, _Tp*, _Args...>::value> >
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    static void construct(allocator_type& __a, _Tp* __p, _Args&&... __args) {
#pragma GCC diagnostic push
# 289 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/allocator_traits.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated"
# 289 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/allocator_traits.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
        __a.construct(__p, std::__1::forward<_Args>(__args)...);
#pragma GCC diagnostic pop
    }
    template <class _Tp, class... _Args, class = void, class =
        _EnableIf<!__has_construct<allocator_type, _Tp*, _Args...>::value> >
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    static void construct(allocator_type&, _Tp* __p, _Args&&... __args) {



        ::new ((void*)__p) _Tp(std::__1::forward<_Args>(__args)...);

    }

    template <class _Tp, class =
        _EnableIf<__has_destroy<allocator_type, _Tp*>::value> >
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    static void destroy(allocator_type& __a, _Tp* __p) {
#pragma GCC diagnostic push
# 308 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/allocator_traits.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated"
# 308 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/allocator_traits.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
        __a.destroy(__p);
#pragma GCC diagnostic pop
    }
    template <class _Tp, class = void, class =
        _EnableIf<!__has_destroy<allocator_type, _Tp*>::value> >
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    static void destroy(allocator_type&, _Tp* __p) {



        __p->~_Tp();

    }

    template <class _Ap = _Alloc, class =
        _EnableIf<__has_max_size<const _Ap>::value> >
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    static size_type max_size(const allocator_type& __a) noexcept {
#pragma GCC diagnostic push
# 327 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/allocator_traits.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated"
# 327 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/allocator_traits.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
        return __a.max_size();
#pragma GCC diagnostic pop
    }
    template <class _Ap = _Alloc, class = void, class =
        _EnableIf<!__has_max_size<const _Ap>::value> >
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    static size_type max_size(const allocator_type&) noexcept {
        return numeric_limits<size_type>::max() / sizeof(value_type);
    }

    template <class _Ap = _Alloc, class =
        _EnableIf<__has_select_on_container_copy_construction<const _Ap>::value> >
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    static allocator_type select_on_container_copy_construction(const allocator_type& __a) {
        return __a.select_on_container_copy_construction();
    }
    template <class _Ap = _Alloc, class = void, class =
        _EnableIf<!__has_select_on_container_copy_construction<const _Ap>::value> >
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    static allocator_type select_on_container_copy_construction(const allocator_type& __a) {
        return __a;
    }
};

template <class _Traits, class _Tp>
struct __rebind_alloc_helper {

    using type = typename _Traits::template rebind_alloc<_Tp>;



};


template <class _Tp>
struct __is_default_allocator : false_type { };

template <class> class allocator;

template <class _Tp>
struct __is_default_allocator<allocator<_Tp> > : true_type { };


template <class _Alloc, class = void>
struct __is_cpp17_move_insertable
    : is_move_constructible<typename _Alloc::value_type>
{ };

template <class _Alloc>
struct __is_cpp17_move_insertable<_Alloc, _EnableIf<
    !__is_default_allocator<_Alloc>::value &&
    __has_construct<_Alloc, typename _Alloc::value_type*, typename _Alloc::value_type&&>::value
> > : true_type { };


template <class _Alloc, class = void>
struct __is_cpp17_copy_insertable
    : integral_constant<bool,
        is_copy_constructible<typename _Alloc::value_type>::value &&
        __is_cpp17_move_insertable<_Alloc>::value
    >
{ };

template <class _Alloc>
struct __is_cpp17_copy_insertable<_Alloc, _EnableIf<
    !__is_default_allocator<_Alloc>::value &&
    __has_construct<_Alloc, typename _Alloc::value_type*, const typename _Alloc::value_type&>::value
> >
    : __is_cpp17_move_insertable<_Alloc>
{ };



} }
# 19 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/function.h" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/compressed_pair.h" 1 3
# 16 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/compressed_pair.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 1 3
# 17 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/compressed_pair.h" 2 3
# 21 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/compressed_pair.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 25 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/compressed_pair.h" 2 3

namespace std { inline namespace __1 {


struct __default_init_tag {};
struct __value_init_tag {};

template <class _Tp, int _Idx,
          bool _CanBeEmptyBase =
              is_empty<_Tp>::value && !__libcpp_is_final<_Tp>::value>
struct __compressed_pair_elem {
  typedef _Tp _ParamT;
  typedef _Tp& reference;
  typedef const _Tp& const_reference;

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
  __compressed_pair_elem(__default_init_tag) {}
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
  __compressed_pair_elem(__value_init_tag) : __value_() {}

  template <class _Up, class = typename enable_if<
      !is_same<__compressed_pair_elem, typename decay<_Up>::type>::value
  >::type>
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  constexpr explicit
  __compressed_pair_elem(_Up&& __u)
      : __value_(std::__1::forward<_Up>(__u))
    {
    }



  template <class... _Args, size_t... _Indexes>
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
  __compressed_pair_elem(piecewise_construct_t, tuple<_Args...> __args,
                         __tuple_indices<_Indexes...>)
      : __value_(std::__1::forward<_Args>(std::__1::get<_Indexes>(__args))...) {}



  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) reference __get() noexcept { return __value_; }
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  const_reference __get() const noexcept { return __value_; }

private:
  _Tp __value_;
};

template <class _Tp, int _Idx>
struct __compressed_pair_elem<_Tp, _Idx, true> : private _Tp {
  typedef _Tp _ParamT;
  typedef _Tp& reference;
  typedef const _Tp& const_reference;
  typedef _Tp __value_type;

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr __compressed_pair_elem() = default;
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
  __compressed_pair_elem(__default_init_tag) {}
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
  __compressed_pair_elem(__value_init_tag) : __value_type() {}

  template <class _Up, class = typename enable_if<
        !is_same<__compressed_pair_elem, typename decay<_Up>::type>::value
  >::type>
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  constexpr explicit
  __compressed_pair_elem(_Up&& __u)
      : __value_type(std::__1::forward<_Up>(__u))
  {}


  template <class... _Args, size_t... _Indexes>
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
  __compressed_pair_elem(piecewise_construct_t, tuple<_Args...> __args,
                         __tuple_indices<_Indexes...>)
      : __value_type(std::__1::forward<_Args>(std::__1::get<_Indexes>(__args))...) {}


  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) reference __get() noexcept { return *this; }
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  const_reference __get() const noexcept { return *this; }
};

template <class _T1, class _T2>
class __compressed_pair : private __compressed_pair_elem<_T1, 0>,
                          private __compressed_pair_elem<_T2, 1> {
public:




  static_assert((!is_same<_T1, _T2>::value),
    "__compressed_pair cannot be instantiated when T1 and T2 are the same type; "
    "The current implementation is NOT ABI-compatible with the previous "
    "implementation for this configuration");

    typedef __compressed_pair_elem<_T1, 0> _Base1;
    typedef __compressed_pair_elem<_T2, 1> _Base2;

    template <bool _Dummy = true,
      class = typename enable_if<
          __dependent_type<is_default_constructible<_T1>, _Dummy>::value &&
          __dependent_type<is_default_constructible<_T2>, _Dummy>::value
      >::type
  >
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  constexpr __compressed_pair() : _Base1(__value_init_tag()), _Base2(__value_init_tag()) {}

  template <class _U1, class _U2>
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
  __compressed_pair(_U1&& __t1, _U2&& __t2)
      : _Base1(std::__1::forward<_U1>(__t1)), _Base2(std::__1::forward<_U2>(__t2)) {}


  template <class... _Args1, class... _Args2>
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
  __compressed_pair(piecewise_construct_t __pc, tuple<_Args1...> __first_args,
                    tuple<_Args2...> __second_args)
      : _Base1(__pc, std::__1::move(__first_args),
               typename __make_tuple_indices<sizeof...(_Args1)>::type()),
        _Base2(__pc, std::__1::move(__second_args),
               typename __make_tuple_indices<sizeof...(_Args2)>::type()) {}


  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  typename _Base1::reference first() noexcept {
    return static_cast<_Base1&>(*this).__get();
  }

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  typename _Base1::const_reference first() const noexcept {
    return static_cast<_Base1 const&>(*this).__get();
  }

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  typename _Base2::reference second() noexcept {
    return static_cast<_Base2&>(*this).__get();
  }

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  typename _Base2::const_reference second() const noexcept {
    return static_cast<_Base2 const&>(*this).__get();
  }

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
  static _Base1* __get_first_base(__compressed_pair* __pair) noexcept {
    return static_cast<_Base1*>(__pair);
  }
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
  static _Base2* __get_second_base(__compressed_pair* __pair) noexcept {
    return static_cast<_Base2*>(__pair);
  }

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  void swap(__compressed_pair& __x)
    noexcept(__is_nothrow_swappable<_T1>::value && __is_nothrow_swappable<_T2>::value)

  {
    using std::__1::swap;
    swap(first(), __x.first());
    swap(second(), __x.second());
  }
};

template <class _T1, class _T2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void swap(__compressed_pair<_T1, _T2>& __x, __compressed_pair<_T1, _T2>& __y)
    noexcept(__is_nothrow_swappable<_T1>::value && __is_nothrow_swappable<_T2>::value) {

  __x.swap(__y);
}

} }
# 20 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/function.h" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/shared_ptr.h" 1 3
# 20 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/shared_ptr.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/allocation_guard.h" 1 3
# 20 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/allocation_guard.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 24 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/allocation_guard.h" 2 3


namespace std { inline namespace __1 {
# 47 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/allocation_guard.h" 3
template<class _Alloc>
struct __allocation_guard {
    using _Pointer = typename allocator_traits<_Alloc>::pointer;
    using _Size = typename allocator_traits<_Alloc>::size_type;

    template<class _AllocT>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit __allocation_guard(_AllocT __alloc, _Size __n)
        : __alloc_(std::__1::move(__alloc))
        , __n_(__n)
        , __ptr_(allocator_traits<_Alloc>::allocate(__alloc_, __n_))
    { }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    ~__allocation_guard() noexcept {
        if (__ptr_ != nullptr) {
            allocator_traits<_Alloc>::deallocate(__alloc_, __ptr_, __n_);
        }
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    _Pointer __release_ptr() noexcept {
        _Pointer __tmp = __ptr_;
        __ptr_ = nullptr;
        return __tmp;
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    _Pointer __get() const noexcept {
        return __ptr_;
    }

private:
    _Alloc __alloc_;
    _Size __n_;
    _Pointer __ptr_;
};

} }
# 21 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/shared_ptr.h" 2 3

# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/allocator.h" 1 3
# 19 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/allocator.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 1 3
# 20 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/allocator.h" 2 3
# 23 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/allocator.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 27 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/allocator.h" 2 3

namespace std { inline namespace __1 {

template <class _Tp> class allocator;


template <>
class __attribute__ ((__type_visibility__("default"))) allocator<void>
{
public:
    __attribute__ ((deprecated)) typedef void* pointer;
    __attribute__ ((deprecated)) typedef const void* const_pointer;
    __attribute__ ((deprecated)) typedef void value_type;

    template <class _Up> struct __attribute__ ((deprecated)) rebind {typedef allocator<_Up> other;};
};

template <>
class __attribute__ ((__type_visibility__("default"))) allocator<const void>
{
public:
    __attribute__ ((deprecated)) typedef const void* pointer;
    __attribute__ ((deprecated)) typedef const void* const_pointer;
    __attribute__ ((deprecated)) typedef const void value_type;

    template <class _Up> struct __attribute__ ((deprecated)) rebind {typedef allocator<_Up> other;};
};
# 68 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/allocator.h" 3
template <bool _Cond, class _Unique>
struct __non_trivial_if { };

template <class _Unique>
struct __non_trivial_if<true, _Unique> {
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    constexpr __non_trivial_if() noexcept { }
};






template <class _Tp>
class __attribute__ ((__type_visibility__("default"))) allocator
    : private __non_trivial_if<!is_void<_Tp>::value, allocator<_Tp> >
{
public:
    typedef size_t size_type;
    typedef ptrdiff_t difference_type;
    typedef _Tp value_type;
    typedef true_type propagate_on_container_move_assignment;
    typedef true_type is_always_equal;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    allocator() noexcept = default;

    template <class _Up>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    allocator(const allocator<_Up>&) noexcept { }

                                  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    _Tp* allocate(size_t __n) {
        if (__n > allocator_traits<allocator>::max_size(*this))
            __throw_length_error("allocator<T>::allocate(size_t n)"
                                 " 'n' exceeds maximum supported size");
        if (__libcpp_is_constant_evaluated()) {
            return static_cast<_Tp*>(::operator new(__n * sizeof(_Tp)));
        } else {
            return static_cast<_Tp*>(std::__1::__libcpp_allocate(__n * sizeof(_Tp), alignof(_Tp)));
        }
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void deallocate(_Tp* __p, size_t __n) noexcept {
        if (__libcpp_is_constant_evaluated()) {
            ::operator delete(__p);
        } else {
            std::__1::__libcpp_deallocate((void*)__p, __n * sizeof(_Tp), alignof(_Tp));
        }
    }



    __attribute__ ((deprecated)) typedef _Tp* pointer;
    __attribute__ ((deprecated)) typedef const _Tp* const_pointer;
    __attribute__ ((deprecated)) typedef _Tp& reference;
    __attribute__ ((deprecated)) typedef const _Tp& const_reference;

    template <class _Up>
    struct __attribute__ ((deprecated)) rebind {
        typedef allocator<_Up> other;
    };

    __attribute__ ((deprecated)) __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    pointer address(reference __x) const noexcept {
        return std::__1::addressof(__x);
    }
    __attribute__ ((deprecated)) __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_pointer address(const_reference __x) const noexcept {
        return std::__1::addressof(__x);
    }

                                  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) __attribute__ ((deprecated))
    _Tp* allocate(size_t __n, const void*) {
        return allocate(__n);
    }

    __attribute__ ((deprecated)) __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) size_type max_size() const noexcept {
        return size_type(~0) / sizeof(_Tp);
    }

    template <class _Up, class... _Args>
    __attribute__ ((deprecated)) __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void construct(_Up* __p, _Args&&... __args) {
        ::new ((void*)__p) _Up(std::__1::forward<_Args>(__args)...);
    }

    __attribute__ ((deprecated)) __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void destroy(pointer __p) {
        __p->~_Tp();
    }

};

template <class _Tp>
class __attribute__ ((__type_visibility__("default"))) allocator<const _Tp>
    : private __non_trivial_if<!is_void<_Tp>::value, allocator<const _Tp> >
{
public:
    typedef size_t size_type;
    typedef ptrdiff_t difference_type;
    typedef const _Tp value_type;
    typedef true_type propagate_on_container_move_assignment;
    typedef true_type is_always_equal;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    allocator() noexcept = default;

    template <class _Up>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    allocator(const allocator<_Up>&) noexcept { }

                                  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const _Tp* allocate(size_t __n) {
        if (__n > allocator_traits<allocator>::max_size(*this))
            __throw_length_error("allocator<const T>::allocate(size_t n)"
                                 " 'n' exceeds maximum supported size");
        if (__libcpp_is_constant_evaluated()) {
            return static_cast<const _Tp*>(::operator new(__n * sizeof(_Tp)));
        } else {
            return static_cast<const _Tp*>(std::__1::__libcpp_allocate(__n * sizeof(_Tp), alignof(_Tp)));
        }
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void deallocate(const _Tp* __p, size_t __n) {
        if (__libcpp_is_constant_evaluated()) {
            ::operator delete(const_cast<_Tp*>(__p));
        } else {
            std::__1::__libcpp_deallocate((void*) const_cast<_Tp *>(__p), __n * sizeof(_Tp), alignof(_Tp));
        }
    }



    __attribute__ ((deprecated)) typedef const _Tp* pointer;
    __attribute__ ((deprecated)) typedef const _Tp* const_pointer;
    __attribute__ ((deprecated)) typedef const _Tp& reference;
    __attribute__ ((deprecated)) typedef const _Tp& const_reference;

    template <class _Up>
    struct __attribute__ ((deprecated)) rebind {
        typedef allocator<_Up> other;
    };

    __attribute__ ((deprecated)) __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_pointer address(const_reference __x) const noexcept {
        return std::__1::addressof(__x);
    }

                                  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) __attribute__ ((deprecated))
    const _Tp* allocate(size_t __n, const void*) {
        return allocate(__n);
    }

    __attribute__ ((deprecated)) __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) size_type max_size() const noexcept {
        return size_type(~0) / sizeof(_Tp);
    }

    template <class _Up, class... _Args>
    __attribute__ ((deprecated)) __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void construct(_Up* __p, _Args&&... __args) {
        ::new ((void*)__p) _Up(std::__1::forward<_Args>(__args)...);
    }

    __attribute__ ((deprecated)) __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void destroy(pointer __p) {
        __p->~_Tp();
    }

};

template <class _Tp, class _Up>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool operator==(const allocator<_Tp>&, const allocator<_Up>&) noexcept {return true;}

template <class _Tp, class _Up>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool operator!=(const allocator<_Tp>&, const allocator<_Up>&) noexcept {return false;}

} }
# 23 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/shared_ptr.h" 2 3


# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/unique_ptr.h" 1 3
# 15 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/unique_ptr.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/hash.h" 1 3
# 23 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/hash.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 1 3
# 24 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/hash.h" 2 3
# 27 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/hash.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/hash.h" 2 3

namespace std { inline namespace __1 {

template <class _Size>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
_Size
__loadword(const void* __p)
{
    _Size __r;
    std::__1::memcpy(&__r, __p, sizeof(__r));
    return __r;
}




template <class _Size, size_t = sizeof(_Size)*8>
struct __murmur2_or_cityhash;

template <class _Size>
struct __murmur2_or_cityhash<_Size, 32>
{
    inline _Size operator()(const void* __key, _Size __len)
         __attribute__((__no_sanitize__("unsigned-integer-overflow")));
};


template <class _Size>
_Size
__murmur2_or_cityhash<_Size, 32>::operator()(const void* __key, _Size __len)
{
    const _Size __m = 0x5bd1e995;
    const _Size __r = 24;
    _Size __h = __len;
    const unsigned char* __data = static_cast<const unsigned char*>(__key);
    for (; __len >= 4; __data += 4, __len -= 4)
    {
        _Size __k = __loadword<_Size>(__data);
        __k *= __m;
        __k ^= __k >> __r;
        __k *= __m;
        __h *= __m;
        __h ^= __k;
    }
    switch (__len)
    {
    case 3:
        __h ^= static_cast<_Size>(__data[2] << 16);
        [[fallthrough]];
    case 2:
        __h ^= static_cast<_Size>(__data[1] << 8);
        [[fallthrough]];
    case 1:
        __h ^= __data[0];
        __h *= __m;
    }
    __h ^= __h >> 13;
    __h *= __m;
    __h ^= __h >> 15;
    return __h;
}

template <class _Size>
struct __murmur2_or_cityhash<_Size, 64>
{
    inline _Size operator()(const void* __key, _Size __len) __attribute__((__no_sanitize__("unsigned-integer-overflow")));

 private:

  static const _Size __k0 = 0xc3a5c85c97cb3127ULL;
  static const _Size __k1 = 0xb492b66fbe98f273ULL;
  static const _Size __k2 = 0x9ae16a3b2f90404fULL;
  static const _Size __k3 = 0xc949d7c7509e6557ULL;

  static _Size __rotate(_Size __val, int __shift) {
    return __shift == 0 ? __val : ((__val >> __shift) | (__val << (64 - __shift)));
  }

  static _Size __rotate_by_at_least_1(_Size __val, int __shift) {
    return (__val >> __shift) | (__val << (64 - __shift));
  }

  static _Size __shift_mix(_Size __val) {
    return __val ^ (__val >> 47);
  }

  static _Size __hash_len_16(_Size __u, _Size __v)
     __attribute__((__no_sanitize__("unsigned-integer-overflow")))
  {
    const _Size __mul = 0x9ddfea08eb382d69ULL;
    _Size __a = (__u ^ __v) * __mul;
    __a ^= (__a >> 47);
    _Size __b = (__v ^ __a) * __mul;
    __b ^= (__b >> 47);
    __b *= __mul;
    return __b;
  }

  static _Size __hash_len_0_to_16(const char* __s, _Size __len)
     __attribute__((__no_sanitize__("unsigned-integer-overflow")))
  {
    if (__len > 8) {
      const _Size __a = __loadword<_Size>(__s);
      const _Size __b = __loadword<_Size>(__s + __len - 8);
      return __hash_len_16(__a, __rotate_by_at_least_1(__b + __len, __len)) ^ __b;
    }
    if (__len >= 4) {
      const uint32_t __a = __loadword<uint32_t>(__s);
      const uint32_t __b = __loadword<uint32_t>(__s + __len - 4);
      return __hash_len_16(__len + (__a << 3), __b);
    }
    if (__len > 0) {
      const unsigned char __a = static_cast<unsigned char>(__s[0]);
      const unsigned char __b = static_cast<unsigned char>(__s[__len >> 1]);
      const unsigned char __c = static_cast<unsigned char>(__s[__len - 1]);
      const uint32_t __y = static_cast<uint32_t>(__a) +
                           (static_cast<uint32_t>(__b) << 8);
      const uint32_t __z = __len + (static_cast<uint32_t>(__c) << 2);
      return __shift_mix(__y * __k2 ^ __z * __k3) * __k2;
    }
    return __k2;
  }

  static _Size __hash_len_17_to_32(const char *__s, _Size __len)
     __attribute__((__no_sanitize__("unsigned-integer-overflow")))
  {
    const _Size __a = __loadword<_Size>(__s) * __k1;
    const _Size __b = __loadword<_Size>(__s + 8);
    const _Size __c = __loadword<_Size>(__s + __len - 8) * __k2;
    const _Size __d = __loadword<_Size>(__s + __len - 16) * __k0;
    return __hash_len_16(__rotate(__a - __b, 43) + __rotate(__c, 30) + __d,
                         __a + __rotate(__b ^ __k3, 20) - __c + __len);
  }



  static pair<_Size, _Size> __weak_hash_len_32_with_seeds(
      _Size __w, _Size __x, _Size __y, _Size __z, _Size __a, _Size __b)
        __attribute__((__no_sanitize__("unsigned-integer-overflow")))
  {
    __a += __w;
    __b = __rotate(__b + __a + __z, 21);
    const _Size __c = __a;
    __a += __x;
    __a += __y;
    __b += __rotate(__a, 44);
    return pair<_Size, _Size>(__a + __z, __b + __c);
  }


  static pair<_Size, _Size> __weak_hash_len_32_with_seeds(
      const char* __s, _Size __a, _Size __b)
    __attribute__((__no_sanitize__("unsigned-integer-overflow")))
  {
    return __weak_hash_len_32_with_seeds(__loadword<_Size>(__s),
                                         __loadword<_Size>(__s + 8),
                                         __loadword<_Size>(__s + 16),
                                         __loadword<_Size>(__s + 24),
                                         __a,
                                         __b);
  }


  static _Size __hash_len_33_to_64(const char *__s, size_t __len)
    __attribute__((__no_sanitize__("unsigned-integer-overflow")))
  {
    _Size __z = __loadword<_Size>(__s + 24);
    _Size __a = __loadword<_Size>(__s) +
                (__len + __loadword<_Size>(__s + __len - 16)) * __k0;
    _Size __b = __rotate(__a + __z, 52);
    _Size __c = __rotate(__a, 37);
    __a += __loadword<_Size>(__s + 8);
    __c += __rotate(__a, 7);
    __a += __loadword<_Size>(__s + 16);
    _Size __vf = __a + __z;
    _Size __vs = __b + __rotate(__a, 31) + __c;
    __a = __loadword<_Size>(__s + 16) + __loadword<_Size>(__s + __len - 32);
    __z += __loadword<_Size>(__s + __len - 8);
    __b = __rotate(__a + __z, 52);
    __c = __rotate(__a, 37);
    __a += __loadword<_Size>(__s + __len - 24);
    __c += __rotate(__a, 7);
    __a += __loadword<_Size>(__s + __len - 16);
    _Size __wf = __a + __z;
    _Size __ws = __b + __rotate(__a, 31) + __c;
    _Size __r = __shift_mix((__vf + __ws) * __k2 + (__wf + __vs) * __k0);
    return __shift_mix(__r * __k0 + __vs) * __k2;
  }
};


template <class _Size>
_Size
__murmur2_or_cityhash<_Size, 64>::operator()(const void* __key, _Size __len)
{
  const char* __s = static_cast<const char*>(__key);
  if (__len <= 32) {
    if (__len <= 16) {
      return __hash_len_0_to_16(__s, __len);
    } else {
      return __hash_len_17_to_32(__s, __len);
    }
  } else if (__len <= 64) {
    return __hash_len_33_to_64(__s, __len);
  }



  _Size __x = __loadword<_Size>(__s + __len - 40);
  _Size __y = __loadword<_Size>(__s + __len - 16) +
              __loadword<_Size>(__s + __len - 56);
  _Size __z = __hash_len_16(__loadword<_Size>(__s + __len - 48) + __len,
                          __loadword<_Size>(__s + __len - 24));
  pair<_Size, _Size> __v = __weak_hash_len_32_with_seeds(__s + __len - 64, __len, __z);
  pair<_Size, _Size> __w = __weak_hash_len_32_with_seeds(__s + __len - 32, __y + __k1, __x);
  __x = __x * __k1 + __loadword<_Size>(__s);


  __len = (__len - 1) & ~static_cast<_Size>(63);
  do {
    __x = __rotate(__x + __y + __v.first + __loadword<_Size>(__s + 8), 37) * __k1;
    __y = __rotate(__y + __v.second + __loadword<_Size>(__s + 48), 42) * __k1;
    __x ^= __w.second;
    __y += __v.first + __loadword<_Size>(__s + 40);
    __z = __rotate(__z + __w.first, 33) * __k1;
    __v = __weak_hash_len_32_with_seeds(__s, __v.second * __k1, __x + __w.first);
    __w = __weak_hash_len_32_with_seeds(__s + 32, __z + __w.second,
                                        __y + __loadword<_Size>(__s + 16));
    std::__1::swap(__z, __x);
    __s += 64;
    __len -= 64;
  } while (__len != 0);
  return __hash_len_16(
      __hash_len_16(__v.first, __w.first) + __shift_mix(__y) * __k1 + __z,
      __hash_len_16(__v.second, __w.second) + __x);
}

template <class _Tp, size_t = sizeof(_Tp) / sizeof(size_t)>
struct __scalar_hash;

#pragma GCC diagnostic push
# 271 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/hash.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated"
# 271 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/hash.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
template <class _Tp>
struct __scalar_hash<_Tp, 0>

    : public unary_function<_Tp, size_t>

{
#pragma GCC diagnostic pop

    __attribute__ ((deprecated)) typedef size_t result_type;
    __attribute__ ((deprecated)) typedef _Tp argument_type;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_t operator()(_Tp __v) const noexcept
    {
        union
        {
            _Tp __t;
            size_t __a;
        } __u;
        __u.__a = 0;
        __u.__t = __v;
        return __u.__a;
    }
};

#pragma GCC diagnostic push
# 297 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/hash.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated"
# 297 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/hash.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
template <class _Tp>
struct __scalar_hash<_Tp, 1>

    : public unary_function<_Tp, size_t>

{
#pragma GCC diagnostic pop

    __attribute__ ((deprecated)) typedef size_t result_type;
    __attribute__ ((deprecated)) typedef _Tp argument_type;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_t operator()(_Tp __v) const noexcept
    {
        union
        {
            _Tp __t;
            size_t __a;
        } __u;
        __u.__t = __v;
        return __u.__a;
    }
};

#pragma GCC diagnostic push
# 322 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/hash.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated"
# 322 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/hash.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
template <class _Tp>
struct __scalar_hash<_Tp, 2>

    : public unary_function<_Tp, size_t>

{
#pragma GCC diagnostic pop

    __attribute__ ((deprecated)) typedef size_t result_type;
    __attribute__ ((deprecated)) typedef _Tp argument_type;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_t operator()(_Tp __v) const noexcept
    {
        union
        {
            _Tp __t;
            struct
            {
                size_t __a;
                size_t __b;
            } __s;
        } __u;
        __u.__t = __v;
        return __murmur2_or_cityhash<size_t>()(&__u, sizeof(__u));
    }
};

#pragma GCC diagnostic push
# 351 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/hash.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated"
# 351 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/hash.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
template <class _Tp>
struct __scalar_hash<_Tp, 3>

    : public unary_function<_Tp, size_t>

{
#pragma GCC diagnostic pop

    __attribute__ ((deprecated)) typedef size_t result_type;
    __attribute__ ((deprecated)) typedef _Tp argument_type;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_t operator()(_Tp __v) const noexcept
    {
        union
        {
            _Tp __t;
            struct
            {
                size_t __a;
                size_t __b;
                size_t __c;
            } __s;
        } __u;
        __u.__t = __v;
        return __murmur2_or_cityhash<size_t>()(&__u, sizeof(__u));
    }
};

#pragma GCC diagnostic push
# 381 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/hash.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated"
# 381 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/hash.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
template <class _Tp>
struct __scalar_hash<_Tp, 4>

    : public unary_function<_Tp, size_t>

{
#pragma GCC diagnostic pop

    __attribute__ ((deprecated)) typedef size_t result_type;
    __attribute__ ((deprecated)) typedef _Tp argument_type;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_t operator()(_Tp __v) const noexcept
    {
        union
        {
            _Tp __t;
            struct
            {
                size_t __a;
                size_t __b;
                size_t __c;
                size_t __d;
            } __s;
        } __u;
        __u.__t = __v;
        return __murmur2_or_cityhash<size_t>()(&__u, sizeof(__u));
    }
};

struct _PairT {
  size_t first;
  size_t second;
};

__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
inline size_t __hash_combine(size_t __lhs, size_t __rhs) noexcept {
    typedef __scalar_hash<_PairT> _HashT;
    const _PairT __p = {__lhs, __rhs};
    return _HashT()(__p);
}

#pragma GCC diagnostic push
# 424 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/hash.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated"
# 424 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/hash.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
template<class _Tp>
struct __attribute__ ((__type_visibility__("default"))) hash<_Tp*>

    : public unary_function<_Tp*, size_t>

{
#pragma GCC diagnostic pop

    __attribute__ ((deprecated)) typedef size_t result_type;
    __attribute__ ((deprecated)) typedef _Tp* argument_type;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_t operator()(_Tp* __v) const noexcept
    {
        union
        {
            _Tp* __t;
            size_t __a;
        } __u;
        __u.__t = __v;
        return __murmur2_or_cityhash<size_t>()(&__u, sizeof(__u));
    }
};

#pragma GCC diagnostic push
# 449 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/hash.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated"
# 449 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/hash.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
template <>
struct __attribute__ ((__type_visibility__("default"))) hash<bool>

    : public unary_function<bool, size_t>

{
#pragma GCC diagnostic pop

    __attribute__ ((deprecated)) typedef size_t result_type;
    __attribute__ ((deprecated)) typedef bool argument_type;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_t operator()(bool __v) const noexcept {return static_cast<size_t>(__v);}
};

#pragma GCC diagnostic push
# 465 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/hash.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated"
# 465 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/hash.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
template <>
struct __attribute__ ((__type_visibility__("default"))) hash<char>

    : public unary_function<char, size_t>

{
#pragma GCC diagnostic pop

    __attribute__ ((deprecated)) typedef size_t result_type;
    __attribute__ ((deprecated)) typedef char argument_type;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_t operator()(char __v) const noexcept {return static_cast<size_t>(__v);}
};

#pragma GCC diagnostic push
# 481 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/hash.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated"
# 481 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/hash.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
template <>
struct __attribute__ ((__type_visibility__("default"))) hash<signed char>

    : public unary_function<signed char, size_t>

{
#pragma GCC diagnostic pop

    __attribute__ ((deprecated)) typedef size_t result_type;
    __attribute__ ((deprecated)) typedef signed char argument_type;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_t operator()(signed char __v) const noexcept {return static_cast<size_t>(__v);}
};

#pragma GCC diagnostic push
# 497 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/hash.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated"
# 497 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/hash.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
template <>
struct __attribute__ ((__type_visibility__("default"))) hash<unsigned char>

    : public unary_function<unsigned char, size_t>

{
#pragma GCC diagnostic pop

    __attribute__ ((deprecated)) typedef size_t result_type;
    __attribute__ ((deprecated)) typedef unsigned char argument_type;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_t operator()(unsigned char __v) const noexcept {return static_cast<size_t>(__v);}
};
# 533 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/hash.h" 3
#pragma GCC diagnostic push
# 533 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/hash.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated"
# 533 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/hash.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
template <>
struct __attribute__ ((__type_visibility__("default"))) hash<char16_t>

    : public unary_function<char16_t, size_t>

{
#pragma GCC diagnostic pop

    __attribute__ ((deprecated)) typedef size_t result_type;
    __attribute__ ((deprecated)) typedef char16_t argument_type;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_t operator()(char16_t __v) const noexcept {return static_cast<size_t>(__v);}
};

#pragma GCC diagnostic push
# 549 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/hash.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated"
# 549 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/hash.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
template <>
struct __attribute__ ((__type_visibility__("default"))) hash<char32_t>

    : public unary_function<char32_t, size_t>

{
#pragma GCC diagnostic pop

    __attribute__ ((deprecated)) typedef size_t result_type;
    __attribute__ ((deprecated)) typedef char32_t argument_type;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_t operator()(char32_t __v) const noexcept {return static_cast<size_t>(__v);}
};




#pragma GCC diagnostic push
# 568 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/hash.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated"
# 568 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/hash.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
template <>
struct __attribute__ ((__type_visibility__("default"))) hash<wchar_t>

    : public unary_function<wchar_t, size_t>

{
#pragma GCC diagnostic pop

    __attribute__ ((deprecated)) typedef size_t result_type;
    __attribute__ ((deprecated)) typedef wchar_t argument_type;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_t operator()(wchar_t __v) const noexcept {return static_cast<size_t>(__v);}
};


#pragma GCC diagnostic push
# 585 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/hash.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated"
# 585 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/hash.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
template <>
struct __attribute__ ((__type_visibility__("default"))) hash<short>

    : public unary_function<short, size_t>

{
#pragma GCC diagnostic pop

    __attribute__ ((deprecated)) typedef size_t result_type;
    __attribute__ ((deprecated)) typedef short argument_type;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_t operator()(short __v) const noexcept {return static_cast<size_t>(__v);}
};

#pragma GCC diagnostic push
# 601 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/hash.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated"
# 601 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/hash.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
template <>
struct __attribute__ ((__type_visibility__("default"))) hash<unsigned short>

    : public unary_function<unsigned short, size_t>

{
#pragma GCC diagnostic pop

    __attribute__ ((deprecated)) typedef size_t result_type;
    __attribute__ ((deprecated)) typedef unsigned short argument_type;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_t operator()(unsigned short __v) const noexcept {return static_cast<size_t>(__v);}
};

#pragma GCC diagnostic push
# 617 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/hash.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated"
# 617 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/hash.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
template <>
struct __attribute__ ((__type_visibility__("default"))) hash<int>

    : public unary_function<int, size_t>

{
#pragma GCC diagnostic pop

    __attribute__ ((deprecated)) typedef size_t result_type;
    __attribute__ ((deprecated)) typedef int argument_type;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_t operator()(int __v) const noexcept {return static_cast<size_t>(__v);}
};

#pragma GCC diagnostic push
# 633 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/hash.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated"
# 633 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/hash.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
template <>
struct __attribute__ ((__type_visibility__("default"))) hash<unsigned int>

    : public unary_function<unsigned int, size_t>

{
#pragma GCC diagnostic pop

    __attribute__ ((deprecated)) typedef size_t result_type;
    __attribute__ ((deprecated)) typedef unsigned int argument_type;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_t operator()(unsigned int __v) const noexcept {return static_cast<size_t>(__v);}
};

#pragma GCC diagnostic push
# 649 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/hash.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated"
# 649 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/hash.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
template <>
struct __attribute__ ((__type_visibility__("default"))) hash<long>

    : public unary_function<long, size_t>

{
#pragma GCC diagnostic pop

    __attribute__ ((deprecated)) typedef size_t result_type;
    __attribute__ ((deprecated)) typedef long argument_type;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_t operator()(long __v) const noexcept {return static_cast<size_t>(__v);}
};

#pragma GCC diagnostic push
# 665 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/hash.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated"
# 665 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/hash.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
template <>
struct __attribute__ ((__type_visibility__("default"))) hash<unsigned long>

    : public unary_function<unsigned long, size_t>

{
#pragma GCC diagnostic pop

    __attribute__ ((deprecated)) typedef size_t result_type;
    __attribute__ ((deprecated)) typedef unsigned long argument_type;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_t operator()(unsigned long __v) const noexcept {return static_cast<size_t>(__v);}
};

template <>
struct __attribute__ ((__type_visibility__("default"))) hash<long long>
    : public __scalar_hash<long long>
{
};

template <>
struct __attribute__ ((__type_visibility__("default"))) hash<unsigned long long>
    : public __scalar_hash<unsigned long long>
{
};



template <>
struct __attribute__ ((__type_visibility__("default"))) hash<__int128_t>
    : public __scalar_hash<__int128_t>
{
};

template <>
struct __attribute__ ((__type_visibility__("default"))) hash<__uint128_t>
    : public __scalar_hash<__uint128_t>
{
};



template <>
struct __attribute__ ((__type_visibility__("default"))) hash<float>
    : public __scalar_hash<float>
{
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_t operator()(float __v) const noexcept
    {

       if (__v == 0.0f)
           return 0;
        return __scalar_hash<float>::operator()(__v);
    }
};

template <>
struct __attribute__ ((__type_visibility__("default"))) hash<double>
    : public __scalar_hash<double>
{
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_t operator()(double __v) const noexcept
    {

       if (__v == 0.0)
           return 0;
        return __scalar_hash<double>::operator()(__v);
    }
};

template <>
struct __attribute__ ((__type_visibility__("default"))) hash<long double>
    : public __scalar_hash<long double>
{
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_t operator()(long double __v) const noexcept
    {

        if (__v == 0.0L)
            return 0;
# 782 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/hash.h" 3
        return __scalar_hash<long double>::operator()(__v);

    }
};



#pragma GCC diagnostic push
# 789 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/hash.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated"
# 789 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/hash.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
template <class _Tp, bool = is_enum<_Tp>::value>
struct __attribute__ ((__type_visibility__("default"))) __enum_hash

    : public unary_function<_Tp, size_t>

{
#pragma GCC diagnostic pop

    __attribute__ ((deprecated)) typedef size_t result_type;
    __attribute__ ((deprecated)) typedef _Tp argument_type;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_t operator()(_Tp __v) const noexcept
    {
        typedef typename underlying_type<_Tp>::type type;
        return hash<type>{}(static_cast<type>(__v));
    }
};
template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) __enum_hash<_Tp, false> {
    __enum_hash() = delete;
    __enum_hash(__enum_hash const&) = delete;
    __enum_hash& operator=(__enum_hash const&) = delete;
};

template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) hash : public __enum_hash<_Tp>
{
};




#pragma GCC diagnostic push
# 823 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/hash.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated"
# 823 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/hash.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
template <>
struct __attribute__ ((__type_visibility__("default"))) hash<nullptr_t>

  : public unary_function<nullptr_t, size_t>

{
#pragma GCC diagnostic pop

    __attribute__ ((deprecated)) typedef size_t result_type;
    __attribute__ ((deprecated)) typedef nullptr_t argument_type;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_t operator()(nullptr_t) const noexcept {
        return 662607004ull;
    }
};



template <class _Key, class _Hash>
using __check_hash_requirements = integral_constant<bool,
    is_copy_constructible<_Hash>::value &&
    is_move_constructible<_Hash>::value &&
    __invokable_r<size_t, _Hash, _Key const&>::value
>;

template <class _Key, class _Hash = hash<_Key> >
using __has_enabled_hash = integral_constant<bool,
    __check_hash_requirements<_Key, _Hash>::value &&
    is_default_constructible<_Hash>::value
>;


template <class _Type, class>
using __enable_hash_helper_imp = _Type;

template <class _Type, class ..._Keys>
using __enable_hash_helper = __enable_hash_helper_imp<_Type,
  typename enable_if<__all<__has_enabled_hash<_Keys>::value...>::value>::type
>;







} }
# 16 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/unique_ptr.h" 2 3





# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 1 3
# 22 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/unique_ptr.h" 2 3
# 30 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/unique_ptr.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 34 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/unique_ptr.h" 2 3

namespace std { inline namespace __1 {

template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) default_delete {
    static_assert(!is_function<_Tp>::value,
                  "default_delete cannot be instantiated for function types");

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr default_delete() noexcept = default;



  template <class _Up>
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  default_delete(const default_delete<_Up>&,
                 typename enable_if<is_convertible<_Up*, _Tp*>::value>::type* =
                     0) noexcept {}

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) void operator()(_Tp* __ptr) const noexcept {
    static_assert(sizeof(_Tp) > 0,
                  "default_delete can not delete incomplete type");
    static_assert(!is_void<_Tp>::value,
                  "default_delete can not delete incomplete type");
    delete __ptr;
  }
};

template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) default_delete<_Tp[]> {
private:
  template <class _Up>
  struct _EnableIfConvertible
      : enable_if<is_convertible<_Up(*)[], _Tp(*)[]>::value> {};

public:

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr default_delete() noexcept = default;




  template <class _Up>
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  default_delete(const default_delete<_Up[]>&,
                 typename _EnableIfConvertible<_Up>::type* = 0) noexcept {}

  template <class _Up>
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  typename _EnableIfConvertible<_Up>::type
  operator()(_Up* __ptr) const noexcept {
    static_assert(sizeof(_Tp) > 0,
                  "default_delete can not delete incomplete type");
    static_assert(!is_void<_Tp>::value,
                  "default_delete can not delete void type");
    delete[] __ptr;
  }
};

template <class _Deleter>
struct __unique_ptr_deleter_sfinae {
  static_assert(!is_reference<_Deleter>::value, "incorrect specialization");
  typedef const _Deleter& __lval_ref_type;
  typedef _Deleter&& __good_rval_ref_type;
  typedef true_type __enable_rval_overload;
};

template <class _Deleter>
struct __unique_ptr_deleter_sfinae<_Deleter const&> {
  typedef const _Deleter& __lval_ref_type;
  typedef const _Deleter&& __bad_rval_ref_type;
  typedef false_type __enable_rval_overload;
};

template <class _Deleter>
struct __unique_ptr_deleter_sfinae<_Deleter&> {
  typedef _Deleter& __lval_ref_type;
  typedef _Deleter&& __bad_rval_ref_type;
  typedef false_type __enable_rval_overload;
};







template <class _Tp, class _Dp = default_delete<_Tp> >
class __attribute__ ((__type_visibility__("default"))) unique_ptr {
public:
  typedef _Tp element_type;
  typedef _Dp deleter_type;
  typedef typename __pointer<_Tp, deleter_type>::type pointer;

  static_assert(!is_rvalue_reference<deleter_type>::value,
                "the specified deleter type cannot be an rvalue reference");

private:
  __compressed_pair<pointer, deleter_type> __ptr_;

  struct __nat { int __for_bool_; };

  typedef __unique_ptr_deleter_sfinae<_Dp> _DeleterSFINAE;

  template <bool _Dummy>
  using _LValRefType =
      typename __dependent_type<_DeleterSFINAE, _Dummy>::__lval_ref_type;

  template <bool _Dummy>
  using _GoodRValRefType =
      typename __dependent_type<_DeleterSFINAE, _Dummy>::__good_rval_ref_type;

  template <bool _Dummy>
  using _BadRValRefType =
      typename __dependent_type<_DeleterSFINAE, _Dummy>::__bad_rval_ref_type;

  template <bool _Dummy, class _Deleter = typename __dependent_type<
                             __identity<deleter_type>, _Dummy>::type>
  using _EnableIfDeleterDefaultConstructible =
      typename enable_if<is_default_constructible<_Deleter>::value &&
                         !is_pointer<_Deleter>::value>::type;

  template <class _ArgType>
  using _EnableIfDeleterConstructible =
      typename enable_if<is_constructible<deleter_type, _ArgType>::value>::type;

  template <class _UPtr, class _Up>
  using _EnableIfMoveConvertible = typename enable_if<
      is_convertible<typename _UPtr::pointer, pointer>::value &&
      !is_array<_Up>::value
  >::type;

  template <class _UDel>
  using _EnableIfDeleterConvertible = typename enable_if<
      (is_reference<_Dp>::value && is_same<_Dp, _UDel>::value) ||
      (!is_reference<_Dp>::value && is_convertible<_UDel, _Dp>::value)
    >::type;

  template <class _UDel>
  using _EnableIfDeleterAssignable = typename enable_if<
      is_assignable<_Dp&, _UDel&&>::value
    >::type;

public:
  template <bool _Dummy = true,
            class = _EnableIfDeleterDefaultConstructible<_Dummy> >
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  constexpr unique_ptr() noexcept : __ptr_(pointer(), __default_init_tag()) {}

  template <bool _Dummy = true,
            class = _EnableIfDeleterDefaultConstructible<_Dummy> >
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  constexpr unique_ptr(nullptr_t) noexcept : __ptr_(pointer(), __default_init_tag()) {}

  template <bool _Dummy = true,
            class = _EnableIfDeleterDefaultConstructible<_Dummy> >
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  explicit unique_ptr(pointer __p) noexcept : __ptr_(__p, __default_init_tag()) {}

  template <bool _Dummy = true,
            class = _EnableIfDeleterConstructible<_LValRefType<_Dummy> > >
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  unique_ptr(pointer __p, _LValRefType<_Dummy> __d) noexcept
      : __ptr_(__p, __d) {}

  template <bool _Dummy = true,
            class = _EnableIfDeleterConstructible<_GoodRValRefType<_Dummy> > >
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  unique_ptr(pointer __p, _GoodRValRefType<_Dummy> __d) noexcept
      : __ptr_(__p, std::__1::move(__d)) {
    static_assert(!is_reference<deleter_type>::value,
                  "rvalue deleter bound to reference");
  }

  template <bool _Dummy = true,
            class = _EnableIfDeleterConstructible<_BadRValRefType<_Dummy> > >
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  unique_ptr(pointer __p, _BadRValRefType<_Dummy> __d) = delete;

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  unique_ptr(unique_ptr&& __u) noexcept
      : __ptr_(__u.release(), std::__1::forward<deleter_type>(__u.get_deleter())) {
  }

  template <class _Up, class _Ep,
      class = _EnableIfMoveConvertible<unique_ptr<_Up, _Ep>, _Up>,
      class = _EnableIfDeleterConvertible<_Ep>
  >
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  unique_ptr(unique_ptr<_Up, _Ep>&& __u) noexcept
      : __ptr_(__u.release(), std::__1::forward<_Ep>(__u.get_deleter())) {}
# 235 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/unique_ptr.h" 3
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  unique_ptr& operator=(unique_ptr&& __u) noexcept {
    reset(__u.release());
    __ptr_.second() = std::__1::forward<deleter_type>(__u.get_deleter());
    return *this;
  }

  template <class _Up, class _Ep,
      class = _EnableIfMoveConvertible<unique_ptr<_Up, _Ep>, _Up>,
      class = _EnableIfDeleterAssignable<_Ep>
  >
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  unique_ptr& operator=(unique_ptr<_Up, _Ep>&& __u) noexcept {
    reset(__u.release());
    __ptr_.second() = std::__1::forward<_Ep>(__u.get_deleter());
    return *this;
  }
# 271 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/unique_ptr.h" 3
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  ~unique_ptr() { reset(); }

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  unique_ptr& operator=(nullptr_t) noexcept {
    reset();
    return *this;
  }

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  typename add_lvalue_reference<_Tp>::type
  operator*() const {
    return *__ptr_.first();
  }
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  pointer operator->() const noexcept {
    return __ptr_.first();
  }
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  pointer get() const noexcept {
    return __ptr_.first();
  }
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  deleter_type& get_deleter() noexcept {
    return __ptr_.second();
  }
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  const deleter_type& get_deleter() const noexcept {
    return __ptr_.second();
  }
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  explicit operator bool() const noexcept {
    return __ptr_.first() != nullptr;
  }

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  pointer release() noexcept {
    pointer __t = __ptr_.first();
    __ptr_.first() = pointer();
    return __t;
  }

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  void reset(pointer __p = pointer()) noexcept {
    pointer __tmp = __ptr_.first();
    __ptr_.first() = __p;
    if (__tmp)
      __ptr_.second()(__tmp);
  }

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  void swap(unique_ptr& __u) noexcept {
    __ptr_.swap(__u.__ptr_);
  }
};


template <class _Tp, class _Dp>
class __attribute__ ((__type_visibility__("default"))) unique_ptr<_Tp[], _Dp> {
public:
  typedef _Tp element_type;
  typedef _Dp deleter_type;
  typedef typename __pointer<_Tp, deleter_type>::type pointer;

private:
  __compressed_pair<pointer, deleter_type> __ptr_;

  template <class _From>
  struct _CheckArrayPointerConversion : is_same<_From, pointer> {};

  template <class _FromElem>
  struct _CheckArrayPointerConversion<_FromElem*>
      : integral_constant<bool,
          is_same<_FromElem*, pointer>::value ||
            (is_same<pointer, element_type*>::value &&
             is_convertible<_FromElem(*)[], element_type(*)[]>::value)
      >
  {};

  typedef __unique_ptr_deleter_sfinae<_Dp> _DeleterSFINAE;

  template <bool _Dummy>
  using _LValRefType =
      typename __dependent_type<_DeleterSFINAE, _Dummy>::__lval_ref_type;

  template <bool _Dummy>
  using _GoodRValRefType =
      typename __dependent_type<_DeleterSFINAE, _Dummy>::__good_rval_ref_type;

  template <bool _Dummy>
  using _BadRValRefType =
      typename __dependent_type<_DeleterSFINAE, _Dummy>::__bad_rval_ref_type;

  template <bool _Dummy, class _Deleter = typename __dependent_type<
                             __identity<deleter_type>, _Dummy>::type>
  using _EnableIfDeleterDefaultConstructible =
      typename enable_if<is_default_constructible<_Deleter>::value &&
                         !is_pointer<_Deleter>::value>::type;

  template <class _ArgType>
  using _EnableIfDeleterConstructible =
      typename enable_if<is_constructible<deleter_type, _ArgType>::value>::type;

  template <class _Pp>
  using _EnableIfPointerConvertible = typename enable_if<
      _CheckArrayPointerConversion<_Pp>::value
  >::type;

  template <class _UPtr, class _Up,
        class _ElemT = typename _UPtr::element_type>
  using _EnableIfMoveConvertible = typename enable_if<
      is_array<_Up>::value &&
      is_same<pointer, element_type*>::value &&
      is_same<typename _UPtr::pointer, _ElemT*>::value &&
      is_convertible<_ElemT(*)[], element_type(*)[]>::value
    >::type;

  template <class _UDel>
  using _EnableIfDeleterConvertible = typename enable_if<
      (is_reference<_Dp>::value && is_same<_Dp, _UDel>::value) ||
      (!is_reference<_Dp>::value && is_convertible<_UDel, _Dp>::value)
    >::type;

  template <class _UDel>
  using _EnableIfDeleterAssignable = typename enable_if<
      is_assignable<_Dp&, _UDel&&>::value
    >::type;

public:
  template <bool _Dummy = true,
            class = _EnableIfDeleterDefaultConstructible<_Dummy> >
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  constexpr unique_ptr() noexcept : __ptr_(pointer(), __default_init_tag()) {}

  template <bool _Dummy = true,
            class = _EnableIfDeleterDefaultConstructible<_Dummy> >
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  constexpr unique_ptr(nullptr_t) noexcept : __ptr_(pointer(), __default_init_tag()) {}

  template <class _Pp, bool _Dummy = true,
            class = _EnableIfDeleterDefaultConstructible<_Dummy>,
            class = _EnableIfPointerConvertible<_Pp> >
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  explicit unique_ptr(_Pp __p) noexcept
      : __ptr_(__p, __default_init_tag()) {}

  template <class _Pp, bool _Dummy = true,
            class = _EnableIfDeleterConstructible<_LValRefType<_Dummy> >,
            class = _EnableIfPointerConvertible<_Pp> >
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  unique_ptr(_Pp __p, _LValRefType<_Dummy> __d) noexcept
      : __ptr_(__p, __d) {}

  template <bool _Dummy = true,
            class = _EnableIfDeleterConstructible<_LValRefType<_Dummy> > >
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  unique_ptr(nullptr_t, _LValRefType<_Dummy> __d) noexcept
      : __ptr_(nullptr, __d) {}

  template <class _Pp, bool _Dummy = true,
            class = _EnableIfDeleterConstructible<_GoodRValRefType<_Dummy> >,
            class = _EnableIfPointerConvertible<_Pp> >
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  unique_ptr(_Pp __p, _GoodRValRefType<_Dummy> __d) noexcept
      : __ptr_(__p, std::__1::move(__d)) {
    static_assert(!is_reference<deleter_type>::value,
                  "rvalue deleter bound to reference");
  }

  template <bool _Dummy = true,
            class = _EnableIfDeleterConstructible<_GoodRValRefType<_Dummy> > >
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  unique_ptr(nullptr_t, _GoodRValRefType<_Dummy> __d) noexcept
      : __ptr_(nullptr, std::__1::move(__d)) {
    static_assert(!is_reference<deleter_type>::value,
                  "rvalue deleter bound to reference");
  }

  template <class _Pp, bool _Dummy = true,
            class = _EnableIfDeleterConstructible<_BadRValRefType<_Dummy> >,
            class = _EnableIfPointerConvertible<_Pp> >
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  unique_ptr(_Pp __p, _BadRValRefType<_Dummy> __d) = delete;

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  unique_ptr(unique_ptr&& __u) noexcept
      : __ptr_(__u.release(), std::__1::forward<deleter_type>(__u.get_deleter())) {
  }

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  unique_ptr& operator=(unique_ptr&& __u) noexcept {
    reset(__u.release());
    __ptr_.second() = std::__1::forward<deleter_type>(__u.get_deleter());
    return *this;
  }

  template <class _Up, class _Ep,
      class = _EnableIfMoveConvertible<unique_ptr<_Up, _Ep>, _Up>,
      class = _EnableIfDeleterConvertible<_Ep>
  >
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  unique_ptr(unique_ptr<_Up, _Ep>&& __u) noexcept
      : __ptr_(__u.release(), std::__1::forward<_Ep>(__u.get_deleter())) {
  }

  template <class _Up, class _Ep,
      class = _EnableIfMoveConvertible<unique_ptr<_Up, _Ep>, _Up>,
      class = _EnableIfDeleterAssignable<_Ep>
  >
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  unique_ptr&
  operator=(unique_ptr<_Up, _Ep>&& __u) noexcept {
    reset(__u.release());
    __ptr_.second() = std::__1::forward<_Ep>(__u.get_deleter());
    return *this;
  }






public:
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  ~unique_ptr() { reset(); }

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  unique_ptr& operator=(nullptr_t) noexcept {
    reset();
    return *this;
  }

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  typename add_lvalue_reference<_Tp>::type
  operator[](size_t __i) const {
    return __ptr_.first()[__i];
  }
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  pointer get() const noexcept {
    return __ptr_.first();
  }

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  deleter_type& get_deleter() noexcept {
    return __ptr_.second();
  }

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  const deleter_type& get_deleter() const noexcept {
    return __ptr_.second();
  }
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  explicit operator bool() const noexcept {
    return __ptr_.first() != nullptr;
  }

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  pointer release() noexcept {
    pointer __t = __ptr_.first();
    __ptr_.first() = pointer();
    return __t;
  }

  template <class _Pp>
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  typename enable_if<
      _CheckArrayPointerConversion<_Pp>::value
  >::type
  reset(_Pp __p) noexcept {
    pointer __tmp = __ptr_.first();
    __ptr_.first() = __p;
    if (__tmp)
      __ptr_.second()(__tmp);
  }

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  void reset(nullptr_t = nullptr) noexcept {
    pointer __tmp = __ptr_.first();
    __ptr_.first() = nullptr;
    if (__tmp)
      __ptr_.second()(__tmp);
  }

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  void swap(unique_ptr& __u) noexcept {
    __ptr_.swap(__u.__ptr_);
  }

};

template <class _Tp, class _Dp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename enable_if<
    __is_swappable<_Dp>::value,
    void
>::type
swap(unique_ptr<_Tp, _Dp>& __x, unique_ptr<_Tp, _Dp>& __y) noexcept {__x.swap(__y);}

template <class _T1, class _D1, class _T2, class _D2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator==(const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y) {return __x.get() == __y.get();}

template <class _T1, class _D1, class _T2, class _D2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator!=(const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y) {return !(__x == __y);}

template <class _T1, class _D1, class _T2, class _D2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator< (const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y)
{
    typedef typename unique_ptr<_T1, _D1>::pointer _P1;
    typedef typename unique_ptr<_T2, _D2>::pointer _P2;
    typedef typename common_type<_P1, _P2>::type _Vp;
    return less<_Vp>()(__x.get(), __y.get());
}

template <class _T1, class _D1, class _T2, class _D2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator> (const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y) {return __y < __x;}

template <class _T1, class _D1, class _T2, class _D2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator<=(const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y) {return !(__y < __x);}

template <class _T1, class _D1, class _T2, class _D2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator>=(const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y) {return !(__x < __y);}

template <class _T1, class _D1>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator==(const unique_ptr<_T1, _D1>& __x, nullptr_t) noexcept
{
    return !__x;
}

template <class _T1, class _D1>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator==(nullptr_t, const unique_ptr<_T1, _D1>& __x) noexcept
{
    return !__x;
}

template <class _T1, class _D1>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator!=(const unique_ptr<_T1, _D1>& __x, nullptr_t) noexcept
{
    return static_cast<bool>(__x);
}

template <class _T1, class _D1>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator!=(nullptr_t, const unique_ptr<_T1, _D1>& __x) noexcept
{
    return static_cast<bool>(__x);
}

template <class _T1, class _D1>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator<(const unique_ptr<_T1, _D1>& __x, nullptr_t)
{
    typedef typename unique_ptr<_T1, _D1>::pointer _P1;
    return less<_P1>()(__x.get(), nullptr);
}

template <class _T1, class _D1>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator<(nullptr_t, const unique_ptr<_T1, _D1>& __x)
{
    typedef typename unique_ptr<_T1, _D1>::pointer _P1;
    return less<_P1>()(nullptr, __x.get());
}

template <class _T1, class _D1>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator>(const unique_ptr<_T1, _D1>& __x, nullptr_t)
{
    return nullptr < __x;
}

template <class _T1, class _D1>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator>(nullptr_t, const unique_ptr<_T1, _D1>& __x)
{
    return __x < nullptr;
}

template <class _T1, class _D1>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator<=(const unique_ptr<_T1, _D1>& __x, nullptr_t)
{
    return !(nullptr < __x);
}

template <class _T1, class _D1>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator<=(nullptr_t, const unique_ptr<_T1, _D1>& __x)
{
    return !(__x < nullptr);
}

template <class _T1, class _D1>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator>=(const unique_ptr<_T1, _D1>& __x, nullptr_t)
{
    return !(__x < nullptr);
}

template <class _T1, class _D1>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator>=(nullptr_t, const unique_ptr<_T1, _D1>& __x)
{
    return !(nullptr < __x);
}



template<class _Tp>
struct __unique_if
{
    typedef unique_ptr<_Tp> __unique_single;
};

template<class _Tp>
struct __unique_if<_Tp[]>
{
    typedef unique_ptr<_Tp[]> __unique_array_unknown_bound;
};

template<class _Tp, size_t _Np>
struct __unique_if<_Tp[_Np]>
{
    typedef void __unique_array_known_bound;
};

template<class _Tp, class... _Args>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename __unique_if<_Tp>::__unique_single
make_unique(_Args&&... __args)
{
    return unique_ptr<_Tp>(new _Tp(std::__1::forward<_Args>(__args)...));
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename __unique_if<_Tp>::__unique_array_unknown_bound
make_unique(size_t __n)
{
    typedef typename remove_extent<_Tp>::type _Up;
    return unique_ptr<_Tp>(new _Up[__n]());
}

template<class _Tp, class... _Args>
    typename __unique_if<_Tp>::__unique_array_known_bound
    make_unique(_Args&&...) = delete;



template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) hash;

template <class _Tp, class _Dp>



struct __attribute__ ((__type_visibility__("default"))) hash<__enable_hash_helper<
    unique_ptr<_Tp, _Dp>, typename unique_ptr<_Tp, _Dp>::pointer> >

{

    __attribute__ ((deprecated)) typedef unique_ptr<_Tp, _Dp> argument_type;
    __attribute__ ((deprecated)) typedef size_t result_type;


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_t operator()(const unique_ptr<_Tp, _Dp>& __ptr) const
    {
        typedef typename unique_ptr<_Tp, _Dp>::pointer pointer;
        return hash<pointer>()(__ptr.get());
    }
};

} }
# 26 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/shared_ptr.h" 2 3






# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 1 3
# 33 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/shared_ptr.h" 2 3


# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/atomic" 1 3
# 582 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/atomic" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__thread/poll_with_backoff.h" 1 3
# 13 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__thread/poll_with_backoff.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/chrono" 1 3
# 831 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/chrono" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/ratio" 1 3
# 83 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/ratio" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 1 3
# 84 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/ratio" 2 3
# 87 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/ratio" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 91 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/ratio" 2 3


namespace std { inline namespace __1 {



template <intmax_t _Xp, intmax_t _Yp>
struct __static_gcd
{
    static const intmax_t value = __static_gcd<_Yp, _Xp % _Yp>::value;
};

template <intmax_t _Xp>
struct __static_gcd<_Xp, 0>
{
    static const intmax_t value = _Xp;
};

template <>
struct __static_gcd<0, 0>
{
    static const intmax_t value = 1;
};



template <intmax_t _Xp, intmax_t _Yp>
struct __static_lcm
{
    static const intmax_t value = _Xp / __static_gcd<_Xp, _Yp>::value * _Yp;
};

template <intmax_t _Xp>
struct __static_abs
{
    static const intmax_t value = _Xp < 0 ? -_Xp : _Xp;
};

template <intmax_t _Xp>
struct __static_sign
{
    static const intmax_t value = _Xp == 0 ? 0 : (_Xp < 0 ? -1 : 1);
};

template <intmax_t _Xp, intmax_t _Yp, intmax_t = __static_sign<_Yp>::value>
class __ll_add;

template <intmax_t _Xp, intmax_t _Yp>
class __ll_add<_Xp, _Yp, 1>
{
    static const intmax_t min = (1LL << (sizeof(intmax_t) * 8 - 1)) + 1;
    static const intmax_t max = -min;

    static_assert(_Xp <= max - _Yp, "overflow in __ll_add");
public:
    static const intmax_t value = _Xp + _Yp;
};

template <intmax_t _Xp, intmax_t _Yp>
class __ll_add<_Xp, _Yp, 0>
{
public:
    static const intmax_t value = _Xp;
};

template <intmax_t _Xp, intmax_t _Yp>
class __ll_add<_Xp, _Yp, -1>
{
    static const intmax_t min = (1LL << (sizeof(intmax_t) * 8 - 1)) + 1;
    static const intmax_t max = -min;

    static_assert(min - _Yp <= _Xp, "overflow in __ll_add");
public:
    static const intmax_t value = _Xp + _Yp;
};

template <intmax_t _Xp, intmax_t _Yp, intmax_t = __static_sign<_Yp>::value>
class __ll_sub;

template <intmax_t _Xp, intmax_t _Yp>
class __ll_sub<_Xp, _Yp, 1>
{
    static const intmax_t min = (1LL << (sizeof(intmax_t) * 8 - 1)) + 1;
    static const intmax_t max = -min;

    static_assert(min + _Yp <= _Xp, "overflow in __ll_sub");
public:
    static const intmax_t value = _Xp - _Yp;
};

template <intmax_t _Xp, intmax_t _Yp>
class __ll_sub<_Xp, _Yp, 0>
{
public:
    static const intmax_t value = _Xp;
};

template <intmax_t _Xp, intmax_t _Yp>
class __ll_sub<_Xp, _Yp, -1>
{
    static const intmax_t min = (1LL << (sizeof(intmax_t) * 8 - 1)) + 1;
    static const intmax_t max = -min;

    static_assert(_Xp <= max + _Yp, "overflow in __ll_sub");
public:
    static const intmax_t value = _Xp - _Yp;
};

template <intmax_t _Xp, intmax_t _Yp>
class __ll_mul
{
    static const intmax_t nan = (1LL << (sizeof(intmax_t) * 8 - 1));
    static const intmax_t min = nan + 1;
    static const intmax_t max = -min;
    static const intmax_t __a_x = __static_abs<_Xp>::value;
    static const intmax_t __a_y = __static_abs<_Yp>::value;

    static_assert(_Xp != nan && _Yp != nan && __a_x <= max / __a_y, "overflow in __ll_mul");
public:
    static const intmax_t value = _Xp * _Yp;
};

template <intmax_t _Yp>
class __ll_mul<0, _Yp>
{
public:
    static const intmax_t value = 0;
};

template <intmax_t _Xp>
class __ll_mul<_Xp, 0>
{
public:
    static const intmax_t value = 0;
};

template <>
class __ll_mul<0, 0>
{
public:
    static const intmax_t value = 0;
};


template <intmax_t _Xp, intmax_t _Yp>
class __ll_div
{
    static const intmax_t nan = (1LL << (sizeof(intmax_t) * 8 - 1));
    static const intmax_t min = nan + 1;
    static const intmax_t max = -min;

    static_assert(_Xp != nan && _Yp != nan && _Yp != 0, "overflow in __ll_div");
public:
    static const intmax_t value = _Xp / _Yp;
};

template <intmax_t _Num, intmax_t _Den = 1>
class __attribute__ ((__type_visibility__("default"))) ratio
{
    static_assert(__static_abs<_Num>::value >= 0, "ratio numerator is out of range");
    static_assert(_Den != 0, "ratio divide by 0");
    static_assert(__static_abs<_Den>::value > 0, "ratio denominator is out of range");
    static constexpr const intmax_t __na = __static_abs<_Num>::value;
    static constexpr const intmax_t __da = __static_abs<_Den>::value;
    static constexpr const intmax_t __s = __static_sign<_Num>::value * __static_sign<_Den>::value;
    static constexpr const intmax_t __gcd = __static_gcd<__na, __da>::value;
public:
    static constexpr const intmax_t num = __s * __na / __gcd;
    static constexpr const intmax_t den = __da / __gcd;

    typedef ratio<num, den> type;
};

template <intmax_t _Num, intmax_t _Den>
constexpr const intmax_t ratio<_Num, _Den>::num;

template <intmax_t _Num, intmax_t _Den>
constexpr const intmax_t ratio<_Num, _Den>::den;

template <class _Tp> struct __is_ratio : false_type {};
template <intmax_t _Num, intmax_t _Den> struct __is_ratio<ratio<_Num, _Den> > : true_type {};

typedef ratio<1LL, 1000000000000000000LL> atto;
typedef ratio<1LL, 1000000000000000LL> femto;
typedef ratio<1LL, 1000000000000LL> pico;
typedef ratio<1LL, 1000000000LL> nano;
typedef ratio<1LL, 1000000LL> micro;
typedef ratio<1LL, 1000LL> milli;
typedef ratio<1LL, 100LL> centi;
typedef ratio<1LL, 10LL> deci;
typedef ratio< 10LL, 1LL> deca;
typedef ratio< 100LL, 1LL> hecto;
typedef ratio< 1000LL, 1LL> kilo;
typedef ratio< 1000000LL, 1LL> mega;
typedef ratio< 1000000000LL, 1LL> giga;
typedef ratio< 1000000000000LL, 1LL> tera;
typedef ratio< 1000000000000000LL, 1LL> peta;
typedef ratio<1000000000000000000LL, 1LL> exa;

template <class _R1, class _R2>
struct __ratio_multiply
{
private:
    static const intmax_t __gcd_n1_d2 = __static_gcd<_R1::num, _R2::den>::value;
    static const intmax_t __gcd_d1_n2 = __static_gcd<_R1::den, _R2::num>::value;
public:
    typedef typename ratio
        <
            __ll_mul<_R1::num / __gcd_n1_d2, _R2::num / __gcd_d1_n2>::value,
            __ll_mul<_R2::den / __gcd_n1_d2, _R1::den / __gcd_d1_n2>::value
        >::type type;
};



template <class _R1, class _R2> using ratio_multiply
                                    = typename __ratio_multiply<_R1, _R2>::type;
# 317 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/ratio" 3
template <class _R1, class _R2>
struct __ratio_divide
{
private:
    static const intmax_t __gcd_n1_n2 = __static_gcd<_R1::num, _R2::num>::value;
    static const intmax_t __gcd_d1_d2 = __static_gcd<_R1::den, _R2::den>::value;
public:
    typedef typename ratio
        <
            __ll_mul<_R1::num / __gcd_n1_n2, _R2::den / __gcd_d1_d2>::value,
            __ll_mul<_R2::num / __gcd_n1_n2, _R1::den / __gcd_d1_d2>::value
        >::type type;
};



template <class _R1, class _R2> using ratio_divide
                                      = typename __ratio_divide<_R1, _R2>::type;
# 344 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/ratio" 3
template <class _R1, class _R2>
struct __ratio_add
{
private:
    static const intmax_t __gcd_n1_n2 = __static_gcd<_R1::num, _R2::num>::value;
    static const intmax_t __gcd_d1_d2 = __static_gcd<_R1::den, _R2::den>::value;
public:
    typedef typename ratio_multiply
        <
            ratio<__gcd_n1_n2, _R1::den / __gcd_d1_d2>,
            ratio
            <
                __ll_add
                <
                    __ll_mul<_R1::num / __gcd_n1_n2, _R2::den / __gcd_d1_d2>::value,
                    __ll_mul<_R2::num / __gcd_n1_n2, _R1::den / __gcd_d1_d2>::value
                >::value,
                _R2::den
            >
        >::type type;
};



template <class _R1, class _R2> using ratio_add
                                         = typename __ratio_add<_R1, _R2>::type;
# 379 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/ratio" 3
template <class _R1, class _R2>
struct __ratio_subtract
{
private:
    static const intmax_t __gcd_n1_n2 = __static_gcd<_R1::num, _R2::num>::value;
    static const intmax_t __gcd_d1_d2 = __static_gcd<_R1::den, _R2::den>::value;
public:
    typedef typename ratio_multiply
        <
            ratio<__gcd_n1_n2, _R1::den / __gcd_d1_d2>,
            ratio
            <
                __ll_sub
                <
                    __ll_mul<_R1::num / __gcd_n1_n2, _R2::den / __gcd_d1_d2>::value,
                    __ll_mul<_R2::num / __gcd_n1_n2, _R1::den / __gcd_d1_d2>::value
                >::value,
                _R2::den
            >
        >::type type;
};



template <class _R1, class _R2> using ratio_subtract
                                    = typename __ratio_subtract<_R1, _R2>::type;
# 416 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/ratio" 3
template <class _R1, class _R2>
struct __attribute__ ((__type_visibility__("default"))) ratio_equal
    : public bool_constant<((_R1::num == _R2::num && _R1::den == _R2::den))> {};

template <class _R1, class _R2>
struct __attribute__ ((__type_visibility__("default"))) ratio_not_equal
    : public bool_constant<((!ratio_equal<_R1, _R2>::value))> {};



template <class _R1, class _R2, bool _Odd = false,
          intmax_t _Q1 = _R1::num / _R1::den, intmax_t _M1 = _R1::num % _R1::den,
          intmax_t _Q2 = _R2::num / _R2::den, intmax_t _M2 = _R2::num % _R2::den>
struct __ratio_less1
{
    static const bool value = _Odd ? _Q2 < _Q1 : _Q1 < _Q2;
};

template <class _R1, class _R2, bool _Odd, intmax_t _Qp>
struct __ratio_less1<_R1, _R2, _Odd, _Qp, 0, _Qp, 0>
{
    static const bool value = false;
};

template <class _R1, class _R2, bool _Odd, intmax_t _Qp, intmax_t _M2>
struct __ratio_less1<_R1, _R2, _Odd, _Qp, 0, _Qp, _M2>
{
    static const bool value = !_Odd;
};

template <class _R1, class _R2, bool _Odd, intmax_t _Qp, intmax_t _M1>
struct __ratio_less1<_R1, _R2, _Odd, _Qp, _M1, _Qp, 0>
{
    static const bool value = _Odd;
};

template <class _R1, class _R2, bool _Odd, intmax_t _Qp, intmax_t _M1,
                                                        intmax_t _M2>
struct __ratio_less1<_R1, _R2, _Odd, _Qp, _M1, _Qp, _M2>
{
    static const bool value = __ratio_less1<ratio<_R1::den, _M1>,
                                            ratio<_R2::den, _M2>, !_Odd>::value;
};

template <class _R1, class _R2, intmax_t _S1 = __static_sign<_R1::num>::value,
                                intmax_t _S2 = __static_sign<_R2::num>::value>
struct __ratio_less
{
    static const bool value = _S1 < _S2;
};

template <class _R1, class _R2>
struct __ratio_less<_R1, _R2, 1LL, 1LL>
{
    static const bool value = __ratio_less1<_R1, _R2>::value;
};

template <class _R1, class _R2>
struct __ratio_less<_R1, _R2, -1LL, -1LL>
{
    static const bool value = __ratio_less1<ratio<-_R2::num, _R2::den>, ratio<-_R1::num, _R1::den> >::value;
};

template <class _R1, class _R2>
struct __attribute__ ((__type_visibility__("default"))) ratio_less
    : public bool_constant<((__ratio_less<_R1, _R2>::value))> {};

template <class _R1, class _R2>
struct __attribute__ ((__type_visibility__("default"))) ratio_less_equal
    : public bool_constant<((!ratio_less<_R2, _R1>::value))> {};

template <class _R1, class _R2>
struct __attribute__ ((__type_visibility__("default"))) ratio_greater
    : public bool_constant<((ratio_less<_R2, _R1>::value))> {};

template <class _R1, class _R2>
struct __attribute__ ((__type_visibility__("default"))) ratio_greater_equal
    : public bool_constant<((!ratio_less<_R1, _R2>::value))> {};

template <class _R1, class _R2>
struct __ratio_gcd
{
    typedef ratio<__static_gcd<_R1::num, _R2::num>::value,
                  __static_lcm<_R1::den, _R2::den>::value> type;
};


template <class _R1, class _R2>
inline constexpr bool ratio_equal_v
    = ratio_equal<_R1, _R2>::value;

template <class _R1, class _R2>
inline constexpr bool ratio_not_equal_v
    = ratio_not_equal<_R1, _R2>::value;

template <class _R1, class _R2>
inline constexpr bool ratio_less_v
    = ratio_less<_R1, _R2>::value;

template <class _R1, class _R2>
inline constexpr bool ratio_less_equal_v
    = ratio_less_equal<_R1, _R2>::value;

template <class _R1, class _R2>
inline constexpr bool ratio_greater_v
    = ratio_greater<_R1, _R2>::value;

template <class _R1, class _R2>
inline constexpr bool ratio_greater_equal_v
    = ratio_greater_equal<_R1, _R2>::value;


} }
# 832 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/chrono" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 1 3
# 833 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/chrono" 2 3
# 837 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/chrono" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 841 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/chrono" 2 3


namespace std { inline namespace __1 { inline namespace __fs { namespace filesystem {
struct _FilesystemClock;
} } } }


namespace std { inline namespace __1 {

namespace chrono
{

template <class _Rep, class _Period = ratio<1> > class __attribute__ ((__type_visibility__("default"))) duration;

template <class _Tp>
struct __is_duration : false_type {};

template <class _Rep, class _Period>
struct __is_duration<duration<_Rep, _Period> > : true_type {};

template <class _Rep, class _Period>
struct __is_duration<const duration<_Rep, _Period> > : true_type {};

template <class _Rep, class _Period>
struct __is_duration<volatile duration<_Rep, _Period> > : true_type {};

template <class _Rep, class _Period>
struct __is_duration<const volatile duration<_Rep, _Period> > : true_type {};

}

template <class _Rep1, class _Period1, class _Rep2, class _Period2>
struct __attribute__ ((__type_visibility__("default"))) common_type<chrono::duration<_Rep1, _Period1>,
                                         chrono::duration<_Rep2, _Period2> >
{
    typedef chrono::duration<typename common_type<_Rep1, _Rep2>::type,
                             typename __ratio_gcd<_Period1, _Period2>::type> type;
};

namespace chrono {



template <class _FromDuration, class _ToDuration,
          class _Period = typename ratio_divide<typename _FromDuration::period, typename _ToDuration::period>::type,
          bool = _Period::num == 1,
          bool = _Period::den == 1>
struct __duration_cast;

template <class _FromDuration, class _ToDuration, class _Period>
struct __duration_cast<_FromDuration, _ToDuration, _Period, true, true>
{
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
    _ToDuration operator()(const _FromDuration& __fd) const
    {
        return _ToDuration(static_cast<typename _ToDuration::rep>(__fd.count()));
    }
};

template <class _FromDuration, class _ToDuration, class _Period>
struct __duration_cast<_FromDuration, _ToDuration, _Period, true, false>
{
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
    _ToDuration operator()(const _FromDuration& __fd) const
    {
        typedef typename common_type<typename _ToDuration::rep, typename _FromDuration::rep, intmax_t>::type _Ct;
        return _ToDuration(static_cast<typename _ToDuration::rep>(
                           static_cast<_Ct>(__fd.count()) / static_cast<_Ct>(_Period::den)));
    }
};

template <class _FromDuration, class _ToDuration, class _Period>
struct __duration_cast<_FromDuration, _ToDuration, _Period, false, true>
{
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
    _ToDuration operator()(const _FromDuration& __fd) const
    {
        typedef typename common_type<typename _ToDuration::rep, typename _FromDuration::rep, intmax_t>::type _Ct;
        return _ToDuration(static_cast<typename _ToDuration::rep>(
                           static_cast<_Ct>(__fd.count()) * static_cast<_Ct>(_Period::num)));
    }
};

template <class _FromDuration, class _ToDuration, class _Period>
struct __duration_cast<_FromDuration, _ToDuration, _Period, false, false>
{
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
    _ToDuration operator()(const _FromDuration& __fd) const
    {
        typedef typename common_type<typename _ToDuration::rep, typename _FromDuration::rep, intmax_t>::type _Ct;
        return _ToDuration(static_cast<typename _ToDuration::rep>(
                           static_cast<_Ct>(__fd.count()) * static_cast<_Ct>(_Period::num)
                                                          / static_cast<_Ct>(_Period::den)));
    }
};

template <class _ToDuration, class _Rep, class _Period>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
constexpr
typename enable_if
<
    __is_duration<_ToDuration>::value,
    _ToDuration
>::type
duration_cast(const duration<_Rep, _Period>& __fd)
{
    return __duration_cast<duration<_Rep, _Period>, _ToDuration>()(__fd);
}

template <class _Rep>
struct __attribute__ ((__type_visibility__("default"))) treat_as_floating_point : is_floating_point<_Rep> {};


template <class _Rep>
inline constexpr bool treat_as_floating_point_v
    = treat_as_floating_point<_Rep>::value;


template <class _Rep>
struct __attribute__ ((__type_visibility__("default"))) duration_values
{
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) static constexpr _Rep zero() noexcept {return _Rep(0);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) static constexpr _Rep max() noexcept {return numeric_limits<_Rep>::max();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) static constexpr _Rep min() noexcept {return numeric_limits<_Rep>::lowest();}
};


template <class _ToDuration, class _Rep, class _Period>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
typename enable_if
<
    __is_duration<_ToDuration>::value,
    _ToDuration
>::type
floor(const duration<_Rep, _Period>& __d)
{
    _ToDuration __t = duration_cast<_ToDuration>(__d);
    if (__t > __d)
        __t = __t - _ToDuration{1};
    return __t;
}

template <class _ToDuration, class _Rep, class _Period>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
typename enable_if
<
    __is_duration<_ToDuration>::value,
    _ToDuration
>::type
ceil(const duration<_Rep, _Period>& __d)
{
    _ToDuration __t = duration_cast<_ToDuration>(__d);
    if (__t < __d)
        __t = __t + _ToDuration{1};
    return __t;
}

template <class _ToDuration, class _Rep, class _Period>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
typename enable_if
<
    __is_duration<_ToDuration>::value,
    _ToDuration
>::type
round(const duration<_Rep, _Period>& __d)
{
    _ToDuration __lower = floor<_ToDuration>(__d);
    _ToDuration __upper = __lower + _ToDuration{1};
    auto __lowerDiff = __d - __lower;
    auto __upperDiff = __upper - __d;
    if (__lowerDiff < __upperDiff)
        return __lower;
    if (__lowerDiff > __upperDiff)
        return __upper;
    return __lower.count() & 1 ? __upper : __lower;
}




template <class _Rep, class _Period>
class __attribute__ ((__type_visibility__("default"))) duration
{
    static_assert(!__is_duration<_Rep>::value, "A duration representation can not be a duration");
    static_assert(__is_ratio<_Period>::value, "Second template parameter of duration must be a std::ratio");
    static_assert(_Period::num > 0, "duration period must be positive");

    template <class _R1, class _R2>
    struct __no_overflow
    {
    private:
        static const intmax_t __gcd_n1_n2 = __static_gcd<_R1::num, _R2::num>::value;
        static const intmax_t __gcd_d1_d2 = __static_gcd<_R1::den, _R2::den>::value;
        static const intmax_t __n1 = _R1::num / __gcd_n1_n2;
        static const intmax_t __d1 = _R1::den / __gcd_d1_d2;
        static const intmax_t __n2 = _R2::num / __gcd_n1_n2;
        static const intmax_t __d2 = _R2::den / __gcd_d1_d2;
        static const intmax_t max = -((intmax_t(1) << (sizeof(intmax_t) * 8 - 1)) + 1);

        template <intmax_t _Xp, intmax_t _Yp, bool __overflow>
        struct __mul
        {
            static const intmax_t value = _Xp * _Yp;
        };

        template <intmax_t _Xp, intmax_t _Yp>
        struct __mul<_Xp, _Yp, true>
        {
            static const intmax_t value = 1;
        };

    public:
        static const bool value = (__n1 <= max / __d2) && (__n2 <= max / __d1);
        typedef ratio<__mul<__n1, __d2, !value>::value,
                      __mul<__n2, __d1, !value>::value> type;
    };

public:
    typedef _Rep rep;
    typedef typename _Period::type period;
private:
    rep __rep_;
public:

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr

        duration() = default;




    template <class _Rep2>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
        explicit duration(const _Rep2& __r,
            typename enable_if
            <
               is_convertible<_Rep2, rep>::value &&
               (treat_as_floating_point<rep>::value ||
               !treat_as_floating_point<_Rep2>::value)
            >::type* = nullptr)
                : __rep_(__r) {}


    template <class _Rep2, class _Period2>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
        duration(const duration<_Rep2, _Period2>& __d,
            typename enable_if
            <
                __no_overflow<_Period2, period>::value && (
                treat_as_floating_point<rep>::value ||
                (__no_overflow<_Period2, period>::type::den == 1 &&
                 !treat_as_floating_point<_Rep2>::value))
            >::type* = nullptr)
                : __rep_(chrono::duration_cast<duration>(__d).count()) {}



    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr rep count() const {return __rep_;}



    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr typename common_type<duration>::type operator+() const {return typename common_type<duration>::type(*this);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr typename common_type<duration>::type operator-() const {return typename common_type<duration>::type(-__rep_);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr duration& operator++() {++__rep_; return *this;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr duration operator++(int) {return duration(__rep_++);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr duration& operator--() {--__rep_; return *this;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr duration operator--(int) {return duration(__rep_--);}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr duration& operator+=(const duration& __d) {__rep_ += __d.count(); return *this;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr duration& operator-=(const duration& __d) {__rep_ -= __d.count(); return *this;}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr duration& operator*=(const rep& rhs) {__rep_ *= rhs; return *this;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr duration& operator/=(const rep& rhs) {__rep_ /= rhs; return *this;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr duration& operator%=(const rep& rhs) {__rep_ %= rhs; return *this;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr duration& operator%=(const duration& rhs) {__rep_ %= rhs.count(); return *this;}



    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) static constexpr duration zero() noexcept {return duration(duration_values<rep>::zero());}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) static constexpr duration min() noexcept {return duration(duration_values<rep>::min());}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) static constexpr duration max() noexcept {return duration(duration_values<rep>::max());}
};

typedef duration<long long, nano> nanoseconds;
typedef duration<long long, micro> microseconds;
typedef duration<long long, milli> milliseconds;
typedef duration<long long > seconds;
typedef duration< long, ratio< 60> > minutes;
typedef duration< long, ratio<3600> > hours;
# 1139 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/chrono" 3
template <class _LhsDuration, class _RhsDuration>
struct __duration_eq
{
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
    bool operator()(const _LhsDuration& __lhs, const _RhsDuration& __rhs) const
        {
            typedef typename common_type<_LhsDuration, _RhsDuration>::type _Ct;
            return _Ct(__lhs).count() == _Ct(__rhs).count();
        }
};

template <class _LhsDuration>
struct __duration_eq<_LhsDuration, _LhsDuration>
{
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
    bool operator()(const _LhsDuration& __lhs, const _LhsDuration& __rhs) const
        {return __lhs.count() == __rhs.count();}
};

template <class _Rep1, class _Period1, class _Rep2, class _Period2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
constexpr
bool
operator==(const duration<_Rep1, _Period1>& __lhs, const duration<_Rep2, _Period2>& __rhs)
{
    return __duration_eq<duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >()(__lhs, __rhs);
}



template <class _Rep1, class _Period1, class _Rep2, class _Period2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
constexpr
bool
operator!=(const duration<_Rep1, _Period1>& __lhs, const duration<_Rep2, _Period2>& __rhs)
{
    return !(__lhs == __rhs);
}



template <class _LhsDuration, class _RhsDuration>
struct __duration_lt
{
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
    bool operator()(const _LhsDuration& __lhs, const _RhsDuration& __rhs) const
        {
            typedef typename common_type<_LhsDuration, _RhsDuration>::type _Ct;
            return _Ct(__lhs).count() < _Ct(__rhs).count();
        }
};

template <class _LhsDuration>
struct __duration_lt<_LhsDuration, _LhsDuration>
{
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
    bool operator()(const _LhsDuration& __lhs, const _LhsDuration& __rhs) const
        {return __lhs.count() < __rhs.count();}
};

template <class _Rep1, class _Period1, class _Rep2, class _Period2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
constexpr
bool
operator< (const duration<_Rep1, _Period1>& __lhs, const duration<_Rep2, _Period2>& __rhs)
{
    return __duration_lt<duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >()(__lhs, __rhs);
}



template <class _Rep1, class _Period1, class _Rep2, class _Period2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
constexpr
bool
operator> (const duration<_Rep1, _Period1>& __lhs, const duration<_Rep2, _Period2>& __rhs)
{
    return __rhs < __lhs;
}



template <class _Rep1, class _Period1, class _Rep2, class _Period2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
constexpr
bool
operator<=(const duration<_Rep1, _Period1>& __lhs, const duration<_Rep2, _Period2>& __rhs)
{
    return !(__rhs < __lhs);
}



template <class _Rep1, class _Period1, class _Rep2, class _Period2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
constexpr
bool
operator>=(const duration<_Rep1, _Period1>& __lhs, const duration<_Rep2, _Period2>& __rhs)
{
    return !(__lhs < __rhs);
}



template <class _Rep1, class _Period1, class _Rep2, class _Period2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
constexpr
typename common_type<duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type
operator+(const duration<_Rep1, _Period1>& __lhs, const duration<_Rep2, _Period2>& __rhs)
{
    typedef typename common_type<duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type _Cd;
    return _Cd(_Cd(__lhs).count() + _Cd(__rhs).count());
}



template <class _Rep1, class _Period1, class _Rep2, class _Period2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
constexpr
typename common_type<duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type
operator-(const duration<_Rep1, _Period1>& __lhs, const duration<_Rep2, _Period2>& __rhs)
{
    typedef typename common_type<duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type _Cd;
    return _Cd(_Cd(__lhs).count() - _Cd(__rhs).count());
}



template <class _Rep1, class _Period, class _Rep2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
constexpr
typename enable_if
<
    is_convertible<_Rep2, typename common_type<_Rep1, _Rep2>::type>::value,
    duration<typename common_type<_Rep1, _Rep2>::type, _Period>
>::type
operator*(const duration<_Rep1, _Period>& __d, const _Rep2& __s)
{
    typedef typename common_type<_Rep1, _Rep2>::type _Cr;
    typedef duration<_Cr, _Period> _Cd;
    return _Cd(_Cd(__d).count() * static_cast<_Cr>(__s));
}

template <class _Rep1, class _Period, class _Rep2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
constexpr
typename enable_if
<
    is_convertible<_Rep1, typename common_type<_Rep1, _Rep2>::type>::value,
    duration<typename common_type<_Rep1, _Rep2>::type, _Period>
>::type
operator*(const _Rep1& __s, const duration<_Rep2, _Period>& __d)
{
    return __d * __s;
}



template <class _Rep1, class _Period, class _Rep2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
constexpr
typename enable_if
<
    !__is_duration<_Rep2>::value &&
      is_convertible<_Rep2, typename common_type<_Rep1, _Rep2>::type>::value,
    duration<typename common_type<_Rep1, _Rep2>::type, _Period>
>::type
operator/(const duration<_Rep1, _Period>& __d, const _Rep2& __s)
{
    typedef typename common_type<_Rep1, _Rep2>::type _Cr;
    typedef duration<_Cr, _Period> _Cd;
    return _Cd(_Cd(__d).count() / static_cast<_Cr>(__s));
}

template <class _Rep1, class _Period1, class _Rep2, class _Period2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
constexpr
typename common_type<_Rep1, _Rep2>::type
operator/(const duration<_Rep1, _Period1>& __lhs, const duration<_Rep2, _Period2>& __rhs)
{
    typedef typename common_type<duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type _Ct;
    return _Ct(__lhs).count() / _Ct(__rhs).count();
}



template <class _Rep1, class _Period, class _Rep2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
constexpr
typename enable_if
<
    !__is_duration<_Rep2>::value &&
      is_convertible<_Rep2, typename common_type<_Rep1, _Rep2>::type>::value,
    duration<typename common_type<_Rep1, _Rep2>::type, _Period>
>::type
operator%(const duration<_Rep1, _Period>& __d, const _Rep2& __s)
{
    typedef typename common_type<_Rep1, _Rep2>::type _Cr;
    typedef duration<_Cr, _Period> _Cd;
    return _Cd(_Cd(__d).count() % static_cast<_Cr>(__s));
}

template <class _Rep1, class _Period1, class _Rep2, class _Period2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
constexpr
typename common_type<duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type
operator%(const duration<_Rep1, _Period1>& __lhs, const duration<_Rep2, _Period2>& __rhs)
{
    typedef typename common_type<_Rep1, _Rep2>::type _Cr;
    typedef typename common_type<duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type _Cd;
    return _Cd(static_cast<_Cr>(_Cd(__lhs).count()) % static_cast<_Cr>(_Cd(__rhs).count()));
}





template <class _Clock, class _Duration = typename _Clock::duration>
class __attribute__ ((__type_visibility__("default"))) time_point
{
    static_assert(__is_duration<_Duration>::value,
                  "Second template parameter of time_point must be a std::chrono::duration");
public:
    typedef _Clock clock;
    typedef _Duration duration;
    typedef typename duration::rep rep;
    typedef typename duration::period period;
private:
    duration __d_;

public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr time_point() : __d_(duration::zero()) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr explicit time_point(const duration& __d) : __d_(__d) {}


    template <class _Duration2>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
    time_point(const time_point<clock, _Duration2>& t,
        typename enable_if
        <
            is_convertible<_Duration2, duration>::value
        >::type* = nullptr)
            : __d_(t.time_since_epoch()) {}



    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr duration time_since_epoch() const {return __d_;}



    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr time_point& operator+=(const duration& __d) {__d_ += __d; return *this;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr time_point& operator-=(const duration& __d) {__d_ -= __d; return *this;}



    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) static constexpr time_point min() noexcept {return time_point(duration::min());}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) static constexpr time_point max() noexcept {return time_point(duration::max());}
};

}

template <class _Clock, class _Duration1, class _Duration2>
struct __attribute__ ((__type_visibility__("default"))) common_type<chrono::time_point<_Clock, _Duration1>,
                                         chrono::time_point<_Clock, _Duration2> >
{
    typedef chrono::time_point<_Clock, typename common_type<_Duration1, _Duration2>::type> type;
};

namespace chrono {

template <class _ToDuration, class _Clock, class _Duration>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
time_point<_Clock, _ToDuration>
time_point_cast(const time_point<_Clock, _Duration>& __t)
{
    return time_point<_Clock, _ToDuration>(chrono::duration_cast<_ToDuration>(__t.time_since_epoch()));
}


template <class _ToDuration, class _Clock, class _Duration>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
typename enable_if
<
    __is_duration<_ToDuration>::value,
    time_point<_Clock, _ToDuration>
>::type
floor(const time_point<_Clock, _Duration>& __t)
{
    return time_point<_Clock, _ToDuration>{floor<_ToDuration>(__t.time_since_epoch())};
}

template <class _ToDuration, class _Clock, class _Duration>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
typename enable_if
<
    __is_duration<_ToDuration>::value,
    time_point<_Clock, _ToDuration>
>::type
ceil(const time_point<_Clock, _Duration>& __t)
{
    return time_point<_Clock, _ToDuration>{ceil<_ToDuration>(__t.time_since_epoch())};
}

template <class _ToDuration, class _Clock, class _Duration>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
typename enable_if
<
    __is_duration<_ToDuration>::value,
    time_point<_Clock, _ToDuration>
>::type
round(const time_point<_Clock, _Duration>& __t)
{
    return time_point<_Clock, _ToDuration>{round<_ToDuration>(__t.time_since_epoch())};
}

template <class _Rep, class _Period>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
typename enable_if
<
    numeric_limits<_Rep>::is_signed,
    duration<_Rep, _Period>
>::type
abs(duration<_Rep, _Period> __d)
{
    return __d >= __d.zero() ? +__d : -__d;
}




template <class _Clock, class _Duration1, class _Duration2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
bool
operator==(const time_point<_Clock, _Duration1>& __lhs, const time_point<_Clock, _Duration2>& __rhs)
{
    return __lhs.time_since_epoch() == __rhs.time_since_epoch();
}



template <class _Clock, class _Duration1, class _Duration2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
bool
operator!=(const time_point<_Clock, _Duration1>& __lhs, const time_point<_Clock, _Duration2>& __rhs)
{
    return !(__lhs == __rhs);
}



template <class _Clock, class _Duration1, class _Duration2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
bool
operator<(const time_point<_Clock, _Duration1>& __lhs, const time_point<_Clock, _Duration2>& __rhs)
{
    return __lhs.time_since_epoch() < __rhs.time_since_epoch();
}



template <class _Clock, class _Duration1, class _Duration2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
bool
operator>(const time_point<_Clock, _Duration1>& __lhs, const time_point<_Clock, _Duration2>& __rhs)
{
    return __rhs < __lhs;
}



template <class _Clock, class _Duration1, class _Duration2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
bool
operator<=(const time_point<_Clock, _Duration1>& __lhs, const time_point<_Clock, _Duration2>& __rhs)
{
    return !(__rhs < __lhs);
}



template <class _Clock, class _Duration1, class _Duration2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
bool
operator>=(const time_point<_Clock, _Duration1>& __lhs, const time_point<_Clock, _Duration2>& __rhs)
{
    return !(__lhs < __rhs);
}



template <class _Clock, class _Duration1, class _Rep2, class _Period2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
time_point<_Clock, typename common_type<_Duration1, duration<_Rep2, _Period2> >::type>
operator+(const time_point<_Clock, _Duration1>& __lhs, const duration<_Rep2, _Period2>& __rhs)
{
    typedef time_point<_Clock, typename common_type<_Duration1, duration<_Rep2, _Period2> >::type> _Tr;
    return _Tr (__lhs.time_since_epoch() + __rhs);
}



template <class _Rep1, class _Period1, class _Clock, class _Duration2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
time_point<_Clock, typename common_type<duration<_Rep1, _Period1>, _Duration2>::type>
operator+(const duration<_Rep1, _Period1>& __lhs, const time_point<_Clock, _Duration2>& __rhs)
{
    return __rhs + __lhs;
}



template <class _Clock, class _Duration1, class _Rep2, class _Period2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
time_point<_Clock, typename common_type<_Duration1, duration<_Rep2, _Period2> >::type>
operator-(const time_point<_Clock, _Duration1>& __lhs, const duration<_Rep2, _Period2>& __rhs)
{
    typedef time_point<_Clock, typename common_type<_Duration1, duration<_Rep2, _Period2> >::type> _Ret;
    return _Ret(__lhs.time_since_epoch() -__rhs);
}



template <class _Clock, class _Duration1, class _Duration2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
typename common_type<_Duration1, _Duration2>::type
operator-(const time_point<_Clock, _Duration1>& __lhs, const time_point<_Clock, _Duration2>& __rhs)
{
    return __lhs.time_since_epoch() - __rhs.time_since_epoch();
}





class __attribute__ ((__visibility__("default"))) system_clock
{
public:
    typedef microseconds duration;
    typedef duration::rep rep;
    typedef duration::period period;
    typedef chrono::time_point<system_clock> time_point;
    static constexpr const bool is_steady = false;

    static time_point now() noexcept;
    static time_t to_time_t (const time_point& __t) noexcept;
    static time_point from_time_t(time_t __t) noexcept;
};


class __attribute__ ((__visibility__("default"))) steady_clock
{
public:
    typedef nanoseconds duration;
    typedef duration::rep rep;
    typedef duration::period period;
    typedef chrono::time_point<steady_clock, duration> time_point;
    static constexpr const bool is_steady = true;

    static time_point now() noexcept;
};

typedef steady_clock high_resolution_clock;
# 2836 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/chrono" 3
}



inline namespace literals
{
  inline namespace chrono_literals
  {

    constexpr chrono::hours operator""h(unsigned long long __h)
    {
        return chrono::hours(static_cast<chrono::hours::rep>(__h));
    }

    constexpr chrono::duration<long double, ratio<3600,1>> operator""h(long double __h)
    {
        return chrono::duration<long double, ratio<3600,1>>(__h);
    }


    constexpr chrono::minutes operator""min(unsigned long long __m)
    {
        return chrono::minutes(static_cast<chrono::minutes::rep>(__m));
    }

    constexpr chrono::duration<long double, ratio<60,1>> operator""min(long double __m)
    {
        return chrono::duration<long double, ratio<60,1>> (__m);
    }


    constexpr chrono::seconds operator""s(unsigned long long __s)
    {
        return chrono::seconds(static_cast<chrono::seconds::rep>(__s));
    }

    constexpr chrono::duration<long double> operator""s(long double __s)
    {
        return chrono::duration<long double> (__s);
    }


    constexpr chrono::milliseconds operator""ms(unsigned long long __ms)
    {
        return chrono::milliseconds(static_cast<chrono::milliseconds::rep>(__ms));
    }

    constexpr chrono::duration<long double, milli> operator""ms(long double __ms)
    {
        return chrono::duration<long double, milli>(__ms);
    }


    constexpr chrono::microseconds operator""us(unsigned long long __us)
    {
        return chrono::microseconds(static_cast<chrono::microseconds::rep>(__us));
    }

    constexpr chrono::duration<long double, micro> operator""us(long double __us)
    {
        return chrono::duration<long double, micro> (__us);
    }


    constexpr chrono::nanoseconds operator""ns(unsigned long long __ns)
    {
        return chrono::nanoseconds(static_cast<chrono::nanoseconds::rep>(__ns));
    }

    constexpr chrono::duration<long double, nano> operator""ns(long double __ns)
    {
        return chrono::duration<long double, nano> (__ns);
    }
# 2921 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/chrono" 3
}}

namespace chrono {
   using namespace literals::chrono_literals;
}



} }


namespace std { inline namespace __1 { inline namespace __fs { namespace filesystem {
struct _FilesystemClock {

  typedef __int128_t rep;
  typedef nano period;





  typedef chrono::duration<rep, period> duration;
  typedef chrono::time_point<_FilesystemClock> time_point;

  __attribute__((__visibility__("default")))
  static constexpr const bool is_steady = false;

  __attribute__((availability(macosx,strict,introduced=10.15))) __attribute__((availability(ios,strict,introduced=13.0))) __attribute__((availability(tvos,strict,introduced=13.0))) __attribute__((availability(watchos,strict,introduced=6.0))) __attribute__ ((__visibility__("default"))) static time_point now() noexcept;

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  static time_t to_time_t(const time_point& __t) noexcept {
      typedef chrono::duration<rep> __secs;
      return time_t(
          chrono::duration_cast<__secs>(__t.time_since_epoch()).count());
  }

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  static time_point from_time_t(time_t __t) noexcept {
      typedef chrono::duration<rep> __secs;
      return time_point(__secs(__t));
  }
};
} } } }
# 14 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__thread/poll_with_backoff.h" 2 3
# 17 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__thread/poll_with_backoff.h" 3


namespace std { inline namespace __1 {

static constexpr const int __libcpp_polling_count = 64;
# 34 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__thread/poll_with_backoff.h" 3
template<class _Fn, class _BFn>
__attribute__((availability(macosx,strict,introduced=11.0))) __attribute__((availability(ios,strict,introduced=14.0))) __attribute__((availability(tvos,strict,introduced=14.0))) __attribute__((availability(watchos,strict,introduced=7.0))) __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool __libcpp_thread_poll_with_backoff(_Fn&& __f, _BFn&& __bf, chrono::nanoseconds __max_elapsed = chrono::nanoseconds::zero()) {
    auto const __start = chrono::high_resolution_clock::now();
    for (int __count = 0;;) {
      if (__f())
        return true;
      if (__count < __libcpp_polling_count) {
        __count += 1;
        continue;
      }
      chrono::nanoseconds const __elapsed = chrono::high_resolution_clock::now() - __start;
      if (__max_elapsed != chrono::nanoseconds::zero() && __max_elapsed < __elapsed)
          return false;
      if (__bf(__elapsed))
        return false;
    }
}







struct __spinning_backoff_policy {
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
  bool operator()(chrono::nanoseconds const&) const {
      return false;
  }
};

} }
# 583 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/atomic" 2 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 1 3
# 587 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/atomic" 2 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__threading_support" 1 3
# 27 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__threading_support" 3







# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/pthread.h" 1 3 4
# 56 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/pthread.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/pthread/sched.h" 1 3 4
# 28 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/pthread/sched.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/pthread/pthread_impl.h" 1 3 4
# 33 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/pthread/pthread_impl.h" 3 4
#pragma clang assume_nonnull begin
# 33 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/pthread/pthread_impl.h" 3 4
#pragma clang assume_nonnull end
# 29 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/pthread/sched.h" 2 3 4

extern "C" {




struct sched_param { int sched_priority; char __opaque[4]; };




extern int sched_yield(void);
extern int sched_get_priority_min(int);
extern int sched_get_priority_max(int);
}
# 57 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/pthread.h" 2 3 4



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_pthread/_pthread_cond_t.h" 1 3 4
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_pthread/_pthread_cond_t.h" 3 4
typedef __darwin_pthread_cond_t pthread_cond_t;
# 61 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/pthread.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_pthread/_pthread_condattr_t.h" 1 3 4
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_pthread/_pthread_condattr_t.h" 3 4
typedef __darwin_pthread_condattr_t pthread_condattr_t;
# 62 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/pthread.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_pthread/_pthread_key_t.h" 1 3 4
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_pthread/_pthread_key_t.h" 3 4
typedef __darwin_pthread_key_t pthread_key_t;
# 63 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/pthread.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_pthread/_pthread_mutex_t.h" 1 3 4
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_pthread/_pthread_mutex_t.h" 3 4
typedef __darwin_pthread_mutex_t pthread_mutex_t;
# 64 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/pthread.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_pthread/_pthread_mutexattr_t.h" 1 3 4
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_pthread/_pthread_mutexattr_t.h" 3 4
typedef __darwin_pthread_mutexattr_t pthread_mutexattr_t;
# 65 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/pthread.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_pthread/_pthread_once_t.h" 1 3 4
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_pthread/_pthread_once_t.h" 3 4
typedef __darwin_pthread_once_t pthread_once_t;
# 66 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/pthread.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_pthread/_pthread_rwlock_t.h" 1 3 4
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_pthread/_pthread_rwlock_t.h" 3 4
typedef __darwin_pthread_rwlock_t pthread_rwlock_t;
# 67 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/pthread.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_pthread/_pthread_rwlockattr_t.h" 1 3 4
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_pthread/_pthread_rwlockattr_t.h" 3 4
typedef __darwin_pthread_rwlockattr_t pthread_rwlockattr_t;
# 68 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/pthread.h" 2 3 4


# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/pthread/qos.h" 1 3 4
# 34 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/pthread/qos.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/qos.h" 1 3 4
# 130 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/qos.h" 3 4
typedef enum : unsigned int { QOS_CLASS_USER_INTERACTIVE __attribute__((availability(macos,introduced=10.10))) __attribute__((availability(ios,introduced=8.0))) = 0x21, QOS_CLASS_USER_INITIATED __attribute__((availability(macos,introduced=10.10))) __attribute__((availability(ios,introduced=8.0))) = 0x19, QOS_CLASS_DEFAULT __attribute__((availability(macos,introduced=10.10))) __attribute__((availability(ios,introduced=8.0))) = 0x15, QOS_CLASS_UTILITY __attribute__((availability(macos,introduced=10.10))) __attribute__((availability(ios,introduced=8.0))) = 0x11, QOS_CLASS_BACKGROUND __attribute__((availability(macos,introduced=10.10))) __attribute__((availability(ios,introduced=8.0))) = 0x09, QOS_CLASS_UNSPECIFIED __attribute__((availability(macos,introduced=10.10))) __attribute__((availability(ios,introduced=8.0))) = 0x00, } qos_class_t;
# 159 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/qos.h" 3 4
extern "C" {
# 170 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/qos.h" 3 4
__attribute__((availability(macos,introduced=10.10))) __attribute__((availability(ios,introduced=8.0)))
qos_class_t
qos_class_self(void);
# 192 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/qos.h" 3 4
__attribute__((availability(macos,introduced=10.10))) __attribute__((availability(ios,introduced=8.0)))
qos_class_t
qos_class_main(void);

}
# 35 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/pthread/qos.h" 2 3 4




#pragma clang assume_nonnull begin

extern "C" {
# 81 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/pthread/qos.h" 3 4
__attribute__((availability(macos,introduced=10.10))) __attribute__((availability(ios,introduced=8.0)))
int
pthread_attr_set_qos_class_np(pthread_attr_t *__attr,
  qos_class_t __qos_class, int __relative_priority);
# 112 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/pthread/qos.h" 3 4
__attribute__((availability(macos,introduced=10.10))) __attribute__((availability(ios,introduced=8.0)))
int
pthread_attr_get_qos_class_np(pthread_attr_t * __attr,
  qos_class_t * _Nullable __qos_class,
  int * _Nullable __relative_priority);
# 153 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/pthread/qos.h" 3 4
__attribute__((availability(macos,introduced=10.10))) __attribute__((availability(ios,introduced=8.0)))
int
pthread_set_qos_class_self_np(qos_class_t __qos_class,
  int __relative_priority);
# 184 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/pthread/qos.h" 3 4
__attribute__((availability(macos,introduced=10.10))) __attribute__((availability(ios,introduced=8.0)))
int
pthread_get_qos_class_np(pthread_t __pthread,
  qos_class_t * _Nullable __qos_class,
  int * _Nullable __relative_priority);
# 211 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/pthread/qos.h" 3 4
typedef struct pthread_override_s* pthread_override_t;
# 263 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/pthread/qos.h" 3 4
__attribute__((availability(macos,introduced=10.10))) __attribute__((availability(ios,introduced=8.0)))
pthread_override_t
pthread_override_qos_class_start_np(pthread_t __pthread,
  qos_class_t __qos_class, int __relative_priority);
# 291 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/pthread/qos.h" 3 4
__attribute__((availability(macos,introduced=10.10))) __attribute__((availability(ios,introduced=8.0)))
int
pthread_override_qos_class_end_np(pthread_override_t __override);

}
# 295 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/pthread/qos.h" 3 4
#pragma clang assume_nonnull end
# 71 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/pthread.h" 2 3 4



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_mach_port_t.h" 1 3 4
# 50 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_mach_port_t.h" 3 4
typedef __darwin_mach_port_t mach_port_t;
# 75 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/pthread.h" 2 3 4
# 103 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/pthread.h" 3 4
#pragma clang assume_nonnull begin

extern "C" {
# 218 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/pthread.h" 3 4
__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_atfork(void (* _Nullable)(void), void (* _Nullable)(void),
  void (* _Nullable)(void));

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_attr_destroy(pthread_attr_t *);

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_attr_getdetachstate(const pthread_attr_t *, int *);

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_attr_getguardsize(const pthread_attr_t * , size_t * );

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_attr_getinheritsched(const pthread_attr_t * , int * );

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_attr_getschedparam(const pthread_attr_t * ,
  struct sched_param * );

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_attr_getschedpolicy(const pthread_attr_t * , int * );

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_attr_getscope(const pthread_attr_t * , int * );

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_attr_getstack(const pthread_attr_t * ,
  void * _Nullable * _Nonnull , size_t * );

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_attr_getstackaddr(const pthread_attr_t * ,
  void * _Nullable * _Nonnull );

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_attr_getstacksize(const pthread_attr_t * , size_t * );

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_attr_init(pthread_attr_t *);

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_attr_setdetachstate(pthread_attr_t *, int);

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_attr_setguardsize(pthread_attr_t *, size_t);

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_attr_setinheritsched(pthread_attr_t *, int);

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_attr_setschedparam(pthread_attr_t * ,
  const struct sched_param * );

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_attr_setschedpolicy(pthread_attr_t *, int);

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_attr_setscope(pthread_attr_t *, int);

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_attr_setstack(pthread_attr_t *, void *, size_t);

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_attr_setstackaddr(pthread_attr_t *, void *);

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_attr_setstacksize(pthread_attr_t *, size_t);

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_cancel(pthread_t) __asm("_" "pthread_cancel" );

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_cond_broadcast(pthread_cond_t *);

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_cond_destroy(pthread_cond_t *);

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_cond_init(
  pthread_cond_t * ,
  const pthread_condattr_t * _Nullable )
  __asm("_" "pthread_cond_init" );

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_cond_signal(pthread_cond_t *);

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_cond_timedwait(
  pthread_cond_t * , pthread_mutex_t * ,
  const struct timespec * _Nullable )
  __asm("_" "pthread_cond_timedwait" );

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_cond_wait(pthread_cond_t * ,
  pthread_mutex_t * ) __asm("_" "pthread_cond_wait" );

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_condattr_destroy(pthread_condattr_t *);

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_condattr_init(pthread_condattr_t *);

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_condattr_getpshared(const pthread_condattr_t * ,
  int * );

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_condattr_setpshared(pthread_condattr_t *, int);

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))

int pthread_create(pthread_t _Nullable * _Nonnull ,
  const pthread_attr_t * _Nullable ,
  void * _Nullable (* _Nonnull)(void * _Nullable),
  void * _Nullable );






__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_detach(pthread_t);

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_equal(pthread_t _Nullable, pthread_t _Nullable);

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
void pthread_exit(void * _Nullable) __attribute__((__noreturn__));

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_getconcurrency(void);

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_getschedparam(pthread_t , int * _Nullable ,
  struct sched_param * _Nullable );

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
void* _Nullable pthread_getspecific(pthread_key_t);

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_join(pthread_t , void * _Nullable * _Nullable)
  __asm("_" "pthread_join" );

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_key_create(pthread_key_t *, void (* _Nullable)(void *));

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_key_delete(pthread_key_t);

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_mutex_destroy(pthread_mutex_t *);

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_mutex_getprioceiling(const pthread_mutex_t * ,
  int * );

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_mutex_init(pthread_mutex_t * ,
  const pthread_mutexattr_t * _Nullable );

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_mutex_lock(pthread_mutex_t *);

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_mutex_setprioceiling(pthread_mutex_t * , int,
  int * );

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_mutex_trylock(pthread_mutex_t *);

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_mutex_unlock(pthread_mutex_t *);

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_mutexattr_destroy(pthread_mutexattr_t *) __asm("_" "pthread_mutexattr_destroy" );

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_mutexattr_getprioceiling(const pthread_mutexattr_t * ,
  int * );

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_mutexattr_getprotocol(const pthread_mutexattr_t * ,
  int * );

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_mutexattr_getpshared(const pthread_mutexattr_t * ,
  int * );

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_mutexattr_gettype(const pthread_mutexattr_t * ,
  int * );

__attribute__((availability(macos,introduced=10.13.4))) __attribute__((availability(ios,introduced=11.3))) __attribute__((availability(watchos,introduced=4.3))) __attribute__((availability(tvos,introduced=11.3)))
int pthread_mutexattr_getpolicy_np(const pthread_mutexattr_t * ,
  int * );

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_mutexattr_init(pthread_mutexattr_t *);

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_mutexattr_setprioceiling(pthread_mutexattr_t *, int);

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_mutexattr_setprotocol(pthread_mutexattr_t *, int);

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_mutexattr_setpshared(pthread_mutexattr_t *, int);

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_mutexattr_settype(pthread_mutexattr_t *, int);

__attribute__((availability(macos,introduced=10.7))) __attribute__((availability(ios,introduced=5.0)))
int pthread_mutexattr_setpolicy_np(pthread_mutexattr_t *, int);

__attribute__((availability(swift,unavailable,message="Use lazily initialized globals instead")))
__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_once(pthread_once_t *, void (* _Nonnull)(void));

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_rwlock_destroy(pthread_rwlock_t * ) __asm("_" "pthread_rwlock_destroy" );

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_rwlock_init(pthread_rwlock_t * ,
  const pthread_rwlockattr_t * _Nullable )
  __asm("_" "pthread_rwlock_init" );

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_rwlock_rdlock(pthread_rwlock_t *) __asm("_" "pthread_rwlock_rdlock" );

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_rwlock_tryrdlock(pthread_rwlock_t *) __asm("_" "pthread_rwlock_tryrdlock" );

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_rwlock_trywrlock(pthread_rwlock_t *) __asm("_" "pthread_rwlock_trywrlock" );

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_rwlock_wrlock(pthread_rwlock_t *) __asm("_" "pthread_rwlock_wrlock" );

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_rwlock_unlock(pthread_rwlock_t *) __asm("_" "pthread_rwlock_unlock" );

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_rwlockattr_destroy(pthread_rwlockattr_t *);

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_rwlockattr_getpshared(const pthread_rwlockattr_t * ,
  int * );

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_rwlockattr_init(pthread_rwlockattr_t *);

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_rwlockattr_setpshared(pthread_rwlockattr_t *, int);

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
pthread_t pthread_self(void);

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_setcancelstate(int , int * _Nullable)
  __asm("_" "pthread_setcancelstate" );

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_setcanceltype(int , int * _Nullable)
  __asm("_" "pthread_setcanceltype" );

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_setconcurrency(int);

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_setschedparam(pthread_t, int, const struct sched_param *);

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_setspecific(pthread_key_t , const void * _Nullable);

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
void pthread_testcancel(void) __asm("_" "pthread_testcancel" );




__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_is_threaded_np(void);

__attribute__((availability(macos,introduced=10.6))) __attribute__((availability(ios,introduced=3.2)))
int pthread_threadid_np(pthread_t _Nullable,__uint64_t* _Nullable);


__attribute__((availability(macos,introduced=10.6))) __attribute__((availability(ios,introduced=3.2)))
int pthread_getname_np(pthread_t,char*,size_t);

__attribute__((availability(macos,introduced=10.6))) __attribute__((availability(ios,introduced=3.2)))
int pthread_setname_np(const char*);


__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_main_np(void);


__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
mach_port_t pthread_mach_thread_np(pthread_t);

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
size_t pthread_get_stacksize_np(pthread_t);

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
void* pthread_get_stackaddr_np(pthread_t);


__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_cond_signal_thread_np(pthread_cond_t *, pthread_t _Nullable);


__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_cond_timedwait_relative_np(pthread_cond_t *, pthread_mutex_t *,
  const struct timespec * _Nullable);


__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))

int pthread_create_suspended_np(
  pthread_t _Nullable * _Nonnull, const pthread_attr_t * _Nullable,
  void * _Nullable (* _Nonnull)(void * _Nullable), void * _Nullable);





__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_kill(pthread_t, int);

__attribute__((availability(macos,introduced=10.5))) __attribute__((availability(ios,introduced=2.0)))
_Nullable pthread_t pthread_from_mach_thread_np(mach_port_t);

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_sigmask(int, const sigset_t * _Nullable, sigset_t * _Nullable)
  __asm("_" "pthread_sigmask" );

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
void pthread_yield_np(void);

__attribute__((availability(macos,introduced=11.0)))
__attribute__((availability(ios,unavailable))) __attribute__((availability(tvos,unavailable))) __attribute__((availability(watchos,unavailable))) __attribute__((availability(driverkit,unavailable)))
void pthread_jit_write_protect_np(int enabled);

__attribute__((availability(macos,introduced=11.0)))
__attribute__((availability(ios,unavailable))) __attribute__((availability(tvos,unavailable))) __attribute__((availability(watchos,unavailable))) __attribute__((availability(driverkit,unavailable)))
int pthread_jit_write_protect_supported_np(void);
# 581 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/pthread.h" 3 4
typedef int (*pthread_jit_write_callback_t)(void * _Nullable ctx);
# 667 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/pthread.h" 3 4
__attribute__((availability(macos,introduced=11.4)))
__attribute__((availability(ios,unavailable))) __attribute__((availability(tvos,unavailable))) __attribute__((availability(watchos,unavailable))) __attribute__((availability(driverkit,unavailable)))
__attribute__((availability(swift,unavailable,message="This interface cannot be safely used from Swift")))
int pthread_jit_write_with_callback_np(
  pthread_jit_write_callback_t _Nonnull callback, void * _Nullable ctx);
# 698 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/pthread.h" 3 4
__attribute__((availability(macos,introduced=12.1)))
__attribute__((availability(ios,unavailable))) __attribute__((availability(tvos,unavailable))) __attribute__((availability(watchos,unavailable))) __attribute__((availability(driverkit,unavailable)))
void pthread_jit_write_freeze_callbacks_np(void);
# 717 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/pthread.h" 3 4
__attribute__((availability(macos,introduced=11.0))) __attribute__((availability(ios,introduced=14.2))) __attribute__((availability(tvos,introduced=14.2))) __attribute__((availability(watchos,introduced=7.1)))
int
pthread_cpu_number_np(size_t *cpu_number_out);


}
# 722 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/pthread.h" 3 4
#pragma clang assume_nonnull end
# 35 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__threading_support" 2 3
# 54 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__threading_support" 3
typedef ::timespec __libcpp_timespec_t;



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 59 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__threading_support" 2 3

namespace std { inline namespace __1 {





typedef pthread_mutex_t __libcpp_mutex_t;


typedef pthread_mutex_t __libcpp_recursive_mutex_t;


typedef pthread_cond_t __libcpp_condvar_t;



typedef pthread_once_t __libcpp_exec_once_flag;






  typedef pthread_t __libcpp_thread_id;




typedef pthread_t __libcpp_thread_t;


typedef pthread_key_t __libcpp_tls_key;
# 160 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__threading_support" 3
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
int __libcpp_recursive_mutex_init(__libcpp_recursive_mutex_t *__m);

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
int __libcpp_recursive_mutex_lock(__libcpp_recursive_mutex_t *__m);

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool __libcpp_recursive_mutex_trylock(__libcpp_recursive_mutex_t *__m);

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
int __libcpp_recursive_mutex_unlock(__libcpp_recursive_mutex_t *__m);

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
int __libcpp_recursive_mutex_destroy(__libcpp_recursive_mutex_t *__m);

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
int __libcpp_mutex_lock(__libcpp_mutex_t *__m);

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool __libcpp_mutex_trylock(__libcpp_mutex_t *__m);

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
int __libcpp_mutex_unlock(__libcpp_mutex_t *__m);

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
int __libcpp_mutex_destroy(__libcpp_mutex_t *__m);


inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
int __libcpp_condvar_signal(__libcpp_condvar_t* __cv);

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
int __libcpp_condvar_broadcast(__libcpp_condvar_t* __cv);

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
int __libcpp_condvar_wait(__libcpp_condvar_t* __cv, __libcpp_mutex_t* __m);

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
int __libcpp_condvar_timedwait(__libcpp_condvar_t *__cv, __libcpp_mutex_t *__m,
                               __libcpp_timespec_t *__ts);

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
int __libcpp_condvar_destroy(__libcpp_condvar_t* __cv);


inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
int __libcpp_execute_once(__libcpp_exec_once_flag *flag,
                          void (*init_routine)());


inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool __libcpp_thread_id_equal(__libcpp_thread_id t1, __libcpp_thread_id t2);

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool __libcpp_thread_id_less(__libcpp_thread_id t1, __libcpp_thread_id t2);


inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool __libcpp_thread_isnull(const __libcpp_thread_t *__t);

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
int __libcpp_thread_create(__libcpp_thread_t *__t, void *(*__func)(void *),
                           void *__arg);

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
__libcpp_thread_id __libcpp_thread_get_current_id();

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
__libcpp_thread_id __libcpp_thread_get_id(const __libcpp_thread_t *__t);

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
int __libcpp_thread_join(__libcpp_thread_t *__t);

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
int __libcpp_thread_detach(__libcpp_thread_t *__t);

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void __libcpp_thread_yield();

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void __libcpp_thread_sleep_for(const chrono::nanoseconds& __ns);


inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
int __libcpp_tls_create(__libcpp_tls_key* __key,
                        void(* __at_exit)(void*));

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void *__libcpp_tls_get(__libcpp_tls_key __key);

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
int __libcpp_tls_set(__libcpp_tls_key __key, void *__p);



struct __libcpp_timed_backoff_policy {
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  bool operator()(chrono::nanoseconds __elapsed) const
  {
      if(__elapsed > chrono::milliseconds(128))
          __libcpp_thread_sleep_for(chrono::milliseconds(8));
      else if(__elapsed > chrono::microseconds(64))
          __libcpp_thread_sleep_for(__elapsed / 2);
      else if(__elapsed > chrono::microseconds(4))
        __libcpp_thread_yield();
      else
        {}
      return false;
  }
};





namespace __thread_detail {

inline __libcpp_timespec_t __convert_to_timespec(const chrono::nanoseconds& __ns)
{
  using namespace chrono;
  seconds __s = duration_cast<seconds>(__ns);
  __libcpp_timespec_t __ts;
  typedef decltype(__ts.tv_sec) __ts_sec;
  const __ts_sec __ts_sec_max = numeric_limits<__ts_sec>::max();

  if (__s.count() < __ts_sec_max)
  {
    __ts.tv_sec = static_cast<__ts_sec>(__s.count());
    __ts.tv_nsec = static_cast<decltype(__ts.tv_nsec)>((__ns - __s).count());
  }
  else
  {
    __ts.tv_sec = __ts_sec_max;
    __ts.tv_nsec = 999999999;
  }

  return __ts;
}

}



int __libcpp_recursive_mutex_init(__libcpp_recursive_mutex_t *__m)
{
  pthread_mutexattr_t attr;
  int __ec = pthread_mutexattr_init(&attr);
  if (__ec)
    return __ec;
  __ec = pthread_mutexattr_settype(&attr, 2);
  if (__ec) {
    pthread_mutexattr_destroy(&attr);
    return __ec;
  }
  __ec = pthread_mutex_init(__m, &attr);
  if (__ec) {
    pthread_mutexattr_destroy(&attr);
    return __ec;
  }
  __ec = pthread_mutexattr_destroy(&attr);
  if (__ec) {
    pthread_mutex_destroy(__m);
    return __ec;
  }
  return 0;
}

int __libcpp_recursive_mutex_lock(__libcpp_recursive_mutex_t *__m)
{
  return pthread_mutex_lock(__m);
}

bool __libcpp_recursive_mutex_trylock(__libcpp_recursive_mutex_t *__m)
{
  return pthread_mutex_trylock(__m) == 0;
}

int __libcpp_recursive_mutex_unlock(__libcpp_recursive_mutex_t *__m)
{
  return pthread_mutex_unlock(__m);
}

int __libcpp_recursive_mutex_destroy(__libcpp_recursive_mutex_t *__m)
{
  return pthread_mutex_destroy(__m);
}

int __libcpp_mutex_lock(__libcpp_mutex_t *__m)
{
  return pthread_mutex_lock(__m);
}

bool __libcpp_mutex_trylock(__libcpp_mutex_t *__m)
{
  return pthread_mutex_trylock(__m) == 0;
}

int __libcpp_mutex_unlock(__libcpp_mutex_t *__m)
{
  return pthread_mutex_unlock(__m);
}

int __libcpp_mutex_destroy(__libcpp_mutex_t *__m)
{
  return pthread_mutex_destroy(__m);
}


int __libcpp_condvar_signal(__libcpp_condvar_t *__cv)
{
  return pthread_cond_signal(__cv);
}

int __libcpp_condvar_broadcast(__libcpp_condvar_t *__cv)
{
  return pthread_cond_broadcast(__cv);
}

int __libcpp_condvar_wait(__libcpp_condvar_t *__cv, __libcpp_mutex_t *__m)
{
  return pthread_cond_wait(__cv, __m);
}

int __libcpp_condvar_timedwait(__libcpp_condvar_t *__cv, __libcpp_mutex_t *__m,
                               __libcpp_timespec_t *__ts)
{
  return pthread_cond_timedwait(__cv, __m, __ts);
}

int __libcpp_condvar_destroy(__libcpp_condvar_t *__cv)
{
  return pthread_cond_destroy(__cv);
}


int __libcpp_execute_once(__libcpp_exec_once_flag *flag,
                          void (*init_routine)()) {
  return pthread_once(flag, init_routine);
}



bool __libcpp_thread_id_equal(__libcpp_thread_id t1, __libcpp_thread_id t2)
{
  return t1 == t2;
}


bool __libcpp_thread_id_less(__libcpp_thread_id t1, __libcpp_thread_id t2)
{
  return t1 < t2;
}


bool __libcpp_thread_isnull(const __libcpp_thread_t *__t) {
  return __libcpp_thread_get_id(__t) == 0;
}

int __libcpp_thread_create(__libcpp_thread_t *__t, void *(*__func)(void *),
                           void *__arg)
{
  return pthread_create(__t, nullptr, __func, __arg);
}

__libcpp_thread_id __libcpp_thread_get_current_id()
{
  const __libcpp_thread_t thread = pthread_self();
  return __libcpp_thread_get_id(&thread);
}

__libcpp_thread_id __libcpp_thread_get_id(const __libcpp_thread_t *__t)
{



  return *__t;

}

int __libcpp_thread_join(__libcpp_thread_t *__t)
{
  return pthread_join(*__t, nullptr);
}

int __libcpp_thread_detach(__libcpp_thread_t *__t)
{
  return pthread_detach(*__t);
}

void __libcpp_thread_yield()
{
  sched_yield();
}

void __libcpp_thread_sleep_for(const chrono::nanoseconds& __ns)
{
   __libcpp_timespec_t __ts = __thread_detail::__convert_to_timespec(__ns);
   while (nanosleep(&__ts, &__ts) == -1 && (*__error()) == 4);
}


int __libcpp_tls_create(__libcpp_tls_key *__key, void (*__at_exit)(void *))
{
  return pthread_key_create(__key, __at_exit);
}

void *__libcpp_tls_get(__libcpp_tls_key __key)
{
  return pthread_getspecific(__key);
}

int __libcpp_tls_set(__libcpp_tls_key __key, void *__p)
{
    return pthread_setspecific(__key, __p);
}
# 640 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__threading_support" 3
class __attribute__ ((__visibility__("default"))) thread;
class __attribute__ ((__visibility__("default"))) __thread_id;

namespace this_thread
{

__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) __thread_id get_id() noexcept;

}

template<> struct hash<__thread_id>;

class __attribute__ ((__type_visibility__("default"))) __thread_id
{



    __libcpp_thread_id __id_;

public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __thread_id() noexcept : __id_(0) {}

    friend __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        bool operator==(__thread_id __x, __thread_id __y) noexcept
        {
        if (__x.__id_ == 0) return __y.__id_ == 0;
        if (__y.__id_ == 0) return false;
        return __libcpp_thread_id_equal(__x.__id_, __y.__id_);
        }
    friend __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        bool operator!=(__thread_id __x, __thread_id __y) noexcept
        {return !(__x == __y);}
    friend __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        bool operator< (__thread_id __x, __thread_id __y) noexcept
        {
        if (__x.__id_ == 0) return __y.__id_ != 0;
        if (__y.__id_ == 0) return false;
        return __libcpp_thread_id_less(__x.__id_, __y.__id_);
        }
    friend __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        bool operator<=(__thread_id __x, __thread_id __y) noexcept
        {return !(__y < __x);}
    friend __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        bool operator> (__thread_id __x, __thread_id __y) noexcept
        {return __y < __x ;}
    friend __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        bool operator>=(__thread_id __x, __thread_id __y) noexcept
        {return !(__x < __y);}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void __reset() { __id_ = 0; }

    template<class _CharT, class _Traits>
    friend
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __os, __thread_id __id);

private:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __thread_id(__libcpp_thread_id __id) : __id_(__id) {}

    friend __thread_id this_thread::get_id() noexcept;
    friend class __attribute__ ((__visibility__("default"))) thread;
    friend struct __attribute__ ((__type_visibility__("default"))) hash<__thread_id>;
};

namespace this_thread
{

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
__thread_id
get_id() noexcept
{
    return __libcpp_thread_get_current_id();
}

}



} }
# 591 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/atomic" 2 3
# 595 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/atomic" 3
# 620 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/atomic" 3
namespace std { inline namespace __1 {




enum __legacy_memory_order {
    __mo_relaxed,
    __mo_consume,
    __mo_acquire,
    __mo_release,
    __mo_acq_rel,
    __mo_seq_cst
};

typedef underlying_type<__legacy_memory_order>::type __memory_order_underlying_t;
# 656 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/atomic" 3
typedef enum memory_order {
  memory_order_relaxed = __mo_relaxed,
  memory_order_consume = __mo_consume,
  memory_order_acquire = __mo_acquire,
  memory_order_release = __mo_release,
  memory_order_acq_rel = __mo_acq_rel,
  memory_order_seq_cst = __mo_seq_cst,
} memory_order;



template <typename _Tp> __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool __cxx_nonatomic_compare_equal(_Tp const& __lhs, _Tp const& __rhs) {
    return std::__1::memcmp(&__lhs, &__rhs, sizeof(_Tp)) == 0;
}

static_assert((is_same<underlying_type<memory_order>::type, __memory_order_underlying_t>::value),
  "unexpected underlying type for std::memory_order");
# 952 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/atomic" 3
template <typename _Tp>
struct __cxx_atomic_base_impl {

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))

    __cxx_atomic_base_impl() noexcept = default;



  constexpr explicit __cxx_atomic_base_impl(_Tp value) noexcept
    : __a_value(value) {}
  __extension__ _Atomic(_Tp) __a_value;
};



__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) inline
void __cxx_atomic_thread_fence(memory_order __order) noexcept {
    __c11_atomic_thread_fence(static_cast<__memory_order_underlying_t>(__order));
}

__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) inline
void __cxx_atomic_signal_fence(memory_order __order) noexcept {
    __c11_atomic_signal_fence(static_cast<__memory_order_underlying_t>(__order));
}

template<class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void __cxx_atomic_init(__cxx_atomic_base_impl<_Tp> volatile* __a, _Tp __val) noexcept {
    __c11_atomic_init(&__a->__a_value, __val);
}
template<class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void __cxx_atomic_init(__cxx_atomic_base_impl<_Tp> * __a, _Tp __val) noexcept {
    __c11_atomic_init(&__a->__a_value, __val);
}

template<class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void __cxx_atomic_store(__cxx_atomic_base_impl<_Tp> volatile* __a, _Tp __val, memory_order __order) noexcept {
    __c11_atomic_store(&__a->__a_value, __val, static_cast<__memory_order_underlying_t>(__order));
}
template<class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void __cxx_atomic_store(__cxx_atomic_base_impl<_Tp> * __a, _Tp __val, memory_order __order) noexcept {
    __c11_atomic_store(&__a->__a_value, __val, static_cast<__memory_order_underlying_t>(__order));
}

template<class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
_Tp __cxx_atomic_load(__cxx_atomic_base_impl<_Tp> const volatile* __a, memory_order __order) noexcept {
    using __ptr_type = typename remove_const<decltype(__a->__a_value)>::type*;
    return __c11_atomic_load(const_cast<__ptr_type>(&__a->__a_value), static_cast<__memory_order_underlying_t>(__order));
}
template<class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
_Tp __cxx_atomic_load(__cxx_atomic_base_impl<_Tp> const* __a, memory_order __order) noexcept {
    using __ptr_type = typename remove_const<decltype(__a->__a_value)>::type*;
    return __c11_atomic_load(const_cast<__ptr_type>(&__a->__a_value), static_cast<__memory_order_underlying_t>(__order));
}

template<class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
_Tp __cxx_atomic_exchange(__cxx_atomic_base_impl<_Tp> volatile* __a, _Tp __value, memory_order __order) noexcept {
    return __c11_atomic_exchange(&__a->__a_value, __value, static_cast<__memory_order_underlying_t>(__order));
}
template<class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
_Tp __cxx_atomic_exchange(__cxx_atomic_base_impl<_Tp> * __a, _Tp __value, memory_order __order) noexcept {
    return __c11_atomic_exchange(&__a->__a_value, __value, static_cast<__memory_order_underlying_t>(__order));
}

__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) inline constexpr memory_order __to_failure_order(memory_order __order) {

  return __order == memory_order_release ? memory_order_relaxed:
         (__order == memory_order_acq_rel ? memory_order_acquire:
             __order);
}

template<class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool __cxx_atomic_compare_exchange_strong(__cxx_atomic_base_impl<_Tp> volatile* __a, _Tp* __expected, _Tp __value, memory_order __success, memory_order __failure) noexcept {
    return __c11_atomic_compare_exchange_strong(&__a->__a_value, __expected, __value, static_cast<__memory_order_underlying_t>(__success), static_cast<__memory_order_underlying_t>(__to_failure_order(__failure)));
}
template<class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool __cxx_atomic_compare_exchange_strong(__cxx_atomic_base_impl<_Tp> * __a, _Tp* __expected, _Tp __value, memory_order __success, memory_order __failure) noexcept {
    return __c11_atomic_compare_exchange_strong(&__a->__a_value, __expected, __value, static_cast<__memory_order_underlying_t>(__success), static_cast<__memory_order_underlying_t>(__to_failure_order(__failure)));
}

template<class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool __cxx_atomic_compare_exchange_weak(__cxx_atomic_base_impl<_Tp> volatile* __a, _Tp* __expected, _Tp __value, memory_order __success, memory_order __failure) noexcept {
    return __c11_atomic_compare_exchange_weak(&__a->__a_value, __expected, __value, static_cast<__memory_order_underlying_t>(__success), static_cast<__memory_order_underlying_t>(__to_failure_order(__failure)));
}
template<class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool __cxx_atomic_compare_exchange_weak(__cxx_atomic_base_impl<_Tp> * __a, _Tp* __expected, _Tp __value, memory_order __success, memory_order __failure) noexcept {
    return __c11_atomic_compare_exchange_weak(&__a->__a_value, __expected, __value, static_cast<__memory_order_underlying_t>(__success), static_cast<__memory_order_underlying_t>(__to_failure_order(__failure)));
}

template<class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
_Tp __cxx_atomic_fetch_add(__cxx_atomic_base_impl<_Tp> volatile* __a, _Tp __delta, memory_order __order) noexcept {
    return __c11_atomic_fetch_add(&__a->__a_value, __delta, static_cast<__memory_order_underlying_t>(__order));
}
template<class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
_Tp __cxx_atomic_fetch_add(__cxx_atomic_base_impl<_Tp> * __a, _Tp __delta, memory_order __order) noexcept {
    return __c11_atomic_fetch_add(&__a->__a_value, __delta, static_cast<__memory_order_underlying_t>(__order));
}

template<class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
_Tp* __cxx_atomic_fetch_add(__cxx_atomic_base_impl<_Tp*> volatile* __a, ptrdiff_t __delta, memory_order __order) noexcept {
    return __c11_atomic_fetch_add(&__a->__a_value, __delta, static_cast<__memory_order_underlying_t>(__order));
}
template<class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
_Tp* __cxx_atomic_fetch_add(__cxx_atomic_base_impl<_Tp*> * __a, ptrdiff_t __delta, memory_order __order) noexcept {
    return __c11_atomic_fetch_add(&__a->__a_value, __delta, static_cast<__memory_order_underlying_t>(__order));
}

template<class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
_Tp __cxx_atomic_fetch_sub(__cxx_atomic_base_impl<_Tp> volatile* __a, _Tp __delta, memory_order __order) noexcept {
    return __c11_atomic_fetch_sub(&__a->__a_value, __delta, static_cast<__memory_order_underlying_t>(__order));
}
template<class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
_Tp __cxx_atomic_fetch_sub(__cxx_atomic_base_impl<_Tp> * __a, _Tp __delta, memory_order __order) noexcept {
    return __c11_atomic_fetch_sub(&__a->__a_value, __delta, static_cast<__memory_order_underlying_t>(__order));
}
template<class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
_Tp* __cxx_atomic_fetch_sub(__cxx_atomic_base_impl<_Tp*> volatile* __a, ptrdiff_t __delta, memory_order __order) noexcept {
    return __c11_atomic_fetch_sub(&__a->__a_value, __delta, static_cast<__memory_order_underlying_t>(__order));
}
template<class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
_Tp* __cxx_atomic_fetch_sub(__cxx_atomic_base_impl<_Tp*> * __a, ptrdiff_t __delta, memory_order __order) noexcept {
    return __c11_atomic_fetch_sub(&__a->__a_value, __delta, static_cast<__memory_order_underlying_t>(__order));
}

template<class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
_Tp __cxx_atomic_fetch_and(__cxx_atomic_base_impl<_Tp> volatile* __a, _Tp __pattern, memory_order __order) noexcept {
    return __c11_atomic_fetch_and(&__a->__a_value, __pattern, static_cast<__memory_order_underlying_t>(__order));
}
template<class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
_Tp __cxx_atomic_fetch_and(__cxx_atomic_base_impl<_Tp> * __a, _Tp __pattern, memory_order __order) noexcept {
    return __c11_atomic_fetch_and(&__a->__a_value, __pattern, static_cast<__memory_order_underlying_t>(__order));
}

template<class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
_Tp __cxx_atomic_fetch_or(__cxx_atomic_base_impl<_Tp> volatile* __a, _Tp __pattern, memory_order __order) noexcept {
    return __c11_atomic_fetch_or(&__a->__a_value, __pattern, static_cast<__memory_order_underlying_t>(__order));
}
template<class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
_Tp __cxx_atomic_fetch_or(__cxx_atomic_base_impl<_Tp> * __a, _Tp __pattern, memory_order __order) noexcept {
    return __c11_atomic_fetch_or(&__a->__a_value, __pattern, static_cast<__memory_order_underlying_t>(__order));
}

template<class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
_Tp __cxx_atomic_fetch_xor(__cxx_atomic_base_impl<_Tp> volatile* __a, _Tp __pattern, memory_order __order) noexcept {
    return __c11_atomic_fetch_xor(&__a->__a_value, __pattern, static_cast<__memory_order_underlying_t>(__order));
}
template<class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
_Tp __cxx_atomic_fetch_xor(__cxx_atomic_base_impl<_Tp> * __a, _Tp __pattern, memory_order __order) noexcept {
    return __c11_atomic_fetch_xor(&__a->__a_value, __pattern, static_cast<__memory_order_underlying_t>(__order));
}



template <class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
_Tp kill_dependency(_Tp __y) noexcept
{
    return __y;
}
# 1498 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/atomic" 3
template <typename _Tp,
          typename _Base = __cxx_atomic_base_impl<_Tp> >

struct __cxx_atomic_impl : public _Base {






  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) __cxx_atomic_impl() noexcept = default;
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr explicit __cxx_atomic_impl(_Tp value) noexcept
    : _Base(value) {}
};




    using __cxx_contention_t = int64_t;


using __cxx_atomic_contention_t = __cxx_atomic_impl<__cxx_contention_t>;
# 1533 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/atomic" 3
__attribute__((availability(macosx,strict,introduced=11.0))) __attribute__((availability(ios,strict,introduced=14.0))) __attribute__((availability(tvos,strict,introduced=14.0))) __attribute__((availability(watchos,strict,introduced=7.0))) __attribute__((__visibility__("default"))) void __cxx_atomic_notify_one(void const volatile*);
__attribute__((availability(macosx,strict,introduced=11.0))) __attribute__((availability(ios,strict,introduced=14.0))) __attribute__((availability(tvos,strict,introduced=14.0))) __attribute__((availability(watchos,strict,introduced=7.0))) __attribute__((__visibility__("default"))) void __cxx_atomic_notify_all(void const volatile*);
__attribute__((availability(macosx,strict,introduced=11.0))) __attribute__((availability(ios,strict,introduced=14.0))) __attribute__((availability(tvos,strict,introduced=14.0))) __attribute__((availability(watchos,strict,introduced=7.0))) __attribute__((__visibility__("default"))) __cxx_contention_t __libcpp_atomic_monitor(void const volatile*);
__attribute__((availability(macosx,strict,introduced=11.0))) __attribute__((availability(ios,strict,introduced=14.0))) __attribute__((availability(tvos,strict,introduced=14.0))) __attribute__((availability(watchos,strict,introduced=7.0))) __attribute__((__visibility__("default"))) void __libcpp_atomic_wait(void const volatile*, __cxx_contention_t);

__attribute__((availability(macosx,strict,introduced=11.0))) __attribute__((availability(ios,strict,introduced=14.0))) __attribute__((availability(tvos,strict,introduced=14.0))) __attribute__((availability(watchos,strict,introduced=7.0))) __attribute__((__visibility__("default"))) void __cxx_atomic_notify_one(__cxx_atomic_contention_t const volatile*);
__attribute__((availability(macosx,strict,introduced=11.0))) __attribute__((availability(ios,strict,introduced=14.0))) __attribute__((availability(tvos,strict,introduced=14.0))) __attribute__((availability(watchos,strict,introduced=7.0))) __attribute__((__visibility__("default"))) void __cxx_atomic_notify_all(__cxx_atomic_contention_t const volatile*);
__attribute__((availability(macosx,strict,introduced=11.0))) __attribute__((availability(ios,strict,introduced=14.0))) __attribute__((availability(tvos,strict,introduced=14.0))) __attribute__((availability(watchos,strict,introduced=7.0))) __attribute__((__visibility__("default"))) __cxx_contention_t __libcpp_atomic_monitor(__cxx_atomic_contention_t const volatile*);
__attribute__((availability(macosx,strict,introduced=11.0))) __attribute__((availability(ios,strict,introduced=14.0))) __attribute__((availability(tvos,strict,introduced=14.0))) __attribute__((availability(watchos,strict,introduced=7.0))) __attribute__((__visibility__("default"))) void __libcpp_atomic_wait(__cxx_atomic_contention_t const volatile*, __cxx_contention_t);

template <class _Atp, class _Fn>
struct __libcpp_atomic_wait_backoff_impl {
    _Atp* __a;
    _Fn __test_fn;
    __attribute__((availability(macosx,strict,introduced=11.0))) __attribute__((availability(ios,strict,introduced=14.0))) __attribute__((availability(tvos,strict,introduced=14.0))) __attribute__((availability(watchos,strict,introduced=7.0)))
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) bool operator()(chrono::nanoseconds __elapsed) const
    {
        if(__elapsed > chrono::microseconds(64))
        {
            auto const __monitor = __libcpp_atomic_monitor(__a);
            if(__test_fn())
                return true;
            __libcpp_atomic_wait(__a, __monitor);
        }
        else if(__elapsed > chrono::microseconds(4))
            __libcpp_thread_yield();
        else
            {}
        return false;
    }
};

template <class _Atp, class _Fn>
__attribute__((availability(macosx,strict,introduced=11.0))) __attribute__((availability(ios,strict,introduced=14.0))) __attribute__((availability(tvos,strict,introduced=14.0))) __attribute__((availability(watchos,strict,introduced=7.0)))
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) bool __cxx_atomic_wait(_Atp* __a, _Fn && __test_fn)
{
    __libcpp_atomic_wait_backoff_impl<_Atp, typename decay<_Fn>::type> __backoff_fn = {__a, __test_fn};
    return __libcpp_thread_poll_with_backoff(__test_fn, __backoff_fn);
}
# 1592 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/atomic" 3
template <class _Atp, class _Tp>
struct __cxx_atomic_wait_test_fn_impl {
    _Atp* __a;
    _Tp __val;
    memory_order __order;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) bool operator()() const
    {
        return !__cxx_nonatomic_compare_equal(__cxx_atomic_load(__a, __order), __val);
    }
};

template <class _Atp, class _Tp>
__attribute__((availability(macosx,strict,introduced=11.0))) __attribute__((availability(ios,strict,introduced=14.0))) __attribute__((availability(tvos,strict,introduced=14.0))) __attribute__((availability(watchos,strict,introduced=7.0)))
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) bool __cxx_atomic_wait(_Atp* __a, _Tp const __val, memory_order __order)
{
    __cxx_atomic_wait_test_fn_impl<_Atp, _Tp> __test_fn = {__a, __val, __order};
    return __cxx_atomic_wait(__a, __test_fn);
}



template <class _Tp, bool = is_integral<_Tp>::value && !is_same<_Tp, bool>::value>
struct __atomic_base
{
    mutable __cxx_atomic_impl<_Tp> __a_;


  static constexpr bool is_always_lock_free = __atomic_always_lock_free(sizeof(__a_), 0);


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    bool is_lock_free() const volatile noexcept
        {return __c11_atomic_is_lock_free(sizeof(_Tp));}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    bool is_lock_free() const noexcept
        {return static_cast<__atomic_base const volatile*>(this)->is_lock_free();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void store(_Tp __d, memory_order __m = memory_order_seq_cst) volatile noexcept
      __attribute__((diagnose_if(__m == memory_order_consume || __m == memory_order_acquire || __m == memory_order_acq_rel, "memory order argument to atomic operation is invalid", "warning")))
        {__cxx_atomic_store(&__a_, __d, __m);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void store(_Tp __d, memory_order __m = memory_order_seq_cst) noexcept
      __attribute__((diagnose_if(__m == memory_order_consume || __m == memory_order_acquire || __m == memory_order_acq_rel, "memory order argument to atomic operation is invalid", "warning")))
        {__cxx_atomic_store(&__a_, __d, __m);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    _Tp load(memory_order __m = memory_order_seq_cst) const volatile noexcept
      __attribute__((diagnose_if(__m == memory_order_release || __m == memory_order_acq_rel, "memory order argument to atomic operation is invalid", "warning")))
        {return __cxx_atomic_load(&__a_, __m);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    _Tp load(memory_order __m = memory_order_seq_cst) const noexcept
      __attribute__((diagnose_if(__m == memory_order_release || __m == memory_order_acq_rel, "memory order argument to atomic operation is invalid", "warning")))
        {return __cxx_atomic_load(&__a_, __m);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    operator _Tp() const volatile noexcept {return load();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    operator _Tp() const noexcept {return load();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    _Tp exchange(_Tp __d, memory_order __m = memory_order_seq_cst) volatile noexcept
        {return __cxx_atomic_exchange(&__a_, __d, __m);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    _Tp exchange(_Tp __d, memory_order __m = memory_order_seq_cst) noexcept
        {return __cxx_atomic_exchange(&__a_, __d, __m);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    bool compare_exchange_weak(_Tp& __e, _Tp __d,
                               memory_order __s, memory_order __f) volatile noexcept
      __attribute__((diagnose_if(__f == memory_order_release || __f == memory_order_acq_rel, "memory order argument to atomic operation is invalid", "warning")))
        {return __cxx_atomic_compare_exchange_weak(&__a_, &__e, __d, __s, __f);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    bool compare_exchange_weak(_Tp& __e, _Tp __d,
                               memory_order __s, memory_order __f) noexcept
      __attribute__((diagnose_if(__f == memory_order_release || __f == memory_order_acq_rel, "memory order argument to atomic operation is invalid", "warning")))
        {return __cxx_atomic_compare_exchange_weak(&__a_, &__e, __d, __s, __f);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    bool compare_exchange_strong(_Tp& __e, _Tp __d,
                                 memory_order __s, memory_order __f) volatile noexcept
      __attribute__((diagnose_if(__f == memory_order_release || __f == memory_order_acq_rel, "memory order argument to atomic operation is invalid", "warning")))
        {return __cxx_atomic_compare_exchange_strong(&__a_, &__e, __d, __s, __f);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    bool compare_exchange_strong(_Tp& __e, _Tp __d,
                                 memory_order __s, memory_order __f) noexcept
      __attribute__((diagnose_if(__f == memory_order_release || __f == memory_order_acq_rel, "memory order argument to atomic operation is invalid", "warning")))
        {return __cxx_atomic_compare_exchange_strong(&__a_, &__e, __d, __s, __f);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    bool compare_exchange_weak(_Tp& __e, _Tp __d,
                              memory_order __m = memory_order_seq_cst) volatile noexcept
        {return __cxx_atomic_compare_exchange_weak(&__a_, &__e, __d, __m, __m);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    bool compare_exchange_weak(_Tp& __e, _Tp __d,
                               memory_order __m = memory_order_seq_cst) noexcept
        {return __cxx_atomic_compare_exchange_weak(&__a_, &__e, __d, __m, __m);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    bool compare_exchange_strong(_Tp& __e, _Tp __d,
                              memory_order __m = memory_order_seq_cst) volatile noexcept
        {return __cxx_atomic_compare_exchange_strong(&__a_, &__e, __d, __m, __m);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    bool compare_exchange_strong(_Tp& __e, _Tp __d,
                                 memory_order __m = memory_order_seq_cst) noexcept
        {return __cxx_atomic_compare_exchange_strong(&__a_, &__e, __d, __m, __m);}

    __attribute__((availability(macosx,strict,introduced=11.0))) __attribute__((availability(ios,strict,introduced=14.0))) __attribute__((availability(tvos,strict,introduced=14.0))) __attribute__((availability(watchos,strict,introduced=7.0))) __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) void wait(_Tp __v, memory_order __m = memory_order_seq_cst) const volatile noexcept
        {__cxx_atomic_wait(&__a_, __v, __m);}
    __attribute__((availability(macosx,strict,introduced=11.0))) __attribute__((availability(ios,strict,introduced=14.0))) __attribute__((availability(tvos,strict,introduced=14.0))) __attribute__((availability(watchos,strict,introduced=7.0))) __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) void wait(_Tp __v, memory_order __m = memory_order_seq_cst) const noexcept
        {__cxx_atomic_wait(&__a_, __v, __m);}
    __attribute__((availability(macosx,strict,introduced=11.0))) __attribute__((availability(ios,strict,introduced=14.0))) __attribute__((availability(tvos,strict,introduced=14.0))) __attribute__((availability(watchos,strict,introduced=7.0))) __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) void notify_one() volatile noexcept
        {__cxx_atomic_notify_one(&__a_);}
    __attribute__((availability(macosx,strict,introduced=11.0))) __attribute__((availability(ios,strict,introduced=14.0))) __attribute__((availability(tvos,strict,introduced=14.0))) __attribute__((availability(watchos,strict,introduced=7.0))) __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) void notify_one() noexcept
        {__cxx_atomic_notify_one(&__a_);}
    __attribute__((availability(macosx,strict,introduced=11.0))) __attribute__((availability(ios,strict,introduced=14.0))) __attribute__((availability(tvos,strict,introduced=14.0))) __attribute__((availability(watchos,strict,introduced=7.0))) __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) void notify_all() volatile noexcept
        {__cxx_atomic_notify_all(&__a_);}
    __attribute__((availability(macosx,strict,introduced=11.0))) __attribute__((availability(ios,strict,introduced=14.0))) __attribute__((availability(tvos,strict,introduced=14.0))) __attribute__((availability(watchos,strict,introduced=7.0))) __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) void notify_all() noexcept
        {__cxx_atomic_notify_all(&__a_);}





    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __atomic_base() noexcept = default;


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
    __atomic_base(_Tp __d) noexcept : __a_(__d) {}


    __atomic_base(const __atomic_base&) = delete;





};


template <class _Tp, bool __b>
constexpr bool __atomic_base<_Tp, __b>::is_always_lock_free;




template <class _Tp>
struct __atomic_base<_Tp, true>
    : public __atomic_base<_Tp, false>
{
    typedef __atomic_base<_Tp, false> __base;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __atomic_base() noexcept = default;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    constexpr __atomic_base(_Tp __d) noexcept : __base(__d) {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    _Tp fetch_add(_Tp __op, memory_order __m = memory_order_seq_cst) volatile noexcept
        {return __cxx_atomic_fetch_add(&this->__a_, __op, __m);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    _Tp fetch_add(_Tp __op, memory_order __m = memory_order_seq_cst) noexcept
        {return __cxx_atomic_fetch_add(&this->__a_, __op, __m);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    _Tp fetch_sub(_Tp __op, memory_order __m = memory_order_seq_cst) volatile noexcept
        {return __cxx_atomic_fetch_sub(&this->__a_, __op, __m);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    _Tp fetch_sub(_Tp __op, memory_order __m = memory_order_seq_cst) noexcept
        {return __cxx_atomic_fetch_sub(&this->__a_, __op, __m);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    _Tp fetch_and(_Tp __op, memory_order __m = memory_order_seq_cst) volatile noexcept
        {return __cxx_atomic_fetch_and(&this->__a_, __op, __m);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    _Tp fetch_and(_Tp __op, memory_order __m = memory_order_seq_cst) noexcept
        {return __cxx_atomic_fetch_and(&this->__a_, __op, __m);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    _Tp fetch_or(_Tp __op, memory_order __m = memory_order_seq_cst) volatile noexcept
        {return __cxx_atomic_fetch_or(&this->__a_, __op, __m);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    _Tp fetch_or(_Tp __op, memory_order __m = memory_order_seq_cst) noexcept
        {return __cxx_atomic_fetch_or(&this->__a_, __op, __m);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    _Tp fetch_xor(_Tp __op, memory_order __m = memory_order_seq_cst) volatile noexcept
        {return __cxx_atomic_fetch_xor(&this->__a_, __op, __m);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    _Tp fetch_xor(_Tp __op, memory_order __m = memory_order_seq_cst) noexcept
        {return __cxx_atomic_fetch_xor(&this->__a_, __op, __m);}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    _Tp operator++(int) volatile noexcept {return fetch_add(_Tp(1));}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    _Tp operator++(int) noexcept {return fetch_add(_Tp(1));}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    _Tp operator--(int) volatile noexcept {return fetch_sub(_Tp(1));}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    _Tp operator--(int) noexcept {return fetch_sub(_Tp(1));}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    _Tp operator++() volatile noexcept {return fetch_add(_Tp(1)) + _Tp(1);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    _Tp operator++() noexcept {return fetch_add(_Tp(1)) + _Tp(1);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    _Tp operator--() volatile noexcept {return fetch_sub(_Tp(1)) - _Tp(1);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    _Tp operator--() noexcept {return fetch_sub(_Tp(1)) - _Tp(1);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    _Tp operator+=(_Tp __op) volatile noexcept {return fetch_add(__op) + __op;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    _Tp operator+=(_Tp __op) noexcept {return fetch_add(__op) + __op;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    _Tp operator-=(_Tp __op) volatile noexcept {return fetch_sub(__op) - __op;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    _Tp operator-=(_Tp __op) noexcept {return fetch_sub(__op) - __op;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    _Tp operator&=(_Tp __op) volatile noexcept {return fetch_and(__op) & __op;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    _Tp operator&=(_Tp __op) noexcept {return fetch_and(__op) & __op;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    _Tp operator|=(_Tp __op) volatile noexcept {return fetch_or(__op) | __op;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    _Tp operator|=(_Tp __op) noexcept {return fetch_or(__op) | __op;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    _Tp operator^=(_Tp __op) volatile noexcept {return fetch_xor(__op) ^ __op;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    _Tp operator^=(_Tp __op) noexcept {return fetch_xor(__op) ^ __op;}
};



template <class _Tp>
struct atomic
    : public __atomic_base<_Tp>
{
    typedef __atomic_base<_Tp> __base;
    typedef _Tp value_type;
    typedef value_type difference_type;





    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    atomic() noexcept = default;


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    constexpr atomic(_Tp __d) noexcept : __base(__d) {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    _Tp operator=(_Tp __d) volatile noexcept
        {__base::store(__d); return __d;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    _Tp operator=(_Tp __d) noexcept
        {__base::store(__d); return __d;}

    atomic& operator=(const atomic&) = delete;
    atomic& operator=(const atomic&) volatile = delete;
};



template <class _Tp>
struct atomic<_Tp*>
    : public __atomic_base<_Tp*>
{
    typedef __atomic_base<_Tp*> __base;
    typedef _Tp* value_type;
    typedef ptrdiff_t difference_type;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    atomic() noexcept = default;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    constexpr atomic(_Tp* __d) noexcept : __base(__d) {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    _Tp* operator=(_Tp* __d) volatile noexcept
        {__base::store(__d); return __d;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    _Tp* operator=(_Tp* __d) noexcept
        {__base::store(__d); return __d;}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    _Tp* fetch_add(ptrdiff_t __op, memory_order __m = memory_order_seq_cst)
                                                                        volatile noexcept
        {return __cxx_atomic_fetch_add(&this->__a_, __op, __m);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    _Tp* fetch_add(ptrdiff_t __op, memory_order __m = memory_order_seq_cst) noexcept
        {return __cxx_atomic_fetch_add(&this->__a_, __op, __m);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    _Tp* fetch_sub(ptrdiff_t __op, memory_order __m = memory_order_seq_cst)
                                                                        volatile noexcept
        {return __cxx_atomic_fetch_sub(&this->__a_, __op, __m);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    _Tp* fetch_sub(ptrdiff_t __op, memory_order __m = memory_order_seq_cst) noexcept
        {return __cxx_atomic_fetch_sub(&this->__a_, __op, __m);}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    _Tp* operator++(int) volatile noexcept {return fetch_add(1);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    _Tp* operator++(int) noexcept {return fetch_add(1);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    _Tp* operator--(int) volatile noexcept {return fetch_sub(1);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    _Tp* operator--(int) noexcept {return fetch_sub(1);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    _Tp* operator++() volatile noexcept {return fetch_add(1) + 1;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    _Tp* operator++() noexcept {return fetch_add(1) + 1;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    _Tp* operator--() volatile noexcept {return fetch_sub(1) - 1;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    _Tp* operator--() noexcept {return fetch_sub(1) - 1;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    _Tp* operator+=(ptrdiff_t __op) volatile noexcept {return fetch_add(__op) + __op;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    _Tp* operator+=(ptrdiff_t __op) noexcept {return fetch_add(__op) + __op;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    _Tp* operator-=(ptrdiff_t __op) volatile noexcept {return fetch_sub(__op) - __op;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    _Tp* operator-=(ptrdiff_t __op) noexcept {return fetch_sub(__op) - __op;}

    atomic& operator=(const atomic&) = delete;
    atomic& operator=(const atomic&) volatile = delete;
};



template <class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
atomic_is_lock_free(const volatile atomic<_Tp>* __o) noexcept
{
    return __o->is_lock_free();
}

template <class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
atomic_is_lock_free(const atomic<_Tp>* __o) noexcept
{
    return __o->is_lock_free();
}



template <class _Tp>
                            __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void
atomic_init(volatile atomic<_Tp>* __o, typename atomic<_Tp>::value_type __d) noexcept
{
    __cxx_atomic_init(&__o->__a_, __d);
}

template <class _Tp>
                            __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void
atomic_init(atomic<_Tp>* __o, typename atomic<_Tp>::value_type __d) noexcept
{
    __cxx_atomic_init(&__o->__a_, __d);
}



template <class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void
atomic_store(volatile atomic<_Tp>* __o, typename atomic<_Tp>::value_type __d) noexcept
{
    __o->store(__d);
}

template <class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void
atomic_store(atomic<_Tp>* __o, typename atomic<_Tp>::value_type __d) noexcept
{
    __o->store(__d);
}



template <class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void
atomic_store_explicit(volatile atomic<_Tp>* __o, typename atomic<_Tp>::value_type __d, memory_order __m) noexcept
  __attribute__((diagnose_if(__m == memory_order_consume || __m == memory_order_acquire || __m == memory_order_acq_rel, "memory order argument to atomic operation is invalid", "warning")))
{
    __o->store(__d, __m);
}

template <class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void
atomic_store_explicit(atomic<_Tp>* __o, typename atomic<_Tp>::value_type __d, memory_order __m) noexcept
  __attribute__((diagnose_if(__m == memory_order_consume || __m == memory_order_acquire || __m == memory_order_acq_rel, "memory order argument to atomic operation is invalid", "warning")))
{
    __o->store(__d, __m);
}



template <class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
_Tp
atomic_load(const volatile atomic<_Tp>* __o) noexcept
{
    return __o->load();
}

template <class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
_Tp
atomic_load(const atomic<_Tp>* __o) noexcept
{
    return __o->load();
}



template <class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
_Tp
atomic_load_explicit(const volatile atomic<_Tp>* __o, memory_order __m) noexcept
  __attribute__((diagnose_if(__m == memory_order_release || __m == memory_order_acq_rel, "memory order argument to atomic operation is invalid", "warning")))
{
    return __o->load(__m);
}

template <class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
_Tp
atomic_load_explicit(const atomic<_Tp>* __o, memory_order __m) noexcept
  __attribute__((diagnose_if(__m == memory_order_release || __m == memory_order_acq_rel, "memory order argument to atomic operation is invalid", "warning")))
{
    return __o->load(__m);
}



template <class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
_Tp
atomic_exchange(volatile atomic<_Tp>* __o, typename atomic<_Tp>::value_type __d) noexcept
{
    return __o->exchange(__d);
}

template <class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
_Tp
atomic_exchange(atomic<_Tp>* __o, typename atomic<_Tp>::value_type __d) noexcept
{
    return __o->exchange(__d);
}



template <class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
_Tp
atomic_exchange_explicit(volatile atomic<_Tp>* __o, typename atomic<_Tp>::value_type __d, memory_order __m) noexcept
{
    return __o->exchange(__d, __m);
}

template <class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
_Tp
atomic_exchange_explicit(atomic<_Tp>* __o, typename atomic<_Tp>::value_type __d, memory_order __m) noexcept
{
    return __o->exchange(__d, __m);
}



template <class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
atomic_compare_exchange_weak(volatile atomic<_Tp>* __o, typename atomic<_Tp>::value_type* __e, typename atomic<_Tp>::value_type __d) noexcept
{
    return __o->compare_exchange_weak(*__e, __d);
}

template <class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
atomic_compare_exchange_weak(atomic<_Tp>* __o, typename atomic<_Tp>::value_type* __e, typename atomic<_Tp>::value_type __d) noexcept
{
    return __o->compare_exchange_weak(*__e, __d);
}



template <class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
atomic_compare_exchange_strong(volatile atomic<_Tp>* __o, typename atomic<_Tp>::value_type* __e, typename atomic<_Tp>::value_type __d) noexcept
{
    return __o->compare_exchange_strong(*__e, __d);
}

template <class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
atomic_compare_exchange_strong(atomic<_Tp>* __o, typename atomic<_Tp>::value_type* __e, typename atomic<_Tp>::value_type __d) noexcept
{
    return __o->compare_exchange_strong(*__e, __d);
}



template <class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
atomic_compare_exchange_weak_explicit(volatile atomic<_Tp>* __o, typename atomic<_Tp>::value_type* __e,
                                      typename atomic<_Tp>::value_type __d,
                                      memory_order __s, memory_order __f) noexcept
  __attribute__((diagnose_if(__f == memory_order_release || __f == memory_order_acq_rel, "memory order argument to atomic operation is invalid", "warning")))
{
    return __o->compare_exchange_weak(*__e, __d, __s, __f);
}

template <class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
atomic_compare_exchange_weak_explicit(atomic<_Tp>* __o, typename atomic<_Tp>::value_type* __e, typename atomic<_Tp>::value_type __d,
                                      memory_order __s, memory_order __f) noexcept
  __attribute__((diagnose_if(__f == memory_order_release || __f == memory_order_acq_rel, "memory order argument to atomic operation is invalid", "warning")))
{
    return __o->compare_exchange_weak(*__e, __d, __s, __f);
}



template <class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
atomic_compare_exchange_strong_explicit(volatile atomic<_Tp>* __o,
                                        typename atomic<_Tp>::value_type* __e, typename atomic<_Tp>::value_type __d,
                                        memory_order __s, memory_order __f) noexcept
  __attribute__((diagnose_if(__f == memory_order_release || __f == memory_order_acq_rel, "memory order argument to atomic operation is invalid", "warning")))
{
    return __o->compare_exchange_strong(*__e, __d, __s, __f);
}

template <class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
atomic_compare_exchange_strong_explicit(atomic<_Tp>* __o, typename atomic<_Tp>::value_type* __e,
                                        typename atomic<_Tp>::value_type __d,
                                        memory_order __s, memory_order __f) noexcept
  __attribute__((diagnose_if(__f == memory_order_release || __f == memory_order_acq_rel, "memory order argument to atomic operation is invalid", "warning")))
{
    return __o->compare_exchange_strong(*__e, __d, __s, __f);
}



template <class _Tp>
__attribute__((availability(macosx,strict,introduced=11.0))) __attribute__((availability(ios,strict,introduced=14.0))) __attribute__((availability(tvos,strict,introduced=14.0))) __attribute__((availability(watchos,strict,introduced=7.0))) __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void atomic_wait(const volatile atomic<_Tp>* __o,
                 typename atomic<_Tp>::value_type __v) noexcept
{
    return __o->wait(__v);
}

template <class _Tp>
__attribute__((availability(macosx,strict,introduced=11.0))) __attribute__((availability(ios,strict,introduced=14.0))) __attribute__((availability(tvos,strict,introduced=14.0))) __attribute__((availability(watchos,strict,introduced=7.0))) __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void atomic_wait(const atomic<_Tp>* __o,
                 typename atomic<_Tp>::value_type __v) noexcept
{
    return __o->wait(__v);
}



template <class _Tp>
__attribute__((availability(macosx,strict,introduced=11.0))) __attribute__((availability(ios,strict,introduced=14.0))) __attribute__((availability(tvos,strict,introduced=14.0))) __attribute__((availability(watchos,strict,introduced=7.0))) __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void atomic_wait_explicit(const volatile atomic<_Tp>* __o,
                          typename atomic<_Tp>::value_type __v,
                          memory_order __m) noexcept
  __attribute__((diagnose_if(__m == memory_order_release || __m == memory_order_acq_rel, "memory order argument to atomic operation is invalid", "warning")))
{
    return __o->wait(__v, __m);
}

template <class _Tp>
__attribute__((availability(macosx,strict,introduced=11.0))) __attribute__((availability(ios,strict,introduced=14.0))) __attribute__((availability(tvos,strict,introduced=14.0))) __attribute__((availability(watchos,strict,introduced=7.0))) __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void atomic_wait_explicit(const atomic<_Tp>* __o,
                          typename atomic<_Tp>::value_type __v,
                          memory_order __m) noexcept
  __attribute__((diagnose_if(__m == memory_order_release || __m == memory_order_acq_rel, "memory order argument to atomic operation is invalid", "warning")))
{
    return __o->wait(__v, __m);
}



template <class _Tp>
__attribute__((availability(macosx,strict,introduced=11.0))) __attribute__((availability(ios,strict,introduced=14.0))) __attribute__((availability(tvos,strict,introduced=14.0))) __attribute__((availability(watchos,strict,introduced=7.0))) __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void atomic_notify_one(volatile atomic<_Tp>* __o) noexcept
{
    __o->notify_one();
}
template <class _Tp>
__attribute__((availability(macosx,strict,introduced=11.0))) __attribute__((availability(ios,strict,introduced=14.0))) __attribute__((availability(tvos,strict,introduced=14.0))) __attribute__((availability(watchos,strict,introduced=7.0))) __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void atomic_notify_one(atomic<_Tp>* __o) noexcept
{
    __o->notify_one();
}



template <class _Tp>
__attribute__((availability(macosx,strict,introduced=11.0))) __attribute__((availability(ios,strict,introduced=14.0))) __attribute__((availability(tvos,strict,introduced=14.0))) __attribute__((availability(watchos,strict,introduced=7.0))) __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void atomic_notify_all(volatile atomic<_Tp>* __o) noexcept
{
    __o->notify_all();
}
template <class _Tp>
__attribute__((availability(macosx,strict,introduced=11.0))) __attribute__((availability(ios,strict,introduced=14.0))) __attribute__((availability(tvos,strict,introduced=14.0))) __attribute__((availability(watchos,strict,introduced=7.0))) __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void atomic_notify_all(atomic<_Tp>* __o) noexcept
{
    __o->notify_all();
}



template <class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename enable_if
<
    is_integral<_Tp>::value && !is_same<_Tp, bool>::value && !is_const<_Tp>::value,
    _Tp
>::type
atomic_fetch_add(volatile atomic<_Tp>* __o, typename atomic<_Tp>::difference_type __op) noexcept
{
    return __o->fetch_add(__op);
}

template <class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename enable_if
<
    is_integral<_Tp>::value && !is_same<_Tp, bool>::value && !is_const<_Tp>::value,
    _Tp
>::type
atomic_fetch_add(atomic<_Tp>* __o, typename atomic<_Tp>::difference_type __op) noexcept
{
    return __o->fetch_add(__op);
}

template <class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
_Tp*
atomic_fetch_add(volatile atomic<_Tp*>* __o, typename atomic<_Tp*>::difference_type __op) noexcept
{
    return __o->fetch_add(__op);
}

template <class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
_Tp*
atomic_fetch_add(atomic<_Tp*>* __o, typename atomic<_Tp*>::difference_type __op) noexcept
{
    return __o->fetch_add(__op);
}



template <class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename enable_if
<
    is_integral<_Tp>::value && !is_same<_Tp, bool>::value && !is_const<_Tp>::value,
    _Tp
>::type
atomic_fetch_add_explicit(volatile atomic<_Tp>* __o, typename atomic<_Tp>::difference_type __op, memory_order __m) noexcept
{
    return __o->fetch_add(__op, __m);
}

template <class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename enable_if
<
    is_integral<_Tp>::value && !is_same<_Tp, bool>::value && !is_const<_Tp>::value,
    _Tp
>::type
atomic_fetch_add_explicit(atomic<_Tp>* __o, typename atomic<_Tp>::difference_type __op, memory_order __m) noexcept
{
    return __o->fetch_add(__op, __m);
}

template <class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
_Tp*
atomic_fetch_add_explicit(volatile atomic<_Tp*>* __o, typename atomic<_Tp*>::difference_type __op, memory_order __m) noexcept
{
    return __o->fetch_add(__op, __m);
}

template <class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
_Tp*
atomic_fetch_add_explicit(atomic<_Tp*>* __o, typename atomic<_Tp*>::difference_type __op, memory_order __m) noexcept
{
    return __o->fetch_add(__op, __m);
}



template <class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename enable_if
<
    is_integral<_Tp>::value && !is_same<_Tp, bool>::value && !is_const<_Tp>::value,
    _Tp
>::type
atomic_fetch_sub(volatile atomic<_Tp>* __o, typename atomic<_Tp>::difference_type __op) noexcept
{
    return __o->fetch_sub(__op);
}

template <class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename enable_if
<
    is_integral<_Tp>::value && !is_same<_Tp, bool>::value && !is_const<_Tp>::value,
    _Tp
>::type
atomic_fetch_sub(atomic<_Tp>* __o, typename atomic<_Tp>::difference_type __op) noexcept
{
    return __o->fetch_sub(__op);
}

template <class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
_Tp*
atomic_fetch_sub(volatile atomic<_Tp*>* __o, typename atomic<_Tp*>::difference_type __op) noexcept
{
    return __o->fetch_sub(__op);
}

template <class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
_Tp*
atomic_fetch_sub(atomic<_Tp*>* __o, typename atomic<_Tp*>::difference_type __op) noexcept
{
    return __o->fetch_sub(__op);
}



template <class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename enable_if
<
    is_integral<_Tp>::value && !is_same<_Tp, bool>::value && !is_const<_Tp>::value,
    _Tp
>::type
atomic_fetch_sub_explicit(volatile atomic<_Tp>* __o, typename atomic<_Tp>::difference_type __op, memory_order __m) noexcept
{
    return __o->fetch_sub(__op, __m);
}

template <class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename enable_if
<
    is_integral<_Tp>::value && !is_same<_Tp, bool>::value && !is_const<_Tp>::value,
    _Tp
>::type
atomic_fetch_sub_explicit(atomic<_Tp>* __o, typename atomic<_Tp>::difference_type __op, memory_order __m) noexcept
{
    return __o->fetch_sub(__op, __m);
}

template <class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
_Tp*
atomic_fetch_sub_explicit(volatile atomic<_Tp*>* __o, typename atomic<_Tp*>::difference_type __op, memory_order __m) noexcept
{
    return __o->fetch_sub(__op, __m);
}

template <class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
_Tp*
atomic_fetch_sub_explicit(atomic<_Tp*>* __o, typename atomic<_Tp*>::difference_type __op, memory_order __m) noexcept
{
    return __o->fetch_sub(__op, __m);
}



template <class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename enable_if
<
    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
    _Tp
>::type
atomic_fetch_and(volatile atomic<_Tp>* __o, typename atomic<_Tp>::value_type __op) noexcept
{
    return __o->fetch_and(__op);
}

template <class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename enable_if
<
    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
    _Tp
>::type
atomic_fetch_and(atomic<_Tp>* __o, typename atomic<_Tp>::value_type __op) noexcept
{
    return __o->fetch_and(__op);
}



template <class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename enable_if
<
    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
    _Tp
>::type
atomic_fetch_and_explicit(volatile atomic<_Tp>* __o, typename atomic<_Tp>::value_type __op, memory_order __m) noexcept
{
    return __o->fetch_and(__op, __m);
}

template <class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename enable_if
<
    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
    _Tp
>::type
atomic_fetch_and_explicit(atomic<_Tp>* __o, typename atomic<_Tp>::value_type __op, memory_order __m) noexcept
{
    return __o->fetch_and(__op, __m);
}



template <class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename enable_if
<
    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
    _Tp
>::type
atomic_fetch_or(volatile atomic<_Tp>* __o, typename atomic<_Tp>::value_type __op) noexcept
{
    return __o->fetch_or(__op);
}

template <class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename enable_if
<
    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
    _Tp
>::type
atomic_fetch_or(atomic<_Tp>* __o, typename atomic<_Tp>::value_type __op) noexcept
{
    return __o->fetch_or(__op);
}



template <class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename enable_if
<
    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
    _Tp
>::type
atomic_fetch_or_explicit(volatile atomic<_Tp>* __o, typename atomic<_Tp>::value_type __op, memory_order __m) noexcept
{
    return __o->fetch_or(__op, __m);
}

template <class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename enable_if
<
    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
    _Tp
>::type
atomic_fetch_or_explicit(atomic<_Tp>* __o, typename atomic<_Tp>::value_type __op, memory_order __m) noexcept
{
    return __o->fetch_or(__op, __m);
}



template <class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename enable_if
<
    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
    _Tp
>::type
atomic_fetch_xor(volatile atomic<_Tp>* __o, typename atomic<_Tp>::value_type __op) noexcept
{
    return __o->fetch_xor(__op);
}

template <class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename enable_if
<
    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
    _Tp
>::type
atomic_fetch_xor(atomic<_Tp>* __o, typename atomic<_Tp>::value_type __op) noexcept
{
    return __o->fetch_xor(__op);
}



template <class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename enable_if
<
    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
    _Tp
>::type
atomic_fetch_xor_explicit(volatile atomic<_Tp>* __o, typename atomic<_Tp>::value_type __op, memory_order __m) noexcept
{
    return __o->fetch_xor(__op, __m);
}

template <class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename enable_if
<
    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
    _Tp
>::type
atomic_fetch_xor_explicit(atomic<_Tp>* __o, typename atomic<_Tp>::value_type __op, memory_order __m) noexcept
{
    return __o->fetch_xor(__op, __m);
}



typedef struct atomic_flag
{
    __cxx_atomic_impl<bool> __a_;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    bool test(memory_order __m = memory_order_seq_cst) const volatile noexcept
        {return bool(true) == __cxx_atomic_load(&__a_, __m);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    bool test(memory_order __m = memory_order_seq_cst) const noexcept
        {return bool(true) == __cxx_atomic_load(&__a_, __m);}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    bool test_and_set(memory_order __m = memory_order_seq_cst) volatile noexcept
        {return __cxx_atomic_exchange(&__a_, bool(true), __m);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    bool test_and_set(memory_order __m = memory_order_seq_cst) noexcept
        {return __cxx_atomic_exchange(&__a_, bool(true), __m);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void clear(memory_order __m = memory_order_seq_cst) volatile noexcept
        {__cxx_atomic_store(&__a_, bool(false), __m);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void clear(memory_order __m = memory_order_seq_cst) noexcept
        {__cxx_atomic_store(&__a_, bool(false), __m);}

    __attribute__((availability(macosx,strict,introduced=11.0))) __attribute__((availability(ios,strict,introduced=14.0))) __attribute__((availability(tvos,strict,introduced=14.0))) __attribute__((availability(watchos,strict,introduced=7.0))) __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void wait(bool __v, memory_order __m = memory_order_seq_cst) const volatile noexcept
        {__cxx_atomic_wait(&__a_, bool(__v), __m);}
    __attribute__((availability(macosx,strict,introduced=11.0))) __attribute__((availability(ios,strict,introduced=14.0))) __attribute__((availability(tvos,strict,introduced=14.0))) __attribute__((availability(watchos,strict,introduced=7.0))) __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void wait(bool __v, memory_order __m = memory_order_seq_cst) const noexcept
        {__cxx_atomic_wait(&__a_, bool(__v), __m);}
    __attribute__((availability(macosx,strict,introduced=11.0))) __attribute__((availability(ios,strict,introduced=14.0))) __attribute__((availability(tvos,strict,introduced=14.0))) __attribute__((availability(watchos,strict,introduced=7.0))) __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void notify_one() volatile noexcept
        {__cxx_atomic_notify_one(&__a_);}
    __attribute__((availability(macosx,strict,introduced=11.0))) __attribute__((availability(ios,strict,introduced=14.0))) __attribute__((availability(tvos,strict,introduced=14.0))) __attribute__((availability(watchos,strict,introduced=7.0))) __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void notify_one() noexcept
        {__cxx_atomic_notify_one(&__a_);}
    __attribute__((availability(macosx,strict,introduced=11.0))) __attribute__((availability(ios,strict,introduced=14.0))) __attribute__((availability(tvos,strict,introduced=14.0))) __attribute__((availability(watchos,strict,introduced=7.0))) __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void notify_all() volatile noexcept
        {__cxx_atomic_notify_all(&__a_);}
    __attribute__((availability(macosx,strict,introduced=11.0))) __attribute__((availability(ios,strict,introduced=14.0))) __attribute__((availability(tvos,strict,introduced=14.0))) __attribute__((availability(watchos,strict,introduced=7.0))) __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void notify_all() noexcept
        {__cxx_atomic_notify_all(&__a_);}





    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    atomic_flag() noexcept = default;


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
    atomic_flag(bool __b) noexcept : __a_(__b) {}


    atomic_flag(const atomic_flag&) = delete;
    atomic_flag& operator=(const atomic_flag&) = delete;
    atomic_flag& operator=(const atomic_flag&) volatile = delete;
# 2605 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/atomic" 3
} atomic_flag;


inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
atomic_flag_test(const volatile atomic_flag* __o) noexcept
{
    return __o->test();
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
atomic_flag_test(const atomic_flag* __o) noexcept
{
    return __o->test();
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
atomic_flag_test_explicit(const volatile atomic_flag* __o, memory_order __m) noexcept
{
    return __o->test(__m);
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
atomic_flag_test_explicit(const atomic_flag* __o, memory_order __m) noexcept
{
    return __o->test(__m);
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
atomic_flag_test_and_set(volatile atomic_flag* __o) noexcept
{
    return __o->test_and_set();
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
atomic_flag_test_and_set(atomic_flag* __o) noexcept
{
    return __o->test_and_set();
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
atomic_flag_test_and_set_explicit(volatile atomic_flag* __o, memory_order __m) noexcept
{
    return __o->test_and_set(__m);
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
atomic_flag_test_and_set_explicit(atomic_flag* __o, memory_order __m) noexcept
{
    return __o->test_and_set(__m);
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void
atomic_flag_clear(volatile atomic_flag* __o) noexcept
{
    __o->clear();
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void
atomic_flag_clear(atomic_flag* __o) noexcept
{
    __o->clear();
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void
atomic_flag_clear_explicit(volatile atomic_flag* __o, memory_order __m) noexcept
{
    __o->clear(__m);
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void
atomic_flag_clear_explicit(atomic_flag* __o, memory_order __m) noexcept
{
    __o->clear(__m);
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) __attribute__((availability(macosx,strict,introduced=11.0))) __attribute__((availability(ios,strict,introduced=14.0))) __attribute__((availability(tvos,strict,introduced=14.0))) __attribute__((availability(watchos,strict,introduced=7.0)))
void
atomic_flag_wait(const volatile atomic_flag* __o, bool __v) noexcept
{
    __o->wait(__v);
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) __attribute__((availability(macosx,strict,introduced=11.0))) __attribute__((availability(ios,strict,introduced=14.0))) __attribute__((availability(tvos,strict,introduced=14.0))) __attribute__((availability(watchos,strict,introduced=7.0)))
void
atomic_flag_wait(const atomic_flag* __o, bool __v) noexcept
{
    __o->wait(__v);
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) __attribute__((availability(macosx,strict,introduced=11.0))) __attribute__((availability(ios,strict,introduced=14.0))) __attribute__((availability(tvos,strict,introduced=14.0))) __attribute__((availability(watchos,strict,introduced=7.0)))
void
atomic_flag_wait_explicit(const volatile atomic_flag* __o,
                          bool __v, memory_order __m) noexcept
{
    __o->wait(__v, __m);
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) __attribute__((availability(macosx,strict,introduced=11.0))) __attribute__((availability(ios,strict,introduced=14.0))) __attribute__((availability(tvos,strict,introduced=14.0))) __attribute__((availability(watchos,strict,introduced=7.0)))
void
atomic_flag_wait_explicit(const atomic_flag* __o,
                          bool __v, memory_order __m) noexcept
{
    __o->wait(__v, __m);
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) __attribute__((availability(macosx,strict,introduced=11.0))) __attribute__((availability(ios,strict,introduced=14.0))) __attribute__((availability(tvos,strict,introduced=14.0))) __attribute__((availability(watchos,strict,introduced=7.0)))
void
atomic_flag_notify_one(volatile atomic_flag* __o) noexcept
{
    __o->notify_one();
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) __attribute__((availability(macosx,strict,introduced=11.0))) __attribute__((availability(ios,strict,introduced=14.0))) __attribute__((availability(tvos,strict,introduced=14.0))) __attribute__((availability(watchos,strict,introduced=7.0)))
void
atomic_flag_notify_one(atomic_flag* __o) noexcept
{
    __o->notify_one();
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) __attribute__((availability(macosx,strict,introduced=11.0))) __attribute__((availability(ios,strict,introduced=14.0))) __attribute__((availability(tvos,strict,introduced=14.0))) __attribute__((availability(watchos,strict,introduced=7.0)))
void
atomic_flag_notify_all(volatile atomic_flag* __o) noexcept
{
    __o->notify_all();
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) __attribute__((availability(macosx,strict,introduced=11.0))) __attribute__((availability(ios,strict,introduced=14.0))) __attribute__((availability(tvos,strict,introduced=14.0))) __attribute__((availability(watchos,strict,introduced=7.0)))
void
atomic_flag_notify_all(atomic_flag* __o) noexcept
{
    __o->notify_all();
}



inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void
atomic_thread_fence(memory_order __m) noexcept
{
    __cxx_atomic_thread_fence(__m);
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void
atomic_signal_fence(memory_order __m) noexcept
{
    __cxx_atomic_signal_fence(__m);
}



typedef atomic<bool> atomic_bool;
typedef atomic<char> atomic_char;
typedef atomic<signed char> atomic_schar;
typedef atomic<unsigned char> atomic_uchar;
typedef atomic<short> atomic_short;
typedef atomic<unsigned short> atomic_ushort;
typedef atomic<int> atomic_int;
typedef atomic<unsigned int> atomic_uint;
typedef atomic<long> atomic_long;
typedef atomic<unsigned long> atomic_ulong;
typedef atomic<long long> atomic_llong;
typedef atomic<unsigned long long> atomic_ullong;



typedef atomic<char16_t> atomic_char16_t;
typedef atomic<char32_t> atomic_char32_t;

typedef atomic<wchar_t> atomic_wchar_t;


typedef atomic<int_least8_t> atomic_int_least8_t;
typedef atomic<uint_least8_t> atomic_uint_least8_t;
typedef atomic<int_least16_t> atomic_int_least16_t;
typedef atomic<uint_least16_t> atomic_uint_least16_t;
typedef atomic<int_least32_t> atomic_int_least32_t;
typedef atomic<uint_least32_t> atomic_uint_least32_t;
typedef atomic<int_least64_t> atomic_int_least64_t;
typedef atomic<uint_least64_t> atomic_uint_least64_t;

typedef atomic<int_fast8_t> atomic_int_fast8_t;
typedef atomic<uint_fast8_t> atomic_uint_fast8_t;
typedef atomic<int_fast16_t> atomic_int_fast16_t;
typedef atomic<uint_fast16_t> atomic_uint_fast16_t;
typedef atomic<int_fast32_t> atomic_int_fast32_t;
typedef atomic<uint_fast32_t> atomic_uint_fast32_t;
typedef atomic<int_fast64_t> atomic_int_fast64_t;
typedef atomic<uint_fast64_t> atomic_uint_fast64_t;

typedef atomic< int8_t> atomic_int8_t;
typedef atomic<uint8_t> atomic_uint8_t;
typedef atomic< int16_t> atomic_int16_t;
typedef atomic<uint16_t> atomic_uint16_t;
typedef atomic< int32_t> atomic_int32_t;
typedef atomic<uint32_t> atomic_uint32_t;
typedef atomic< int64_t> atomic_int64_t;
typedef atomic<uint64_t> atomic_uint64_t;

typedef atomic<intptr_t> atomic_intptr_t;
typedef atomic<uintptr_t> atomic_uintptr_t;
typedef atomic<size_t> atomic_size_t;
typedef atomic<ptrdiff_t> atomic_ptrdiff_t;
typedef atomic<intmax_t> atomic_intmax_t;
typedef atomic<uintmax_t> atomic_uintmax_t;
# 2832 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/atomic" 3
typedef conditional<__atomic_always_lock_free(sizeof(__cxx_contention_t), 0), __cxx_contention_t, long long>::type __libcpp_signed_lock_free;
typedef conditional<__atomic_always_lock_free(sizeof(__cxx_contention_t), 0), __cxx_contention_t, unsigned long long>::type __libcpp_unsigned_lock_free;
# 2847 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/atomic" 3
typedef atomic<__libcpp_signed_lock_free> atomic_signed_lock_free;
typedef atomic<__libcpp_unsigned_lock_free> atomic_unsigned_lock_free;




} }
# 36 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/shared_ptr.h" 2 3
# 44 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/shared_ptr.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 48 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/shared_ptr.h" 2 3

namespace std { inline namespace __1 {

template <class _Alloc>
class __allocator_destructor
{
    typedef allocator_traits<_Alloc> __alloc_traits;
public:
    typedef typename __alloc_traits::pointer pointer;
    typedef typename __alloc_traits::size_type size_type;
private:
    _Alloc& __alloc_;
    size_type __s_;
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) __allocator_destructor(_Alloc& __a, size_type __s)
             noexcept
        : __alloc_(__a), __s_(__s) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void operator()(pointer __p) noexcept
        {__alloc_traits::deallocate(__alloc_, __p, __s_);}
};
# 81 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/shared_ptr.h" 3
template <class _ValueType>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
_ValueType __libcpp_relaxed_load(_ValueType const* __value) {



    return __atomic_load_n(__value, 0);



}

template <class _ValueType>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
_ValueType __libcpp_acquire_load(_ValueType const* __value) {



    return __atomic_load_n(__value, 2);



}

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) _Tp
__libcpp_atomic_refcount_increment(_Tp& __t) noexcept
{

    return __atomic_add_fetch(&__t, 1, 0);



}

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) _Tp
__libcpp_atomic_refcount_decrement(_Tp& __t) noexcept
{

    return __atomic_add_fetch(&__t, -1, 4);



}

class __attribute__ ((__visibility__("default"))) bad_weak_ptr
    : public std::exception
{
public:
    bad_weak_ptr() noexcept = default;
    bad_weak_ptr(const bad_weak_ptr&) noexcept = default;
    virtual ~bad_weak_ptr() noexcept;
    virtual const char* what() const noexcept;
};

[[noreturn]] inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void __throw_bad_weak_ptr()
{

    throw bad_weak_ptr();



}

template<class _Tp> class __attribute__ ((__type_visibility__("default"))) weak_ptr;

class __attribute__ ((__visibility__("default"))) __shared_count
{
    __shared_count(const __shared_count&);
    __shared_count& operator=(const __shared_count&);

protected:
    long __shared_owners_;
    virtual ~__shared_count();
private:
    virtual void __on_zero_shared() noexcept = 0;

public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit __shared_count(long __refs = 0) noexcept
        : __shared_owners_(__refs) {}






    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void __add_shared() noexcept {
      __libcpp_atomic_refcount_increment(__shared_owners_);
    }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    bool __release_shared() noexcept {
      if (__libcpp_atomic_refcount_decrement(__shared_owners_) == -1) {
        __on_zero_shared();
        return true;
      }
      return false;
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    long use_count() const noexcept {
        return __libcpp_relaxed_load(&__shared_owners_) + 1;
    }
};

class __attribute__ ((__visibility__("default"))) __shared_weak_count
    : private __shared_count
{
    long __shared_weak_owners_;

public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit __shared_weak_count(long __refs = 0) noexcept
        : __shared_count(__refs),
          __shared_weak_owners_(__refs) {}
protected:
    virtual ~__shared_weak_count();

public:






    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void __add_shared() noexcept {
      __shared_count::__add_shared();
    }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void __add_weak() noexcept {
      __libcpp_atomic_refcount_increment(__shared_weak_owners_);
    }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void __release_shared() noexcept {
      if (__shared_count::__release_shared())
        __release_weak();
    }

    void __release_weak() noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    long use_count() const noexcept {return __shared_count::use_count();}
    __shared_weak_count* lock() noexcept;

    virtual const void* __get_deleter(const type_info&) const noexcept;
private:
    virtual void __on_zero_shared_weak() noexcept = 0;
};

template <class _Tp, class _Dp, class _Alloc>
class __shared_ptr_pointer
    : public __shared_weak_count
{
    __compressed_pair<__compressed_pair<_Tp, _Dp>, _Alloc> __data_;
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __shared_ptr_pointer(_Tp __p, _Dp __d, _Alloc __a)
        : __data_(__compressed_pair<_Tp, _Dp>(__p, std::__1::move(__d)), std::__1::move(__a)) {}


    virtual const void* __get_deleter(const type_info&) const noexcept;


private:
    virtual void __on_zero_shared() noexcept;
    virtual void __on_zero_shared_weak() noexcept;
};



template <class _Tp, class _Dp, class _Alloc>
const void*
__shared_ptr_pointer<_Tp, _Dp, _Alloc>::__get_deleter(const type_info& __t) const noexcept
{
    return __t == typeid(_Dp) ? std::__1::addressof(__data_.first().second()) : nullptr;
}



template <class _Tp, class _Dp, class _Alloc>
void
__shared_ptr_pointer<_Tp, _Dp, _Alloc>::__on_zero_shared() noexcept
{
    __data_.first().second()(__data_.first().first());
    __data_.first().second().~_Dp();
}

template <class _Tp, class _Dp, class _Alloc>
void
__shared_ptr_pointer<_Tp, _Dp, _Alloc>::__on_zero_shared_weak() noexcept
{
    typedef typename __allocator_traits_rebind<_Alloc, __shared_ptr_pointer>::type _Al;
    typedef allocator_traits<_Al> _ATraits;
    typedef pointer_traits<typename _ATraits::pointer> _PTraits;

    _Al __a(__data_.second());
    __data_.second().~_Alloc();
    __a.deallocate(_PTraits::pointer_to(*this), 1);
}

template <class _Tp, class _Alloc>
struct __shared_ptr_emplace
    : __shared_weak_count
{
    template<class ..._Args>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit __shared_ptr_emplace(_Alloc __a, _Args&& ...__args)
        : __storage_(std::__1::move(__a))
    {





        ::new ((void*)__get_elem()) _Tp(std::__1::forward<_Args>(__args)...);

    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    _Alloc* __get_alloc() noexcept { return __storage_.__get_alloc(); }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    _Tp* __get_elem() noexcept { return __storage_.__get_elem(); }

private:
    virtual void __on_zero_shared() noexcept {





        __get_elem()->~_Tp();

    }

    virtual void __on_zero_shared_weak() noexcept {
        using _ControlBlockAlloc = typename __allocator_traits_rebind<_Alloc, __shared_ptr_emplace>::type;
        using _ControlBlockPointer = typename allocator_traits<_ControlBlockAlloc>::pointer;
        _ControlBlockAlloc __tmp(*__get_alloc());
        __storage_.~_Storage();
        allocator_traits<_ControlBlockAlloc>::deallocate(__tmp,
            pointer_traits<_ControlBlockPointer>::pointer_to(*this), 1);
    }
# 336 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/shared_ptr.h" 3
    using _CompressedPair = __compressed_pair<_Alloc, _Tp>;
    struct alignas(_CompressedPair) _Storage {
        char __blob_[sizeof(_CompressedPair)];

        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) explicit _Storage(_Alloc&& __a) {
            ::new ((void*)__get_alloc()) _Alloc(std::__1::move(__a));
        }
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) ~_Storage() {
            __get_alloc()->~_Alloc();
        }
        _Alloc* __get_alloc() noexcept {
            _CompressedPair *__as_pair = reinterpret_cast<_CompressedPair*>(__blob_);
            typename _CompressedPair::_Base1* __first = _CompressedPair::__get_first_base(__as_pair);
            _Alloc *__alloc = reinterpret_cast<_Alloc*>(__first);
            return __alloc;
        }
        __attribute__((__no_sanitize__("cfi"))) _Tp* __get_elem() noexcept {
            _CompressedPair *__as_pair = reinterpret_cast<_CompressedPair*>(__blob_);
            typename _CompressedPair::_Base2* __second = _CompressedPair::__get_second_base(__as_pair);
            _Tp *__elem = reinterpret_cast<_Tp*>(__second);
            return __elem;
        }
    };

    static_assert(alignof(_Storage) == alignof(_CompressedPair), "");
    static_assert(sizeof(_Storage) == sizeof(_CompressedPair), "");
    _Storage __storage_;
};

struct __shared_ptr_dummy_rebind_allocator_type;
template <>
class __attribute__ ((__type_visibility__("default"))) allocator<__shared_ptr_dummy_rebind_allocator_type>
{
public:
    template <class _Other>
    struct rebind
    {
        typedef allocator<_Other> other;
    };
};

template<class _Tp> class __attribute__ ((__type_visibility__("default"))) enable_shared_from_this;

template<class _Tp, class _Up>
struct __compatible_with

    : is_convertible<remove_extent_t<_Tp>*, remove_extent_t<_Up>*> {};




template <class _Ptr, class = void>
struct __is_deletable : false_type { };
template <class _Ptr>
struct __is_deletable<_Ptr, decltype(delete declval<_Ptr>())> : true_type { };

template <class _Ptr, class = void>
struct __is_array_deletable : false_type { };
template <class _Ptr>
struct __is_array_deletable<_Ptr, decltype(delete[] declval<_Ptr>())> : true_type { };

template <class _Dp, class _Pt,
    class = decltype(declval<_Dp>()(declval<_Pt>()))>
static true_type __well_formed_deleter_test(int);

template <class, class>
static false_type __well_formed_deleter_test(...);

template <class _Dp, class _Pt>
struct __well_formed_deleter : decltype(__well_formed_deleter_test<_Dp, _Pt>(0)) {};

template<class _Dp, class _Tp, class _Yp>
struct __shared_ptr_deleter_ctor_reqs
{
    static const bool value = __compatible_with<_Tp, _Yp>::value &&
                              is_move_constructible<_Dp>::value &&
                              __well_formed_deleter<_Dp, _Tp*>::value;
};







template<class _Tp>
class __attribute__ ((__type_visibility__("default"))) shared_ptr
{
public:

    typedef weak_ptr<_Tp> weak_type;
    typedef remove_extent_t<_Tp> element_type;




private:
    element_type* __ptr_;
    __shared_weak_count* __cntrl_;

    struct __nat {int __for_bool_;};
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    constexpr shared_ptr() noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    constexpr shared_ptr(nullptr_t) noexcept;

    template<class _Yp, class = _EnableIf<
        _And<
            __compatible_with<_Yp, _Tp>




            , _If<is_array<_Tp>::value, __is_array_deletable<_Yp*>, __is_deletable<_Yp*> >

        >::value
    > >
    explicit shared_ptr(_Yp* __p) : __ptr_(__p) {
        unique_ptr<_Yp> __hold(__p);
        typedef typename __shared_ptr_default_allocator<_Yp>::type _AllocT;
        typedef __shared_ptr_pointer<_Yp*, __shared_ptr_default_delete<_Tp, _Yp>, _AllocT > _CntrlBlk;
        __cntrl_ = new _CntrlBlk(__p, __shared_ptr_default_delete<_Tp, _Yp>(), _AllocT());
        __hold.release();
        __enable_weak_this(__p, __p);
    }

    template<class _Yp, class _Dp>
        shared_ptr(_Yp* __p, _Dp __d,
                   typename enable_if<__shared_ptr_deleter_ctor_reqs<_Dp, _Yp, element_type>::value, __nat>::type = __nat());
    template<class _Yp, class _Dp, class _Alloc>
        shared_ptr(_Yp* __p, _Dp __d, _Alloc __a,
                   typename enable_if<__shared_ptr_deleter_ctor_reqs<_Dp, _Yp, element_type>::value, __nat>::type = __nat());
    template <class _Dp> shared_ptr(nullptr_t __p, _Dp __d);
    template <class _Dp, class _Alloc> shared_ptr(nullptr_t __p, _Dp __d, _Alloc __a);
    template<class _Yp> __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) shared_ptr(const shared_ptr<_Yp>& __r, element_type* __p) noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    shared_ptr(const shared_ptr& __r) noexcept;
    template<class _Yp>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        shared_ptr(const shared_ptr<_Yp>& __r,
                   typename enable_if<__compatible_with<_Yp, element_type>::value, __nat>::type = __nat())
                       noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    shared_ptr(shared_ptr&& __r) noexcept;
    template<class _Yp> __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) shared_ptr(shared_ptr<_Yp>&& __r,
                   typename enable_if<__compatible_with<_Yp, element_type>::value, __nat>::type = __nat())
                       noexcept;
    template<class _Yp> explicit shared_ptr(const weak_ptr<_Yp>& __r,
                   typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type= __nat());





    template <class _Yp, class _Dp>
        shared_ptr(unique_ptr<_Yp, _Dp>&&,
                   typename enable_if
                   <
                       !is_lvalue_reference<_Dp>::value &&
                       is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type*>::value,
                       __nat
                   >::type = __nat());
    template <class _Yp, class _Dp>
        shared_ptr(unique_ptr<_Yp, _Dp>&&,
                   typename enable_if
                   <
                       is_lvalue_reference<_Dp>::value &&
                       is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type*>::value,
                       __nat
                   >::type = __nat());

    ~shared_ptr();

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    shared_ptr& operator=(const shared_ptr& __r) noexcept;
    template<class _Yp>
        typename enable_if
        <
            __compatible_with<_Yp, element_type>::value,
            shared_ptr&
        >::type
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        operator=(const shared_ptr<_Yp>& __r) noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    shared_ptr& operator=(shared_ptr&& __r) noexcept;
    template<class _Yp>
        typename enable_if
        <
            __compatible_with<_Yp, element_type>::value,
            shared_ptr&
        >::type
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        operator=(shared_ptr<_Yp>&& __r);
# 541 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/shared_ptr.h" 3
    template <class _Yp, class _Dp>
        typename enable_if
        <
            is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type*>::value,
            shared_ptr&
        >::type
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        operator=(unique_ptr<_Yp, _Dp>&& __r);

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void swap(shared_ptr& __r) noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void reset() noexcept;
    template<class _Yp>
        typename enable_if
        <
            __compatible_with<_Yp, element_type>::value,
            void
        >::type
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        reset(_Yp* __p);
    template<class _Yp, class _Dp>
        typename enable_if
        <
            __compatible_with<_Yp, element_type>::value,
            void
        >::type
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        reset(_Yp* __p, _Dp __d);
    template<class _Yp, class _Dp, class _Alloc>
        typename enable_if
        <
            __compatible_with<_Yp, element_type>::value,
            void
        >::type
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        reset(_Yp* __p, _Dp __d, _Alloc __a);

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    element_type* get() const noexcept {return __ptr_;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    typename add_lvalue_reference<element_type>::type operator*() const noexcept
        {return *__ptr_;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    element_type* operator->() const noexcept
    {
        static_assert(!is_array<_Tp>::value,
                      "std::shared_ptr<T>::operator-> is only valid when T is not an array type.");
        return __ptr_;
    }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    long use_count() const noexcept {return __cntrl_ ? __cntrl_->use_count() : 0;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    bool unique() const noexcept {return use_count() == 1;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit operator bool() const noexcept {return get() != nullptr;}
    template <class _Up>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        bool owner_before(shared_ptr<_Up> const& __p) const noexcept
        {return __cntrl_ < __p.__cntrl_;}
    template <class _Up>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        bool owner_before(weak_ptr<_Up> const& __p) const noexcept
        {return __cntrl_ < __p.__cntrl_;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    bool
    __owner_equivalent(const shared_ptr& __p) const
        {return __cntrl_ == __p.__cntrl_;}


    typename add_lvalue_reference<element_type>::type
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    operator[](ptrdiff_t __i) const
    {
            static_assert(is_array<_Tp>::value,
                          "std::shared_ptr<T>::operator[] is only valid when T is an array type.");
            return __ptr_[__i];
    }



    template <class _Dp>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        _Dp* __get_deleter() const noexcept
            {return static_cast<_Dp*>(__cntrl_
                    ? const_cast<void *>(__cntrl_->__get_deleter(typeid(_Dp)))
                      : nullptr);}


    template<class _Yp, class _CntrlBlk>
    static shared_ptr<_Tp>
    __create_with_control_block(_Yp* __p, _CntrlBlk* __cntrl) noexcept
    {
        shared_ptr<_Tp> __r;
        __r.__ptr_ = __p;
        __r.__cntrl_ = __cntrl;
        __r.__enable_weak_this(__r.__ptr_, __r.__ptr_);
        return __r;
    }

private:
    template <class _Yp, bool = is_function<_Yp>::value>
        struct __shared_ptr_default_allocator
        {
            typedef allocator<_Yp> type;
        };

    template <class _Yp>
        struct __shared_ptr_default_allocator<_Yp, true>
        {
            typedef allocator<__shared_ptr_dummy_rebind_allocator_type> type;
        };

    template <class _Yp, class _OrigPtr>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        typename enable_if<is_convertible<_OrigPtr*,
                                          const enable_shared_from_this<_Yp>*
        >::value,
            void>::type
        __enable_weak_this(const enable_shared_from_this<_Yp>* __e,
                           _OrigPtr* __ptr) noexcept
        {
            typedef typename remove_cv<_Yp>::type _RawYp;
            if (__e && __e->__weak_this_.expired())
            {
                __e->__weak_this_ = shared_ptr<_RawYp>(*this,
                    const_cast<_RawYp*>(static_cast<const _Yp*>(__ptr)));
            }
        }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) void __enable_weak_this(...) noexcept {}

    template <class, class _Yp>
        struct __shared_ptr_default_delete
            : default_delete<_Yp> {};

    template <class _Yp, class _Un, size_t _Sz>
        struct __shared_ptr_default_delete<_Yp[_Sz], _Un>
            : default_delete<_Yp[]> {};

    template <class _Yp, class _Un>
        struct __shared_ptr_default_delete<_Yp[], _Un>
            : default_delete<_Yp[]> {};

    template <class _Up> friend class __attribute__ ((__type_visibility__("default"))) shared_ptr;
    template <class _Up> friend class __attribute__ ((__type_visibility__("default"))) weak_ptr;
};


template<class _Tp>
shared_ptr(weak_ptr<_Tp>) -> shared_ptr<_Tp>;
template<class _Tp, class _Dp>
shared_ptr(unique_ptr<_Tp, _Dp>) -> shared_ptr<_Tp>;


template<class _Tp>
inline
constexpr
shared_ptr<_Tp>::shared_ptr() noexcept
    : __ptr_(nullptr),
      __cntrl_(nullptr)
{
}

template<class _Tp>
inline
constexpr
shared_ptr<_Tp>::shared_ptr(nullptr_t) noexcept
    : __ptr_(nullptr),
      __cntrl_(nullptr)
{
}

template<class _Tp>
template<class _Yp, class _Dp>
shared_ptr<_Tp>::shared_ptr(_Yp* __p, _Dp __d,
                            typename enable_if<__shared_ptr_deleter_ctor_reqs<_Dp, _Yp, element_type>::value, __nat>::type)
    : __ptr_(__p)
{

    try
    {

        typedef typename __shared_ptr_default_allocator<_Yp>::type _AllocT;
        typedef __shared_ptr_pointer<_Yp*, _Dp, _AllocT > _CntrlBlk;

        __cntrl_ = new _CntrlBlk(__p, std::__1::move(__d), _AllocT());



        __enable_weak_this(__p, __p);

    }
    catch (...)
    {
        __d(__p);
        throw;
    }

}

template<class _Tp>
template<class _Dp>
shared_ptr<_Tp>::shared_ptr(nullptr_t __p, _Dp __d)
    : __ptr_(nullptr)
{

    try
    {

        typedef typename __shared_ptr_default_allocator<_Tp>::type _AllocT;
        typedef __shared_ptr_pointer<nullptr_t, _Dp, _AllocT > _CntrlBlk;

        __cntrl_ = new _CntrlBlk(__p, std::__1::move(__d), _AllocT());




    }
    catch (...)
    {
        __d(__p);
        throw;
    }

}

template<class _Tp>
template<class _Yp, class _Dp, class _Alloc>
shared_ptr<_Tp>::shared_ptr(_Yp* __p, _Dp __d, _Alloc __a,
                            typename enable_if<__shared_ptr_deleter_ctor_reqs<_Dp, _Yp, element_type>::value, __nat>::type)
    : __ptr_(__p)
{

    try
    {

        typedef __shared_ptr_pointer<_Yp*, _Dp, _Alloc> _CntrlBlk;
        typedef typename __allocator_traits_rebind<_Alloc, _CntrlBlk>::type _A2;
        typedef __allocator_destructor<_A2> _D2;
        _A2 __a2(__a);
        unique_ptr<_CntrlBlk, _D2> __hold2(__a2.allocate(1), _D2(__a2, 1));
        ::new ((void*)std::__1::addressof(*__hold2.get()))

            _CntrlBlk(__p, std::__1::move(__d), __a);



        __cntrl_ = std::__1::addressof(*__hold2.release());
        __enable_weak_this(__p, __p);

    }
    catch (...)
    {
        __d(__p);
        throw;
    }

}

template<class _Tp>
template<class _Dp, class _Alloc>
shared_ptr<_Tp>::shared_ptr(nullptr_t __p, _Dp __d, _Alloc __a)
    : __ptr_(nullptr)
{

    try
    {

        typedef __shared_ptr_pointer<nullptr_t, _Dp, _Alloc> _CntrlBlk;
        typedef typename __allocator_traits_rebind<_Alloc, _CntrlBlk>::type _A2;
        typedef __allocator_destructor<_A2> _D2;
        _A2 __a2(__a);
        unique_ptr<_CntrlBlk, _D2> __hold2(__a2.allocate(1), _D2(__a2, 1));
        ::new ((void*)std::__1::addressof(*__hold2.get()))

            _CntrlBlk(__p, std::__1::move(__d), __a);



        __cntrl_ = std::__1::addressof(*__hold2.release());

    }
    catch (...)
    {
        __d(__p);
        throw;
    }

}

template<class _Tp>
template<class _Yp>
inline
shared_ptr<_Tp>::shared_ptr(const shared_ptr<_Yp>& __r, element_type *__p) noexcept
    : __ptr_(__p),
      __cntrl_(__r.__cntrl_)
{
    if (__cntrl_)
        __cntrl_->__add_shared();
}

template<class _Tp>
inline
shared_ptr<_Tp>::shared_ptr(const shared_ptr& __r) noexcept
    : __ptr_(__r.__ptr_),
      __cntrl_(__r.__cntrl_)
{
    if (__cntrl_)
        __cntrl_->__add_shared();
}

template<class _Tp>
template<class _Yp>
inline
shared_ptr<_Tp>::shared_ptr(const shared_ptr<_Yp>& __r,
                            typename enable_if<__compatible_with<_Yp, element_type>::value, __nat>::type)
         noexcept
    : __ptr_(__r.__ptr_),
      __cntrl_(__r.__cntrl_)
{
    if (__cntrl_)
        __cntrl_->__add_shared();
}

template<class _Tp>
inline
shared_ptr<_Tp>::shared_ptr(shared_ptr&& __r) noexcept
    : __ptr_(__r.__ptr_),
      __cntrl_(__r.__cntrl_)
{
    __r.__ptr_ = nullptr;
    __r.__cntrl_ = nullptr;
}

template<class _Tp>
template<class _Yp>
inline
shared_ptr<_Tp>::shared_ptr(shared_ptr<_Yp>&& __r,
                            typename enable_if<__compatible_with<_Yp, element_type>::value, __nat>::type)
         noexcept
    : __ptr_(__r.__ptr_),
      __cntrl_(__r.__cntrl_)
{
    __r.__ptr_ = nullptr;
    __r.__cntrl_ = nullptr;
}
# 903 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/shared_ptr.h" 3
template<class _Tp>
template <class _Yp, class _Dp>
shared_ptr<_Tp>::shared_ptr(unique_ptr<_Yp, _Dp>&& __r,
                            typename enable_if
                            <
                                !is_lvalue_reference<_Dp>::value &&
                                is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type*>::value,
                                __nat
                            >::type)
    : __ptr_(__r.get())
{

    if (__ptr_ == nullptr)
        __cntrl_ = nullptr;
    else

    {
        typedef typename __shared_ptr_default_allocator<_Yp>::type _AllocT;
        typedef __shared_ptr_pointer<typename unique_ptr<_Yp, _Dp>::pointer, _Dp, _AllocT > _CntrlBlk;
        __cntrl_ = new _CntrlBlk(__r.get(), __r.get_deleter(), _AllocT());
        __enable_weak_this(__r.get(), __r.get());
    }
    __r.release();
}

template<class _Tp>
template <class _Yp, class _Dp>
shared_ptr<_Tp>::shared_ptr(unique_ptr<_Yp, _Dp>&& __r,
                            typename enable_if
                            <
                                is_lvalue_reference<_Dp>::value &&
                                is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type*>::value,
                                __nat
                            >::type)
    : __ptr_(__r.get())
{

    if (__ptr_ == nullptr)
        __cntrl_ = nullptr;
    else

    {
        typedef typename __shared_ptr_default_allocator<_Yp>::type _AllocT;
        typedef __shared_ptr_pointer<typename unique_ptr<_Yp, _Dp>::pointer,
                                     reference_wrapper<typename remove_reference<_Dp>::type>,
                                     _AllocT > _CntrlBlk;
        __cntrl_ = new _CntrlBlk(__r.get(), std::__1::ref(__r.get_deleter()), _AllocT());
        __enable_weak_this(__r.get(), __r.get());
    }
    __r.release();
}

template<class _Tp>
shared_ptr<_Tp>::~shared_ptr()
{
    if (__cntrl_)
        __cntrl_->__release_shared();
}

template<class _Tp>
inline
shared_ptr<_Tp>&
shared_ptr<_Tp>::operator=(const shared_ptr& __r) noexcept
{
    shared_ptr(__r).swap(*this);
    return *this;
}

template<class _Tp>
template<class _Yp>
inline
typename enable_if
<
    __compatible_with<_Yp, typename shared_ptr<_Tp>::element_type>::value,
    shared_ptr<_Tp>&
>::type
shared_ptr<_Tp>::operator=(const shared_ptr<_Yp>& __r) noexcept
{
    shared_ptr(__r).swap(*this);
    return *this;
}

template<class _Tp>
inline
shared_ptr<_Tp>&
shared_ptr<_Tp>::operator=(shared_ptr&& __r) noexcept
{
    shared_ptr(std::__1::move(__r)).swap(*this);
    return *this;
}

template<class _Tp>
template<class _Yp>
inline
typename enable_if
<
    __compatible_with<_Yp, typename shared_ptr<_Tp>::element_type>::value,
    shared_ptr<_Tp>&
>::type
shared_ptr<_Tp>::operator=(shared_ptr<_Yp>&& __r)
{
    shared_ptr(std::__1::move(__r)).swap(*this);
    return *this;
}
# 1025 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/shared_ptr.h" 3
template<class _Tp>
template <class _Yp, class _Dp>
inline
typename enable_if
<
    is_convertible<typename unique_ptr<_Yp, _Dp>::pointer,
                   typename shared_ptr<_Tp>::element_type*>::value,
    shared_ptr<_Tp>&
>::type
shared_ptr<_Tp>::operator=(unique_ptr<_Yp, _Dp>&& __r)
{
    shared_ptr(std::__1::move(__r)).swap(*this);
    return *this;
}

template<class _Tp>
inline
void
shared_ptr<_Tp>::swap(shared_ptr& __r) noexcept
{
    std::__1::swap(__ptr_, __r.__ptr_);
    std::__1::swap(__cntrl_, __r.__cntrl_);
}

template<class _Tp>
inline
void
shared_ptr<_Tp>::reset() noexcept
{
    shared_ptr().swap(*this);
}

template<class _Tp>
template<class _Yp>
inline
typename enable_if
<
    __compatible_with<_Yp, typename shared_ptr<_Tp>::element_type>::value,
    void
>::type
shared_ptr<_Tp>::reset(_Yp* __p)
{
    shared_ptr(__p).swap(*this);
}

template<class _Tp>
template<class _Yp, class _Dp>
inline
typename enable_if
<
    __compatible_with<_Yp, typename shared_ptr<_Tp>::element_type>::value,
    void
>::type
shared_ptr<_Tp>::reset(_Yp* __p, _Dp __d)
{
    shared_ptr(__p, __d).swap(*this);
}

template<class _Tp>
template<class _Yp, class _Dp, class _Alloc>
inline
typename enable_if
<
    __compatible_with<_Yp, typename shared_ptr<_Tp>::element_type>::value,
    void
>::type
shared_ptr<_Tp>::reset(_Yp* __p, _Dp __d, _Alloc __a)
{
    shared_ptr(__p, __d, __a).swap(*this);
}




template<class _Tp, class _Alloc, class ..._Args, class = _EnableIf<!is_array<_Tp>::value> >
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
shared_ptr<_Tp> allocate_shared(const _Alloc& __a, _Args&& ...__args)
{
    using _ControlBlock = __shared_ptr_emplace<_Tp, _Alloc>;
    using _ControlBlockAllocator = typename __allocator_traits_rebind<_Alloc, _ControlBlock>::type;
    __allocation_guard<_ControlBlockAllocator> __guard(__a, 1);
    ::new ((void*)std::__1::addressof(*__guard.__get())) _ControlBlock(__a, std::__1::forward<_Args>(__args)...);
    auto __control_block = __guard.__release_ptr();
    return shared_ptr<_Tp>::__create_with_control_block((*__control_block).__get_elem(), std::__1::addressof(*__control_block));
}

template<class _Tp, class ..._Args, class = _EnableIf<!is_array<_Tp>::value> >
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
shared_ptr<_Tp> make_shared(_Args&& ...__args)
{
    return std::__1::allocate_shared<_Tp>(allocator<_Tp>(), std::__1::forward<_Args>(__args)...);
}

template<class _Tp, class _Up>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator==(const shared_ptr<_Tp>& __x, const shared_ptr<_Up>& __y) noexcept
{
    return __x.get() == __y.get();
}

template<class _Tp, class _Up>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator!=(const shared_ptr<_Tp>& __x, const shared_ptr<_Up>& __y) noexcept
{
    return !(__x == __y);
}

template<class _Tp, class _Up>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator<(const shared_ptr<_Tp>& __x, const shared_ptr<_Up>& __y) noexcept
{




    return less<>()(__x.get(), __y.get());


}

template<class _Tp, class _Up>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator>(const shared_ptr<_Tp>& __x, const shared_ptr<_Up>& __y) noexcept
{
    return __y < __x;
}

template<class _Tp, class _Up>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator<=(const shared_ptr<_Tp>& __x, const shared_ptr<_Up>& __y) noexcept
{
    return !(__y < __x);
}

template<class _Tp, class _Up>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator>=(const shared_ptr<_Tp>& __x, const shared_ptr<_Up>& __y) noexcept
{
    return !(__x < __y);
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator==(const shared_ptr<_Tp>& __x, nullptr_t) noexcept
{
    return !__x;
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator==(nullptr_t, const shared_ptr<_Tp>& __x) noexcept
{
    return !__x;
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator!=(const shared_ptr<_Tp>& __x, nullptr_t) noexcept
{
    return static_cast<bool>(__x);
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator!=(nullptr_t, const shared_ptr<_Tp>& __x) noexcept
{
    return static_cast<bool>(__x);
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator<(const shared_ptr<_Tp>& __x, nullptr_t) noexcept
{
    return less<_Tp*>()(__x.get(), nullptr);
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator<(nullptr_t, const shared_ptr<_Tp>& __x) noexcept
{
    return less<_Tp*>()(nullptr, __x.get());
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator>(const shared_ptr<_Tp>& __x, nullptr_t) noexcept
{
    return nullptr < __x;
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator>(nullptr_t, const shared_ptr<_Tp>& __x) noexcept
{
    return __x < nullptr;
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator<=(const shared_ptr<_Tp>& __x, nullptr_t) noexcept
{
    return !(nullptr < __x);
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator<=(nullptr_t, const shared_ptr<_Tp>& __x) noexcept
{
    return !(__x < nullptr);
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator>=(const shared_ptr<_Tp>& __x, nullptr_t) noexcept
{
    return !(__x < nullptr);
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator>=(nullptr_t, const shared_ptr<_Tp>& __x) noexcept
{
    return !(nullptr < __x);
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void
swap(shared_ptr<_Tp>& __x, shared_ptr<_Tp>& __y) noexcept
{
    __x.swap(__y);
}

template<class _Tp, class _Up>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
shared_ptr<_Tp>
static_pointer_cast(const shared_ptr<_Up>& __r) noexcept
{
    return shared_ptr<_Tp>(__r,
                           static_cast<
                               typename shared_ptr<_Tp>::element_type*>(__r.get()));
}

template<class _Tp, class _Up>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
shared_ptr<_Tp>
dynamic_pointer_cast(const shared_ptr<_Up>& __r) noexcept
{
    typedef typename shared_ptr<_Tp>::element_type _ET;
    _ET* __p = dynamic_cast<_ET*>(__r.get());
    return __p ? shared_ptr<_Tp>(__r, __p) : shared_ptr<_Tp>();
}

template<class _Tp, class _Up>
shared_ptr<_Tp>
const_pointer_cast(const shared_ptr<_Up>& __r) noexcept
{
    typedef typename shared_ptr<_Tp>::element_type _RTp;
    return shared_ptr<_Tp>(__r, const_cast<_RTp*>(__r.get()));
}

template<class _Tp, class _Up>
shared_ptr<_Tp>
reinterpret_pointer_cast(const shared_ptr<_Up>& __r) noexcept
{
    return shared_ptr<_Tp>(__r,
                           reinterpret_cast<
                               typename shared_ptr<_Tp>::element_type*>(__r.get()));
}



template<class _Dp, class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
_Dp*
get_deleter(const shared_ptr<_Tp>& __p) noexcept
{
    return __p.template __get_deleter<_Dp>();
}



template<class _Tp>
class __attribute__ ((__type_visibility__("default"))) weak_ptr
{
public:
    typedef _Tp element_type;
private:
    element_type* __ptr_;
    __shared_weak_count* __cntrl_;

public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    constexpr weak_ptr() noexcept;
    template<class _Yp> __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) weak_ptr(shared_ptr<_Yp> const& __r,
                   typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat*>::type = 0)
                        noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    weak_ptr(weak_ptr const& __r) noexcept;
    template<class _Yp> __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) weak_ptr(weak_ptr<_Yp> const& __r,
                   typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat*>::type = 0)
                         noexcept;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    weak_ptr(weak_ptr&& __r) noexcept;
    template<class _Yp> __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) weak_ptr(weak_ptr<_Yp>&& __r,
                   typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat*>::type = 0)
                         noexcept;
    ~weak_ptr();

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    weak_ptr& operator=(weak_ptr const& __r) noexcept;
    template<class _Yp>
        typename enable_if
        <
            is_convertible<_Yp*, element_type*>::value,
            weak_ptr&
        >::type
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        operator=(weak_ptr<_Yp> const& __r) noexcept;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    weak_ptr& operator=(weak_ptr&& __r) noexcept;
    template<class _Yp>
        typename enable_if
        <
            is_convertible<_Yp*, element_type*>::value,
            weak_ptr&
        >::type
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        operator=(weak_ptr<_Yp>&& __r) noexcept;

    template<class _Yp>
        typename enable_if
        <
            is_convertible<_Yp*, element_type*>::value,
            weak_ptr&
        >::type
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        operator=(shared_ptr<_Yp> const& __r) noexcept;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void swap(weak_ptr& __r) noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void reset() noexcept;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    long use_count() const noexcept
        {return __cntrl_ ? __cntrl_->use_count() : 0;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    bool expired() const noexcept
        {return __cntrl_ == nullptr || __cntrl_->use_count() == 0;}
    shared_ptr<_Tp> lock() const noexcept;
    template<class _Up>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        bool owner_before(const shared_ptr<_Up>& __r) const noexcept
        {return __cntrl_ < __r.__cntrl_;}
    template<class _Up>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        bool owner_before(const weak_ptr<_Up>& __r) const noexcept
        {return __cntrl_ < __r.__cntrl_;}

    template <class _Up> friend class __attribute__ ((__type_visibility__("default"))) weak_ptr;
    template <class _Up> friend class __attribute__ ((__type_visibility__("default"))) shared_ptr;
};


template<class _Tp>
weak_ptr(shared_ptr<_Tp>) -> weak_ptr<_Tp>;


template<class _Tp>
inline
constexpr
weak_ptr<_Tp>::weak_ptr() noexcept
    : __ptr_(nullptr),
      __cntrl_(nullptr)
{
}

template<class _Tp>
inline
weak_ptr<_Tp>::weak_ptr(weak_ptr const& __r) noexcept
    : __ptr_(__r.__ptr_),
      __cntrl_(__r.__cntrl_)
{
    if (__cntrl_)
        __cntrl_->__add_weak();
}

template<class _Tp>
template<class _Yp>
inline
weak_ptr<_Tp>::weak_ptr(shared_ptr<_Yp> const& __r,
                        typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat*>::type)
                         noexcept
    : __ptr_(__r.__ptr_),
      __cntrl_(__r.__cntrl_)
{
    if (__cntrl_)
        __cntrl_->__add_weak();
}

template<class _Tp>
template<class _Yp>
inline
weak_ptr<_Tp>::weak_ptr(weak_ptr<_Yp> const& __r,
                        typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat*>::type)
         noexcept
    : __ptr_(__r.__ptr_),
      __cntrl_(__r.__cntrl_)
{
    if (__cntrl_)
        __cntrl_->__add_weak();
}

template<class _Tp>
inline
weak_ptr<_Tp>::weak_ptr(weak_ptr&& __r) noexcept
    : __ptr_(__r.__ptr_),
      __cntrl_(__r.__cntrl_)
{
    __r.__ptr_ = nullptr;
    __r.__cntrl_ = nullptr;
}

template<class _Tp>
template<class _Yp>
inline
weak_ptr<_Tp>::weak_ptr(weak_ptr<_Yp>&& __r,
                        typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat*>::type)
         noexcept
    : __ptr_(__r.__ptr_),
      __cntrl_(__r.__cntrl_)
{
    __r.__ptr_ = nullptr;
    __r.__cntrl_ = nullptr;
}

template<class _Tp>
weak_ptr<_Tp>::~weak_ptr()
{
    if (__cntrl_)
        __cntrl_->__release_weak();
}

template<class _Tp>
inline
weak_ptr<_Tp>&
weak_ptr<_Tp>::operator=(weak_ptr const& __r) noexcept
{
    weak_ptr(__r).swap(*this);
    return *this;
}

template<class _Tp>
template<class _Yp>
inline
typename enable_if
<
    is_convertible<_Yp*, _Tp*>::value,
    weak_ptr<_Tp>&
>::type
weak_ptr<_Tp>::operator=(weak_ptr<_Yp> const& __r) noexcept
{
    weak_ptr(__r).swap(*this);
    return *this;
}

template<class _Tp>
inline
weak_ptr<_Tp>&
weak_ptr<_Tp>::operator=(weak_ptr&& __r) noexcept
{
    weak_ptr(std::__1::move(__r)).swap(*this);
    return *this;
}

template<class _Tp>
template<class _Yp>
inline
typename enable_if
<
    is_convertible<_Yp*, _Tp*>::value,
    weak_ptr<_Tp>&
>::type
weak_ptr<_Tp>::operator=(weak_ptr<_Yp>&& __r) noexcept
{
    weak_ptr(std::__1::move(__r)).swap(*this);
    return *this;
}

template<class _Tp>
template<class _Yp>
inline
typename enable_if
<
    is_convertible<_Yp*, _Tp*>::value,
    weak_ptr<_Tp>&
>::type
weak_ptr<_Tp>::operator=(shared_ptr<_Yp> const& __r) noexcept
{
    weak_ptr(__r).swap(*this);
    return *this;
}

template<class _Tp>
inline
void
weak_ptr<_Tp>::swap(weak_ptr& __r) noexcept
{
    std::__1::swap(__ptr_, __r.__ptr_);
    std::__1::swap(__cntrl_, __r.__cntrl_);
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void
swap(weak_ptr<_Tp>& __x, weak_ptr<_Tp>& __y) noexcept
{
    __x.swap(__y);
}

template<class _Tp>
inline
void
weak_ptr<_Tp>::reset() noexcept
{
    weak_ptr().swap(*this);
}

template<class _Tp>
template<class _Yp>
shared_ptr<_Tp>::shared_ptr(const weak_ptr<_Yp>& __r,
                            typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type)
    : __ptr_(__r.__ptr_),
      __cntrl_(__r.__cntrl_ ? __r.__cntrl_->lock() : __r.__cntrl_)
{
    if (__cntrl_ == nullptr)
        __throw_bad_weak_ptr();
}

template<class _Tp>
shared_ptr<_Tp>
weak_ptr<_Tp>::lock() const noexcept
{
    shared_ptr<_Tp> __r;
    __r.__cntrl_ = __cntrl_ ? __cntrl_->lock() : __cntrl_;
    if (__r.__cntrl_)
        __r.__ptr_ = __ptr_;
    return __r;
}


template <class _Tp = void> struct owner_less;





#pragma GCC diagnostic push
# 1603 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/shared_ptr.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated"
# 1603 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/shared_ptr.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) owner_less<shared_ptr<_Tp> >

    : binary_function<shared_ptr<_Tp>, shared_ptr<_Tp>, bool>

{
#pragma GCC diagnostic pop

    __attribute__ ((deprecated)) typedef bool result_type;
    __attribute__ ((deprecated)) typedef shared_ptr<_Tp> first_argument_type;
    __attribute__ ((deprecated)) typedef shared_ptr<_Tp> second_argument_type;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    bool operator()(shared_ptr<_Tp> const& __x, shared_ptr<_Tp> const& __y) const noexcept
        {return __x.owner_before(__y);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    bool operator()(shared_ptr<_Tp> const& __x, weak_ptr<_Tp> const& __y) const noexcept
        {return __x.owner_before(__y);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    bool operator()( weak_ptr<_Tp> const& __x, shared_ptr<_Tp> const& __y) const noexcept
        {return __x.owner_before(__y);}
};

#pragma GCC diagnostic push
# 1627 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/shared_ptr.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated"
# 1627 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/shared_ptr.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) owner_less<weak_ptr<_Tp> >

    : binary_function<weak_ptr<_Tp>, weak_ptr<_Tp>, bool>

{
#pragma GCC diagnostic pop

    __attribute__ ((deprecated)) typedef bool result_type;
    __attribute__ ((deprecated)) typedef weak_ptr<_Tp> first_argument_type;
    __attribute__ ((deprecated)) typedef weak_ptr<_Tp> second_argument_type;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    bool operator()( weak_ptr<_Tp> const& __x, weak_ptr<_Tp> const& __y) const noexcept
        {return __x.owner_before(__y);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    bool operator()(shared_ptr<_Tp> const& __x, weak_ptr<_Tp> const& __y) const noexcept
        {return __x.owner_before(__y);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    bool operator()( weak_ptr<_Tp> const& __x, shared_ptr<_Tp> const& __y) const noexcept
        {return __x.owner_before(__y);}
};


template <>
struct __attribute__ ((__type_visibility__("default"))) owner_less<void>
{
    template <class _Tp, class _Up>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    bool operator()( shared_ptr<_Tp> const& __x, shared_ptr<_Up> const& __y) const noexcept
        {return __x.owner_before(__y);}
    template <class _Tp, class _Up>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    bool operator()( shared_ptr<_Tp> const& __x, weak_ptr<_Up> const& __y) const noexcept
        {return __x.owner_before(__y);}
    template <class _Tp, class _Up>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    bool operator()( weak_ptr<_Tp> const& __x, shared_ptr<_Up> const& __y) const noexcept
        {return __x.owner_before(__y);}
    template <class _Tp, class _Up>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    bool operator()( weak_ptr<_Tp> const& __x, weak_ptr<_Up> const& __y) const noexcept
        {return __x.owner_before(__y);}
    typedef void is_transparent;
};


template<class _Tp>
class __attribute__ ((__type_visibility__("default"))) enable_shared_from_this
{
    mutable weak_ptr<_Tp> __weak_this_;
protected:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
    enable_shared_from_this() noexcept {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    enable_shared_from_this(enable_shared_from_this const&) noexcept {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    enable_shared_from_this& operator=(enable_shared_from_this const&) noexcept
        {return *this;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    ~enable_shared_from_this() {}
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    shared_ptr<_Tp> shared_from_this()
        {return shared_ptr<_Tp>(__weak_this_);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    shared_ptr<_Tp const> shared_from_this() const
        {return shared_ptr<const _Tp>(__weak_this_);}


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    weak_ptr<_Tp> weak_from_this() noexcept
       { return __weak_this_; }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    weak_ptr<const _Tp> weak_from_this() const noexcept
        { return __weak_this_; }


    template <class _Up> friend class shared_ptr;
};

template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) hash;

template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) hash<shared_ptr<_Tp> >
{

    __attribute__ ((deprecated)) typedef shared_ptr<_Tp> argument_type;
    __attribute__ ((deprecated)) typedef size_t result_type;


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_t operator()(const shared_ptr<_Tp>& __ptr) const noexcept
    {
        return hash<typename shared_ptr<_Tp>::element_type*>()(__ptr.get());
    }
};

template<class _CharT, class _Traits, class _Yp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
basic_ostream<_CharT, _Traits>&
operator<<(basic_ostream<_CharT, _Traits>& __os, shared_ptr<_Yp> const& __p);




class __attribute__ ((__visibility__("default"))) __sp_mut
{
    void* __lx;
public:
    void lock() noexcept;
    void unlock() noexcept;

private:
    constexpr __sp_mut(void*) noexcept;
    __sp_mut(const __sp_mut&);
    __sp_mut& operator=(const __sp_mut&);

    friend __attribute__ ((__visibility__("default"))) __sp_mut& __get_sp_mut(const void*);
};

__attribute__ ((__visibility__("default"))) __attribute__((availability(macosx,strict,introduced=10.9))) __attribute__((availability(ios,strict,introduced=7.0)))
__sp_mut& __get_sp_mut(const void*);

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
atomic_is_lock_free(const shared_ptr<_Tp>*)
{
    return false;
}

template <class _Tp>
__attribute__((availability(macosx,strict,introduced=10.9))) __attribute__((availability(ios,strict,introduced=7.0)))
shared_ptr<_Tp>
atomic_load(const shared_ptr<_Tp>* __p)
{
    __sp_mut& __m = __get_sp_mut(__p);
    __m.lock();
    shared_ptr<_Tp> __q = *__p;
    __m.unlock();
    return __q;
}

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
__attribute__((availability(macosx,strict,introduced=10.9))) __attribute__((availability(ios,strict,introduced=7.0)))
shared_ptr<_Tp>
atomic_load_explicit(const shared_ptr<_Tp>* __p, memory_order)
{
    return atomic_load(__p);
}

template <class _Tp>
__attribute__((availability(macosx,strict,introduced=10.9))) __attribute__((availability(ios,strict,introduced=7.0)))
void
atomic_store(shared_ptr<_Tp>* __p, shared_ptr<_Tp> __r)
{
    __sp_mut& __m = __get_sp_mut(__p);
    __m.lock();
    __p->swap(__r);
    __m.unlock();
}

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
__attribute__((availability(macosx,strict,introduced=10.9))) __attribute__((availability(ios,strict,introduced=7.0)))
void
atomic_store_explicit(shared_ptr<_Tp>* __p, shared_ptr<_Tp> __r, memory_order)
{
    atomic_store(__p, __r);
}

template <class _Tp>
__attribute__((availability(macosx,strict,introduced=10.9))) __attribute__((availability(ios,strict,introduced=7.0)))
shared_ptr<_Tp>
atomic_exchange(shared_ptr<_Tp>* __p, shared_ptr<_Tp> __r)
{
    __sp_mut& __m = __get_sp_mut(__p);
    __m.lock();
    __p->swap(__r);
    __m.unlock();
    return __r;
}

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
__attribute__((availability(macosx,strict,introduced=10.9))) __attribute__((availability(ios,strict,introduced=7.0)))
shared_ptr<_Tp>
atomic_exchange_explicit(shared_ptr<_Tp>* __p, shared_ptr<_Tp> __r, memory_order)
{
    return atomic_exchange(__p, __r);
}

template <class _Tp>
__attribute__((availability(macosx,strict,introduced=10.9))) __attribute__((availability(ios,strict,introduced=7.0)))
bool
atomic_compare_exchange_strong(shared_ptr<_Tp>* __p, shared_ptr<_Tp>* __v, shared_ptr<_Tp> __w)
{
    shared_ptr<_Tp> __temp;
    __sp_mut& __m = __get_sp_mut(__p);
    __m.lock();
    if (__p->__owner_equivalent(*__v))
    {
        std::__1::swap(__temp, *__p);
        *__p = __w;
        __m.unlock();
        return true;
    }
    std::__1::swap(__temp, *__v);
    *__v = *__p;
    __m.unlock();
    return false;
}

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
__attribute__((availability(macosx,strict,introduced=10.9))) __attribute__((availability(ios,strict,introduced=7.0)))
bool
atomic_compare_exchange_weak(shared_ptr<_Tp>* __p, shared_ptr<_Tp>* __v, shared_ptr<_Tp> __w)
{
    return atomic_compare_exchange_strong(__p, __v, __w);
}

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
__attribute__((availability(macosx,strict,introduced=10.9))) __attribute__((availability(ios,strict,introduced=7.0)))
bool
atomic_compare_exchange_strong_explicit(shared_ptr<_Tp>* __p, shared_ptr<_Tp>* __v,
                                        shared_ptr<_Tp> __w, memory_order, memory_order)
{
    return atomic_compare_exchange_strong(__p, __v, __w);
}

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
__attribute__((availability(macosx,strict,introduced=10.9))) __attribute__((availability(ios,strict,introduced=7.0)))
bool
atomic_compare_exchange_weak_explicit(shared_ptr<_Tp>* __p, shared_ptr<_Tp>* __v,
                                      shared_ptr<_Tp> __w, memory_order, memory_order)
{
    return atomic_compare_exchange_weak(__p, __v, __w);
}



} }
# 21 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/function.h" 2 3

# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/memory" 1 3
# 679 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/memory" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/pointer_safety.h" 1 3
# 18 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/pointer_safety.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 22 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/pointer_safety.h" 2 3

namespace std { inline namespace __1 {



enum class pointer_safety : unsigned char {
  relaxed,
  preferred,
  strict
};

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
pointer_safety get_pointer_safety() noexcept {
  return pointer_safety::relaxed;
}

__attribute__ ((__visibility__("default"))) void declare_reachable(void* __p);
__attribute__ ((__visibility__("default"))) void declare_no_pointers(char* __p, size_t __n);
__attribute__ ((__visibility__("default"))) void undeclare_no_pointers(char* __p, size_t __n);
__attribute__ ((__visibility__("default"))) void* __undeclare_reachable(void* __p);

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
_Tp*
undeclare_reachable(_Tp* __p)
{
    return static_cast<_Tp*>(__undeclare_reachable(__p));
}



} }
# 680 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/memory" 2 3

# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/raw_storage_iterator.h" 1 3
# 16 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/raw_storage_iterator.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/iterator" 1 3
# 579 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/iterator" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/access.h" 1 3
# 18 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/access.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 22 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/access.h" 2 3

namespace std { inline namespace __1 {

template <class _Tp, size_t _Np>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
_Tp*
begin(_Tp (&__array)[_Np])
{
    return __array;
}

template <class _Tp, size_t _Np>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
_Tp*
end(_Tp (&__array)[_Np])
{
    return __array + _Np;
}



template <class _Cp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
auto
begin(_Cp& __c) -> decltype(__c.begin())
{
    return __c.begin();
}

template <class _Cp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
auto
begin(const _Cp& __c) -> decltype(__c.begin())
{
    return __c.begin();
}

template <class _Cp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
auto
end(_Cp& __c) -> decltype(__c.end())
{
    return __c.end();
}

template <class _Cp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
auto
end(const _Cp& __c) -> decltype(__c.end())
{
    return __c.end();
}



template <class _Cp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
auto cbegin(const _Cp& __c) -> decltype(std::__1::begin(__c))
{
    return std::__1::begin(__c);
}

template <class _Cp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
auto cend(const _Cp& __c) -> decltype(std::__1::end(__c))
{
    return std::__1::end(__c);
}
# 130 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/access.h" 3
} }
# 580 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/iterator" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/advance.h" 1 3
# 15 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/advance.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__function_like.h" 1 3
# 17 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__function_like.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 21 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__function_like.h" 2 3

namespace std { inline namespace __1 {
# 52 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__function_like.h" 3
} }
# 16 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/advance.h" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/concepts.h" 1 3
# 15 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/concepts.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/iter_move.h" 1 3
# 17 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/iter_move.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 1 3
# 18 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/iter_move.h" 2 3
# 22 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/iter_move.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 26 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/iter_move.h" 2 3

namespace std { inline namespace __1 {
# 87 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/iter_move.h" 3
} }
# 16 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/concepts.h" 2 3





# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 1 3
# 22 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/concepts.h" 2 3
# 25 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/concepts.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 29 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/concepts.h" 2 3

namespace std { inline namespace __1 {
# 268 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/concepts.h" 3
} }
# 17 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/advance.h" 2 3






# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 1 3
# 24 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/advance.h" 2 3
# 27 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/advance.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/advance.h" 2 3

namespace std { inline namespace __1 {

template <class _InputIter>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
void __advance(_InputIter& __i, typename iterator_traits<_InputIter>::difference_type __n, input_iterator_tag) {
  for (; __n > 0; --__n)
    ++__i;
}

template <class _BiDirIter>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
void __advance(_BiDirIter& __i, typename iterator_traits<_BiDirIter>::difference_type __n, bidirectional_iterator_tag) {
  if (__n >= 0)
    for (; __n > 0; --__n)
      ++__i;
  else
    for (; __n < 0; ++__n)
      --__i;
}

template <class _RandIter>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
void __advance(_RandIter& __i, typename iterator_traits<_RandIter>::difference_type __n, random_access_iterator_tag) {
  __i += __n;
}

template <
    class _InputIter, class _Distance,
    class _IntegralDistance = decltype(std::__1::__convert_to_integral(declval<_Distance>())),
    class = _EnableIf<is_integral<_IntegralDistance>::value> >
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
void advance(_InputIter& __i, _Distance __orig_n) {
  typedef typename iterator_traits<_InputIter>::difference_type _Difference;
  _Difference __n = static_cast<_Difference>(std::__1::__convert_to_integral(__orig_n));
  ((void)0);

  std::__1::__advance(__i, __n, typename iterator_traits<_InputIter>::iterator_category());
}
# 196 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/advance.h" 3
} }
# 581 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/iterator" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/back_insert_iterator.h" 1 3
# 14 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/back_insert_iterator.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/iterator.h" 1 3
# 18 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/iterator.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 22 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/iterator.h" 2 3

namespace std { inline namespace __1 {

template<class _Category, class _Tp, class _Distance = ptrdiff_t,
         class _Pointer = _Tp*, class _Reference = _Tp&>
struct __attribute__ ((__type_visibility__("default"))) __attribute__ ((deprecated)) iterator
{
    typedef _Tp value_type;
    typedef _Distance difference_type;
    typedef _Pointer pointer;
    typedef _Reference reference;
    typedef _Category iterator_category;
};

} }
# 15 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/back_insert_iterator.h" 2 3
# 22 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/back_insert_iterator.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 26 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/back_insert_iterator.h" 2 3

namespace std { inline namespace __1 {

#pragma GCC diagnostic push
# 29 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/back_insert_iterator.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated"
# 29 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/back_insert_iterator.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
template <class _Container>
class __attribute__ ((__type_visibility__("default"))) back_insert_iterator

    : public iterator<output_iterator_tag, void, void, void, void>

{
#pragma GCC diagnostic pop
protected:
    _Container* container;
public:
    typedef output_iterator_tag iterator_category;
    typedef void value_type;



    typedef void difference_type;

    typedef void pointer;
    typedef void reference;
    typedef _Container container_type;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) explicit back_insert_iterator(_Container& __x) : container(std::__1::addressof(__x)) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) back_insert_iterator& operator=(const typename _Container::value_type& __value_)
        {container->push_back(__value_); return *this;}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) back_insert_iterator& operator=(typename _Container::value_type&& __value_)
        {container->push_back(std::__1::move(__value_)); return *this;}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) back_insert_iterator& operator*() {return *this;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) back_insert_iterator& operator++() {return *this;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) back_insert_iterator operator++(int) {return *this;}
};

template <class _Container>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
back_insert_iterator<_Container>
back_inserter(_Container& __x)
{
    return back_insert_iterator<_Container>(__x);
}

} }
# 582 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/iterator" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/common_iterator.h" 1 3
# 18 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/common_iterator.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/iter_swap.h" 1 3
# 17 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/iter_swap.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__ranges/access.h" 1 3
# 15 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__ranges/access.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__ranges/enable_borrowed_range.h" 1 3
# 21 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__ranges/enable_borrowed_range.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 25 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__ranges/enable_borrowed_range.h" 2 3

namespace std { inline namespace __1 {
# 42 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__ranges/enable_borrowed_range.h" 3
} }
# 16 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__ranges/access.h" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__utility/__decay_copy.h" 1 3
# 15 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__utility/__decay_copy.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 1 3
# 16 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__utility/__decay_copy.h" 2 3
# 19 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__utility/__decay_copy.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 23 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__utility/__decay_copy.h" 2 3

namespace std { inline namespace __1 {

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) typename decay<_Tp>::type __decay_copy(_Tp&& __t)



{
  return std::__1::forward<_Tp>(__t);
}

} }
# 17 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__ranges/access.h" 2 3


# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 1 3
# 20 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__ranges/access.h" 2 3
# 23 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__ranges/access.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 27 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__ranges/access.h" 2 3

namespace std { inline namespace __1 {
# 218 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__ranges/access.h" 3
} }
# 18 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/iter_swap.h" 2 3

# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 1 3
# 20 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/iter_swap.h" 2 3
# 23 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/iter_swap.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 27 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/iter_swap.h" 2 3

namespace std { inline namespace __1 {
# 103 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/iter_swap.h" 3
} }
# 19 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/common_iterator.h" 2 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/variant" 1 3
# 207 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/variant" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__variant/monostate.h" 1 3
# 19 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__variant/monostate.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 23 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__variant/monostate.h" 2 3

namespace std { inline namespace __1 {



struct __attribute__ ((__type_visibility__("default"))) monostate {};

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
constexpr bool operator<(monostate, monostate) noexcept { return false; }

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
constexpr bool operator>(monostate, monostate) noexcept { return false; }

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
constexpr bool operator<=(monostate, monostate) noexcept { return true; }

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
constexpr bool operator>=(monostate, monostate) noexcept { return true; }

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
constexpr bool operator==(monostate, monostate) noexcept { return true; }

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
constexpr bool operator!=(monostate, monostate) noexcept { return false; }

template <>
struct __attribute__ ((__type_visibility__("default"))) hash<monostate> {
  using argument_type = monostate;
  using result_type = size_t;

  inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  result_type operator()(const argument_type&) const noexcept {
    return 66740831;
  }
};



} }
# 208 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/variant" 2 3






# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 1 3
# 215 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/variant" 2 3
# 220 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/variant" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 224 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/variant" 2 3

namespace std {

class __attribute__ ((__visibility__("default"))) __attribute__((availability(macosx,strict,introduced=10.13))) __attribute__((availability(ios,strict,introduced=11.0))) __attribute__((availability(tvos,strict,introduced=11.0))) __attribute__((availability(watchos,strict,introduced=4.0))) bad_variant_access : public exception {
public:
  virtual const char* what() const noexcept;
};

}

namespace std { inline namespace __1 {
# 243 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/variant" 3
template<class _Tp, size_t _Size>
struct __farray {
  static_assert(_Size > 0, "N-dimensional array should never be empty in std::visit");
  _Tp __buf_[_Size] = {};

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
  const _Tp &operator[](size_t __n) const noexcept {
      return __buf_[__n];
  }
};

[[noreturn]]
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
__attribute__((availability(macosx,strict,introduced=10.13))) __attribute__((availability(ios,strict,introduced=11.0))) __attribute__((availability(tvos,strict,introduced=11.0))) __attribute__((availability(watchos,strict,introduced=4.0)))
void __throw_bad_variant_access() {

        throw bad_variant_access();



}

template <class... _Types>
class __attribute__ ((__type_visibility__("default"))) variant;

template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) variant_size;

template <class _Tp>
inline constexpr size_t variant_size_v = variant_size<_Tp>::value;

template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) variant_size<const _Tp> : variant_size<_Tp> {};

template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) variant_size<volatile _Tp> : variant_size<_Tp> {};

template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) variant_size<const volatile _Tp>
    : variant_size<_Tp> {};

template <class... _Types>
struct __attribute__ ((__type_visibility__("default"))) variant_size<variant<_Types...>>
    : integral_constant<size_t, sizeof...(_Types)> {};

template <size_t _Ip, class _Tp>
struct __attribute__ ((__type_visibility__("default"))) variant_alternative;

template <size_t _Ip, class _Tp>
using variant_alternative_t = typename variant_alternative<_Ip, _Tp>::type;

template <size_t _Ip, class _Tp>
struct __attribute__ ((__type_visibility__("default"))) variant_alternative<_Ip, const _Tp>
    : add_const<variant_alternative_t<_Ip, _Tp>> {};

template <size_t _Ip, class _Tp>
struct __attribute__ ((__type_visibility__("default"))) variant_alternative<_Ip, volatile _Tp>
    : add_volatile<variant_alternative_t<_Ip, _Tp>> {};

template <size_t _Ip, class _Tp>
struct __attribute__ ((__type_visibility__("default"))) variant_alternative<_Ip, const volatile _Tp>
    : add_cv<variant_alternative_t<_Ip, _Tp>> {};

template <size_t _Ip, class... _Types>
struct __attribute__ ((__type_visibility__("default"))) variant_alternative<_Ip, variant<_Types...>> {
  static_assert(_Ip < sizeof...(_Types), "Index out of bounds in std::variant_alternative<>");
  using type = __type_pack_element<_Ip, _Types...>;
};

inline constexpr size_t variant_npos = static_cast<size_t>(-1);

constexpr int __choose_index_type(unsigned int __num_elem) {
  if (__num_elem < numeric_limits<unsigned char>::max())
    return 0;
  if (__num_elem < numeric_limits<unsigned short>::max())
    return 1;
  return 2;
}

template <size_t _NumAlts>
using __variant_index_t =

  unsigned int;







template <class _IndexType>
constexpr _IndexType __variant_npos = static_cast<_IndexType>(-1);

template <class... _Types>
class __attribute__ ((__type_visibility__("default"))) variant;

template <class... _Types>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr variant<_Types...>&
__as_variant(variant<_Types...>& __vs) noexcept {
  return __vs;
}

template <class... _Types>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr const variant<_Types...>&
__as_variant(const variant<_Types...>& __vs) noexcept {
  return __vs;
}

template <class... _Types>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr variant<_Types...>&&
__as_variant(variant<_Types...>&& __vs) noexcept {
  return std::__1::move(__vs);
}

template <class... _Types>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr const variant<_Types...>&&
__as_variant(const variant<_Types...>&& __vs) noexcept {
  return std::__1::move(__vs);
}

namespace __find_detail {

template <class _Tp, class... _Types>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
constexpr size_t __find_index() {
  constexpr bool __matches[] = {is_same_v<_Tp, _Types>...};
  size_t __result = __not_found;
  for (size_t __i = 0; __i < sizeof...(_Types); ++__i) {
    if (__matches[__i]) {
      if (__result != __not_found) {
        return __ambiguous;
      }
      __result = __i;
    }
  }
  return __result;
}

template <size_t _Index>
struct __find_unambiguous_index_sfinae_impl
    : integral_constant<size_t, _Index> {};

template <>
struct __find_unambiguous_index_sfinae_impl<__not_found> {};

template <>
struct __find_unambiguous_index_sfinae_impl<__ambiguous> {};

template <class _Tp, class... _Types>
struct __find_unambiguous_index_sfinae
    : __find_unambiguous_index_sfinae_impl<__find_index<_Tp, _Types...>()> {};

}

namespace __variant_detail {

struct __valueless_t {};

enum class _Trait { _TriviallyAvailable, _Available, _Unavailable };

template <typename _Tp,
          template <typename> class _IsTriviallyAvailable,
          template <typename> class _IsAvailable>
constexpr _Trait __trait =
    _IsTriviallyAvailable<_Tp>::value
        ? _Trait::_TriviallyAvailable
        : _IsAvailable<_Tp>::value ? _Trait::_Available : _Trait::_Unavailable;

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
constexpr _Trait __common_trait(initializer_list<_Trait> __traits) {
  _Trait __result = _Trait::_TriviallyAvailable;
  for (_Trait __t : __traits) {
    if (static_cast<int>(__t) > static_cast<int>(__result)) {
      __result = __t;
    }
  }
  return __result;
}

template <typename... _Types>
struct __traits {
  static constexpr _Trait __copy_constructible_trait =
      __common_trait({__trait<_Types,
                              is_trivially_copy_constructible,
                              is_copy_constructible>...});

  static constexpr _Trait __move_constructible_trait =
      __common_trait({__trait<_Types,
                              is_trivially_move_constructible,
                              is_move_constructible>...});

  static constexpr _Trait __copy_assignable_trait = __common_trait(
      {__copy_constructible_trait,
       __trait<_Types, is_trivially_copy_assignable, is_copy_assignable>...});

  static constexpr _Trait __move_assignable_trait = __common_trait(
      {__move_constructible_trait,
       __trait<_Types, is_trivially_move_assignable, is_move_assignable>...});

  static constexpr _Trait __destructible_trait = __common_trait(
      {__trait<_Types, is_trivially_destructible, is_destructible>...});
};

namespace __access {

struct __union {
  template <class _Vp>
  inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  static constexpr auto&& __get_alt(_Vp&& __v, in_place_index_t<0>) {
    return std::__1::forward<_Vp>(__v).__head;
  }

  template <class _Vp, size_t _Ip>
  inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  static constexpr auto&& __get_alt(_Vp&& __v, in_place_index_t<_Ip>) {
    return __get_alt(std::__1::forward<_Vp>(__v).__tail, in_place_index<_Ip - 1>);
  }
};

struct __base {
  template <size_t _Ip, class _Vp>
  inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  static constexpr auto&& __get_alt(_Vp&& __v) {
    return __union::__get_alt(std::__1::forward<_Vp>(__v).__data,
                              in_place_index<_Ip>);
  }
};

struct __variant {
  template <size_t _Ip, class _Vp>
  inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  static constexpr auto&& __get_alt(_Vp&& __v) {
    return __base::__get_alt<_Ip>(std::__1::forward<_Vp>(__v).__impl);
  }
};

}

namespace __visitation {

struct __base {
  template <class _Visitor, class... _Vs>
  inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  static constexpr decltype(auto)
  __visit_alt_at(size_t __index, _Visitor&& __visitor, _Vs&&... __vs) {
    constexpr auto __fdiagonal =
        __make_fdiagonal<_Visitor&&,
                         decltype(std::__1::forward<_Vs>(__vs).__as_base())...>();
    return __fdiagonal[__index](std::__1::forward<_Visitor>(__visitor),
                                std::__1::forward<_Vs>(__vs).__as_base()...);
  }

  template <class _Visitor, class... _Vs>
  inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  static constexpr decltype(auto) __visit_alt(_Visitor&& __visitor,
                                              _Vs&&... __vs) {
    constexpr auto __fmatrix =
        __make_fmatrix<_Visitor&&,
                       decltype(std::__1::forward<_Vs>(__vs).__as_base())...>();
    return __at(__fmatrix, __vs.index()...)(
        std::__1::forward<_Visitor>(__visitor),
        std::__1::forward<_Vs>(__vs).__as_base()...);
  }

private:
  template <class _Tp>
  inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  static constexpr const _Tp& __at(const _Tp& __elem) { return __elem; }

  template <class _Tp, size_t _Np, typename... _Indices>
  inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  static constexpr auto&& __at(const __farray<_Tp, _Np>& __elems,
                               size_t __index, _Indices... __indices) {
    return __at(__elems[__index], __indices...);
  }

  template <class _Fp, class... _Fs>
  static constexpr void __std_visit_visitor_return_type_check() {
    static_assert(
        __all<is_same_v<_Fp, _Fs>...>::value,
        "`std::visit` requires the visitor to have a single return type.");
  }

  template <class... _Fs>
  inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  static constexpr auto __make_farray(_Fs&&... __fs) {
    __std_visit_visitor_return_type_check<__uncvref_t<_Fs>...>();
    using __result = __farray<common_type_t<__uncvref_t<_Fs>...>, sizeof...(_Fs)>;
    return __result{{std::__1::forward<_Fs>(__fs)...}};
  }

  template <size_t... _Is>
  struct __dispatcher {
    template <class _Fp, class... _Vs>
    inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    static constexpr decltype(auto) __dispatch(_Fp __f, _Vs... __vs) {
        return std::__1::__invoke_constexpr(
            static_cast<_Fp>(__f),
            __access::__base::__get_alt<_Is>(static_cast<_Vs>(__vs))...);
    }
  };

  template <class _Fp, class... _Vs, size_t... _Is>
  inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  static constexpr auto __make_dispatch(index_sequence<_Is...>) {
    return __dispatcher<_Is...>::template __dispatch<_Fp, _Vs...>;
  }

  template <size_t _Ip, class _Fp, class... _Vs>
  inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  static constexpr auto __make_fdiagonal_impl() {
    return __make_dispatch<_Fp, _Vs...>(
        index_sequence<(__identity<_Vs>{}, _Ip)...>{});
  }

  template <class _Fp, class... _Vs, size_t... _Is>
  inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  static constexpr auto __make_fdiagonal_impl(index_sequence<_Is...>) {
    return __base::__make_farray(__make_fdiagonal_impl<_Is, _Fp, _Vs...>()...);
  }

  template <class _Fp, class _Vp, class... _Vs>
  inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  static constexpr auto __make_fdiagonal() {
    constexpr size_t _Np = __uncvref_t<_Vp>::__size();
    static_assert(__all<(_Np == __uncvref_t<_Vs>::__size())...>::value);
    return __make_fdiagonal_impl<_Fp, _Vp, _Vs...>(make_index_sequence<_Np>{});
  }

  template <class _Fp, class... _Vs, size_t... _Is>
  inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  static constexpr auto __make_fmatrix_impl(index_sequence<_Is...> __is) {
    return __make_dispatch<_Fp, _Vs...>(__is);
  }

  template <class _Fp, class... _Vs, size_t... _Is, size_t... _Js, class... _Ls>
  inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  static constexpr auto __make_fmatrix_impl(index_sequence<_Is...>,
                                            index_sequence<_Js...>,
                                            _Ls... __ls) {
    return __base::__make_farray(__make_fmatrix_impl<_Fp, _Vs...>(
        index_sequence<_Is..., _Js>{}, __ls...)...);
  }

  template <class _Fp, class... _Vs>
  inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  static constexpr auto __make_fmatrix() {
    return __make_fmatrix_impl<_Fp, _Vs...>(
        index_sequence<>{}, make_index_sequence<__uncvref_t<_Vs>::__size()>{}...);
  }
};

struct __variant {
  template <class _Visitor, class... _Vs>
  inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  static constexpr decltype(auto)
  __visit_alt_at(size_t __index, _Visitor&& __visitor, _Vs&&... __vs) {
    return __base::__visit_alt_at(__index,
                                  std::__1::forward<_Visitor>(__visitor),
                                  std::__1::forward<_Vs>(__vs).__impl...);
  }

  template <class _Visitor, class... _Vs>
  inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  static constexpr decltype(auto) __visit_alt(_Visitor&& __visitor,
                                              _Vs&&... __vs) {
    return __base::__visit_alt(
        std::__1::forward<_Visitor>(__visitor),
        std::__1::__as_variant(std::__1::forward<_Vs>(__vs)).__impl...);
  }

  template <class _Visitor, class... _Vs>
  inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  static constexpr decltype(auto)
  __visit_value_at(size_t __index, _Visitor&& __visitor, _Vs&&... __vs) {
    return __visit_alt_at(
        __index,
        __make_value_visitor(std::__1::forward<_Visitor>(__visitor)),
        std::__1::forward<_Vs>(__vs)...);
  }

  template <class _Visitor, class... _Vs>
  inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  static constexpr decltype(auto) __visit_value(_Visitor&& __visitor,
                                                _Vs&&... __vs) {
    return __visit_alt(
        __make_value_visitor(std::__1::forward<_Visitor>(__visitor)),
        std::__1::forward<_Vs>(__vs)...);
  }
# 644 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/variant" 3
private:
  template <class _Visitor, class... _Values>
  static constexpr void __std_visit_exhaustive_visitor_check() {
    static_assert(is_invocable_v<_Visitor, _Values...>,
                  "`std::visit` requires the visitor to be exhaustive.");
  }

  template <class _Visitor>
  struct __value_visitor {
    template <class... _Alts>
    inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    constexpr decltype(auto) operator()(_Alts&&... __alts) const {
      __std_visit_exhaustive_visitor_check<
          _Visitor,
          decltype((std::__1::forward<_Alts>(__alts).__value))...>();
      return std::__1::__invoke_constexpr(std::__1::forward<_Visitor>(__visitor),
                                std::__1::forward<_Alts>(__alts).__value...);
    }
    _Visitor&& __visitor;
  };
# 688 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/variant" 3
  template <class _Visitor>
  inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  static constexpr auto __make_value_visitor(_Visitor&& __visitor) {
    return __value_visitor<_Visitor>{std::__1::forward<_Visitor>(__visitor)};
  }
# 701 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/variant" 3
};

}

template <size_t _Index, class _Tp>
struct __attribute__ ((__type_visibility__("default"))) __alt {
  using __value_type = _Tp;

  template <class... _Args>
  inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  explicit constexpr __alt(in_place_t, _Args&&... __args)
      : __value(std::__1::forward<_Args>(__args)...) {}

  __value_type __value;
};

template <_Trait _DestructibleTrait, size_t _Index, class... _Types>
union __attribute__ ((__type_visibility__("default"))) __union;

template <_Trait _DestructibleTrait, size_t _Index>
union __attribute__ ((__type_visibility__("default"))) __union<_DestructibleTrait, _Index> {};
# 759 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/variant" 3
template <size_t _Index, class _Tp, class... _Types> union __attribute__ ((__type_visibility__("default"))) __union<_Trait::_TriviallyAvailable, _Index, _Tp, _Types...> { public: inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) explicit constexpr __union(__valueless_t) noexcept : __dummy{} {} template <class... _Args> inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) explicit constexpr __union(in_place_index_t<0>, _Args&&... __args) : __head(in_place, std::__1::forward<_Args>(__args)...) {} template <size_t _Ip, class... _Args> inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) explicit constexpr __union(in_place_index_t<_Ip>, _Args&&... __args) : __tail(in_place_index<_Ip - 1>, std::__1::forward<_Args>(__args)...) {} __union(const __union&) = default; __union(__union&&) = default; ~__union() = default; __union& operator=(const __union&) = default; __union& operator=(__union&&) = default; private: char __dummy; __alt<_Index, _Tp> __head; __union<_Trait::_TriviallyAvailable, _Index + 1, _Types...> __tail; friend struct __access::__union; };
template <size_t _Index, class _Tp, class... _Types> union __attribute__ ((__type_visibility__("default"))) __union<_Trait::_Available, _Index, _Tp, _Types...> { public: inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) explicit constexpr __union(__valueless_t) noexcept : __dummy{} {} template <class... _Args> inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) explicit constexpr __union(in_place_index_t<0>, _Args&&... __args) : __head(in_place, std::__1::forward<_Args>(__args)...) {} template <size_t _Ip, class... _Args> inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) explicit constexpr __union(in_place_index_t<_Ip>, _Args&&... __args) : __tail(in_place_index<_Ip - 1>, std::__1::forward<_Args>(__args)...) {} __union(const __union&) = default; __union(__union&&) = default; ~__union() {} __union& operator=(const __union&) = default; __union& operator=(__union&&) = default; private: char __dummy; __alt<_Index, _Tp> __head; __union<_Trait::_Available, _Index + 1, _Types...> __tail; friend struct __access::__union; };
template <size_t _Index, class _Tp, class... _Types> union __attribute__ ((__type_visibility__("default"))) __union<_Trait::_Unavailable, _Index, _Tp, _Types...> { public: inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) explicit constexpr __union(__valueless_t) noexcept : __dummy{} {} template <class... _Args> inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) explicit constexpr __union(in_place_index_t<0>, _Args&&... __args) : __head(in_place, std::__1::forward<_Args>(__args)...) {} template <size_t _Ip, class... _Args> inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) explicit constexpr __union(in_place_index_t<_Ip>, _Args&&... __args) : __tail(in_place_index<_Ip - 1>, std::__1::forward<_Args>(__args)...) {} __union(const __union&) = default; __union(__union&&) = default; ~__union() = delete; __union& operator=(const __union&) = default; __union& operator=(__union&&) = default; private: char __dummy; __alt<_Index, _Tp> __head; __union<_Trait::_Unavailable, _Index + 1, _Types...> __tail; friend struct __access::__union; };



template <_Trait _DestructibleTrait, class... _Types>
class __attribute__ ((__type_visibility__("default"))) __base {
public:
  using __index_t = __variant_index_t<sizeof...(_Types)>;

  inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  explicit constexpr __base(__valueless_t tag) noexcept
      : __data(tag), __index(__variant_npos<__index_t>) {}

  template <size_t _Ip, class... _Args>
  inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  explicit constexpr __base(in_place_index_t<_Ip>, _Args&&... __args)
      :
        __data(in_place_index<_Ip>, std::__1::forward<_Args>(__args)...),
        __index(_Ip) {}

  inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  constexpr bool valueless_by_exception() const noexcept {
    return index() == variant_npos;
  }

  inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  constexpr size_t index() const noexcept {
    return __index == __variant_npos<__index_t> ? variant_npos : __index;
  }

protected:
  inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  constexpr auto&& __as_base() & { return *this; }

  inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  constexpr auto&& __as_base() && { return std::__1::move(*this); }

  inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  constexpr auto&& __as_base() const & { return *this; }

  inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  constexpr auto&& __as_base() const && { return std::__1::move(*this); }

  inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  static constexpr size_t __size() { return sizeof...(_Types); }

  __union<_DestructibleTrait, 0, _Types...> __data;
  __index_t __index;

  friend struct __access::__base;
  friend struct __visitation::__base;
};

template <class _Traits, _Trait = _Traits::__destructible_trait>
class __attribute__ ((__type_visibility__("default"))) __dtor;
# 840 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/variant" 3
template <class... _Types> class __attribute__ ((__type_visibility__("default"))) __dtor<__traits<_Types...>, _Trait::_TriviallyAvailable> : public __base<_Trait::_TriviallyAvailable, _Types...> { using __base_type = __base<_Trait::_TriviallyAvailable, _Types...>; using __index_t = typename __base_type::__index_t; public: using __base_type::__base_type; using __base_type::operator=; __dtor(const __dtor&) = default; __dtor(__dtor&&) = default; ~__dtor() = default; __dtor& operator=(const __dtor&) = default; __dtor& operator=(__dtor&&) = default; protected: inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) void __destroy() noexcept { this->__index = __variant_npos<__index_t>; } };




template <class... _Types> class __attribute__ ((__type_visibility__("default"))) __dtor<__traits<_Types...>, _Trait::_Available> : public __base<_Trait::_Available, _Types...> { using __base_type = __base<_Trait::_Available, _Types...>; using __index_t = typename __base_type::__index_t; public: using __base_type::__base_type; using __base_type::operator=; __dtor(const __dtor&) = default; __dtor(__dtor&&) = default; ~__dtor() { __destroy(); } __dtor& operator=(const __dtor&) = default; __dtor& operator=(__dtor&&) = default; protected: inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) void __destroy() noexcept { if (!this->valueless_by_exception()) { __visitation::__base::__visit_alt( [](auto& __alt) noexcept { using __alt_type = __uncvref_t<decltype(__alt)>; __alt.~__alt_type(); }, *this); } this->__index = __variant_npos<__index_t>; } };
# 860 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/variant" 3
template <class... _Types> class __attribute__ ((__type_visibility__("default"))) __dtor<__traits<_Types...>, _Trait::_Unavailable> : public __base<_Trait::_Unavailable, _Types...> { using __base_type = __base<_Trait::_Unavailable, _Types...>; using __index_t = typename __base_type::__index_t; public: using __base_type::__base_type; using __base_type::operator=; __dtor(const __dtor&) = default; __dtor(__dtor&&) = default; ~__dtor() = delete; __dtor& operator=(const __dtor&) = default; __dtor& operator=(__dtor&&) = default; protected: inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) void __destroy() noexcept = delete; };






template <class _Traits>
class __attribute__ ((__type_visibility__("default"))) __ctor : public __dtor<_Traits> {
  using __base_type = __dtor<_Traits>;

public:
  using __base_type::__base_type;
  using __base_type::operator=;

protected:
  template <size_t _Ip, class _Tp, class... _Args>
  inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  static _Tp& __construct_alt(__alt<_Ip, _Tp>& __a, _Args&&... __args) {
    ::new ((void*)std::__1::addressof(__a))
        __alt<_Ip, _Tp>(in_place, std::__1::forward<_Args>(__args)...);
    return __a.__value;
  }

  template <class _Rhs>
  inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  static void __generic_construct(__ctor& __lhs, _Rhs&& __rhs) {
    __lhs.__destroy();
    if (!__rhs.valueless_by_exception()) {
      __visitation::__base::__visit_alt_at(
          __rhs.index(),
          [](auto& __lhs_alt, auto&& __rhs_alt) {
            __construct_alt(
                __lhs_alt,
                std::__1::forward<decltype(__rhs_alt)>(__rhs_alt).__value);
          },
          __lhs, std::__1::forward<_Rhs>(__rhs));
      __lhs.__index = __rhs.index();
    }
  }
};

template <class _Traits, _Trait = _Traits::__move_constructible_trait>
class __attribute__ ((__type_visibility__("default"))) __move_constructor;
# 924 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/variant" 3
template <class... _Types> class __attribute__ ((__type_visibility__("default"))) __move_constructor<__traits<_Types...>, _Trait::_TriviallyAvailable> : public __ctor<__traits<_Types...>> { using __base_type = __ctor<__traits<_Types...>>; public: using __base_type::__base_type; using __base_type::operator=; __move_constructor(const __move_constructor&) = default; __move_constructor(__move_constructor&& __that) = default; ~__move_constructor() = default; __move_constructor& operator=(const __move_constructor&) = default; __move_constructor& operator=(__move_constructor&&) = default; };



template <class... _Types> class __attribute__ ((__type_visibility__("default"))) __move_constructor<__traits<_Types...>, _Trait::_Available> : public __ctor<__traits<_Types...>> { using __base_type = __ctor<__traits<_Types...>>; public: using __base_type::__base_type; using __base_type::operator=; __move_constructor(const __move_constructor&) = default; __move_constructor(__move_constructor&& __that) noexcept( __all<is_nothrow_move_constructible_v<_Types>...>::value) : __move_constructor(__valueless_t{}) { this->__generic_construct(*this, std::__1::move(__that)); } ~__move_constructor() = default; __move_constructor& operator=(const __move_constructor&) = default; __move_constructor& operator=(__move_constructor&&) = default; };







template <class... _Types> class __attribute__ ((__type_visibility__("default"))) __move_constructor<__traits<_Types...>, _Trait::_Unavailable> : public __ctor<__traits<_Types...>> { using __base_type = __ctor<__traits<_Types...>>; public: using __base_type::__base_type; using __base_type::operator=; __move_constructor(const __move_constructor&) = default; __move_constructor(__move_constructor&&) = delete; ~__move_constructor() = default; __move_constructor& operator=(const __move_constructor&) = default; __move_constructor& operator=(__move_constructor&&) = default; };





template <class _Traits, _Trait = _Traits::__copy_constructible_trait>
class __attribute__ ((__type_visibility__("default"))) __copy_constructor;
# 964 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/variant" 3
template <class... _Types> class __attribute__ ((__type_visibility__("default"))) __copy_constructor<__traits<_Types...>, _Trait::_TriviallyAvailable> : public __move_constructor<__traits<_Types...>> { using __base_type = __move_constructor<__traits<_Types...>>; public: using __base_type::__base_type; using __base_type::operator=; __copy_constructor(const __copy_constructor& __that) = default; __copy_constructor(__copy_constructor&&) = default; ~__copy_constructor() = default; __copy_constructor& operator=(const __copy_constructor&) = default; __copy_constructor& operator=(__copy_constructor&&) = default; };



template <class... _Types> class __attribute__ ((__type_visibility__("default"))) __copy_constructor<__traits<_Types...>, _Trait::_Available> : public __move_constructor<__traits<_Types...>> { using __base_type = __move_constructor<__traits<_Types...>>; public: using __base_type::__base_type; using __base_type::operator=; __copy_constructor(const __copy_constructor& __that) : __copy_constructor(__valueless_t{}) { this->__generic_construct(*this, __that); } __copy_constructor(__copy_constructor&&) = default; ~__copy_constructor() = default; __copy_constructor& operator=(const __copy_constructor&) = default; __copy_constructor& operator=(__copy_constructor&&) = default; };






template <class... _Types> class __attribute__ ((__type_visibility__("default"))) __copy_constructor<__traits<_Types...>, _Trait::_Unavailable> : public __move_constructor<__traits<_Types...>> { using __base_type = __move_constructor<__traits<_Types...>>; public: using __base_type::__base_type; using __base_type::operator=; __copy_constructor(const __copy_constructor&) = delete; __copy_constructor(__copy_constructor&&) = default; ~__copy_constructor() = default; __copy_constructor& operator=(const __copy_constructor&) = default; __copy_constructor& operator=(__copy_constructor&&) = default; };





template <class _Traits>
class __attribute__ ((__type_visibility__("default"))) __assignment : public __copy_constructor<_Traits> {
  using __base_type = __copy_constructor<_Traits>;

public:
  using __base_type::__base_type;
  using __base_type::operator=;

  template <size_t _Ip, class... _Args>
  inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  auto& __emplace(_Args&&... __args) {
    this->__destroy();
    auto& __res = this->__construct_alt(__access::__base::__get_alt<_Ip>(*this),
                          std::__1::forward<_Args>(__args)...);
    this->__index = _Ip;
    return __res;
  }

protected:
  template <size_t _Ip, class _Tp, class _Arg>
  inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  void __assign_alt(__alt<_Ip, _Tp>& __a, _Arg&& __arg) {
    if (this->index() == _Ip) {
      __a.__value = std::__1::forward<_Arg>(__arg);
    } else {
      struct {
        void operator()(true_type) const {
          __this->__emplace<_Ip>(std::__1::forward<_Arg>(__arg));
        }
        void operator()(false_type) const {
          __this->__emplace<_Ip>(_Tp(std::__1::forward<_Arg>(__arg)));
        }
        __assignment* __this;
        _Arg&& __arg;
      } __impl{this, std::__1::forward<_Arg>(__arg)};
      __impl(bool_constant<is_nothrow_constructible_v<_Tp, _Arg> ||
                           !is_nothrow_move_constructible_v<_Tp>>{});
    }
  }

  template <class _That>
  inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  void __generic_assign(_That&& __that) {
    if (this->valueless_by_exception() && __that.valueless_by_exception()) {

    } else if (__that.valueless_by_exception()) {
      this->__destroy();
    } else {
      __visitation::__base::__visit_alt_at(
          __that.index(),
          [this](auto& __this_alt, auto&& __that_alt) {
            this->__assign_alt(
                __this_alt,
                std::__1::forward<decltype(__that_alt)>(__that_alt).__value);
          },
          *this, std::__1::forward<_That>(__that));
    }
  }
};

template <class _Traits, _Trait = _Traits::__move_assignable_trait>
class __attribute__ ((__type_visibility__("default"))) __move_assignment;
# 1063 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/variant" 3
template <class... _Types> class __attribute__ ((__type_visibility__("default"))) __move_assignment<__traits<_Types...>, _Trait::_TriviallyAvailable> : public __assignment<__traits<_Types...>> { using __base_type = __assignment<__traits<_Types...>>; public: using __base_type::__base_type; using __base_type::operator=; __move_assignment(const __move_assignment&) = default; __move_assignment(__move_assignment&&) = default; ~__move_assignment() = default; __move_assignment& operator=(const __move_assignment&) = default; __move_assignment& operator=(__move_assignment&& __that) = default; };



template <class... _Types> class __attribute__ ((__type_visibility__("default"))) __move_assignment<__traits<_Types...>, _Trait::_Available> : public __assignment<__traits<_Types...>> { using __base_type = __assignment<__traits<_Types...>>; public: using __base_type::__base_type; using __base_type::operator=; __move_assignment(const __move_assignment&) = default; __move_assignment(__move_assignment&&) = default; ~__move_assignment() = default; __move_assignment& operator=(const __move_assignment&) = default; __move_assignment& operator=(__move_assignment&& __that) noexcept( __all<(is_nothrow_move_constructible_v<_Types> && is_nothrow_move_assignable_v<_Types>)...>::value) { this->__generic_assign(std::__1::move(__that)); return *this; } };
# 1076 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/variant" 3
template <class... _Types> class __attribute__ ((__type_visibility__("default"))) __move_assignment<__traits<_Types...>, _Trait::_Unavailable> : public __assignment<__traits<_Types...>> { using __base_type = __assignment<__traits<_Types...>>; public: using __base_type::__base_type; using __base_type::operator=; __move_assignment(const __move_assignment&) = default; __move_assignment(__move_assignment&&) = default; ~__move_assignment() = default; __move_assignment& operator=(const __move_assignment&) = default; __move_assignment& operator=(__move_assignment&&) = delete; };





template <class _Traits, _Trait = _Traits::__copy_assignable_trait>
class __attribute__ ((__type_visibility__("default"))) __copy_assignment;
# 1104 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/variant" 3
template <class... _Types> class __attribute__ ((__type_visibility__("default"))) __copy_assignment<__traits<_Types...>, _Trait::_TriviallyAvailable> : public __move_assignment<__traits<_Types...>> { using __base_type = __move_assignment<__traits<_Types...>>; public: using __base_type::__base_type; using __base_type::operator=; __copy_assignment(const __copy_assignment&) = default; __copy_assignment(__copy_assignment&&) = default; ~__copy_assignment() = default; __copy_assignment& operator=(const __copy_assignment& __that) = default; __copy_assignment& operator=(__copy_assignment&&) = default; };



template <class... _Types> class __attribute__ ((__type_visibility__("default"))) __copy_assignment<__traits<_Types...>, _Trait::_Available> : public __move_assignment<__traits<_Types...>> { using __base_type = __move_assignment<__traits<_Types...>>; public: using __base_type::__base_type; using __base_type::operator=; __copy_assignment(const __copy_assignment&) = default; __copy_assignment(__copy_assignment&&) = default; ~__copy_assignment() = default; __copy_assignment& operator=(const __copy_assignment& __that) { this->__generic_assign(__that); return *this; } __copy_assignment& operator=(__copy_assignment&&) = default; };






template <class... _Types> class __attribute__ ((__type_visibility__("default"))) __copy_assignment<__traits<_Types...>, _Trait::_Unavailable> : public __move_assignment<__traits<_Types...>> { using __base_type = __move_assignment<__traits<_Types...>>; public: using __base_type::__base_type; using __base_type::operator=; __copy_assignment(const __copy_assignment&) = default; __copy_assignment(__copy_assignment&&) = default; ~__copy_assignment() = default; __copy_assignment& operator=(const __copy_assignment&) = delete; __copy_assignment& operator=(__copy_assignment&&) = default; };





template <class... _Types>
class __attribute__ ((__type_visibility__("default"))) __impl
    : public __copy_assignment<__traits<_Types...>> {
  using __base_type = __copy_assignment<__traits<_Types...>>;

public:
  using __base_type::__base_type;
  using __base_type::operator=;

  template <size_t _Ip, class _Arg>
  inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  void __assign(_Arg&& __arg) {
    this->__assign_alt(__access::__base::__get_alt<_Ip>(*this),
                       std::__1::forward<_Arg>(__arg));
  }

  inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  void __swap(__impl& __that) {
    if (this->valueless_by_exception() && __that.valueless_by_exception()) {

    } else if (this->index() == __that.index()) {
      __visitation::__base::__visit_alt_at(
          this->index(),
          [](auto& __this_alt, auto& __that_alt) {
            using std::__1::swap;
            swap(__this_alt.__value, __that_alt.__value);
          },
          *this,
          __that);
    } else {
      __impl* __lhs = this;
      __impl* __rhs = std::__1::addressof(__that);
      if (__lhs->__move_nothrow() && !__rhs->__move_nothrow()) {
        std::__1::swap(__lhs, __rhs);
      }
      __impl __tmp(std::__1::move(*__rhs));

      if constexpr (__all<is_nothrow_move_constructible_v<_Types>...>::value) {
        this->__generic_construct(*__rhs, std::__1::move(*__lhs));
      } else {



        try {
          this->__generic_construct(*__rhs, std::__1::move(*__lhs));
        } catch (...) {
          if (__tmp.__move_nothrow()) {
            this->__generic_construct(*__rhs, std::__1::move(__tmp));
          }
          throw;
        }
      }





      this->__generic_construct(*__lhs, std::__1::move(__tmp));
    }
  }

private:
  inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  bool __move_nothrow() const {
    constexpr bool __results[] = {is_nothrow_move_constructible_v<_Types>...};
    return this->valueless_by_exception() || __results[this->index()];
  }
};

struct __no_narrowing_check {
  template <class _Dest, class _Source>
  using _Apply = __identity<_Dest>;
};

struct __narrowing_check {
  template <class _Dest>
  static auto __test_impl(_Dest (&&)[1]) -> __identity<_Dest>;
  template <class _Dest, class _Source>
  using _Apply = decltype(__test_impl<_Dest>({declval<_Source>()}));
};

template <class _Dest, class _Source>
using __check_for_narrowing =
  typename _If<



    is_arithmetic<_Dest>::value,
    __narrowing_check,
    __no_narrowing_check
  >::template _Apply<_Dest, _Source>;

template <class _Tp, size_t _Idx>
struct __overload {
  template <class _Up>
  auto operator()(_Tp, _Up&&) const -> __check_for_narrowing<_Tp, _Up>;
};

template <class _Tp, size_t>
struct __overload_bool {
  template <class _Up, class _Ap = __uncvref_t<_Up>>
  auto operator()(bool, _Up&&) const
      -> enable_if_t<is_same_v<_Ap, bool>, __identity<_Tp>>;
};

template <size_t _Idx>
struct __overload<bool, _Idx> : __overload_bool<bool, _Idx> {};
template <size_t _Idx>
struct __overload<bool const, _Idx> : __overload_bool<bool const, _Idx> {};
template <size_t _Idx>
struct __overload<bool volatile, _Idx> : __overload_bool<bool volatile, _Idx> {};
template <size_t _Idx>
struct __overload<bool const volatile, _Idx> : __overload_bool<bool const volatile, _Idx> {};

template <class ..._Bases>
struct __all_overloads : _Bases... {
  void operator()() const;
  using _Bases::operator()...;
};

template <class IdxSeq>
struct __make_overloads_imp;

template <size_t ..._Idx>
struct __make_overloads_imp<__tuple_indices<_Idx...> > {
  template <class ..._Types>
  using _Apply = __all_overloads<__overload<_Types, _Idx>...>;
};

template <class ..._Types>
using _MakeOverloads = typename __make_overloads_imp<
    __make_indices_imp<sizeof...(_Types), 0> >::template _Apply<_Types...>;

template <class _Tp, class... _Types>
using __best_match_t =
    typename invoke_result_t<_MakeOverloads<_Types...>, _Tp, _Tp>::type;

}

template <class... _Types>
class __attribute__ ((__type_visibility__("default"))) variant
    : private __sfinae_ctor_base<
          __all<is_copy_constructible_v<_Types>...>::value,
          __all<is_move_constructible_v<_Types>...>::value>,
      private __sfinae_assign_base<
          __all<(is_copy_constructible_v<_Types> &&
                 is_copy_assignable_v<_Types>)...>::value,
          __all<(is_move_constructible_v<_Types> &&
                 is_move_assignable_v<_Types>)...>::value> {
  static_assert(0 < sizeof...(_Types),
                "variant must consist of at least one alternative.");

  static_assert(__all<!is_array_v<_Types>...>::value,
                "variant can not have an array type as an alternative.");

  static_assert(__all<!is_reference_v<_Types>...>::value,
                "variant can not have a reference type as an alternative.");

  static_assert(__all<!is_void_v<_Types>...>::value,
                "variant can not have a void type as an alternative.");

  using __first_type = variant_alternative_t<0, variant>;

public:
  template <bool _Dummy = true,
            enable_if_t<__dependent_type<is_default_constructible<__first_type>,
                                         _Dummy>::value,
                        int> = 0>
  inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  constexpr variant() noexcept(is_nothrow_default_constructible_v<__first_type>)
      : __impl(in_place_index<0>) {}

  variant(const variant&) = default;
  variant(variant&&) = default;

  template <
      class _Arg,
      enable_if_t<!is_same_v<__uncvref_t<_Arg>, variant>, int> = 0,
      enable_if_t<!__is_inplace_type<__uncvref_t<_Arg>>::value, int> = 0,
      enable_if_t<!__is_inplace_index<__uncvref_t<_Arg>>::value, int> = 0,
      class _Tp = __variant_detail::__best_match_t<_Arg, _Types...>,
      size_t _Ip =
          __find_detail::__find_unambiguous_index_sfinae<_Tp, _Types...>::value,
      enable_if_t<is_constructible_v<_Tp, _Arg>, int> = 0>
  inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  constexpr variant(_Arg&& __arg) noexcept(
      is_nothrow_constructible_v<_Tp, _Arg>)
      : __impl(in_place_index<_Ip>, std::__1::forward<_Arg>(__arg)) {}

  template <size_t _Ip, class... _Args,
            class = enable_if_t<(_Ip < sizeof...(_Types)), int>,
            class _Tp = variant_alternative_t<_Ip, variant<_Types...>>,
            enable_if_t<is_constructible_v<_Tp, _Args...>, int> = 0>
  inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  explicit constexpr variant(
      in_place_index_t<_Ip>,
      _Args&&... __args) noexcept(is_nothrow_constructible_v<_Tp, _Args...>)
      : __impl(in_place_index<_Ip>, std::__1::forward<_Args>(__args)...) {}

  template <
      size_t _Ip,
      class _Up,
      class... _Args,
      enable_if_t<(_Ip < sizeof...(_Types)), int> = 0,
      class _Tp = variant_alternative_t<_Ip, variant<_Types...>>,
      enable_if_t<is_constructible_v<_Tp, initializer_list<_Up>&, _Args...>,
                  int> = 0>
  inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  explicit constexpr variant(
      in_place_index_t<_Ip>,
      initializer_list<_Up> __il,
      _Args&&... __args) noexcept(
      is_nothrow_constructible_v<_Tp, initializer_list<_Up>&, _Args...>)
      : __impl(in_place_index<_Ip>, __il, std::__1::forward<_Args>(__args)...) {}

  template <
      class _Tp,
      class... _Args,
      size_t _Ip =
          __find_detail::__find_unambiguous_index_sfinae<_Tp, _Types...>::value,
      enable_if_t<is_constructible_v<_Tp, _Args...>, int> = 0>
  inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  explicit constexpr variant(in_place_type_t<_Tp>, _Args&&... __args) noexcept(
      is_nothrow_constructible_v<_Tp, _Args...>)
      : __impl(in_place_index<_Ip>, std::__1::forward<_Args>(__args)...) {}

  template <
      class _Tp,
      class _Up,
      class... _Args,
      size_t _Ip =
          __find_detail::__find_unambiguous_index_sfinae<_Tp, _Types...>::value,
      enable_if_t<is_constructible_v<_Tp, initializer_list<_Up>&, _Args...>,
                  int> = 0>
  inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  explicit constexpr variant(
      in_place_type_t<_Tp>,
      initializer_list<_Up> __il,
      _Args&&... __args) noexcept(
      is_nothrow_constructible_v<_Tp, initializer_list< _Up>&, _Args...>)
      : __impl(in_place_index<_Ip>, __il, std::__1::forward<_Args>(__args)...) {}

  ~variant() = default;

  variant& operator=(const variant&) = default;
  variant& operator=(variant&&) = default;

  template <
      class _Arg,
      enable_if_t<!is_same_v<__uncvref_t<_Arg>, variant>, int> = 0,
      class _Tp = __variant_detail::__best_match_t<_Arg, _Types...>,
      size_t _Ip =
          __find_detail::__find_unambiguous_index_sfinae<_Tp, _Types...>::value,
      enable_if_t<is_assignable_v<_Tp&, _Arg> && is_constructible_v<_Tp, _Arg>,
                  int> = 0>
  inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  variant& operator=(_Arg&& __arg) noexcept(
      is_nothrow_assignable_v<_Tp&, _Arg> &&
      is_nothrow_constructible_v<_Tp, _Arg>) {
    __impl.template __assign<_Ip>(std::__1::forward<_Arg>(__arg));
    return *this;
  }

  template <
      size_t _Ip,
      class... _Args,
      enable_if_t<(_Ip < sizeof...(_Types)), int> = 0,
      class _Tp = variant_alternative_t<_Ip, variant<_Types...>>,
      enable_if_t<is_constructible_v<_Tp, _Args...>, int> = 0>
  inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  _Tp& emplace(_Args&&... __args) {
    return __impl.template __emplace<_Ip>(std::__1::forward<_Args>(__args)...);
  }

  template <
      size_t _Ip,
      class _Up,
      class... _Args,
      enable_if_t<(_Ip < sizeof...(_Types)), int> = 0,
      class _Tp = variant_alternative_t<_Ip, variant<_Types...>>,
      enable_if_t<is_constructible_v<_Tp, initializer_list<_Up>&, _Args...>,
                  int> = 0>
  inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  _Tp& emplace(initializer_list<_Up> __il, _Args&&... __args) {
    return __impl.template __emplace<_Ip>(__il, std::__1::forward<_Args>(__args)...);
  }

  template <
      class _Tp,
      class... _Args,
      size_t _Ip =
          __find_detail::__find_unambiguous_index_sfinae<_Tp, _Types...>::value,
      enable_if_t<is_constructible_v<_Tp, _Args...>, int> = 0>
  inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  _Tp& emplace(_Args&&... __args) {
    return __impl.template __emplace<_Ip>(std::__1::forward<_Args>(__args)...);
  }

  template <
      class _Tp,
      class _Up,
      class... _Args,
      size_t _Ip =
          __find_detail::__find_unambiguous_index_sfinae<_Tp, _Types...>::value,
      enable_if_t<is_constructible_v<_Tp, initializer_list<_Up>&, _Args...>,
                  int> = 0>
  inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  _Tp& emplace(initializer_list<_Up> __il, _Args&&... __args) {
    return __impl.template __emplace<_Ip>(__il, std::__1::forward<_Args>(__args)...);
  }

  inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  constexpr bool valueless_by_exception() const noexcept {
    return __impl.valueless_by_exception();
  }

  inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  constexpr size_t index() const noexcept { return __impl.index(); }

  template <
      bool _Dummy = true,
      enable_if_t<
          __all<(
              __dependent_type<is_move_constructible<_Types>, _Dummy>::value &&
              __dependent_type<is_swappable<_Types>, _Dummy>::value)...>::value,
          int> = 0>
  inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  void swap(variant& __that) noexcept(
      __all<(is_nothrow_move_constructible_v<_Types> &&
             is_nothrow_swappable_v<_Types>)...>::value) {
    __impl.__swap(__that.__impl);
  }

private:
  __variant_detail::__impl<_Types...> __impl;

  friend struct __variant_detail::__access::__variant;
  friend struct __variant_detail::__visitation::__variant;
};

template <size_t _Ip, class... _Types>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
constexpr bool __holds_alternative(const variant<_Types...>& __v) noexcept {
  return __v.index() == _Ip;
}

template <class _Tp, class... _Types>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
constexpr bool holds_alternative(const variant<_Types...>& __v) noexcept {
  return __holds_alternative<__find_exactly_one_t<_Tp, _Types...>::value>(__v);
}

template <size_t _Ip, class _Vp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
__attribute__((availability(macosx,strict,introduced=10.13))) __attribute__((availability(ios,strict,introduced=11.0))) __attribute__((availability(tvos,strict,introduced=11.0))) __attribute__((availability(watchos,strict,introduced=4.0)))
constexpr auto&& __generic_get(_Vp&& __v) {
  using __variant_detail::__access::__variant;
  if (!__holds_alternative<_Ip>(__v)) {
    __throw_bad_variant_access();
  }
  return __variant::__get_alt<_Ip>(std::__1::forward<_Vp>(__v)).__value;
}

template <size_t _Ip, class... _Types>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
__attribute__((availability(macosx,strict,introduced=10.13))) __attribute__((availability(ios,strict,introduced=11.0))) __attribute__((availability(tvos,strict,introduced=11.0))) __attribute__((availability(watchos,strict,introduced=4.0)))
constexpr variant_alternative_t<_Ip, variant<_Types...>>& get(
    variant<_Types...>& __v) {
  static_assert(_Ip < sizeof...(_Types));
  static_assert(!is_void_v<variant_alternative_t<_Ip, variant<_Types...>>>);
  return __generic_get<_Ip>(__v);
}

template <size_t _Ip, class... _Types>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
__attribute__((availability(macosx,strict,introduced=10.13))) __attribute__((availability(ios,strict,introduced=11.0))) __attribute__((availability(tvos,strict,introduced=11.0))) __attribute__((availability(watchos,strict,introduced=4.0)))
constexpr variant_alternative_t<_Ip, variant<_Types...>>&& get(
    variant<_Types...>&& __v) {
  static_assert(_Ip < sizeof...(_Types));
  static_assert(!is_void_v<variant_alternative_t<_Ip, variant<_Types...>>>);
  return __generic_get<_Ip>(std::__1::move(__v));
}

template <size_t _Ip, class... _Types>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
__attribute__((availability(macosx,strict,introduced=10.13))) __attribute__((availability(ios,strict,introduced=11.0))) __attribute__((availability(tvos,strict,introduced=11.0))) __attribute__((availability(watchos,strict,introduced=4.0)))
constexpr const variant_alternative_t<_Ip, variant<_Types...>>& get(
    const variant<_Types...>& __v) {
  static_assert(_Ip < sizeof...(_Types));
  static_assert(!is_void_v<variant_alternative_t<_Ip, variant<_Types...>>>);
  return __generic_get<_Ip>(__v);
}

template <size_t _Ip, class... _Types>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
__attribute__((availability(macosx,strict,introduced=10.13))) __attribute__((availability(ios,strict,introduced=11.0))) __attribute__((availability(tvos,strict,introduced=11.0))) __attribute__((availability(watchos,strict,introduced=4.0)))
constexpr const variant_alternative_t<_Ip, variant<_Types...>>&& get(
    const variant<_Types...>&& __v) {
  static_assert(_Ip < sizeof...(_Types));
  static_assert(!is_void_v<variant_alternative_t<_Ip, variant<_Types...>>>);
  return __generic_get<_Ip>(std::__1::move(__v));
}

template <class _Tp, class... _Types>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
__attribute__((availability(macosx,strict,introduced=10.13))) __attribute__((availability(ios,strict,introduced=11.0))) __attribute__((availability(tvos,strict,introduced=11.0))) __attribute__((availability(watchos,strict,introduced=4.0)))
constexpr _Tp& get(variant<_Types...>& __v) {
  static_assert(!is_void_v<_Tp>);
  return std::__1::get<__find_exactly_one_t<_Tp, _Types...>::value>(__v);
}

template <class _Tp, class... _Types>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
__attribute__((availability(macosx,strict,introduced=10.13))) __attribute__((availability(ios,strict,introduced=11.0))) __attribute__((availability(tvos,strict,introduced=11.0))) __attribute__((availability(watchos,strict,introduced=4.0)))
constexpr _Tp&& get(variant<_Types...>&& __v) {
  static_assert(!is_void_v<_Tp>);
  return std::__1::get<__find_exactly_one_t<_Tp, _Types...>::value>(
      std::__1::move(__v));
}

template <class _Tp, class... _Types>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
__attribute__((availability(macosx,strict,introduced=10.13))) __attribute__((availability(ios,strict,introduced=11.0))) __attribute__((availability(tvos,strict,introduced=11.0))) __attribute__((availability(watchos,strict,introduced=4.0)))
constexpr const _Tp& get(const variant<_Types...>& __v) {
  static_assert(!is_void_v<_Tp>);
  return std::__1::get<__find_exactly_one_t<_Tp, _Types...>::value>(__v);
}

template <class _Tp, class... _Types>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
__attribute__((availability(macosx,strict,introduced=10.13))) __attribute__((availability(ios,strict,introduced=11.0))) __attribute__((availability(tvos,strict,introduced=11.0))) __attribute__((availability(watchos,strict,introduced=4.0)))
constexpr const _Tp&& get(const variant<_Types...>&& __v) {
  static_assert(!is_void_v<_Tp>);
  return std::__1::get<__find_exactly_one_t<_Tp, _Types...>::value>(
      std::__1::move(__v));
}

template <size_t _Ip, class _Vp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
constexpr auto* __generic_get_if(_Vp* __v) noexcept {
  using __variant_detail::__access::__variant;
  return __v && __holds_alternative<_Ip>(*__v)
             ? std::__1::addressof(__variant::__get_alt<_Ip>(*__v).__value)
             : nullptr;
}

template <size_t _Ip, class... _Types>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
constexpr add_pointer_t<variant_alternative_t<_Ip, variant<_Types...>>>
get_if(variant<_Types...>* __v) noexcept {
  static_assert(_Ip < sizeof...(_Types));
  static_assert(!is_void_v<variant_alternative_t<_Ip, variant<_Types...>>>);
  return __generic_get_if<_Ip>(__v);
}

template <size_t _Ip, class... _Types>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
constexpr add_pointer_t<const variant_alternative_t<_Ip, variant<_Types...>>>
get_if(const variant<_Types...>* __v) noexcept {
  static_assert(_Ip < sizeof...(_Types));
  static_assert(!is_void_v<variant_alternative_t<_Ip, variant<_Types...>>>);
  return __generic_get_if<_Ip>(__v);
}

template <class _Tp, class... _Types>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
constexpr add_pointer_t<_Tp>
get_if(variant<_Types...>* __v) noexcept {
  static_assert(!is_void_v<_Tp>);
  return std::__1::get_if<__find_exactly_one_t<_Tp, _Types...>::value>(__v);
}

template <class _Tp, class... _Types>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
constexpr add_pointer_t<const _Tp>
get_if(const variant<_Types...>* __v) noexcept {
  static_assert(!is_void_v<_Tp>);
  return std::__1::get_if<__find_exactly_one_t<_Tp, _Types...>::value>(__v);
}

template <class _Operator>
struct __convert_to_bool {
  template <class _T1, class _T2>
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr bool operator()(_T1 && __t1, _T2&& __t2) const {
    static_assert(is_convertible<decltype(_Operator{}(std::__1::forward<_T1>(__t1), std::__1::forward<_T2>(__t2))), bool>::value,
        "the relational operator does not return a type which is implicitly convertible to bool");
    return _Operator{}(std::__1::forward<_T1>(__t1), std::__1::forward<_T2>(__t2));
  }
};

template <class... _Types>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
constexpr bool operator==(const variant<_Types...>& __lhs,
                          const variant<_Types...>& __rhs) {
  using __variant_detail::__visitation::__variant;
  if (__lhs.index() != __rhs.index()) return false;
  if (__lhs.valueless_by_exception()) return true;
  return __variant::__visit_value_at(__lhs.index(), __convert_to_bool<equal_to<>>{}, __lhs, __rhs);
}

template <class... _Types>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
constexpr bool operator!=(const variant<_Types...>& __lhs,
                          const variant<_Types...>& __rhs) {
  using __variant_detail::__visitation::__variant;
  if (__lhs.index() != __rhs.index()) return true;
  if (__lhs.valueless_by_exception()) return false;
  return __variant::__visit_value_at(
      __lhs.index(), __convert_to_bool<not_equal_to<>>{}, __lhs, __rhs);
}

template <class... _Types>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
constexpr bool operator<(const variant<_Types...>& __lhs,
                         const variant<_Types...>& __rhs) {
  using __variant_detail::__visitation::__variant;
  if (__rhs.valueless_by_exception()) return false;
  if (__lhs.valueless_by_exception()) return true;
  if (__lhs.index() < __rhs.index()) return true;
  if (__lhs.index() > __rhs.index()) return false;
  return __variant::__visit_value_at(__lhs.index(), __convert_to_bool<less<>>{}, __lhs, __rhs);
}

template <class... _Types>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
constexpr bool operator>(const variant<_Types...>& __lhs,
                         const variant<_Types...>& __rhs) {
  using __variant_detail::__visitation::__variant;
  if (__lhs.valueless_by_exception()) return false;
  if (__rhs.valueless_by_exception()) return true;
  if (__lhs.index() > __rhs.index()) return true;
  if (__lhs.index() < __rhs.index()) return false;
  return __variant::__visit_value_at(__lhs.index(), __convert_to_bool<greater<>>{}, __lhs, __rhs);
}

template <class... _Types>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
constexpr bool operator<=(const variant<_Types...>& __lhs,
                          const variant<_Types...>& __rhs) {
  using __variant_detail::__visitation::__variant;
  if (__lhs.valueless_by_exception()) return true;
  if (__rhs.valueless_by_exception()) return false;
  if (__lhs.index() < __rhs.index()) return true;
  if (__lhs.index() > __rhs.index()) return false;
  return __variant::__visit_value_at(
      __lhs.index(), __convert_to_bool<less_equal<>>{}, __lhs, __rhs);
}

template <class... _Types>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
constexpr bool operator>=(const variant<_Types...>& __lhs,
                          const variant<_Types...>& __rhs) {
  using __variant_detail::__visitation::__variant;
  if (__rhs.valueless_by_exception()) return true;
  if (__lhs.valueless_by_exception()) return false;
  if (__lhs.index() > __rhs.index()) return true;
  if (__lhs.index() < __rhs.index()) return false;
  return __variant::__visit_value_at(
      __lhs.index(), __convert_to_bool<greater_equal<>>{}, __lhs, __rhs);
}

template <class... _Vs>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __attribute__((availability(macosx,strict,introduced=10.13))) __attribute__((availability(ios,strict,introduced=11.0))) __attribute__((availability(tvos,strict,introduced=11.0))) __attribute__((availability(watchos,strict,introduced=4.0))) constexpr void
    __throw_if_valueless(_Vs&&... __vs) {
  const bool __valueless =
      (... || std::__1::__as_variant(__vs).valueless_by_exception());
  if (__valueless) {
    __throw_bad_variant_access();
  }
}

template <
    class _Visitor, class... _Vs,
    typename = void_t<decltype(std::__1::__as_variant(declval<_Vs>()))...> >
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __attribute__((availability(macosx,strict,introduced=10.13))) __attribute__((availability(ios,strict,introduced=11.0))) __attribute__((availability(tvos,strict,introduced=11.0))) __attribute__((availability(watchos,strict,introduced=4.0))) constexpr
    decltype(auto) visit(_Visitor&& __visitor, _Vs&&... __vs) {
  using __variant_detail::__visitation::__variant;
  std::__1::__throw_if_valueless(std::__1::forward<_Vs>(__vs)...);
  return __variant::__visit_value(std::__1::forward<_Visitor>(__visitor),
                                  std::__1::forward<_Vs>(__vs)...);
}
# 1719 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/variant" 3
template <class... _Types>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
auto swap(variant<_Types...>& __lhs,
          variant<_Types...>& __rhs) noexcept(noexcept(__lhs.swap(__rhs)))
    -> decltype(__lhs.swap(__rhs)) {
  __lhs.swap(__rhs);
}

template <class... _Types>
struct __attribute__ ((__type_visibility__("default"))) hash<
    __enable_hash_helper<variant<_Types...>, remove_const_t<_Types>...>> {
  using argument_type = variant<_Types...>;
  using result_type = size_t;

  inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  result_type operator()(const argument_type& __v) const {
    using __variant_detail::__visitation::__variant;
    size_t __res =
        __v.valueless_by_exception()
               ? 299792458
               : __variant::__visit_alt(
                     [](const auto& __alt) {
                       using __alt_type = __uncvref_t<decltype(__alt)>;
                       using __value_type = remove_const_t<
                         typename __alt_type::__value_type>;
                       return hash<__value_type>{}(__alt.__value);
                     },
                     __v);
    return __hash_combine(__res, hash<size_t>{}(__v.index()));
  }
};




template <size_t _Ip, class _Vp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
constexpr auto&& __unchecked_get(_Vp&& __v) noexcept {
  using __variant_detail::__access::__variant;
  return __variant::__get_alt<_Ip>(std::__1::forward<_Vp>(__v)).__value;
}

template <class _Tp, class... _Types>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
constexpr auto&& __unchecked_get(const variant<_Types...>& __v) noexcept {
  return __unchecked_get<__find_exactly_one_t<_Tp, _Types...>::value>(__v);
}

template <class _Tp, class... _Types>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
constexpr auto&& __unchecked_get(variant<_Types...>& __v) noexcept {
  return __unchecked_get<__find_exactly_one_t<_Tp, _Types...>::value>(__v);
}



} }
# 23 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/common_iterator.h" 2 3
# 26 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/common_iterator.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 30 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/common_iterator.h" 2 3

namespace std { inline namespace __1 {
# 297 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/common_iterator.h" 3
} }
# 583 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/iterator" 2 3

# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/counted_iterator.h" 1 3
# 15 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/counted_iterator.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/default_sentinel.h" 1 3
# 17 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/default_sentinel.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 21 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/default_sentinel.h" 2 3

namespace std { inline namespace __1 {
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/default_sentinel.h" 3
} }
# 16 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/counted_iterator.h" 2 3







# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 1 3
# 24 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/counted_iterator.h" 2 3
# 27 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/counted_iterator.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/counted_iterator.h" 2 3

namespace std { inline namespace __1 {
# 302 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/counted_iterator.h" 3
} }
# 585 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/iterator" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/data.h" 1 3
# 19 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/data.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 23 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/data.h" 2 3

namespace std { inline namespace __1 {



template <class _Cont> constexpr
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
auto data(_Cont& __c)
noexcept(noexcept(__c.data()))
-> decltype (__c.data())
{ return __c.data(); }

template <class _Cont> constexpr
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
auto data(const _Cont& __c)
noexcept(noexcept(__c.data()))
-> decltype (__c.data())
{ return __c.data(); }

template <class _Tp, size_t _Sz>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
constexpr _Tp* data(_Tp (&__array)[_Sz]) noexcept { return __array; }

template <class _Ep>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
constexpr const _Ep* data(initializer_list<_Ep> __il) noexcept { return __il.begin(); }



} }
# 586 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/iterator" 2 3

# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/distance.h" 1 3
# 18 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/distance.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 22 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/distance.h" 2 3

namespace std { inline namespace __1 {

template <class _InputIter>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
typename iterator_traits<_InputIter>::difference_type
__distance(_InputIter __first, _InputIter __last, input_iterator_tag)
{
    typename iterator_traits<_InputIter>::difference_type __r(0);
    for (; __first != __last; ++__first)
        ++__r;
    return __r;
}

template <class _RandIter>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
typename iterator_traits<_RandIter>::difference_type
__distance(_RandIter __first, _RandIter __last, random_access_iterator_tag)
{
    return __last - __first;
}

template <class _InputIter>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
typename iterator_traits<_InputIter>::difference_type
distance(_InputIter __first, _InputIter __last)
{
    return std::__1::__distance(__first, __last, typename iterator_traits<_InputIter>::iterator_category());
}

} }
# 588 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/iterator" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/empty.h" 1 3
# 19 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/empty.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 23 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/empty.h" 2 3

namespace std { inline namespace __1 {



template <class _Cont>
                              __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
constexpr auto empty(const _Cont& __c)
noexcept(noexcept(__c.empty()))
-> decltype (__c.empty())
{ return __c.empty(); }

template <class _Tp, size_t _Sz>
                              __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
constexpr bool empty(const _Tp (&)[_Sz]) noexcept { return false; }

template <class _Ep>
                              __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
constexpr bool empty(initializer_list<_Ep> __il) noexcept { return __il.size() == 0; }



} }
# 589 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/iterator" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/erase_if_container.h" 1 3
# 17 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/erase_if_container.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 21 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/erase_if_container.h" 2 3

namespace std { inline namespace __1 {

template <class _Container, class _Predicate>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename _Container::size_type
__libcpp_erase_if_container(_Container& __c, _Predicate& __pred) {
  typename _Container::size_type __old_size = __c.size();

  const typename _Container::iterator __last = __c.end();
  for (typename _Container::iterator __iter = __c.begin(); __iter != __last;) {
    if (__pred(*__iter))
      __iter = __c.erase(__iter);
    else
      ++__iter;
  }

  return __old_size - __c.size();
}

} }
# 590 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/iterator" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/front_insert_iterator.h" 1 3
# 22 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/front_insert_iterator.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 26 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/front_insert_iterator.h" 2 3

namespace std { inline namespace __1 {

#pragma GCC diagnostic push
# 29 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/front_insert_iterator.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated"
# 29 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/front_insert_iterator.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
template <class _Container>
class __attribute__ ((__type_visibility__("default"))) front_insert_iterator

    : public iterator<output_iterator_tag, void, void, void, void>

{
#pragma GCC diagnostic pop
protected:
    _Container* container;
public:
    typedef output_iterator_tag iterator_category;
    typedef void value_type;



    typedef void difference_type;

    typedef void pointer;
    typedef void reference;
    typedef _Container container_type;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) explicit front_insert_iterator(_Container& __x) : container(std::__1::addressof(__x)) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) front_insert_iterator& operator=(const typename _Container::value_type& __value_)
        {container->push_front(__value_); return *this;}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) front_insert_iterator& operator=(typename _Container::value_type&& __value_)
        {container->push_front(std::__1::move(__value_)); return *this;}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) front_insert_iterator& operator*() {return *this;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) front_insert_iterator& operator++() {return *this;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) front_insert_iterator operator++(int) {return *this;}
};

template <class _Container>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
front_insert_iterator<_Container>
front_inserter(_Container& __x)
{
    return front_insert_iterator<_Container>(__x);
}

} }
# 591 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/iterator" 2 3

# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/insert_iterator.h" 1 3
# 22 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/insert_iterator.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 26 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/insert_iterator.h" 2 3

namespace std { inline namespace __1 {

#pragma GCC diagnostic push
# 29 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/insert_iterator.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated"
# 29 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/insert_iterator.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
template <class _Container>
class __attribute__ ((__type_visibility__("default"))) insert_iterator

    : public iterator<output_iterator_tag, void, void, void, void>

{
#pragma GCC diagnostic pop
protected:
    _Container* container;
    typename _Container::iterator iter;
public:
    typedef output_iterator_tag iterator_category;
    typedef void value_type;



    typedef void difference_type;

    typedef void pointer;
    typedef void reference;
    typedef _Container container_type;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) insert_iterator(_Container& __x, typename _Container::iterator __i)
        : container(std::__1::addressof(__x)), iter(__i) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) insert_iterator& operator=(const typename _Container::value_type& __value_)
        {iter = container->insert(iter, __value_); ++iter; return *this;}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) insert_iterator& operator=(typename _Container::value_type&& __value_)
        {iter = container->insert(iter, std::__1::move(__value_)); ++iter; return *this;}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) insert_iterator& operator*() {return *this;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) insert_iterator& operator++() {return *this;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) insert_iterator& operator++(int) {return *this;}
};

template <class _Container>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
insert_iterator<_Container>
inserter(_Container& __x, typename _Container::iterator __i)
{
    return insert_iterator<_Container>(__x, __i);
}

} }
# 593 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/iterator" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/istreambuf_iterator.h" 1 3
# 20 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/istreambuf_iterator.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 24 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/istreambuf_iterator.h" 2 3

namespace std { inline namespace __1 {

#pragma GCC diagnostic push
# 27 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/istreambuf_iterator.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated"
# 27 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/istreambuf_iterator.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
template<class _CharT, class _Traits>
class __attribute__ ((__type_visibility__("default"))) istreambuf_iterator

    : public iterator<input_iterator_tag, _CharT,
                      typename _Traits::off_type, _CharT*,
                      _CharT>

{
#pragma GCC diagnostic pop
public:
    typedef input_iterator_tag iterator_category;
    typedef _CharT value_type;
    typedef typename _Traits::off_type difference_type;
    typedef _CharT* pointer;
    typedef _CharT reference;
    typedef _CharT char_type;
    typedef _Traits traits_type;
    typedef typename _Traits::int_type int_type;
    typedef basic_streambuf<_CharT,_Traits> streambuf_type;
    typedef basic_istream<_CharT,_Traits> istream_type;
private:
    mutable streambuf_type* __sbuf_;

    class __proxy
    {
        char_type __keep_;
        streambuf_type* __sbuf_;
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) __proxy(char_type __c, streambuf_type* __s)
            : __keep_(__c), __sbuf_(__s) {}
        friend class istreambuf_iterator;
    public:
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) char_type operator*() const {return __keep_;}
    };

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    bool __test_for_eof() const
    {
        if (__sbuf_ && traits_type::eq_int_type(__sbuf_->sgetc(), traits_type::eof()))
            __sbuf_ = nullptr;
        return __sbuf_ == nullptr;
    }
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr istreambuf_iterator() noexcept : __sbuf_(nullptr) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) istreambuf_iterator(istream_type& __s) noexcept
        : __sbuf_(__s.rdbuf()) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) istreambuf_iterator(streambuf_type* __s) noexcept
        : __sbuf_(__s) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) istreambuf_iterator(const __proxy& __p) noexcept
        : __sbuf_(__p.__sbuf_) {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) char_type operator*() const
        {return static_cast<char_type>(__sbuf_->sgetc());}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) istreambuf_iterator& operator++()
        {
            __sbuf_->sbumpc();
            return *this;
        }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) __proxy operator++(int)
        {
            return __proxy(__sbuf_->sbumpc(), __sbuf_);
        }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) bool equal(const istreambuf_iterator& __b) const
        {return __test_for_eof() == __b.__test_for_eof();}
};

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool operator==(const istreambuf_iterator<_CharT,_Traits>& __a,
                const istreambuf_iterator<_CharT,_Traits>& __b)
                {return __a.equal(__b);}

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool operator!=(const istreambuf_iterator<_CharT,_Traits>& __a,
                const istreambuf_iterator<_CharT,_Traits>& __b)
                {return !__a.equal(__b);}

} }
# 594 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/iterator" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/istream_iterator.h" 1 3
# 21 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/istream_iterator.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 25 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/istream_iterator.h" 2 3

namespace std { inline namespace __1 {

#pragma GCC diagnostic push
# 28 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/istream_iterator.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated"
# 28 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/istream_iterator.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
template <class _Tp, class _CharT = char,
          class _Traits = char_traits<_CharT>, class _Distance = ptrdiff_t>
class __attribute__ ((__type_visibility__("default"))) istream_iterator

    : public iterator<input_iterator_tag, _Tp, _Distance, const _Tp*, const _Tp&>

{
#pragma GCC diagnostic pop
public:
    typedef input_iterator_tag iterator_category;
    typedef _Tp value_type;
    typedef _Distance difference_type;
    typedef const _Tp* pointer;
    typedef const _Tp& reference;
    typedef _CharT char_type;
    typedef _Traits traits_type;
    typedef basic_istream<_CharT,_Traits> istream_type;
private:
    istream_type* __in_stream_;
    _Tp __value_;
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr istream_iterator() : __in_stream_(nullptr), __value_() {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) istream_iterator(istream_type& __s) : __in_stream_(std::__1::addressof(__s))
        {
            if (!(*__in_stream_ >> __value_))
                __in_stream_ = nullptr;
        }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) const _Tp& operator*() const {return __value_;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) const _Tp* operator->() const {return std::__1::addressof((operator*()));}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) istream_iterator& operator++()
        {
            if (!(*__in_stream_ >> __value_))
                __in_stream_ = nullptr;
            return *this;
        }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) istream_iterator operator++(int)
        {istream_iterator __t(*this); ++(*this); return __t;}

    template <class _Up, class _CharU, class _TraitsU, class _DistanceU>
    friend __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    bool
    operator==(const istream_iterator<_Up, _CharU, _TraitsU, _DistanceU>& __x,
               const istream_iterator<_Up, _CharU, _TraitsU, _DistanceU>& __y);

    template <class _Up, class _CharU, class _TraitsU, class _DistanceU>
    friend __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    bool
    operator==(const istream_iterator<_Up, _CharU, _TraitsU, _DistanceU>& __x,
               const istream_iterator<_Up, _CharU, _TraitsU, _DistanceU>& __y);
};

template <class _Tp, class _CharT, class _Traits, class _Distance>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator==(const istream_iterator<_Tp, _CharT, _Traits, _Distance>& __x,
           const istream_iterator<_Tp, _CharT, _Traits, _Distance>& __y)
{
    return __x.__in_stream_ == __y.__in_stream_;
}

template <class _Tp, class _CharT, class _Traits, class _Distance>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator!=(const istream_iterator<_Tp, _CharT, _Traits, _Distance>& __x,
           const istream_iterator<_Tp, _CharT, _Traits, _Distance>& __y)
{
    return !(__x == __y);
}

} }
# 595 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/iterator" 2 3




# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/move_iterator.h" 1 3
# 15 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/move_iterator.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 1 3
# 16 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/move_iterator.h" 2 3
# 19 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/move_iterator.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 23 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/move_iterator.h" 2 3

namespace std { inline namespace __1 {

template <class _Iter>
class __attribute__ ((__type_visibility__("default"))) move_iterator
{
private:
    _Iter __i;
public:
    typedef _Iter iterator_type;
    typedef typename iterator_traits<iterator_type>::value_type value_type;
    typedef typename iterator_traits<iterator_type>::difference_type difference_type;
    typedef iterator_type pointer;
    typedef _If<__is_cpp17_random_access_iterator<_Iter>::value,
        random_access_iterator_tag,
        typename iterator_traits<_Iter>::iterator_category> iterator_category;





    typedef typename iterator_traits<iterator_type>::reference __reference;
    typedef typename conditional<
            is_reference<__reference>::value,
            typename remove_reference<__reference>::type&&,
            __reference
        >::type reference;




    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
    move_iterator() : __i() {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
    explicit move_iterator(_Iter __x) : __i(__x) {}

    template <class _Up, class = _EnableIf<
        !is_same<_Up, _Iter>::value && is_convertible<_Up const&, _Iter>::value
    > >
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
    move_iterator(const move_iterator<_Up>& __u) : __i(__u.base()) {}

    template <class _Up, class = _EnableIf<
        !is_same<_Up, _Iter>::value &&
        is_convertible<_Up const&, _Iter>::value &&
        is_assignable<_Iter&, _Up const&>::value
    > >
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
    move_iterator& operator=(const move_iterator<_Up>& __u) {
        __i = __u.base();
        return *this;
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr _Iter base() const {return __i;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
    reference operator*() const { return static_cast<reference>(*__i); }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
    pointer operator->() const { return __i;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
    move_iterator& operator++() {++__i; return *this;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
    move_iterator operator++(int) {move_iterator __tmp(*this); ++__i; return __tmp;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
    move_iterator& operator--() {--__i; return *this;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
    move_iterator operator--(int) {move_iterator __tmp(*this); --__i; return __tmp;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
    move_iterator operator+ (difference_type __n) const {return move_iterator(__i + __n);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
    move_iterator& operator+=(difference_type __n) {__i += __n; return *this;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
    move_iterator operator- (difference_type __n) const {return move_iterator(__i - __n);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
    move_iterator& operator-=(difference_type __n) {__i -= __n; return *this;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
    reference operator[](difference_type __n) const { return static_cast<reference>(__i[__n]); }
};

template <class _Iter1, class _Iter2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
bool
operator==(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)
{
    return __x.base() == __y.base();
}

template <class _Iter1, class _Iter2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
bool
operator<(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)
{
    return __x.base() < __y.base();
}

template <class _Iter1, class _Iter2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
bool
operator!=(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)
{
    return __x.base() != __y.base();
}

template <class _Iter1, class _Iter2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
bool
operator>(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)
{
    return __x.base() > __y.base();
}

template <class _Iter1, class _Iter2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
bool
operator>=(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)
{
    return __x.base() >= __y.base();
}

template <class _Iter1, class _Iter2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
bool
operator<=(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)
{
    return __x.base() <= __y.base();
}


template <class _Iter1, class _Iter2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
auto
operator-(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)
-> decltype(__x.base() - __y.base())
{
    return __x.base() - __y.base();
}
# 169 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/move_iterator.h" 3
template <class _Iter>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
move_iterator<_Iter>
operator+(typename move_iterator<_Iter>::difference_type __n, const move_iterator<_Iter>& __x)
{
    return move_iterator<_Iter>(__x.base() + __n);
}

template <class _Iter>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
move_iterator<_Iter>
make_move_iterator(_Iter __i)
{
    return move_iterator<_Iter>(__i);
}

} }
# 600 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/iterator" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/next.h" 1 3
# 20 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/next.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 1 3
# 21 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/next.h" 2 3
# 24 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/next.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 28 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/next.h" 2 3

namespace std { inline namespace __1 {

template <class _InputIter>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
    typename enable_if<__is_cpp17_input_iterator<_InputIter>::value, _InputIter>::type
    next(_InputIter __x, typename iterator_traits<_InputIter>::difference_type __n = 1) {
  ((void)0);


  std::__1::advance(__x, __n);
  return __x;
}
# 83 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/next.h" 3
} }
# 601 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/iterator" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/ostreambuf_iterator.h" 1 3
# 20 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/ostreambuf_iterator.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 24 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/ostreambuf_iterator.h" 2 3

namespace std { inline namespace __1 {

#pragma GCC diagnostic push
# 27 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/ostreambuf_iterator.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated"
# 27 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/ostreambuf_iterator.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
template <class _CharT, class _Traits>
class __attribute__ ((__type_visibility__("default"))) ostreambuf_iterator

    : public iterator<output_iterator_tag, void, void, void, void>

{
#pragma GCC diagnostic pop
public:
    typedef output_iterator_tag iterator_category;
    typedef void value_type;



    typedef void difference_type;

    typedef void pointer;
    typedef void reference;
    typedef _CharT char_type;
    typedef _Traits traits_type;
    typedef basic_streambuf<_CharT, _Traits> streambuf_type;
    typedef basic_ostream<_CharT, _Traits> ostream_type;

private:
    streambuf_type* __sbuf_;
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) ostreambuf_iterator(ostream_type& __s) noexcept
        : __sbuf_(__s.rdbuf()) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) ostreambuf_iterator(streambuf_type* __s) noexcept
        : __sbuf_(__s) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) ostreambuf_iterator& operator=(_CharT __c)
        {
            if (__sbuf_ && traits_type::eq_int_type(__sbuf_->sputc(__c), traits_type::eof()))
                __sbuf_ = nullptr;
            return *this;
        }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) ostreambuf_iterator& operator*() {return *this;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) ostreambuf_iterator& operator++() {return *this;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) ostreambuf_iterator& operator++(int) {return *this;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) bool failed() const noexcept {return __sbuf_ == nullptr;}

    template <class _Ch, class _Tr>
    friend
    __attribute__ ((__visibility__("hidden")))
    ostreambuf_iterator<_Ch, _Tr>
    __pad_and_output(ostreambuf_iterator<_Ch, _Tr> __s,
                     const _Ch* __ob, const _Ch* __op, const _Ch* __oe,
                     ios_base& __iob, _Ch __fl);
};

} }
# 602 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/iterator" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/ostream_iterator.h" 1 3
# 21 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/ostream_iterator.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 25 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/ostream_iterator.h" 2 3

namespace std { inline namespace __1 {

#pragma GCC diagnostic push
# 28 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/ostream_iterator.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated"
# 28 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/ostream_iterator.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
template <class _Tp, class _CharT = char, class _Traits = char_traits<_CharT> >
class __attribute__ ((__type_visibility__("default"))) ostream_iterator

    : public iterator<output_iterator_tag, void, void, void, void>

{
#pragma GCC diagnostic pop
public:
    typedef output_iterator_tag iterator_category;
    typedef void value_type;



    typedef void difference_type;

    typedef void pointer;
    typedef void reference;
    typedef _CharT char_type;
    typedef _Traits traits_type;
    typedef basic_ostream<_CharT, _Traits> ostream_type;

private:
    ostream_type* __out_stream_;
    const char_type* __delim_;
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) ostream_iterator(ostream_type& __s) noexcept
        : __out_stream_(std::__1::addressof(__s)), __delim_(nullptr) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) ostream_iterator(ostream_type& __s, const _CharT* __delimiter) noexcept
        : __out_stream_(std::__1::addressof(__s)), __delim_(__delimiter) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) ostream_iterator& operator=(const _Tp& __value_)
        {
            *__out_stream_ << __value_;
            if (__delim_)
                *__out_stream_ << __delim_;
            return *this;
        }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) ostream_iterator& operator*() {return *this;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) ostream_iterator& operator++() {return *this;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) ostream_iterator& operator++(int) {return *this;}
};

} }
# 603 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/iterator" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/prev.h" 1 3
# 20 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/prev.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 1 3
# 21 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/prev.h" 2 3
# 24 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/prev.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 28 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/prev.h" 2 3

namespace std { inline namespace __1 {

template <class _InputIter>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
    typename enable_if<__is_cpp17_input_iterator<_InputIter>::value, _InputIter>::type
    prev(_InputIter __x, typename iterator_traits<_InputIter>::difference_type __n = 1) {
  ((void)0);

  std::__1::advance(__x, -__n);
  return __x;
}
# 75 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/prev.h" 3
} }
# 604 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/iterator" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/projected.h" 1 3
# 15 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/projected.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 1 3
# 16 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/projected.h" 2 3
# 19 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/projected.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 23 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/projected.h" 2 3

namespace std { inline namespace __1 {
# 41 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/projected.h" 3
} }
# 605 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/iterator" 2 3

# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/reverse_access.h" 1 3
# 14 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/reverse_access.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/reverse_iterator.h" 1 3
# 17 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/reverse_iterator.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 1 3
# 18 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/reverse_iterator.h" 2 3
# 21 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/reverse_iterator.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 25 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/reverse_iterator.h" 2 3

namespace std { inline namespace __1 {

template <class _Tp, class = void>
struct __is_stashing_iterator : false_type {};

template <class _Tp>
struct __is_stashing_iterator<_Tp, typename __void_t<typename _Tp::__stashing_iterator_tag>::type>
  : true_type {};

#pragma GCC diagnostic push
# 35 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/reverse_iterator.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated"
# 35 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/reverse_iterator.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
template <class _Iter>
class __attribute__ ((__type_visibility__("default"))) reverse_iterator

    : public iterator<typename iterator_traits<_Iter>::iterator_category,
                      typename iterator_traits<_Iter>::value_type,
                      typename iterator_traits<_Iter>::difference_type,
                      typename iterator_traits<_Iter>::pointer,
                      typename iterator_traits<_Iter>::reference>

{
#pragma GCC diagnostic pop
private:

    _Iter __t;


    static_assert(!__is_stashing_iterator<_Iter>::value,
      "The specified iterator type cannot be used with reverse_iterator; "
      "Using stashing iterators with reverse_iterator causes undefined behavior");

protected:
    _Iter current;
public:
    typedef _Iter iterator_type;
    typedef typename iterator_traits<_Iter>::difference_type difference_type;
    typedef typename iterator_traits<_Iter>::reference reference;
    typedef typename iterator_traits<_Iter>::pointer pointer;
    typedef _If<__is_cpp17_random_access_iterator<_Iter>::value,
        random_access_iterator_tag,
        typename iterator_traits<_Iter>::iterator_category> iterator_category;
    typedef typename iterator_traits<_Iter>::value_type value_type;
# 75 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/reverse_iterator.h" 3
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
    reverse_iterator() : __t(), current() {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
    explicit reverse_iterator(_Iter __x) : __t(__x), current(__x) {}

    template <class _Up, class = _EnableIf<
        !is_same<_Up, _Iter>::value && is_convertible<_Up const&, _Iter>::value
    > >
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
    reverse_iterator(const reverse_iterator<_Up>& __u)
        : __t(__u.base()), current(__u.base())
    { }

    template <class _Up, class = _EnableIf<
        !is_same<_Up, _Iter>::value &&
        is_convertible<_Up const&, _Iter>::value &&
        is_assignable<_Up const&, _Iter>::value
    > >
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
    reverse_iterator& operator=(const reverse_iterator<_Up>& __u) {
        __t = current = __u.base();
        return *this;
    }
# 125 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/reverse_iterator.h" 3
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
    _Iter base() const {return current;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
    reference operator*() const {_Iter __tmp = current; return *--__tmp;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
    pointer operator->() const {return std::__1::addressof(operator*());}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
    reverse_iterator& operator++() {--current; return *this;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
    reverse_iterator operator++(int) {reverse_iterator __tmp(*this); --current; return __tmp;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
    reverse_iterator& operator--() {++current; return *this;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
    reverse_iterator operator--(int) {reverse_iterator __tmp(*this); ++current; return __tmp;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
    reverse_iterator operator+ (difference_type __n) const {return reverse_iterator(current - __n);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
    reverse_iterator& operator+=(difference_type __n) {current -= __n; return *this;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
    reverse_iterator operator- (difference_type __n) const {return reverse_iterator(current + __n);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
    reverse_iterator& operator-=(difference_type __n) {current += __n; return *this;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
    reference operator[](difference_type __n) const {return *(*this + __n);}
};

template <class _Iter1, class _Iter2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
bool
operator==(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)
{
    return __x.base() == __y.base();
}

template <class _Iter1, class _Iter2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
bool
operator<(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)
{
    return __x.base() > __y.base();
}

template <class _Iter1, class _Iter2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
bool
operator!=(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)
{
    return __x.base() != __y.base();
}

template <class _Iter1, class _Iter2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
bool
operator>(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)
{
    return __x.base() < __y.base();
}

template <class _Iter1, class _Iter2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
bool
operator>=(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)
{
    return __x.base() <= __y.base();
}

template <class _Iter1, class _Iter2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
bool
operator<=(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)
{
    return __x.base() >= __y.base();
}


template <class _Iter1, class _Iter2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
auto
operator-(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)
-> decltype(__y.base() - __x.base())
{
    return __y.base() - __x.base();
}
# 218 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/reverse_iterator.h" 3
template <class _Iter>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
reverse_iterator<_Iter>
operator+(typename reverse_iterator<_Iter>::difference_type __n, const reverse_iterator<_Iter>& __x)
{
    return reverse_iterator<_Iter>(__x.base() - __n);
}


template <class _Iter>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
reverse_iterator<_Iter> make_reverse_iterator(_Iter __i)
{
    return reverse_iterator<_Iter>(__i);
}


} }
# 15 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/reverse_access.h" 2 3
# 20 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/reverse_access.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 24 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/reverse_access.h" 2 3

namespace std { inline namespace __1 {





template <class _Tp, size_t _Np>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
reverse_iterator<_Tp*> rbegin(_Tp (&__array)[_Np])
{
    return reverse_iterator<_Tp*>(__array + _Np);
}

template <class _Tp, size_t _Np>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
reverse_iterator<_Tp*> rend(_Tp (&__array)[_Np])
{
    return reverse_iterator<_Tp*>(__array);
}

template <class _Ep>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
reverse_iterator<const _Ep*> rbegin(initializer_list<_Ep> __il)
{
    return reverse_iterator<const _Ep*>(__il.end());
}

template <class _Ep>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
reverse_iterator<const _Ep*> rend(initializer_list<_Ep> __il)
{
    return reverse_iterator<const _Ep*>(__il.begin());
}

template <class _Cp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
auto rbegin(_Cp& __c) -> decltype(__c.rbegin())
{
    return __c.rbegin();
}

template <class _Cp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
auto rbegin(const _Cp& __c) -> decltype(__c.rbegin())
{
    return __c.rbegin();
}

template <class _Cp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
auto rend(_Cp& __c) -> decltype(__c.rend())
{
    return __c.rend();
}

template <class _Cp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
auto rend(const _Cp& __c) -> decltype(__c.rend())
{
    return __c.rend();
}

template <class _Cp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
auto crbegin(const _Cp& __c) -> decltype(std::__1::rbegin(__c))
{
    return std::__1::rbegin(__c);
}

template <class _Cp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
auto crend(const _Cp& __c) -> decltype(std::__1::rend(__c))
{
    return std::__1::rend(__c);
}





} }
# 607 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/iterator" 2 3

# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/size.h" 1 3
# 15 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/size.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 1 3
# 16 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/size.h" 2 3
# 19 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/size.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 23 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/size.h" 2 3

namespace std { inline namespace __1 {



template <class _Cont>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
constexpr auto size(const _Cont& __c)
noexcept(noexcept(__c.size()))
-> decltype (__c.size())
{ return __c.size(); }

template <class _Tp, size_t _Sz>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
constexpr size_t size(const _Tp (&)[_Sz]) noexcept { return _Sz; }
# 54 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/size.h" 3
} }
# 609 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/iterator" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/wrap_iter.h" 1 3
# 17 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/wrap_iter.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 1 3
# 18 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/wrap_iter.h" 2 3
# 21 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/wrap_iter.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 25 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/wrap_iter.h" 2 3

namespace std { inline namespace __1 {

template <class _Iter>
class __wrap_iter
{
public:
    typedef _Iter iterator_type;
    typedef typename iterator_traits<iterator_type>::value_type value_type;
    typedef typename iterator_traits<iterator_type>::difference_type difference_type;
    typedef typename iterator_traits<iterator_type>::pointer pointer;
    typedef typename iterator_traits<iterator_type>::reference reference;
    typedef typename iterator_traits<iterator_type>::iterator_category iterator_category;




private:
    iterator_type __i;
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr __wrap_iter() noexcept

                : __i{}

    {



    }
    template <class _Up> __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
        __wrap_iter(const __wrap_iter<_Up>& __u,
            typename enable_if<is_convertible<_Up, iterator_type>::value>::type* = nullptr) noexcept
            : __i(__u.base())
    {



    }
# 86 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/wrap_iter.h" 3
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr reference operator*() const noexcept
    {




        return *__i;
    }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr pointer operator->() const noexcept
    {




        return std::__1::__to_address(__i);
    }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr __wrap_iter& operator++() noexcept
    {




        ++__i;
        return *this;
    }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr __wrap_iter operator++(int) noexcept
        {__wrap_iter __tmp(*this); ++(*this); return __tmp;}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr __wrap_iter& operator--() noexcept
    {




        --__i;
        return *this;
    }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr __wrap_iter operator--(int) noexcept
        {__wrap_iter __tmp(*this); --(*this); return __tmp;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr __wrap_iter operator+ (difference_type __n) const noexcept
        {__wrap_iter __w(*this); __w += __n; return __w;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr __wrap_iter& operator+=(difference_type __n) noexcept
    {




        __i += __n;
        return *this;
    }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr __wrap_iter operator- (difference_type __n) const noexcept
        {return *this + (-__n);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr __wrap_iter& operator-=(difference_type __n) noexcept
        {*this += -__n; return *this;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr reference operator[](difference_type __n) const noexcept
    {




        return __i[__n];
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr iterator_type base() const noexcept {return __i;}

private:






    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr __wrap_iter(iterator_type __x) noexcept : __i(__x) {}


    template <class _Up> friend class __wrap_iter;
    template <class _CharT, class _Traits, class _Alloc> friend class basic_string;
    template <class _Tp, class _Alloc> friend class __attribute__ ((__type_visibility__("default"))) vector;
    template <class _Tp, size_t> friend class __attribute__ ((__type_visibility__("default"))) span;
};

template <class _Iter1>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
bool operator==(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter1>& __y) noexcept
{
    return __x.base() == __y.base();
}

template <class _Iter1, class _Iter2>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
bool operator==(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) noexcept
{
    return __x.base() == __y.base();
}

template <class _Iter1>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
bool operator<(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter1>& __y) noexcept
{




    return __x.base() < __y.base();
}

template <class _Iter1, class _Iter2>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
bool operator<(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) noexcept
{




    return __x.base() < __y.base();
}

template <class _Iter1>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
bool operator!=(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter1>& __y) noexcept
{
    return !(__x == __y);
}

template <class _Iter1, class _Iter2>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
bool operator!=(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) noexcept
{
    return !(__x == __y);
}

template <class _Iter1>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
bool operator>(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter1>& __y) noexcept
{
    return __y < __x;
}

template <class _Iter1, class _Iter2>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
bool operator>(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) noexcept
{
    return __y < __x;
}

template <class _Iter1>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
bool operator>=(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter1>& __y) noexcept
{
    return !(__x < __y);
}

template <class _Iter1, class _Iter2>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
bool operator>=(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) noexcept
{
    return !(__x < __y);
}

template <class _Iter1>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
bool operator<=(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter1>& __y) noexcept
{
    return !(__y < __x);
}

template <class _Iter1, class _Iter2>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
bool operator<=(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) noexcept
{
    return !(__y < __x);
}

template <class _Iter1, class _Iter2>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr

auto operator-(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) noexcept
    -> decltype(__x.base() - __y.base())




{




    return __x.base() - __y.base();
}

template <class _Iter1>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
__wrap_iter<_Iter1> operator+(typename __wrap_iter<_Iter1>::difference_type __n, __wrap_iter<_Iter1> __x) noexcept
{
    __x += __n;
    return __x;
}


template <class _It>
struct __is_cpp17_contiguous_iterator<__wrap_iter<_It> > : true_type {};


template <class _Iter>
constexpr
decltype(std::__1::__to_address(declval<_Iter>()))
__to_address(__wrap_iter<_Iter> __w) noexcept {
    return std::__1::__to_address(__w.base());
}

} }
# 610 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/iterator" 2 3







# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 1 3
# 618 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/iterator" 2 3
# 622 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/iterator" 3
# 17 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/raw_storage_iterator.h" 2 3
# 21 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/raw_storage_iterator.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 25 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/raw_storage_iterator.h" 2 3

namespace std { inline namespace __1 {



#pragma GCC diagnostic push
# 30 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/raw_storage_iterator.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated"
# 30 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/raw_storage_iterator.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
template <class _OutputIterator, class _Tp>
class __attribute__ ((__type_visibility__("default"))) __attribute__ ((deprecated)) raw_storage_iterator

    : public iterator<output_iterator_tag, void, void, void, void>

{
#pragma GCC diagnostic pop
private:
    _OutputIterator __x_;
public:
    typedef output_iterator_tag iterator_category;
    typedef void value_type;



    typedef void difference_type;

    typedef void pointer;
    typedef void reference;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) explicit raw_storage_iterator(_OutputIterator __x) : __x_(__x) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) raw_storage_iterator& operator*() {return *this;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) raw_storage_iterator& operator=(const _Tp& __element)
        {::new ((void*)std::__1::addressof(*__x_)) _Tp(__element); return *this;}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) raw_storage_iterator& operator=(_Tp&& __element)
        {::new ((void*)std::__1::addressof(*__x_)) _Tp(std::__1::move(__element)); return *this;}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) raw_storage_iterator& operator++() {++__x_; return *this;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) raw_storage_iterator operator++(int)
        {raw_storage_iterator __t(*this); ++__x_; return __t;}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) _OutputIterator base() const { return __x_; }

};



} }
# 682 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/memory" 2 3

# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/temporary_buffer.h" 1 3
# 20 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/temporary_buffer.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 24 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/temporary_buffer.h" 2 3

namespace std { inline namespace __1 {

template <class _Tp>
                      __attribute__((__no_sanitize__("cfi")))
pair<_Tp*, ptrdiff_t>
get_temporary_buffer(ptrdiff_t __n) noexcept
{
    pair<_Tp*, ptrdiff_t> __r(0, 0);
    const ptrdiff_t __m = (~ptrdiff_t(0) ^
                           ptrdiff_t(ptrdiff_t(1) << (sizeof(ptrdiff_t) * 8 - 1)))
                           / sizeof(_Tp);
    if (__n > __m)
        __n = __m;
    while (__n > 0)
    {

    if (__is_overaligned_for_new(alignof(_Tp)))
        {
            align_val_t __al =
                align_val_t(alignment_of<_Tp>::value);
            __r.first = static_cast<_Tp*>(::operator new(
                __n * sizeof(_Tp), __al, nothrow));
        } else {
            __r.first = static_cast<_Tp*>(::operator new(
                __n * sizeof(_Tp), nothrow));
        }
# 62 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/temporary_buffer.h" 3
        if (__r.first)
        {
            __r.second = __n;
            break;
        }
        __n /= 2;
    }
    return __r;
}

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void return_temporary_buffer(_Tp* __p) noexcept
{
  std::__1::__libcpp_deallocate_unsized((void*)__p, alignof(_Tp));
}

struct __return_temporary_buffer
{
    template <class _Tp>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) void operator()(_Tp* __p) const {std::__1::return_temporary_buffer(__p);}
};

} }
# 684 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/memory" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/uninitialized_algorithms.h" 1 3
# 21 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/uninitialized_algorithms.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 25 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/uninitialized_algorithms.h" 2 3

namespace std { inline namespace __1 {

template <class _InputIterator, class _ForwardIterator>
_ForwardIterator
uninitialized_copy(_InputIterator __f, _InputIterator __l, _ForwardIterator __r)
{
    typedef typename iterator_traits<_ForwardIterator>::value_type value_type;

    _ForwardIterator __s = __r;
    try
    {

        for (; __f != __l; ++__f, (void) ++__r)
            ::new ((void*)std::__1::addressof(*__r)) value_type(*__f);

    }
    catch (...)
    {
        for (; __s != __r; ++__s)
            __s->~value_type();
        throw;
    }

    return __r;
}

template <class _InputIterator, class _Size, class _ForwardIterator>
_ForwardIterator
uninitialized_copy_n(_InputIterator __f, _Size __n, _ForwardIterator __r)
{
    typedef typename iterator_traits<_ForwardIterator>::value_type value_type;

    _ForwardIterator __s = __r;
    try
    {

        for (; __n > 0; ++__f, (void) ++__r, (void) --__n)
            ::new ((void*)std::__1::addressof(*__r)) value_type(*__f);

    }
    catch (...)
    {
        for (; __s != __r; ++__s)
            __s->~value_type();
        throw;
    }

    return __r;
}

template <class _ForwardIterator, class _Tp>
void
uninitialized_fill(_ForwardIterator __f, _ForwardIterator __l, const _Tp& __x)
{
    typedef typename iterator_traits<_ForwardIterator>::value_type value_type;

    _ForwardIterator __s = __f;
    try
    {

        for (; __f != __l; ++__f)
            ::new ((void*)std::__1::addressof(*__f)) value_type(__x);

    }
    catch (...)
    {
        for (; __s != __f; ++__s)
            __s->~value_type();
        throw;
    }

}

template <class _ForwardIterator, class _Size, class _Tp>
_ForwardIterator
uninitialized_fill_n(_ForwardIterator __f, _Size __n, const _Tp& __x)
{
    typedef typename iterator_traits<_ForwardIterator>::value_type value_type;

    _ForwardIterator __s = __f;
    try
    {

        for (; __n > 0; ++__f, (void) --__n)
            ::new ((void*)std::__1::addressof(*__f)) value_type(__x);

    }
    catch (...)
    {
        for (; __s != __f; ++__s)
            __s->~value_type();
        throw;
    }

    return __f;
}



template <class _ForwardIterator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void destroy(_ForwardIterator __first, _ForwardIterator __last) {
    for (; __first != __last; ++__first)
        std::__1::destroy_at(std::__1::addressof(*__first));
}

template <class _ForwardIterator, class _Size>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
_ForwardIterator destroy_n(_ForwardIterator __first, _Size __n) {
    for (; __n > 0; (void)++__first, --__n)
        std::__1::destroy_at(std::__1::addressof(*__first));
    return __first;
}

template <class _ForwardIterator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void uninitialized_default_construct(_ForwardIterator __first, _ForwardIterator __last) {
    using _Vt = typename iterator_traits<_ForwardIterator>::value_type;
    auto __idx = __first;

    try {

    for (; __idx != __last; ++__idx)
        ::new ((void*)std::__1::addressof(*__idx)) _Vt;

    } catch (...) {
        std::__1::destroy(__first, __idx);
        throw;
    }

}

template <class _ForwardIterator, class _Size>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
_ForwardIterator uninitialized_default_construct_n(_ForwardIterator __first, _Size __n) {
    using _Vt = typename iterator_traits<_ForwardIterator>::value_type;
    auto __idx = __first;

    try {

    for (; __n > 0; (void)++__idx, --__n)
        ::new ((void*)std::__1::addressof(*__idx)) _Vt;
    return __idx;

    } catch (...) {
        std::__1::destroy(__first, __idx);
        throw;
    }

}


template <class _ForwardIterator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void uninitialized_value_construct(_ForwardIterator __first, _ForwardIterator __last) {
    using _Vt = typename iterator_traits<_ForwardIterator>::value_type;
    auto __idx = __first;

    try {

    for (; __idx != __last; ++__idx)
        ::new ((void*)std::__1::addressof(*__idx)) _Vt();

    } catch (...) {
        std::__1::destroy(__first, __idx);
        throw;
    }

}

template <class _ForwardIterator, class _Size>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
_ForwardIterator uninitialized_value_construct_n(_ForwardIterator __first, _Size __n) {
    using _Vt = typename iterator_traits<_ForwardIterator>::value_type;
    auto __idx = __first;

    try {

    for (; __n > 0; (void)++__idx, --__n)
        ::new ((void*)std::__1::addressof(*__idx)) _Vt();
    return __idx;

    } catch (...) {
        std::__1::destroy(__first, __idx);
        throw;
    }

}


template <class _InputIt, class _ForwardIt>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
_ForwardIt uninitialized_move(_InputIt __first, _InputIt __last, _ForwardIt __first_res) {
    using _Vt = typename iterator_traits<_ForwardIt>::value_type;
    auto __idx = __first_res;

    try {

    for (; __first != __last; (void)++__idx, ++__first)
        ::new ((void*)std::__1::addressof(*__idx)) _Vt(std::__1::move(*__first));
    return __idx;

    } catch (...) {
        std::__1::destroy(__first_res, __idx);
        throw;
    }

}

template <class _InputIt, class _Size, class _ForwardIt>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
pair<_InputIt, _ForwardIt>
uninitialized_move_n(_InputIt __first, _Size __n, _ForwardIt __first_res) {
    using _Vt = typename iterator_traits<_ForwardIt>::value_type;
    auto __idx = __first_res;

    try {

    for (; __n > 0; ++__idx, (void)++__first, --__n)
        ::new ((void*)std::__1::addressof(*__idx)) _Vt(std::__1::move(*__first));
    return {__first, __idx};

    } catch (...) {
        std::__1::destroy(__first_res, __idx);
        throw;
    }

}



} }
# 685 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/memory" 2 3
# 696 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/memory" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 1 3
# 697 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/memory" 2 3
# 707 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/memory" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 711 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/memory" 2 3


namespace std { inline namespace __1 {

template <class _Alloc, class _Ptr>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void __construct_forward_with_exception_guarantees(_Alloc& __a, _Ptr __begin1, _Ptr __end1, _Ptr& __begin2) {
    static_assert(__is_cpp17_move_insertable<_Alloc>::value,
        "The specified type does not meet the requirements of Cpp17MoveInsertable");
    typedef allocator_traits<_Alloc> _Traits;
    for (; __begin1 != __end1; ++__begin1, (void)++__begin2) {
        _Traits::construct(__a, std::__1::__to_address(__begin2),



            std::__1::move_if_noexcept(*__begin1)

        );
    }
}

template <class _Alloc, class _Tp, typename enable_if<
    (__is_default_allocator<_Alloc>::value || !__has_construct<_Alloc, _Tp*, _Tp>::value) &&
    is_trivially_move_constructible<_Tp>::value
>::type>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void __construct_forward_with_exception_guarantees(_Alloc&, _Tp* __begin1, _Tp* __end1, _Tp*& __begin2) {
    ptrdiff_t _Np = __end1 - __begin1;
    if (_Np > 0) {
        std::__1::memcpy(__begin2, __begin1, _Np * sizeof(_Tp));
        __begin2 += _Np;
    }
}

template <class _Alloc, class _Iter, class _Ptr>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void __construct_range_forward(_Alloc& __a, _Iter __begin1, _Iter __end1, _Ptr& __begin2) {
    typedef allocator_traits<_Alloc> _Traits;
    for (; __begin1 != __end1; ++__begin1, (void) ++__begin2) {
        _Traits::construct(__a, std::__1::__to_address(__begin2), *__begin1);
    }
}

template <class _Alloc, class _Source, class _Dest,
          class _RawSource = typename remove_const<_Source>::type,
          class _RawDest = typename remove_const<_Dest>::type,
          class =
    typename enable_if<
        is_trivially_copy_constructible<_Dest>::value &&
        is_same<_RawSource, _RawDest>::value &&
        (__is_default_allocator<_Alloc>::value || !__has_construct<_Alloc, _Dest*, _Source&>::value)
    >::type>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void __construct_range_forward(_Alloc&, _Source* __begin1, _Source* __end1, _Dest*& __begin2) {
    ptrdiff_t _Np = __end1 - __begin1;
    if (_Np > 0) {
        std::__1::memcpy(const_cast<_RawDest*>(__begin2), __begin1, _Np * sizeof(_Dest));
        __begin2 += _Np;
    }
}

template <class _Alloc, class _Ptr>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void __construct_backward_with_exception_guarantees(_Alloc& __a, _Ptr __begin1, _Ptr __end1, _Ptr& __end2) {
    static_assert(__is_cpp17_move_insertable<_Alloc>::value,
        "The specified type does not meet the requirements of Cpp17MoveInsertable");
    typedef allocator_traits<_Alloc> _Traits;
    while (__end1 != __begin1) {
        _Traits::construct(__a, std::__1::__to_address(__end2 - 1),



            std::__1::move_if_noexcept(*--__end1)

        );
        --__end2;
    }
}

template <class _Alloc, class _Tp, class = typename enable_if<
    (__is_default_allocator<_Alloc>::value || !__has_construct<_Alloc, _Tp*, _Tp>::value) &&
    is_trivially_move_constructible<_Tp>::value
>::type>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void __construct_backward_with_exception_guarantees(_Alloc&, _Tp* __begin1, _Tp* __end1, _Tp*& __end2) {
    ptrdiff_t _Np = __end1 - __begin1;
    __end2 -= _Np;
    if (_Np > 0)
        std::__1::memcpy(static_cast<void*>(__end2), static_cast<void const*>(__begin1), _Np * sizeof(_Tp));
}

struct __destruct_n
{
private:
    size_t __size_;

    template <class _Tp>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) void __process(_Tp* __p, false_type) noexcept
        {for (size_t __i = 0; __i < __size_; ++__i, ++__p) __p->~_Tp();}

    template <class _Tp>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) void __process(_Tp*, true_type) noexcept
        {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) void __incr(false_type) noexcept
        {++__size_;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) void __incr(true_type) noexcept
        {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) void __set(size_t __s, false_type) noexcept
        {__size_ = __s;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) void __set(size_t, true_type) noexcept
        {}
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) explicit __destruct_n(size_t __s) noexcept
        : __size_(__s) {}

    template <class _Tp>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) void __incr() noexcept
        {__incr(integral_constant<bool, is_trivially_destructible<_Tp>::value>());}

    template <class _Tp>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) void __set(size_t __s, _Tp*) noexcept
        {__set(__s, integral_constant<bool, is_trivially_destructible<_Tp>::value>());}

    template <class _Tp>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) void operator()(_Tp* __p) noexcept
        {__process(__p, integral_constant<bool, is_trivially_destructible<_Tp>::value>());}
};

__attribute__ ((__visibility__("default"))) void* align(size_t __align, size_t __sz, void*& __ptr, size_t& __space);


template <typename _Alloc>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void __swap_allocator(_Alloc & __a1, _Alloc & __a2, true_type)

    noexcept



{
    using std::__1::swap;
    swap(__a1, __a2);
}

template <typename _Alloc>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void __swap_allocator(_Alloc &, _Alloc &, false_type) noexcept {}

template <typename _Alloc>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void __swap_allocator(_Alloc & __a1, _Alloc & __a2)

    noexcept



{
    std::__1::__swap_allocator(__a1, __a2,
      integral_constant<bool, allocator_traits<_Alloc>::propagate_on_container_swap::value>());
}

template <typename _Alloc, typename _Traits=allocator_traits<_Alloc> >
struct __noexcept_move_assign_container : public integral_constant<bool,
    _Traits::propagate_on_container_move_assignment::value

        || _Traits::is_always_equal::value



    > {};


template <class _Tp, class _Alloc>
struct __temp_value {
    typedef allocator_traits<_Alloc> _Traits;

    typename aligned_storage<sizeof(_Tp), alignof(_Tp)>::type __v;
    _Alloc &__a;

    _Tp *__addr() { return reinterpret_cast<_Tp *>(addressof(__v)); }
    _Tp & get() { return *__addr(); }

    template<class... _Args>
    __attribute__((__no_sanitize__("cfi")))
    __temp_value(_Alloc &__alloc, _Args&& ... __args) : __a(__alloc) {
      _Traits::construct(__a, reinterpret_cast<_Tp*>(addressof(__v)),
                         std::__1::forward<_Args>(__args)...);
    }

    ~__temp_value() { _Traits::destroy(__a, __addr()); }
    };

template<typename _Alloc, typename = void, typename = void>
struct __is_allocator : false_type {};

template<typename _Alloc>
struct __is_allocator<_Alloc,
       typename __void_t<typename _Alloc::value_type>::type,
       typename __void_t<decltype(declval<_Alloc&>().allocate(size_t(0)))>::type
     >
   : true_type {};





struct __builtin_new_allocator {
  struct __builtin_new_deleter {
    typedef void* pointer_type;

    constexpr explicit __builtin_new_deleter(size_t __size, size_t __align)
        : __size_(__size), __align_(__align) {}

    void operator()(void* p) const noexcept {
        std::__1::__libcpp_deallocate(p, __size_, __align_);
    }

   private:
    size_t __size_;
    size_t __align_;
  };

  typedef unique_ptr<void, __builtin_new_deleter> __holder_t;

  static __holder_t __allocate_bytes(size_t __s, size_t __align) {
      return __holder_t(std::__1::__libcpp_allocate(__s, __align),
                     __builtin_new_deleter(__s, __align));
  }

  static void __deallocate_bytes(void* __p, size_t __s,
                                 size_t __align) noexcept {
      std::__1::__libcpp_deallocate(__p, __s, __align);
  }

  template <class _Tp>
  __attribute__((__nodebug__)) __attribute__ ((__always_inline__))
  static __holder_t __allocate_type(size_t __n) {
      return __allocate_bytes(__n * sizeof(_Tp), alignof(_Tp));
  }

  template <class _Tp>
  __attribute__((__nodebug__)) __attribute__ ((__always_inline__))
  static void __deallocate_type(void* __p, size_t __n) noexcept {
      __deallocate_bytes(__p, __n * sizeof(_Tp), alignof(_Tp));
  }
};


} }
# 974 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/memory" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 1 3
# 20 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/assert.h" 1 3 4
# 44 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/assert.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/stdlib.h" 1 3 4
# 45 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/assert.h" 2 3 4
# 81 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/assert.h" 3 4
extern "C" {
void __assert_rtn(const char *, const char *, int, const char *) __attribute__((__noreturn__)) __attribute__((__cold__)) __attribute__((__disable_tail_calls__));



}
# 21 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 2 3
# 24 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 3
# 975 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/memory" 2 3
# 23 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/function.h" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 1 3
# 24 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/function.h" 2 3
# 28 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/function.h" 3


namespace std { inline namespace __1 {



class __attribute__ ((__visibility__("default"))) bad_function_call
    : public exception
{
public:






    virtual ~bad_function_call() noexcept {}





};

[[noreturn]] inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void __throw_bad_function_call()
{

    throw bad_function_call();



}
# 69 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/function.h" 3
template<class _Fp> class __attribute__ ((__type_visibility__("default"))) function;

namespace __function
{

template<class _Rp>
struct __maybe_derive_from_unary_function
{
};

template<class _Rp, class _A1>
struct __maybe_derive_from_unary_function<_Rp(_A1)>
    : public unary_function<_A1, _Rp>
{
};

template<class _Rp>
struct __maybe_derive_from_binary_function
{
};

template<class _Rp, class _A1, class _A2>
struct __maybe_derive_from_binary_function<_Rp(_A1, _A2)>
    : public binary_function<_A1, _A2, _Rp>
{
};

template <class _Fp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool __not_null(_Fp const&) { return true; }

template <class _Fp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool __not_null(_Fp* __ptr) { return __ptr; }

template <class _Ret, class _Class>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool __not_null(_Ret _Class::*__ptr) { return __ptr; }

template <class _Fp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool __not_null(function<_Fp> const& __f) { return !!__f; }


template <class _Rp, class ..._Args>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool __not_null(_Rp (^__p)(_Args...)) { return __p; }


}



namespace __function {



template <class _Fp, class _Ap, class _FB> class __alloc_func;
template <class _Fp, class _FB>
class __default_alloc_func;

template <class _Fp, class _Ap, class _Rp, class... _ArgTypes>
class __alloc_func<_Fp, _Ap, _Rp(_ArgTypes...)>
{
    __compressed_pair<_Fp, _Ap> __f_;

  public:
    typedef _Fp _Target;
    typedef _Ap _Alloc;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const _Target& __target() const { return __f_.first(); }


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const _Alloc& __get_allocator() const { return __f_.second(); }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit __alloc_func(_Target&& __f)
        : __f_(piecewise_construct, std::__1::forward_as_tuple(std::__1::move(__f)),
               std::__1::forward_as_tuple())
    {
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit __alloc_func(const _Target& __f, const _Alloc& __a)
        : __f_(piecewise_construct, std::__1::forward_as_tuple(__f),
               std::__1::forward_as_tuple(__a))
    {
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit __alloc_func(const _Target& __f, _Alloc&& __a)
        : __f_(piecewise_construct, std::__1::forward_as_tuple(__f),
               std::__1::forward_as_tuple(std::__1::move(__a)))
    {
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit __alloc_func(_Target&& __f, _Alloc&& __a)
        : __f_(piecewise_construct, std::__1::forward_as_tuple(std::__1::move(__f)),
               std::__1::forward_as_tuple(std::__1::move(__a)))
    {
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    _Rp operator()(_ArgTypes&&... __arg)
    {
        typedef __invoke_void_return_wrapper<_Rp> _Invoker;
        return _Invoker::__call(__f_.first(),
                                std::__1::forward<_ArgTypes>(__arg)...);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __alloc_func* __clone() const
    {
        typedef allocator_traits<_Alloc> __alloc_traits;
        typedef
            typename __rebind_alloc_helper<__alloc_traits, __alloc_func>::type
                _AA;
        _AA __a(__f_.second());
        typedef __allocator_destructor<_AA> _Dp;
        unique_ptr<__alloc_func, _Dp> __hold(__a.allocate(1), _Dp(__a, 1));
        ::new ((void*)__hold.get()) __alloc_func(__f_.first(), _Alloc(__a));
        return __hold.release();
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void destroy() noexcept { __f_.~__compressed_pair<_Target, _Alloc>(); }

    static void __destroy_and_delete(__alloc_func* __f) {
      typedef allocator_traits<_Alloc> __alloc_traits;
      typedef typename __rebind_alloc_helper<__alloc_traits, __alloc_func>::type
          _FunAlloc;
      _FunAlloc __a(__f->__get_allocator());
      __f->destroy();
      __a.deallocate(__f, 1);
    }
};

template <class _Fp, class _Rp, class... _ArgTypes>
class __default_alloc_func<_Fp, _Rp(_ArgTypes...)> {
  _Fp __f_;

public:
  typedef _Fp _Target;

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  const _Target& __target() const { return __f_; }

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  explicit __default_alloc_func(_Target&& __f) : __f_(std::__1::move(__f)) {}

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  explicit __default_alloc_func(const _Target& __f) : __f_(__f) {}

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  _Rp operator()(_ArgTypes&&... __arg) {
    typedef __invoke_void_return_wrapper<_Rp> _Invoker;
    return _Invoker::__call(__f_, std::__1::forward<_ArgTypes>(__arg)...);
  }

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  __default_alloc_func* __clone() const {
      __builtin_new_allocator::__holder_t __hold =
        __builtin_new_allocator::__allocate_type<__default_alloc_func>(1);
    __default_alloc_func* __res =
        ::new ((void*)__hold.get()) __default_alloc_func(__f_);
    (void)__hold.release();
    return __res;
  }

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  void destroy() noexcept { __f_.~_Target(); }

  static void __destroy_and_delete(__default_alloc_func* __f) {
    __f->destroy();
      __builtin_new_allocator::__deallocate_type<__default_alloc_func>(__f, 1);
  }
};



template<class _Fp> class __attribute__ ((__type_visibility__("default"))) __base;

template<class _Rp, class ..._ArgTypes>
class __base<_Rp(_ArgTypes...)>
{
    __base(const __base&);
    __base& operator=(const __base&);
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) __base() {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) virtual ~__base() {}
    virtual __base* __clone() const = 0;
    virtual void __clone(__base*) const = 0;
    virtual void destroy() noexcept = 0;
    virtual void destroy_deallocate() noexcept = 0;
    virtual _Rp operator()(_ArgTypes&& ...) = 0;

    virtual const void* target(const type_info&) const noexcept = 0;
    virtual const std::type_info& target_type() const noexcept = 0;

};



template<class _FD, class _Alloc, class _FB> class __func;

template<class _Fp, class _Alloc, class _Rp, class ..._ArgTypes>
class __func<_Fp, _Alloc, _Rp(_ArgTypes...)>
    : public __base<_Rp(_ArgTypes...)>
{
    __alloc_func<_Fp, _Alloc, _Rp(_ArgTypes...)> __f_;
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit __func(_Fp&& __f)
        : __f_(std::__1::move(__f)) {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit __func(const _Fp& __f, const _Alloc& __a)
        : __f_(__f, __a) {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit __func(const _Fp& __f, _Alloc&& __a)
        : __f_(__f, std::__1::move(__a)) {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit __func(_Fp&& __f, _Alloc&& __a)
        : __f_(std::__1::move(__f), std::__1::move(__a)) {}

    virtual __base<_Rp(_ArgTypes...)>* __clone() const;
    virtual void __clone(__base<_Rp(_ArgTypes...)>*) const;
    virtual void destroy() noexcept;
    virtual void destroy_deallocate() noexcept;
    virtual _Rp operator()(_ArgTypes&&... __arg);

    virtual const void* target(const type_info&) const noexcept;
    virtual const std::type_info& target_type() const noexcept;

};

template<class _Fp, class _Alloc, class _Rp, class ..._ArgTypes>
__base<_Rp(_ArgTypes...)>*
__func<_Fp, _Alloc, _Rp(_ArgTypes...)>::__clone() const
{
    typedef allocator_traits<_Alloc> __alloc_traits;
    typedef typename __rebind_alloc_helper<__alloc_traits, __func>::type _Ap;
    _Ap __a(__f_.__get_allocator());
    typedef __allocator_destructor<_Ap> _Dp;
    unique_ptr<__func, _Dp> __hold(__a.allocate(1), _Dp(__a, 1));
    ::new ((void*)__hold.get()) __func(__f_.__target(), _Alloc(__a));
    return __hold.release();
}

template<class _Fp, class _Alloc, class _Rp, class ..._ArgTypes>
void
__func<_Fp, _Alloc, _Rp(_ArgTypes...)>::__clone(__base<_Rp(_ArgTypes...)>* __p) const
{
    ::new ((void*)__p) __func(__f_.__target(), __f_.__get_allocator());
}

template<class _Fp, class _Alloc, class _Rp, class ..._ArgTypes>
void
__func<_Fp, _Alloc, _Rp(_ArgTypes...)>::destroy() noexcept
{
    __f_.destroy();
}

template<class _Fp, class _Alloc, class _Rp, class ..._ArgTypes>
void
__func<_Fp, _Alloc, _Rp(_ArgTypes...)>::destroy_deallocate() noexcept
{
    typedef allocator_traits<_Alloc> __alloc_traits;
    typedef typename __rebind_alloc_helper<__alloc_traits, __func>::type _Ap;
    _Ap __a(__f_.__get_allocator());
    __f_.destroy();
    __a.deallocate(this, 1);
}

template<class _Fp, class _Alloc, class _Rp, class ..._ArgTypes>
_Rp
__func<_Fp, _Alloc, _Rp(_ArgTypes...)>::operator()(_ArgTypes&& ... __arg)
{
    return __f_(std::__1::forward<_ArgTypes>(__arg)...);
}



template<class _Fp, class _Alloc, class _Rp, class ..._ArgTypes>
const void*
__func<_Fp, _Alloc, _Rp(_ArgTypes...)>::target(const type_info& __ti) const noexcept
{
    if (__ti == typeid(_Fp))
        return &__f_.__target();
    return nullptr;
}

template<class _Fp, class _Alloc, class _Rp, class ..._ArgTypes>
const std::type_info&
__func<_Fp, _Alloc, _Rp(_ArgTypes...)>::target_type() const noexcept
{
    return typeid(_Fp);
}





template <class _Fp> class __value_func;

template <class _Rp, class... _ArgTypes> class __value_func<_Rp(_ArgTypes...)>
{
    typename aligned_storage<3 * sizeof(void*)>::type __buf_;

    typedef __base<_Rp(_ArgTypes...)> __func;
    __func* __f_;

    __attribute__((__no_sanitize__("cfi"))) static __func* __as_base(void* p)
    {
        return reinterpret_cast<__func*>(p);
    }

  public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __value_func() noexcept : __f_(nullptr) {}

    template <class _Fp, class _Alloc>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) __value_func(_Fp&& __f, const _Alloc& __a)
        : __f_(nullptr)
    {
        typedef allocator_traits<_Alloc> __alloc_traits;
        typedef __function::__func<_Fp, _Alloc, _Rp(_ArgTypes...)> _Fun;
        typedef typename __rebind_alloc_helper<__alloc_traits, _Fun>::type
            _FunAlloc;

        if (__function::__not_null(__f))
        {
            _FunAlloc __af(__a);
            if (sizeof(_Fun) <= sizeof(__buf_) &&
                is_nothrow_copy_constructible<_Fp>::value &&
                is_nothrow_copy_constructible<_FunAlloc>::value)
            {
                __f_ =
                    ::new ((void*)&__buf_) _Fun(std::__1::move(__f), _Alloc(__af));
            }
            else
            {
                typedef __allocator_destructor<_FunAlloc> _Dp;
                unique_ptr<__func, _Dp> __hold(__af.allocate(1), _Dp(__af, 1));
                ::new ((void*)__hold.get()) _Fun(std::__1::move(__f), _Alloc(__a));
                __f_ = __hold.release();
            }
        }
    }

    template <class _Fp,
        class = typename enable_if<!is_same<typename decay<_Fp>::type, __value_func>::value>::type>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) explicit __value_func(_Fp&& __f)
        : __value_func(std::__1::forward<_Fp>(__f), allocator<_Fp>()) {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __value_func(const __value_func& __f)
    {
        if (__f.__f_ == nullptr)
            __f_ = nullptr;
        else if ((void*)__f.__f_ == &__f.__buf_)
        {
            __f_ = __as_base(&__buf_);
            __f.__f_->__clone(__f_);
        }
        else
            __f_ = __f.__f_->__clone();
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __value_func(__value_func&& __f) noexcept
    {
        if (__f.__f_ == nullptr)
            __f_ = nullptr;
        else if ((void*)__f.__f_ == &__f.__buf_)
        {
            __f_ = __as_base(&__buf_);
            __f.__f_->__clone(__f_);
        }
        else
        {
            __f_ = __f.__f_;
            __f.__f_ = nullptr;
        }
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    ~__value_func()
    {
        if ((void*)__f_ == &__buf_)
            __f_->destroy();
        else if (__f_)
            __f_->destroy_deallocate();
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __value_func& operator=(__value_func&& __f)
    {
        *this = nullptr;
        if (__f.__f_ == nullptr)
            __f_ = nullptr;
        else if ((void*)__f.__f_ == &__f.__buf_)
        {
            __f_ = __as_base(&__buf_);
            __f.__f_->__clone(__f_);
        }
        else
        {
            __f_ = __f.__f_;
            __f.__f_ = nullptr;
        }
        return *this;
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __value_func& operator=(nullptr_t)
    {
        __func* __f = __f_;
        __f_ = nullptr;
        if ((void*)__f == &__buf_)
            __f->destroy();
        else if (__f)
            __f->destroy_deallocate();
        return *this;
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    _Rp operator()(_ArgTypes&&... __args) const
    {
        if (__f_ == nullptr)
            __throw_bad_function_call();
        return (*__f_)(std::__1::forward<_ArgTypes>(__args)...);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void swap(__value_func& __f) noexcept
    {
        if (&__f == this)
            return;
        if ((void*)__f_ == &__buf_ && (void*)__f.__f_ == &__f.__buf_)
        {
            typename aligned_storage<sizeof(__buf_)>::type __tempbuf;
            __func* __t = __as_base(&__tempbuf);
            __f_->__clone(__t);
            __f_->destroy();
            __f_ = nullptr;
            __f.__f_->__clone(__as_base(&__buf_));
            __f.__f_->destroy();
            __f.__f_ = nullptr;
            __f_ = __as_base(&__buf_);
            __t->__clone(__as_base(&__f.__buf_));
            __t->destroy();
            __f.__f_ = __as_base(&__f.__buf_);
        }
        else if ((void*)__f_ == &__buf_)
        {
            __f_->__clone(__as_base(&__f.__buf_));
            __f_->destroy();
            __f_ = __f.__f_;
            __f.__f_ = __as_base(&__f.__buf_);
        }
        else if ((void*)__f.__f_ == &__f.__buf_)
        {
            __f.__f_->__clone(__as_base(&__buf_));
            __f.__f_->destroy();
            __f.__f_ = __f_;
            __f_ = __as_base(&__buf_);
        }
        else
            std::__1::swap(__f_, __f.__f_);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit operator bool() const noexcept { return __f_ != nullptr; }


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const std::type_info& target_type() const noexcept
    {
        if (__f_ == nullptr)
            return typeid(void);
        return __f_->target_type();
    }

    template <typename _Tp>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) const _Tp* target() const noexcept
    {
        if (__f_ == nullptr)
            return nullptr;
        return (const _Tp*)__f_->target(typeid(_Tp));
    }

};



union __policy_storage
{
    mutable char __small[sizeof(void*) * 2];
    void* __large;
};


template <typename _Fun>
struct __use_small_storage
    : public integral_constant<
          bool, sizeof(_Fun) <= sizeof(__policy_storage) &&
                    alignof(_Fun) <= alignof(__policy_storage) &&
                    is_trivially_copy_constructible<_Fun>::value &&
                    is_trivially_destructible<_Fun>::value> {};



struct __policy
{

    void* (*const __clone)(const void*);
    void (*const __destroy)(void*);


    const bool __is_null;


    const std::type_info* const __type_info;



    template <typename _Fun>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) static const __policy* __create()
    {
        return __choose_policy<_Fun>(__use_small_storage<_Fun>());
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    static const __policy* __create_empty()
    {
        static const constexpr __policy __policy_ = {nullptr, nullptr,
                                                             true,

                                                             &typeid(void)



        };
        return &__policy_;
    }

  private:
    template <typename _Fun> static void* __large_clone(const void* __s)
    {
        const _Fun* __f = static_cast<const _Fun*>(__s);
        return __f->__clone();
    }

    template <typename _Fun>
    static void __large_destroy(void* __s) {
      _Fun::__destroy_and_delete(static_cast<_Fun*>(__s));
    }

    template <typename _Fun>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) static const __policy*
    __choose_policy( false_type) {
      static const constexpr __policy __policy_ = {
          &__large_clone<_Fun>, &__large_destroy<_Fun>, false,

          &typeid(typename _Fun::_Target)



      };
        return &__policy_;
    }

    template <typename _Fun>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) static const __policy*
        __choose_policy( true_type)
    {
        static const constexpr __policy __policy_ = {
            nullptr, nullptr, false,

            &typeid(typename _Fun::_Target)



        };
        return &__policy_;
    }
};



template <typename _Tp>
using __fast_forward =
    typename conditional<is_scalar<_Tp>::value, _Tp, _Tp&&>::type;



template <class _Fp> struct __policy_invoker;

template <class _Rp, class... _ArgTypes>
struct __policy_invoker<_Rp(_ArgTypes...)>
{
    typedef _Rp (*__Call)(const __policy_storage*,
                          __fast_forward<_ArgTypes>...);

    __Call __call_;


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __policy_invoker() : __call_(&__call_empty) {}


    template <typename _Fun>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) static __policy_invoker __create()
    {
        return __policy_invoker(&__call_impl<_Fun>);
    }

  private:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit __policy_invoker(__Call __c) : __call_(__c) {}

    static _Rp __call_empty(const __policy_storage*,
                            __fast_forward<_ArgTypes>...)
    {
        __throw_bad_function_call();
    }

    template <typename _Fun>
    static _Rp __call_impl(const __policy_storage* __buf,
                           __fast_forward<_ArgTypes>... __args)
    {
        _Fun* __f = reinterpret_cast<_Fun*>(__use_small_storage<_Fun>::value
                                                ? &__buf->__small
                                                : __buf->__large);
        return (*__f)(std::__1::forward<_ArgTypes>(__args)...);
    }
};




template <class _Fp> class __policy_func;

template <class _Rp, class... _ArgTypes> class __policy_func<_Rp(_ArgTypes...)>
{

    __policy_storage __buf_;




    typedef __function::__policy_invoker<_Rp(_ArgTypes...)> __invoker;
    __invoker __invoker_;



    const __policy* __policy_;

  public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __policy_func() : __policy_(__policy::__create_empty()) {}

    template <class _Fp, class _Alloc>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) __policy_func(_Fp&& __f, const _Alloc& __a)
        : __policy_(__policy::__create_empty())
    {
        typedef __alloc_func<_Fp, _Alloc, _Rp(_ArgTypes...)> _Fun;
        typedef allocator_traits<_Alloc> __alloc_traits;
        typedef typename __rebind_alloc_helper<__alloc_traits, _Fun>::type
            _FunAlloc;

        if (__function::__not_null(__f))
        {
            __invoker_ = __invoker::template __create<_Fun>();
            __policy_ = __policy::__create<_Fun>();

            _FunAlloc __af(__a);
            if (__use_small_storage<_Fun>())
            {
                ::new ((void*)&__buf_.__small)
                    _Fun(std::__1::move(__f), _Alloc(__af));
            }
            else
            {
                typedef __allocator_destructor<_FunAlloc> _Dp;
                unique_ptr<_Fun, _Dp> __hold(__af.allocate(1), _Dp(__af, 1));
                ::new ((void*)__hold.get())
                    _Fun(std::__1::move(__f), _Alloc(__af));
                __buf_.__large = __hold.release();
            }
        }
    }

    template <class _Fp, class = typename enable_if<!is_same<typename decay<_Fp>::type, __policy_func>::value>::type>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) explicit __policy_func(_Fp&& __f)
        : __policy_(__policy::__create_empty()) {
      typedef __default_alloc_func<_Fp, _Rp(_ArgTypes...)> _Fun;

      if (__function::__not_null(__f)) {
        __invoker_ = __invoker::template __create<_Fun>();
        __policy_ = __policy::__create<_Fun>();
        if (__use_small_storage<_Fun>()) {
          ::new ((void*)&__buf_.__small) _Fun(std::__1::move(__f));
        } else {
          __builtin_new_allocator::__holder_t __hold =
              __builtin_new_allocator::__allocate_type<_Fun>(1);
          __buf_.__large = ::new ((void*)__hold.get()) _Fun(std::__1::move(__f));
          (void)__hold.release();
        }
      }
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __policy_func(const __policy_func& __f)
        : __buf_(__f.__buf_), __invoker_(__f.__invoker_),
          __policy_(__f.__policy_)
    {
        if (__policy_->__clone)
            __buf_.__large = __policy_->__clone(__f.__buf_.__large);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __policy_func(__policy_func&& __f)
        : __buf_(__f.__buf_), __invoker_(__f.__invoker_),
          __policy_(__f.__policy_)
    {
        if (__policy_->__destroy)
        {
            __f.__policy_ = __policy::__create_empty();
            __f.__invoker_ = __invoker();
        }
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    ~__policy_func()
    {
        if (__policy_->__destroy)
            __policy_->__destroy(__buf_.__large);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __policy_func& operator=(__policy_func&& __f)
    {
        *this = nullptr;
        __buf_ = __f.__buf_;
        __invoker_ = __f.__invoker_;
        __policy_ = __f.__policy_;
        __f.__policy_ = __policy::__create_empty();
        __f.__invoker_ = __invoker();
        return *this;
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __policy_func& operator=(nullptr_t)
    {
        const __policy* __p = __policy_;
        __policy_ = __policy::__create_empty();
        __invoker_ = __invoker();
        if (__p->__destroy)
            __p->__destroy(__buf_.__large);
        return *this;
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    _Rp operator()(_ArgTypes&&... __args) const
    {
        return __invoker_.__call_(std::__1::addressof(__buf_),
                                  std::__1::forward<_ArgTypes>(__args)...);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void swap(__policy_func& __f)
    {
        std::__1::swap(__invoker_, __f.__invoker_);
        std::__1::swap(__policy_, __f.__policy_);
        std::__1::swap(__buf_, __f.__buf_);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit operator bool() const noexcept
    {
        return !__policy_->__is_null;
    }


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const std::type_info& target_type() const noexcept
    {
        return *__policy_->__type_info;
    }

    template <typename _Tp>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) const _Tp* target() const noexcept
    {
        if (__policy_->__is_null || typeid(_Tp) != *__policy_->__type_info)
            return nullptr;
        if (__policy_->__clone)
            return reinterpret_cast<const _Tp*>(__buf_.__large);
        else
            return reinterpret_cast<const _Tp*>(&__buf_.__small);
    }

};



extern "C" void *_Block_copy(const void *);
extern "C" void _Block_release(const void *);

template<class _Rp1, class ..._ArgTypes1, class _Alloc, class _Rp, class ..._ArgTypes>
class __func<_Rp1(^)(_ArgTypes1...), _Alloc, _Rp(_ArgTypes...)>
    : public __base<_Rp(_ArgTypes...)>
{
    typedef _Rp1(^__block_type)(_ArgTypes1...);
    __block_type __f_;

public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit __func(__block_type const& __f)
        : __f_(reinterpret_cast<__block_type>(__f ? _Block_copy(__f) : nullptr))
    { }



    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit __func(__block_type __f, const _Alloc& )
        : __f_(reinterpret_cast<__block_type>(__f ? _Block_copy(__f) : nullptr))
    { }

    virtual __base<_Rp(_ArgTypes...)>* __clone() const {
        ((void)0);



        return nullptr;
    }

    virtual void __clone(__base<_Rp(_ArgTypes...)>* __p) const {
        ::new ((void*)__p) __func(__f_);
    }

    virtual void destroy() noexcept {
        if (__f_)
            _Block_release(__f_);
        __f_ = 0;
    }

    virtual void destroy_deallocate() noexcept {
        ((void)0);



    }

    virtual _Rp operator()(_ArgTypes&& ... __arg) {
        return std::__1::__invoke(__f_, std::__1::forward<_ArgTypes>(__arg)...);
    }


    virtual const void* target(type_info const& __ti) const noexcept {
        if (__ti == typeid(__func::__block_type))
            return &__f_;
        return (const void*)nullptr;
    }

    virtual const std::type_info& target_type() const noexcept {
        return typeid(__func::__block_type);
    }

};



}

template<class _Rp, class ..._ArgTypes>
class __attribute__ ((__type_visibility__("default"))) function<_Rp(_ArgTypes...)>

    : public __function::__maybe_derive_from_unary_function<_Rp(_ArgTypes...)>,
      public __function::__maybe_derive_from_binary_function<_Rp(_ArgTypes...)>

{

    typedef __function::__value_func<_Rp(_ArgTypes...)> __func;




    __func __f_;

    template <class _Fp, bool = _And<
        _IsNotSame<__uncvref_t<_Fp>, function>,
        __invokable<_Fp, _ArgTypes...>
    >::value>
    struct __callable;
    template <class _Fp>
        struct __callable<_Fp, true>
        {
            static const bool value = is_void<_Rp>::value ||
                __is_core_convertible<typename __invoke_of<_Fp, _ArgTypes...>::type,
                                      _Rp>::value;
        };
    template <class _Fp>
        struct __callable<_Fp, false>
        {
            static const bool value = false;
        };

  template <class _Fp>
  using _EnableIfLValueCallable = typename enable_if<__callable<_Fp&>::value>::type;
public:
    typedef _Rp result_type;


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    function() noexcept { }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    function(nullptr_t) noexcept {}
    function(const function&);
    function(function&&) noexcept;
    template<class _Fp, class = _EnableIfLValueCallable<_Fp>>
    function(_Fp);
# 1013 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/function.h" 3
    function& operator=(const function&);
    function& operator=(function&&) noexcept;
    function& operator=(nullptr_t) noexcept;
    template<class _Fp, class = _EnableIfLValueCallable<typename decay<_Fp>::type>>
    function& operator=(_Fp&&);

    ~function();


    void swap(function&) noexcept;
# 1032 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/function.h" 3
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit operator bool() const noexcept {
      return static_cast<bool>(__f_);
    }


    template<class _R2, class... _ArgTypes2>
      bool operator==(const function<_R2(_ArgTypes2...)>&) const = delete;
    template<class _R2, class... _ArgTypes2>
      bool operator!=(const function<_R2(_ArgTypes2...)>&) const = delete;
public:

    _Rp operator()(_ArgTypes...) const;



    const std::type_info& target_type() const noexcept;
    template <typename _Tp> _Tp* target() noexcept;
    template <typename _Tp> const _Tp* target() const noexcept;

};


template<class _Rp, class ..._Ap>
function(_Rp(*)(_Ap...)) -> function<_Rp(_Ap...)>;

template<class _Fp>
struct __strip_signature;

template<class _Rp, class _Gp, class ..._Ap>
struct __strip_signature<_Rp (_Gp::*) (_Ap...)> { using type = _Rp(_Ap...); };
template<class _Rp, class _Gp, class ..._Ap>
struct __strip_signature<_Rp (_Gp::*) (_Ap...) const> { using type = _Rp(_Ap...); };
template<class _Rp, class _Gp, class ..._Ap>
struct __strip_signature<_Rp (_Gp::*) (_Ap...) volatile> { using type = _Rp(_Ap...); };
template<class _Rp, class _Gp, class ..._Ap>
struct __strip_signature<_Rp (_Gp::*) (_Ap...) const volatile> { using type = _Rp(_Ap...); };

template<class _Rp, class _Gp, class ..._Ap>
struct __strip_signature<_Rp (_Gp::*) (_Ap...) &> { using type = _Rp(_Ap...); };
template<class _Rp, class _Gp, class ..._Ap>
struct __strip_signature<_Rp (_Gp::*) (_Ap...) const &> { using type = _Rp(_Ap...); };
template<class _Rp, class _Gp, class ..._Ap>
struct __strip_signature<_Rp (_Gp::*) (_Ap...) volatile &> { using type = _Rp(_Ap...); };
template<class _Rp, class _Gp, class ..._Ap>
struct __strip_signature<_Rp (_Gp::*) (_Ap...) const volatile &> { using type = _Rp(_Ap...); };

template<class _Rp, class _Gp, class ..._Ap>
struct __strip_signature<_Rp (_Gp::*) (_Ap...) noexcept> { using type = _Rp(_Ap...); };
template<class _Rp, class _Gp, class ..._Ap>
struct __strip_signature<_Rp (_Gp::*) (_Ap...) const noexcept> { using type = _Rp(_Ap...); };
template<class _Rp, class _Gp, class ..._Ap>
struct __strip_signature<_Rp (_Gp::*) (_Ap...) volatile noexcept> { using type = _Rp(_Ap...); };
template<class _Rp, class _Gp, class ..._Ap>
struct __strip_signature<_Rp (_Gp::*) (_Ap...) const volatile noexcept> { using type = _Rp(_Ap...); };

template<class _Rp, class _Gp, class ..._Ap>
struct __strip_signature<_Rp (_Gp::*) (_Ap...) & noexcept> { using type = _Rp(_Ap...); };
template<class _Rp, class _Gp, class ..._Ap>
struct __strip_signature<_Rp (_Gp::*) (_Ap...) const & noexcept> { using type = _Rp(_Ap...); };
template<class _Rp, class _Gp, class ..._Ap>
struct __strip_signature<_Rp (_Gp::*) (_Ap...) volatile & noexcept> { using type = _Rp(_Ap...); };
template<class _Rp, class _Gp, class ..._Ap>
struct __strip_signature<_Rp (_Gp::*) (_Ap...) const volatile & noexcept> { using type = _Rp(_Ap...); };

template<class _Fp, class _Stripped = typename __strip_signature<decltype(&_Fp::operator())>::type>
function(_Fp) -> function<_Stripped>;


template<class _Rp, class ..._ArgTypes>
function<_Rp(_ArgTypes...)>::function(const function& __f) : __f_(__f.__f_) {}
# 1111 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/function.h" 3
template <class _Rp, class... _ArgTypes>
function<_Rp(_ArgTypes...)>::function(function&& __f) noexcept
    : __f_(std::__1::move(__f.__f_)) {}
# 1123 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/function.h" 3
template <class _Rp, class... _ArgTypes>
template <class _Fp, class>
function<_Rp(_ArgTypes...)>::function(_Fp __f) : __f_(std::__1::move(__f)) {}
# 1135 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/function.h" 3
template<class _Rp, class ..._ArgTypes>
function<_Rp(_ArgTypes...)>&
function<_Rp(_ArgTypes...)>::operator=(const function& __f)
{
    function(__f).swap(*this);
    return *this;
}

template<class _Rp, class ..._ArgTypes>
function<_Rp(_ArgTypes...)>&
function<_Rp(_ArgTypes...)>::operator=(function&& __f) noexcept
{
    __f_ = std::__1::move(__f.__f_);
    return *this;
}

template<class _Rp, class ..._ArgTypes>
function<_Rp(_ArgTypes...)>&
function<_Rp(_ArgTypes...)>::operator=(nullptr_t) noexcept
{
    __f_ = nullptr;
    return *this;
}

template<class _Rp, class ..._ArgTypes>
template <class _Fp, class>
function<_Rp(_ArgTypes...)>&
function<_Rp(_ArgTypes...)>::operator=(_Fp&& __f)
{
    function(std::__1::forward<_Fp>(__f)).swap(*this);
    return *this;
}

template<class _Rp, class ..._ArgTypes>
function<_Rp(_ArgTypes...)>::~function() {}

template<class _Rp, class ..._ArgTypes>
void
function<_Rp(_ArgTypes...)>::swap(function& __f) noexcept
{
    __f_.swap(__f.__f_);
}

template<class _Rp, class ..._ArgTypes>
_Rp
function<_Rp(_ArgTypes...)>::operator()(_ArgTypes... __arg) const
{
    return __f_(std::__1::forward<_ArgTypes>(__arg)...);
}



template<class _Rp, class ..._ArgTypes>
const std::type_info&
function<_Rp(_ArgTypes...)>::target_type() const noexcept
{
    return __f_.target_type();
}

template<class _Rp, class ..._ArgTypes>
template <typename _Tp>
_Tp*
function<_Rp(_ArgTypes...)>::target() noexcept
{
    return (_Tp*)(__f_.template target<_Tp>());
}

template<class _Rp, class ..._ArgTypes>
template <typename _Tp>
const _Tp*
function<_Rp(_ArgTypes...)>::target() const noexcept
{
    return __f_.template target<_Tp>();
}



template <class _Rp, class... _ArgTypes>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator==(const function<_Rp(_ArgTypes...)>& __f, nullptr_t) noexcept {return !__f;}

template <class _Rp, class... _ArgTypes>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator==(nullptr_t, const function<_Rp(_ArgTypes...)>& __f) noexcept {return !__f;}

template <class _Rp, class... _ArgTypes>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator!=(const function<_Rp(_ArgTypes...)>& __f, nullptr_t) noexcept {return (bool)__f;}

template <class _Rp, class... _ArgTypes>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator!=(nullptr_t, const function<_Rp(_ArgTypes...)>& __f) noexcept {return (bool)__f;}

template <class _Rp, class... _ArgTypes>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void
swap(function<_Rp(_ArgTypes...)>& __x, function<_Rp(_ArgTypes...)>& __y) noexcept
{return __x.swap(__y);}
# 2814 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/function.h" 3
} }
# 501 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/functional" 2 3

# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/identity.h" 1 3
# 18 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/identity.h" 3


namespace std { inline namespace __1 {
# 35 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/identity.h" 3
} }
# 503 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/functional" 2 3

# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/mem_fn.h" 1 3
# 21 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/mem_fn.h" 3


namespace std { inline namespace __1 {

template <class _Tp>
class __mem_fn

    : public __weak_result_type<_Tp>

{
public:

    typedef _Tp type;
private:
    type __f_;

public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __mem_fn(type __f) noexcept : __f_(__f) {}



    template <class... _ArgTypes>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    typename __invoke_return<type, _ArgTypes...>::type
    operator() (_ArgTypes&&... __args) const {
        return std::__1::__invoke(__f_, std::__1::forward<_ArgTypes>(__args)...);
    }
# 149 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/mem_fn.h" 3
};

template<class _Rp, class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
__mem_fn<_Rp _Tp::*>
mem_fn(_Rp _Tp::* __pm) noexcept
{
    return __mem_fn<_Rp _Tp::*>(__pm);
}

} }
# 505 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/functional" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/mem_fun_ref.h" 1 3
# 19 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/mem_fun_ref.h" 3


namespace std { inline namespace __1 {
# 171 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/mem_fun_ref.h" 3
} }
# 506 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/functional" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/not_fn.h" 1 3
# 20 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/not_fn.h" 3


namespace std { inline namespace __1 {



struct __not_fn_op
{
    template<class... _Args>
    static auto __call(_Args&&... __args)
    noexcept(noexcept(!std::__1::invoke(std::__1::forward<_Args>(__args)...)))
    -> decltype( !std::__1::invoke(std::__1::forward<_Args>(__args)...))
    { return !std::__1::invoke(std::__1::forward<_Args>(__args)...); }
};

template<class _Fn,
         class = _EnableIf<is_constructible_v<decay_t<_Fn>, _Fn> &&
                           is_move_constructible_v<_Fn>>>
                              auto not_fn(_Fn&& __f)
{
    return __perfect_forward<__not_fn_op, _Fn>(std::__1::forward<_Fn>(__f));
}



} }
# 507 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/functional" 2 3

# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/pointer_to_binary_function.h" 1 3
# 18 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/pointer_to_binary_function.h" 3


namespace std { inline namespace __1 {
# 44 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/pointer_to_binary_function.h" 3
} }
# 509 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/functional" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/pointer_to_unary_function.h" 1 3
# 18 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/pointer_to_unary_function.h" 3


namespace std { inline namespace __1 {
# 44 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/pointer_to_unary_function.h" 3
} }
# 510 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/functional" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/ranges_operations.h" 1 3
# 19 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/ranges_operations.h" 3


namespace std { inline namespace __1 {
# 95 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/ranges_operations.h" 3
} }
# 511 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/functional" 2 3


# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/unary_negate.h" 1 3
# 18 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/unary_negate.h" 3


namespace std { inline namespace __1 {



template <class _Predicate>
class __attribute__ ((__type_visibility__("default"))) __attribute__ ((deprecated)) unary_negate
    : public unary_function<typename _Predicate::argument_type, bool>
{
    _Predicate __pred_;
public:
    constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit unary_negate(const _Predicate& __pred)
        : __pred_(__pred) {}
    constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    bool operator()(const typename _Predicate::argument_type& __x) const
        {return !__pred_(__x);}
};

template <class _Predicate>
__attribute__ ((deprecated)) inline constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
unary_negate<_Predicate>
not1(const _Predicate& __pred) {return unary_negate<_Predicate>(__pred);}



} }
# 514 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/functional" 2 3




# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/memory" 1 3
# 974 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/memory" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 1 3
# 20 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/assert.h" 1 3 4
# 44 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/assert.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/stdlib.h" 1 3 4
# 45 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/assert.h" 2 3 4
# 81 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/assert.h" 3 4
extern "C" {
void __assert_rtn(const char *, const char *, int, const char *) __attribute__((__noreturn__)) __attribute__((__cold__)) __attribute__((__disable_tail_calls__));



}
# 21 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 2 3
# 24 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 3
# 975 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/memory" 2 3
# 519 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/functional" 2 3

# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 1 3
# 521 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/functional" 2 3
# 527 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/functional" 3
# 654 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/algorithm" 2 3


# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/memory" 1 3
# 974 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/memory" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 1 3
# 20 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/assert.h" 1 3 4
# 44 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/assert.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/stdlib.h" 1 3 4
# 45 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/assert.h" 2 3 4
# 81 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/assert.h" 3 4
extern "C" {
void __assert_rtn(const char *, const char *, int, const char *) __attribute__((__noreturn__)) __attribute__((__cold__)) __attribute__((__disable_tail_calls__));



}
# 21 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 2 3
# 24 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 3
# 975 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/memory" 2 3
# 657 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/algorithm" 2 3

# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/memory" 1 3
# 974 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/memory" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 1 3
# 20 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/assert.h" 1 3 4
# 44 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/assert.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/stdlib.h" 1 3 4
# 45 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/assert.h" 2 3 4
# 81 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/assert.h" 3 4
extern "C" {
void __assert_rtn(const char *, const char *, int, const char *) __attribute__((__noreturn__)) __attribute__((__cold__)) __attribute__((__disable_tail_calls__));



}
# 21 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 2 3
# 24 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 3
# 975 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/memory" 2 3
# 659 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/algorithm" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 1 3
# 660 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/algorithm" 2 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/adjacent_find.h" 1 3
# 19 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/adjacent_find.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 23 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/adjacent_find.h" 2 3

namespace std { inline namespace __1 {

template <class _ForwardIterator, class _BinaryPredicate>
                      inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) _ForwardIterator
adjacent_find(_ForwardIterator __first, _ForwardIterator __last, _BinaryPredicate __pred) {
  if (__first != __last) {
    _ForwardIterator __i = __first;
    while (++__i != __last) {
      if (__pred(*__first, *__i))
        return __first;
      __first = __i;
    }
  }
  return __last;
}

template <class _ForwardIterator>
                      inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) _ForwardIterator
adjacent_find(_ForwardIterator __first, _ForwardIterator __last) {
  typedef typename iterator_traits<_ForwardIterator>::value_type __v;
  return std::__1::adjacent_find(__first, __last, __equal_to<__v>());
}

} }
# 664 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/algorithm" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/all_of.h" 1 3
# 17 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/all_of.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 21 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/all_of.h" 2 3

namespace std { inline namespace __1 {

template <class _InputIterator, class _Predicate>
                      inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) bool
all_of(_InputIterator __first, _InputIterator __last, _Predicate __pred) {
  for (; __first != __last; ++__first)
    if (!__pred(*__first))
      return false;
  return true;
}

} }
# 665 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/algorithm" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/any_of.h" 1 3
# 17 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/any_of.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 21 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/any_of.h" 2 3

namespace std { inline namespace __1 {

template <class _InputIterator, class _Predicate>
                      inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) bool
any_of(_InputIterator __first, _InputIterator __last, _Predicate __pred) {
  for (; __first != __last; ++__first)
    if (__pred(*__first))
      return true;
  return false;
}

} }
# 666 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/algorithm" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/binary_search.h" 1 3
# 14 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/binary_search.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/lower_bound.h" 1 3
# 14 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/lower_bound.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/half_positive.h" 1 3
# 13 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/half_positive.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 1 3
# 14 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/half_positive.h" 2 3
# 17 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/half_positive.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 21 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/half_positive.h" 2 3

namespace std { inline namespace __1 {



template <typename _Integral>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
typename enable_if
<
    is_integral<_Integral>::value,
    _Integral
>::type
__half_positive(_Integral __value)
{
    return static_cast<_Integral>(static_cast<typename make_unsigned<_Integral>::type>(__value) / 2);
}

template <typename _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
typename enable_if
<
    !is_integral<_Tp>::value,
    _Tp
>::type
__half_positive(_Tp __value)
{
    return __value / 2;
}

} }
# 15 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/lower_bound.h" 2 3
# 19 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/lower_bound.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 23 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/lower_bound.h" 2 3

namespace std { inline namespace __1 {

template <class _Compare, class _ForwardIterator, class _Tp>
                              _ForwardIterator
__lower_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, _Compare __comp)
{
    typedef typename iterator_traits<_ForwardIterator>::difference_type difference_type;
    difference_type __len = std::__1::distance(__first, __last);
    while (__len != 0)
    {
        difference_type __l2 = std::__1::__half_positive(__len);
        _ForwardIterator __m = __first;
        std::__1::advance(__m, __l2);
        if (__comp(*__m, __value_))
        {
            __first = ++__m;
            __len -= __l2 + 1;
        }
        else
            __len = __l2;
    }
    return __first;
}

template <class _ForwardIterator, class _Tp, class _Compare>
                      inline
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
_ForwardIterator
lower_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, _Compare __comp)
{
    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
    return std::__1::__lower_bound<_Comp_ref>(__first, __last, __value_, __comp);
}

template <class _ForwardIterator, class _Tp>
                      inline
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
_ForwardIterator
lower_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_)
{
    return std::__1::lower_bound(__first, __last, __value_,
                             __less<typename iterator_traits<_ForwardIterator>::value_type, _Tp>());
}

} }
# 15 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/binary_search.h" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/comp_ref_type.h" 1 3
# 13 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/comp_ref_type.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 1 3
# 14 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/comp_ref_type.h" 2 3
# 17 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/comp_ref_type.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 21 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/comp_ref_type.h" 2 3

namespace std { inline namespace __1 {
# 71 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/comp_ref_type.h" 3
template <class _Comp>
struct __comp_ref_type {



  typedef typename add_lvalue_reference<_Comp>::type type;



};


} }
# 16 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/binary_search.h" 2 3
# 20 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/binary_search.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 24 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/binary_search.h" 2 3

namespace std { inline namespace __1 {

template <class _Compare, class _ForwardIterator, class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
__binary_search(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, _Compare __comp)
{
    __first = std::__1::__lower_bound<_Compare>(__first, __last, __value_, __comp);
    return __first != __last && !__comp(__value_, *__first);
}

template <class _ForwardIterator, class _Tp, class _Compare>
                      inline
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
binary_search(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, _Compare __comp)
{
    typedef typename __comp_ref_type<_Compare>::type _Comp_ref;
    return std::__1::__binary_search<_Comp_ref>(__first, __last, __value_, __comp);
}

template <class _ForwardIterator, class _Tp>
                      inline
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
binary_search(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_)
{
    return std::__1::binary_search(__first, __last, __value_,
                             __less<typename iterator_traits<_ForwardIterator>::value_type, _Tp>());
}


} }
# 667 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/algorithm" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/clamp.h" 1 3
# 18 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/clamp.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 22 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/clamp.h" 2 3

namespace std { inline namespace __1 {



template<class _Tp, class _Compare>
                      inline
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
const _Tp&
clamp(const _Tp& __v, const _Tp& __lo, const _Tp& __hi, _Compare __comp)
{
    ((void)0);
    return __comp(__v, __lo) ? __lo : __comp(__hi, __v) ? __hi : __v;

}

template<class _Tp>
                      inline
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
const _Tp&
clamp(const _Tp& __v, const _Tp& __lo, const _Tp& __hi)
{
    return std::__1::clamp(__v, __lo, __hi, __less<_Tp>());
}


} }
# 668 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/algorithm" 2 3


# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/copy.h" 1 3
# 13 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/copy.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/unwrap_iter.h" 1 3
# 15 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/unwrap_iter.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 1 3
# 16 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/unwrap_iter.h" 2 3
# 19 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/unwrap_iter.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 23 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/unwrap_iter.h" 2 3

namespace std { inline namespace __1 {
# 41 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/unwrap_iter.h" 3
template <class _Iter, bool = __is_cpp17_contiguous_iterator<_Iter>::value>
struct __unwrap_iter_impl {
    static constexpr _Iter
    __apply(_Iter __i) noexcept {
        return __i;
    }
};



template <class _Iter>
struct __unwrap_iter_impl<_Iter, true> {
    static constexpr decltype(std::__1::__to_address(declval<_Iter>()))
    __apply(_Iter __i) noexcept {
        return std::__1::__to_address(__i);
    }
};



template<class _Iter, class _Impl = __unwrap_iter_impl<_Iter> >
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
decltype(_Impl::__apply(declval<_Iter>()))
__unwrap_iter(_Iter __i) noexcept
{
    return _Impl::__apply(__i);
}

template<class _OrigIter>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
_OrigIter __rewrap_iter(_OrigIter, _OrigIter __result)
{
    return __result;
}

template<class _OrigIter, class _UnwrappedIter>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
_OrigIter __rewrap_iter(_OrigIter __first, _UnwrappedIter __result)
{


    return __first + (__result - std::__1::__unwrap_iter(__first));
}

} }
# 14 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/copy.h" 2 3


# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 1 3
# 17 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/copy.h" 2 3
# 20 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/copy.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 24 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/copy.h" 2 3

namespace std { inline namespace __1 {



template <class _InputIterator, class _OutputIterator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
_OutputIterator
__copy_constexpr(_InputIterator __first, _InputIterator __last, _OutputIterator __result)
{
    for (; __first != __last; ++__first, (void) ++__result)
        *__result = *__first;
    return __result;
}

template <class _InputIterator, class _OutputIterator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
_OutputIterator
__copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result)
{
    return std::__1::__copy_constexpr(__first, __last, __result);
}

template <class _Tp, class _Up>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename enable_if
<
    is_same<typename remove_const<_Tp>::type, _Up>::value &&
    is_trivially_copy_assignable<_Up>::value,
    _Up*
>::type
__copy(_Tp* __first, _Tp* __last, _Up* __result)
{
    const size_t __n = static_cast<size_t>(__last - __first);
    if (__n > 0)
        std::__1::memmove(__result, __first, __n * sizeof(_Up));
    return __result + __n;
}

template <class _InputIterator, class _OutputIterator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
_OutputIterator
copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result)
{
    if (__libcpp_is_constant_evaluated()) {
        return std::__1::__copy_constexpr(__first, __last, __result);
    } else {
        return std::__1::__rewrap_iter(__result,
            std::__1::__copy(std::__1::__unwrap_iter(__first),
                          std::__1::__unwrap_iter(__last),
                          std::__1::__unwrap_iter(__result)));
    }
}

} }
# 671 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/algorithm" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/copy_backward.h" 1 3
# 16 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/copy_backward.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 1 3
# 17 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/copy_backward.h" 2 3
# 20 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/copy_backward.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 24 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/copy_backward.h" 2 3

namespace std { inline namespace __1 {

template <class _BidirectionalIterator, class _OutputIterator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
_OutputIterator
__copy_backward_constexpr(_BidirectionalIterator __first, _BidirectionalIterator __last, _OutputIterator __result)
{
    while (__first != __last)
        *--__result = *--__last;
    return __result;
}

template <class _BidirectionalIterator, class _OutputIterator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
_OutputIterator
__copy_backward(_BidirectionalIterator __first, _BidirectionalIterator __last, _OutputIterator __result)
{
    return std::__1::__copy_backward_constexpr(__first, __last, __result);
}

template <class _Tp, class _Up>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename enable_if
<
    is_same<typename remove_const<_Tp>::type, _Up>::value &&
    is_trivially_copy_assignable<_Up>::value,
    _Up*
>::type
__copy_backward(_Tp* __first, _Tp* __last, _Up* __result)
{
    const size_t __n = static_cast<size_t>(__last - __first);
    if (__n > 0)
    {
        __result -= __n;
        std::__1::memmove(__result, __first, __n * sizeof(_Up));
    }
    return __result;
}

template <class _BidirectionalIterator1, class _BidirectionalIterator2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
_BidirectionalIterator2
copy_backward(_BidirectionalIterator1 __first, _BidirectionalIterator1 __last,
              _BidirectionalIterator2 __result)
{
    if (__libcpp_is_constant_evaluated()) {
        return std::__1::__copy_backward_constexpr(__first, __last, __result);
    } else {
        return std::__1::__rewrap_iter(__result,
            std::__1::__copy_backward(std::__1::__unwrap_iter(__first),
                                   std::__1::__unwrap_iter(__last),
                                   std::__1::__unwrap_iter(__result)));
    }
}

} }
# 672 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/algorithm" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/copy_if.h" 1 3
# 16 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/copy_if.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 1 3
# 17 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/copy_if.h" 2 3
# 20 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/copy_if.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 24 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/copy_if.h" 2 3

namespace std { inline namespace __1 {

template<class _InputIterator, class _OutputIterator, class _Predicate>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
_OutputIterator
copy_if(_InputIterator __first, _InputIterator __last,
        _OutputIterator __result, _Predicate __pred)
{
    for (; __first != __last; ++__first)
    {
        if (__pred(*__first))
        {
            *__result = *__first;
            ++__result;
        }
    }
    return __result;
}

} }
# 673 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/algorithm" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/copy_n.h" 1 3
# 17 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/copy_n.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 1 3
# 18 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/copy_n.h" 2 3
# 21 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/copy_n.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 25 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/copy_n.h" 2 3

namespace std { inline namespace __1 {

template<class _InputIterator, class _Size, class _OutputIterator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename enable_if
<
    __is_cpp17_input_iterator<_InputIterator>::value &&
   !__is_cpp17_random_access_iterator<_InputIterator>::value,
    _OutputIterator
>::type
copy_n(_InputIterator __first, _Size __orig_n, _OutputIterator __result)
{
    typedef decltype(std::__1::__convert_to_integral(__orig_n)) _IntegralSize;
    _IntegralSize __n = __orig_n;
    if (__n > 0)
    {
        *__result = *__first;
        ++__result;
        for (--__n; __n > 0; --__n)
        {
            ++__first;
            *__result = *__first;
            ++__result;
        }
    }
    return __result;
}

template<class _InputIterator, class _Size, class _OutputIterator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename enable_if
<
    __is_cpp17_random_access_iterator<_InputIterator>::value,
    _OutputIterator
>::type
copy_n(_InputIterator __first, _Size __orig_n, _OutputIterator __result)
{
    typedef decltype(std::__1::__convert_to_integral(__orig_n)) _IntegralSize;
    _IntegralSize __n = __orig_n;
    return std::__1::copy(__first, __first + __n, __result);
}

} }
# 674 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/algorithm" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/count.h" 1 3
# 18 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/count.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 22 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/count.h" 2 3

namespace std { inline namespace __1 {

template <class _InputIterator, class _Tp>
                      inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    typename iterator_traits<_InputIterator>::difference_type
    count(_InputIterator __first, _InputIterator __last, const _Tp& __value_) {
  typename iterator_traits<_InputIterator>::difference_type __r(0);
  for (; __first != __last; ++__first)
    if (*__first == __value_)
      ++__r;
  return __r;
}

} }
# 675 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/algorithm" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/count_if.h" 1 3
# 18 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/count_if.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 22 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/count_if.h" 2 3

namespace std { inline namespace __1 {

template <class _InputIterator, class _Predicate>
                      inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    typename iterator_traits<_InputIterator>::difference_type
    count_if(_InputIterator __first, _InputIterator __last, _Predicate __pred) {
  typename iterator_traits<_InputIterator>::difference_type __r(0);
  for (; __first != __last; ++__first)
    if (__pred(*__first))
      ++__r;
  return __r;
}

} }
# 676 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/algorithm" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/equal.h" 1 3
# 20 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/equal.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 24 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/equal.h" 2 3

namespace std { inline namespace __1 {

template <class _InputIterator1, class _InputIterator2, class _BinaryPredicate>
                      inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) bool
equal(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _BinaryPredicate __pred) {
  for (; __first1 != __last1; ++__first1, (void)++__first2)
    if (!__pred(*__first1, *__first2))
      return false;
  return true;
}

template <class _InputIterator1, class _InputIterator2>
                      inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) bool
equal(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2) {
  typedef typename iterator_traits<_InputIterator1>::value_type __v1;
  typedef typename iterator_traits<_InputIterator2>::value_type __v2;
  return std::__1::equal(__first1, __last1, __first2, __equal_to<__v1, __v2>());
}


template <class _BinaryPredicate, class _InputIterator1, class _InputIterator2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) bool
__equal(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2,
        _BinaryPredicate __pred, input_iterator_tag, input_iterator_tag) {
  for (; __first1 != __last1 && __first2 != __last2; ++__first1, (void)++__first2)
    if (!__pred(*__first1, *__first2))
      return false;
  return __first1 == __last1 && __first2 == __last2;
}

template <class _BinaryPredicate, class _RandomAccessIterator1, class _RandomAccessIterator2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) bool
__equal(_RandomAccessIterator1 __first1, _RandomAccessIterator1 __last1, _RandomAccessIterator2 __first2,
        _RandomAccessIterator2 __last2, _BinaryPredicate __pred, random_access_iterator_tag,
        random_access_iterator_tag) {
  if (std::__1::distance(__first1, __last1) != std::__1::distance(__first2, __last2))
    return false;
  return std::__1::equal<_RandomAccessIterator1, _RandomAccessIterator2,
                      typename add_lvalue_reference<_BinaryPredicate>::type>(__first1, __last1, __first2, __pred);
}

template <class _InputIterator1, class _InputIterator2, class _BinaryPredicate>
                      inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) bool
equal(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2,
      _BinaryPredicate __pred) {
  return std::__1::__equal<typename add_lvalue_reference<_BinaryPredicate>::type>(
      __first1, __last1, __first2, __last2, __pred, typename iterator_traits<_InputIterator1>::iterator_category(),
      typename iterator_traits<_InputIterator2>::iterator_category());
}

template <class _InputIterator1, class _InputIterator2>
                      inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) bool
equal(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2) {
  typedef typename iterator_traits<_InputIterator1>::value_type __v1;
  typedef typename iterator_traits<_InputIterator2>::value_type __v2;
  return std::__1::__equal(__first1, __last1, __first2, __last2, __equal_to<__v1, __v2>(),
                        typename iterator_traits<_InputIterator1>::iterator_category(),
                        typename iterator_traits<_InputIterator2>::iterator_category());
}


} }
# 677 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/algorithm" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/equal_range.h" 1 3
# 17 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/equal_range.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/upper_bound.h" 1 3
# 19 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/upper_bound.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 23 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/upper_bound.h" 2 3

namespace std { inline namespace __1 {

template <class _Compare, class _ForwardIterator, class _Tp>
                              _ForwardIterator
__upper_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, _Compare __comp)
{
    typedef typename iterator_traits<_ForwardIterator>::difference_type difference_type;
    difference_type __len = std::__1::distance(__first, __last);
    while (__len != 0)
    {
        difference_type __l2 = std::__1::__half_positive(__len);
        _ForwardIterator __m = __first;
        std::__1::advance(__m, __l2);
        if (__comp(__value_, *__m))
            __len = __l2;
        else
        {
            __first = ++__m;
            __len -= __l2 + 1;
        }
    }
    return __first;
}

template <class _ForwardIterator, class _Tp, class _Compare>
                      inline
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
_ForwardIterator
upper_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, _Compare __comp)
{
    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
    return std::__1::__upper_bound<_Comp_ref>(__first, __last, __value_, __comp);
}

template <class _ForwardIterator, class _Tp>
                      inline
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
_ForwardIterator
upper_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_)
{
    return std::__1::upper_bound(__first, __last, __value_,
                             __less<_Tp, typename iterator_traits<_ForwardIterator>::value_type>());
}

} }
# 18 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/equal_range.h" 2 3
# 22 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/equal_range.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 26 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/equal_range.h" 2 3

namespace std { inline namespace __1 {

template <class _Compare, class _ForwardIterator, class _Tp>
                              pair<_ForwardIterator, _ForwardIterator>
__equal_range(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, _Compare __comp)
{
    typedef typename iterator_traits<_ForwardIterator>::difference_type difference_type;
    difference_type __len = std::__1::distance(__first, __last);
    while (__len != 0)
    {
        difference_type __l2 = std::__1::__half_positive(__len);
        _ForwardIterator __m = __first;
        std::__1::advance(__m, __l2);
        if (__comp(*__m, __value_))
        {
            __first = ++__m;
            __len -= __l2 + 1;
        }
        else if (__comp(__value_, *__m))
        {
            __last = __m;
            __len = __l2;
        }
        else
        {
            _ForwardIterator __mp1 = __m;
            return pair<_ForwardIterator, _ForwardIterator>
                   (
                      std::__1::__lower_bound<_Compare>(__first, __m, __value_, __comp),
                      std::__1::__upper_bound<_Compare>(++__mp1, __last, __value_, __comp)
                   );
        }
    }
    return pair<_ForwardIterator, _ForwardIterator>(__first, __first);
}

template <class _ForwardIterator, class _Tp, class _Compare>
                      inline
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
pair<_ForwardIterator, _ForwardIterator>
equal_range(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, _Compare __comp)
{
    typedef typename __comp_ref_type<_Compare>::type _Comp_ref;
    return std::__1::__equal_range<_Comp_ref>(__first, __last, __value_, __comp);
}

template <class _ForwardIterator, class _Tp>
                      inline
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
pair<_ForwardIterator, _ForwardIterator>
equal_range(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_)
{
    return std::__1::equal_range(__first, __last, __value_,
                             __less<typename iterator_traits<_ForwardIterator>::value_type, _Tp>());
}

} }
# 678 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/algorithm" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/fill_n.h" 1 3
# 14 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/fill_n.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 1 3
# 15 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/fill_n.h" 2 3
# 18 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/fill_n.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 22 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/fill_n.h" 2 3

namespace std { inline namespace __1 {

template <class _OutputIterator, class _Size, class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
_OutputIterator
__fill_n(_OutputIterator __first, _Size __n, const _Tp& __value_)
{
    for (; __n > 0; ++__first, (void) --__n)
        *__first = __value_;
    return __first;
}

template <class _OutputIterator, class _Size, class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
_OutputIterator
fill_n(_OutputIterator __first, _Size __n, const _Tp& __value_)
{
   return std::__1::__fill_n(__first, std::__1::__convert_to_integral(__n), __value_);
}

} }
# 679 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/algorithm" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/fill.h" 1 3
# 15 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/fill.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 1 3
# 16 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/fill.h" 2 3
# 19 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/fill.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 23 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/fill.h" 2 3

namespace std { inline namespace __1 {

template <class _ForwardIterator, class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void
__fill(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, forward_iterator_tag)
{
    for (; __first != __last; ++__first)
        *__first = __value_;
}

template <class _RandomAccessIterator, class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void
__fill(_RandomAccessIterator __first, _RandomAccessIterator __last, const _Tp& __value_, random_access_iterator_tag)
{
    std::__1::fill_n(__first, __last - __first, __value_);
}

template <class _ForwardIterator, class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void
fill(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_)
{
    std::__1::__fill(__first, __last, __value_, typename iterator_traits<_ForwardIterator>::iterator_category());
}

} }
# 680 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/algorithm" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/find.h" 1 3
# 17 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/find.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 21 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/find.h" 2 3

namespace std { inline namespace __1 {

template <class _InputIterator, class _Tp>
                      inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) _InputIterator
find(_InputIterator __first, _InputIterator __last, const _Tp& __value_) {
  for (; __first != __last; ++__first)
    if (*__first == __value_)
      break;
  return __first;
}

} }
# 681 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/algorithm" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/find_end.h" 1 3
# 16 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/find_end.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 1 3
# 17 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/find_end.h" 2 3
# 20 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/find_end.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 24 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/find_end.h" 2 3

namespace std { inline namespace __1 {

template <class _BinaryPredicate, class _ForwardIterator1, class _ForwardIterator2>
                              _ForwardIterator1 __find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
                                                           _ForwardIterator2 __first2, _ForwardIterator2 __last2,
                                                           _BinaryPredicate __pred, forward_iterator_tag,
                                                           forward_iterator_tag) {

  _ForwardIterator1 __r = __last1;
  if (__first2 == __last2)
    return __r;
  while (true) {
    while (true) {
      if (__first1 == __last1)
        return __r;
      if (__pred(*__first1, *__first2))
        break;
      ++__first1;
    }

    _ForwardIterator1 __m1 = __first1;
    _ForwardIterator2 __m2 = __first2;
    while (true) {
      if (++__m2 == __last2) {
        __r = __first1;
        ++__first1;
        break;
      }
      if (++__m1 == __last1)
        return __r;
      if (!__pred(*__m1, *__m2))
      {
        ++__first1;
        break;
      }
    }
  }
}

template <class _BinaryPredicate, class _BidirectionalIterator1, class _BidirectionalIterator2>
                              _BidirectionalIterator1 __find_end(
    _BidirectionalIterator1 __first1, _BidirectionalIterator1 __last1, _BidirectionalIterator2 __first2,
    _BidirectionalIterator2 __last2, _BinaryPredicate __pred, bidirectional_iterator_tag, bidirectional_iterator_tag) {

  if (__first2 == __last2)
    return __last1;
  _BidirectionalIterator1 __l1 = __last1;
  _BidirectionalIterator2 __l2 = __last2;
  --__l2;
  while (true) {

    while (true) {
      if (__first1 == __l1)
        return __last1;
      if (__pred(*--__l1, *__l2))
        break;
    }

    _BidirectionalIterator1 __m1 = __l1;
    _BidirectionalIterator2 __m2 = __l2;
    while (true) {
      if (__m2 == __first2)
        return __m1;
      if (__m1 == __first1)
        return __last1;
      if (!__pred(*--__m1, *--__m2))
      {
        break;
      }
    }
  }
}

template <class _BinaryPredicate, class _RandomAccessIterator1, class _RandomAccessIterator2>
constexpr _RandomAccessIterator1 __find_end(
    _RandomAccessIterator1 __first1, _RandomAccessIterator1 __last1, _RandomAccessIterator2 __first2,
    _RandomAccessIterator2 __last2, _BinaryPredicate __pred, random_access_iterator_tag, random_access_iterator_tag) {

  typename iterator_traits<_RandomAccessIterator2>::difference_type __len2 = __last2 - __first2;
  if (__len2 == 0)
    return __last1;
  typename iterator_traits<_RandomAccessIterator1>::difference_type __len1 = __last1 - __first1;
  if (__len1 < __len2)
    return __last1;
  const _RandomAccessIterator1 __s = __first1 + (__len2 - 1);
  _RandomAccessIterator1 __l1 = __last1;
  _RandomAccessIterator2 __l2 = __last2;
  --__l2;
  while (true) {
    while (true) {
      if (__s == __l1)
        return __last1;
      if (__pred(*--__l1, *__l2))
        break;
    }
    _RandomAccessIterator1 __m1 = __l1;
    _RandomAccessIterator2 __m2 = __l2;
    while (true) {
      if (__m2 == __first2)
        return __m1;

      if (!__pred(*--__m1, *--__m2)) {
        break;
      }
    }
  }
}

template <class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate>
                      inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) _ForwardIterator1
find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2, _ForwardIterator2 __last2,
         _BinaryPredicate __pred) {
  return std::__1::__find_end<typename add_lvalue_reference<_BinaryPredicate>::type>(
      __first1, __last1, __first2, __last2, __pred, typename iterator_traits<_ForwardIterator1>::iterator_category(),
      typename iterator_traits<_ForwardIterator2>::iterator_category());
}

template <class _ForwardIterator1, class _ForwardIterator2>
                      inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) _ForwardIterator1
find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2, _ForwardIterator2 __last2) {
  typedef typename iterator_traits<_ForwardIterator1>::value_type __v1;
  typedef typename iterator_traits<_ForwardIterator2>::value_type __v2;
  return std::__1::find_end(__first1, __last1, __first2, __last2, __equal_to<__v1, __v2>());
}

} }
# 682 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/algorithm" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/find_first_of.h" 1 3
# 19 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/find_first_of.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 23 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/find_first_of.h" 2 3

namespace std { inline namespace __1 {

template <class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate>
constexpr _ForwardIterator1 __find_first_of_ce(_ForwardIterator1 __first1,
                                                                   _ForwardIterator1 __last1,
                                                                   _ForwardIterator2 __first2,
                                                                   _ForwardIterator2 __last2, _BinaryPredicate __pred) {
  for (; __first1 != __last1; ++__first1)
    for (_ForwardIterator2 __j = __first2; __j != __last2; ++__j)
      if (__pred(*__first1, *__j))
        return __first1;
  return __last1;
}

template <class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate>
                      inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) _ForwardIterator1
find_first_of(_ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2,
              _ForwardIterator2 __last2, _BinaryPredicate __pred) {
  return std::__1::__find_first_of_ce(__first1, __last1, __first2, __last2, __pred);
}

template <class _ForwardIterator1, class _ForwardIterator2>
                      inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) _ForwardIterator1 find_first_of(
    _ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2, _ForwardIterator2 __last2) {
  typedef typename iterator_traits<_ForwardIterator1>::value_type __v1;
  typedef typename iterator_traits<_ForwardIterator2>::value_type __v2;
  return std::__1::__find_first_of_ce(__first1, __last1, __first2, __last2, __equal_to<__v1, __v2>());
}

} }
# 683 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/algorithm" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/find_if.h" 1 3
# 17 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/find_if.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 21 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/find_if.h" 2 3

namespace std { inline namespace __1 {

template <class _InputIterator, class _Predicate>
                      inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) _InputIterator
find_if(_InputIterator __first, _InputIterator __last, _Predicate __pred) {
  for (; __first != __last; ++__first)
    if (__pred(*__first))
      break;
  return __first;
}

} }
# 684 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/algorithm" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/find_if_not.h" 1 3
# 17 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/find_if_not.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 21 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/find_if_not.h" 2 3

namespace std { inline namespace __1 {

template <class _InputIterator, class _Predicate>
                      inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) _InputIterator
find_if_not(_InputIterator __first, _InputIterator __last, _Predicate __pred) {
  for (; __first != __last; ++__first)
    if (!__pred(*__first))
      break;
  return __first;
}

} }
# 685 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/algorithm" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/for_each.h" 1 3
# 17 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/for_each.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 21 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/for_each.h" 2 3

namespace std { inline namespace __1 {

template <class _InputIterator, class _Function>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) _Function for_each(_InputIterator __first,
                                                                                  _InputIterator __last,
                                                                                  _Function __f) {
  for (; __first != __last; ++__first)
    __f(*__first);
  return __f;
}

} }
# 686 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/algorithm" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/for_each_n.h" 1 3
# 14 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/for_each_n.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 1 3
# 15 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/for_each_n.h" 2 3
# 18 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/for_each_n.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 22 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/for_each_n.h" 2 3

namespace std { inline namespace __1 {



template <class _InputIterator, class _Size, class _Function>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) _InputIterator for_each_n(_InputIterator __first,
                                                                                         _Size __orig_n,
                                                                                         _Function __f) {
  typedef decltype(std::__1::__convert_to_integral(__orig_n)) _IntegralSize;
  _IntegralSize __n = __orig_n;
  while (__n > 0) {
    __f(*__first);
    ++__first;
    --__n;
  }
  return __first;
}



} }
# 687 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/algorithm" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/generate_n.h" 1 3
# 13 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/generate_n.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 1 3
# 14 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/generate_n.h" 2 3
# 17 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/generate_n.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 21 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/generate_n.h" 2 3

namespace std { inline namespace __1 {

template <class _OutputIterator, class _Size, class _Generator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
_OutputIterator
generate_n(_OutputIterator __first, _Size __orig_n, _Generator __gen)
{
    typedef decltype(std::__1::__convert_to_integral(__orig_n)) _IntegralSize;
    _IntegralSize __n = __orig_n;
    for (; __n > 0; ++__first, (void) --__n)
        *__first = __gen();
    return __first;
}

} }
# 688 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/algorithm" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/generate.h" 1 3
# 16 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/generate.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 20 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/generate.h" 2 3

namespace std { inline namespace __1 {

template <class _ForwardIterator, class _Generator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void
generate(_ForwardIterator __first, _ForwardIterator __last, _Generator __gen)
{
    for (; __first != __last; ++__first)
        *__first = __gen();
}

} }
# 689 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/algorithm" 2 3

# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/includes.h" 1 3
# 19 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/includes.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 23 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/includes.h" 2 3

namespace std { inline namespace __1 {

template <class _Compare, class _InputIterator1, class _InputIterator2>
                              bool
__includes(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2,
           _Compare __comp)
{
    for (; __first2 != __last2; ++__first1)
    {
        if (__first1 == __last1 || __comp(*__first2, *__first1))
            return false;
        if (!__comp(*__first1, *__first2))
            ++__first2;
    }
    return true;
}

template <class _InputIterator1, class _InputIterator2, class _Compare>
                      inline
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
includes(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2,
         _Compare __comp)
{
    typedef typename __comp_ref_type<_Compare>::type _Comp_ref;
    return std::__1::__includes<_Comp_ref>(__first1, __last1, __first2, __last2, __comp);
}

template <class _InputIterator1, class _InputIterator2>
                      inline
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
includes(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2)
{
    return std::__1::includes(__first1, __last1, __first2, __last2,
                          __less<typename iterator_traits<_InputIterator1>::value_type,
                                 typename iterator_traits<_InputIterator2>::value_type>());
}

} }
# 691 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/algorithm" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/inplace_merge.h" 1 3
# 16 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/inplace_merge.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/min.h" 1 3
# 14 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/min.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/min_element.h" 1 3
# 18 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/min_element.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 22 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/min_element.h" 2 3

namespace std { inline namespace __1 {

template <class _ForwardIterator, class _Compare>
                      inline
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
_ForwardIterator
min_element(_ForwardIterator __first, _ForwardIterator __last, _Compare __comp)
{
    static_assert(__is_cpp17_forward_iterator<_ForwardIterator>::value,
        "std::min_element requires a ForwardIterator");
    if (__first != __last)
    {
        _ForwardIterator __i = __first;
        while (++__i != __last)
            if (__comp(*__i, *__first))
                __first = __i;
    }
    return __first;
}

template <class _ForwardIterator>
                      inline
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
_ForwardIterator
min_element(_ForwardIterator __first, _ForwardIterator __last)
{
    return std::__1::min_element(__first, __last,
              __less<typename iterator_traits<_ForwardIterator>::value_type>());
}

} }
# 15 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/min.h" 2 3
# 19 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/min.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 23 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/min.h" 2 3

namespace std { inline namespace __1 {

template <class _Tp, class _Compare>
                      inline
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
const _Tp&
min(const _Tp& __a, const _Tp& __b, _Compare __comp)
{
    return __comp(__b, __a) ? __b : __a;
}

template <class _Tp>
                      inline
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
const _Tp&
min(const _Tp& __a, const _Tp& __b)
{
    return std::__1::min(__a, __b, __less<_Tp>());
}



template<class _Tp, class _Compare>
                      inline
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
_Tp
min(initializer_list<_Tp> __t, _Compare __comp)
{
    return *std::__1::min_element(__t.begin(), __t.end(), __comp);
}

template<class _Tp>
                      inline
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
_Tp
min(initializer_list<_Tp> __t)
{
    return *std::__1::min_element(__t.begin(), __t.end(), __less<_Tp>());
}



} }
# 17 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/inplace_merge.h" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/move.h" 1 3
# 17 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/move.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 1 3
# 18 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/move.h" 2 3
# 21 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/move.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 25 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/move.h" 2 3

namespace std { inline namespace __1 {



template <class _InputIterator, class _OutputIterator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
_OutputIterator
__move_constexpr(_InputIterator __first, _InputIterator __last, _OutputIterator __result)
{
    for (; __first != __last; ++__first, (void) ++__result)
        *__result = std::__1::move(*__first);
    return __result;
}

template <class _InputIterator, class _OutputIterator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
_OutputIterator
__move(_InputIterator __first, _InputIterator __last, _OutputIterator __result)
{
    return std::__1::__move_constexpr(__first, __last, __result);
}

template <class _Tp, class _Up>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
typename enable_if
<
    is_same<typename remove_const<_Tp>::type, _Up>::value &&
    is_trivially_move_assignable<_Up>::value,
    _Up*
>::type
__move(_Tp* __first, _Tp* __last, _Up* __result)
{
    const size_t __n = static_cast<size_t>(__last - __first);
    if (__n > 0)
        std::__1::memmove(__result, __first, __n * sizeof(_Up));
    return __result + __n;
}

template <class _InputIterator, class _OutputIterator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
_OutputIterator
move(_InputIterator __first, _InputIterator __last, _OutputIterator __result)
{
    if (__libcpp_is_constant_evaluated()) {
        return std::__1::__move_constexpr(__first, __last, __result);
    } else {
        return std::__1::__rewrap_iter(__result,
            std::__1::__move(std::__1::__unwrap_iter(__first),
                          std::__1::__unwrap_iter(__last),
                          std::__1::__unwrap_iter(__result)));
    }
}

} }
# 18 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/inplace_merge.h" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/rotate.h" 1 3
# 13 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/rotate.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/move_backward.h" 1 3
# 16 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/move_backward.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 1 3
# 17 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/move_backward.h" 2 3
# 20 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/move_backward.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 24 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/move_backward.h" 2 3

namespace std { inline namespace __1 {

template <class _InputIterator, class _OutputIterator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
_OutputIterator
__move_backward_constexpr(_InputIterator __first, _InputIterator __last, _OutputIterator __result)
{
    while (__first != __last)
        *--__result = std::__1::move(*--__last);
    return __result;
}

template <class _InputIterator, class _OutputIterator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
_OutputIterator
__move_backward(_InputIterator __first, _InputIterator __last, _OutputIterator __result)
{
    return std::__1::__move_backward_constexpr(__first, __last, __result);
}

template <class _Tp, class _Up>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
typename enable_if
<
    is_same<typename remove_const<_Tp>::type, _Up>::value &&
    is_trivially_move_assignable<_Up>::value,
    _Up*
>::type
__move_backward(_Tp* __first, _Tp* __last, _Up* __result)
{
    const size_t __n = static_cast<size_t>(__last - __first);
    if (__n > 0)
    {
        __result -= __n;
        std::__1::memmove(__result, __first, __n * sizeof(_Up));
    }
    return __result;
}

template <class _BidirectionalIterator1, class _BidirectionalIterator2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
_BidirectionalIterator2
move_backward(_BidirectionalIterator1 __first, _BidirectionalIterator1 __last,
              _BidirectionalIterator2 __result)
{
    if (__libcpp_is_constant_evaluated()) {
        return std::__1::__move_backward_constexpr(__first, __last, __result);
    } else {
        return std::__1::__rewrap_iter(__result,
            std::__1::__move_backward(std::__1::__unwrap_iter(__first),
                                   std::__1::__unwrap_iter(__last),
                                   std::__1::__unwrap_iter(__result)));
    }
}

} }
# 14 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/rotate.h" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/swap_ranges.h" 1 3
# 14 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/swap_ranges.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 1 3
# 15 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/swap_ranges.h" 2 3
# 18 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/swap_ranges.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 22 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/swap_ranges.h" 2 3

namespace std { inline namespace __1 {

template <class _ForwardIterator1, class _ForwardIterator2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) _ForwardIterator2
swap_ranges(_ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2) {
  for (; __first1 != __last1; ++__first1, (void)++__first2)
    swap(*__first1, *__first2);
  return __first2;
}

} }
# 15 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/rotate.h" 2 3
# 24 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/rotate.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 28 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/rotate.h" 2 3

namespace std { inline namespace __1 {

template <class _ForwardIterator>
constexpr _ForwardIterator
__rotate_left(_ForwardIterator __first, _ForwardIterator __last)
{
    typedef typename iterator_traits<_ForwardIterator>::value_type value_type;
    value_type __tmp = std::__1::move(*__first);
    _ForwardIterator __lm1 = std::__1::move(std::__1::next(__first), __last, __first);
    *__lm1 = std::__1::move(__tmp);
    return __lm1;
}

template <class _BidirectionalIterator>
constexpr _BidirectionalIterator
__rotate_right(_BidirectionalIterator __first, _BidirectionalIterator __last)
{
    typedef typename iterator_traits<_BidirectionalIterator>::value_type value_type;
    _BidirectionalIterator __lm1 = std::__1::prev(__last);
    value_type __tmp = std::__1::move(*__lm1);
    _BidirectionalIterator __fp1 = std::__1::move_backward(__first, __lm1, __last);
    *__first = std::__1::move(__tmp);
    return __fp1;
}

template <class _ForwardIterator>
constexpr _ForwardIterator
__rotate_forward(_ForwardIterator __first, _ForwardIterator __middle, _ForwardIterator __last)
{
    _ForwardIterator __i = __middle;
    while (true)
    {
        swap(*__first, *__i);
        ++__first;
        if (++__i == __last)
            break;
        if (__first == __middle)
            __middle = __i;
    }
    _ForwardIterator __r = __first;
    if (__first != __middle)
    {
        __i = __middle;
        while (true)
        {
            swap(*__first, *__i);
            ++__first;
            if (++__i == __last)
            {
                if (__first == __middle)
                    break;
                __i = __middle;
            }
            else if (__first == __middle)
                __middle = __i;
        }
    }
    return __r;
}

template<typename _Integral>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
constexpr _Integral
__algo_gcd(_Integral __x, _Integral __y)
{
    do
    {
        _Integral __t = __x % __y;
        __x = __y;
        __y = __t;
    } while (__y);
    return __x;
}

template<typename _RandomAccessIterator>
constexpr _RandomAccessIterator
__rotate_gcd(_RandomAccessIterator __first, _RandomAccessIterator __middle, _RandomAccessIterator __last)
{
    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;
    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;

    const difference_type __m1 = __middle - __first;
    const difference_type __m2 = __last - __middle;
    if (__m1 == __m2)
    {
        std::__1::swap_ranges(__first, __middle, __middle);
        return __middle;
    }
    const difference_type __g = std::__1::__algo_gcd(__m1, __m2);
    for (_RandomAccessIterator __p = __first + __g; __p != __first;)
    {
        value_type __t(std::__1::move(*--__p));
        _RandomAccessIterator __p1 = __p;
        _RandomAccessIterator __p2 = __p1 + __m1;
        do
        {
            *__p1 = std::__1::move(*__p2);
            __p1 = __p2;
            const difference_type __d = __last - __p2;
            if (__m1 < __d)
                __p2 += __m1;
            else
                __p2 = __first + (__m1 - __d);
        } while (__p2 != __p);
        *__p1 = std::__1::move(__t);
    }
    return __first + __m2;
}

template <class _ForwardIterator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
constexpr _ForwardIterator
__rotate(_ForwardIterator __first, _ForwardIterator __middle, _ForwardIterator __last,
         std::__1::forward_iterator_tag)
{
    typedef typename iterator_traits<_ForwardIterator>::value_type value_type;
    if (is_trivially_move_assignable<value_type>::value)
    {
        if (std::__1::next(__first) == __middle)
            return std::__1::__rotate_left(__first, __last);
    }
    return std::__1::__rotate_forward(__first, __middle, __last);
}

template <class _BidirectionalIterator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
constexpr _BidirectionalIterator
__rotate(_BidirectionalIterator __first, _BidirectionalIterator __middle, _BidirectionalIterator __last,
         bidirectional_iterator_tag)
{
    typedef typename iterator_traits<_BidirectionalIterator>::value_type value_type;
    if (is_trivially_move_assignable<value_type>::value)
    {
        if (std::__1::next(__first) == __middle)
            return std::__1::__rotate_left(__first, __last);
        if (std::__1::next(__middle) == __last)
            return std::__1::__rotate_right(__first, __last);
    }
    return std::__1::__rotate_forward(__first, __middle, __last);
}

template <class _RandomAccessIterator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
constexpr _RandomAccessIterator
__rotate(_RandomAccessIterator __first, _RandomAccessIterator __middle, _RandomAccessIterator __last,
         random_access_iterator_tag)
{
    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;
    if (is_trivially_move_assignable<value_type>::value)
    {
        if (std::__1::next(__first) == __middle)
            return std::__1::__rotate_left(__first, __last);
        if (std::__1::next(__middle) == __last)
            return std::__1::__rotate_right(__first, __last);
        return std::__1::__rotate_gcd(__first, __middle, __last);
    }
    return std::__1::__rotate_forward(__first, __middle, __last);
}

template <class _ForwardIterator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
                              _ForwardIterator
rotate(_ForwardIterator __first, _ForwardIterator __middle, _ForwardIterator __last)
{
    if (__first == __middle)
        return __last;
    if (__middle == __last)
        return __first;
    return std::__1::__rotate(__first, __middle, __last,
                           typename iterator_traits<_ForwardIterator>::iterator_category());
}

} }
# 19 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/inplace_merge.h" 2 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/memory" 1 3
# 974 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/memory" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 1 3
# 20 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/assert.h" 1 3 4
# 44 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/assert.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/stdlib.h" 1 3 4
# 45 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/assert.h" 2 3 4
# 81 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/assert.h" 3 4
extern "C" {
void __assert_rtn(const char *, const char *, int, const char *) __attribute__((__noreturn__)) __attribute__((__cold__)) __attribute__((__disable_tail_calls__));



}
# 21 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 2 3
# 24 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 3
# 975 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/memory" 2 3
# 23 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/inplace_merge.h" 2 3
# 26 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/inplace_merge.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 30 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/inplace_merge.h" 2 3

namespace std { inline namespace __1 {

template <class _Predicate>
class __invert
{
private:
    _Predicate __p_;
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) __invert() {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit __invert(_Predicate __p) : __p_(__p) {}

    template <class _T1>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    bool operator()(const _T1& __x) {return !__p_(__x);}

    template <class _T1, class _T2>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    bool operator()(const _T1& __x, const _T2& __y) {return __p_(__y, __x);}
};

template <class _Compare, class _InputIterator1, class _InputIterator2,
          class _OutputIterator>
void __half_inplace_merge(_InputIterator1 __first1, _InputIterator1 __last1,
                          _InputIterator2 __first2, _InputIterator2 __last2,
                          _OutputIterator __result, _Compare __comp)
{
    for (; __first1 != __last1; ++__result)
    {
        if (__first2 == __last2)
        {
            std::__1::move(__first1, __last1, __result);
            return;
        }

        if (__comp(*__first2, *__first1))
        {
            *__result = std::__1::move(*__first2);
            ++__first2;
        }
        else
        {
            *__result = std::__1::move(*__first1);
            ++__first1;
        }
    }

}

template <class _Compare, class _BidirectionalIterator>
void
__buffered_inplace_merge(_BidirectionalIterator __first, _BidirectionalIterator __middle, _BidirectionalIterator __last,
                _Compare __comp, typename iterator_traits<_BidirectionalIterator>::difference_type __len1,
                                 typename iterator_traits<_BidirectionalIterator>::difference_type __len2,
                typename iterator_traits<_BidirectionalIterator>::value_type* __buff)
{
    typedef typename iterator_traits<_BidirectionalIterator>::value_type value_type;
    __destruct_n __d(0);
    unique_ptr<value_type, __destruct_n&> __h2(__buff, __d);
    if (__len1 <= __len2)
    {
        value_type* __p = __buff;
        for (_BidirectionalIterator __i = __first; __i != __middle; __d.template __incr<value_type>(), (void) ++__i, (void) ++__p)
            ::new ((void*)__p) value_type(std::__1::move(*__i));
        std::__1::__half_inplace_merge<_Compare>(__buff, __p, __middle, __last, __first, __comp);
    }
    else
    {
        value_type* __p = __buff;
        for (_BidirectionalIterator __i = __middle; __i != __last; __d.template __incr<value_type>(), (void) ++__i, (void) ++__p)
            ::new ((void*)__p) value_type(std::__1::move(*__i));
        typedef reverse_iterator<_BidirectionalIterator> _RBi;
        typedef reverse_iterator<value_type*> _Rv;
        typedef __invert<_Compare> _Inverted;
        std::__1::__half_inplace_merge<_Inverted>(_Rv(__p), _Rv(__buff),
                                    _RBi(__middle), _RBi(__first),
                                    _RBi(__last), _Inverted(__comp));
    }
}

template <class _Compare, class _BidirectionalIterator>
void
__inplace_merge(_BidirectionalIterator __first, _BidirectionalIterator __middle, _BidirectionalIterator __last,
                _Compare __comp, typename iterator_traits<_BidirectionalIterator>::difference_type __len1,
                                 typename iterator_traits<_BidirectionalIterator>::difference_type __len2,
                typename iterator_traits<_BidirectionalIterator>::value_type* __buff, ptrdiff_t __buff_size)
{
    typedef typename iterator_traits<_BidirectionalIterator>::difference_type difference_type;
    while (true)
    {

        if (__len2 == 0)
            return;
        if (__len1 <= __buff_size || __len2 <= __buff_size)
            return std::__1::__buffered_inplace_merge<_Compare>
                   (__first, __middle, __last, __comp, __len1, __len2, __buff);

        for (; true; ++__first, (void) --__len1)
        {
            if (__len1 == 0)
                return;
            if (__comp(*__middle, *__first))
                break;
        }
# 144 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/inplace_merge.h" 3
        _BidirectionalIterator __m1;
        _BidirectionalIterator __m2;
        difference_type __len11;
        difference_type __len21;

        if (__len1 < __len2)
        {
            __len21 = __len2 / 2;
            __m2 = __middle;
            std::__1::advance(__m2, __len21);
            __m1 = std::__1::__upper_bound<_Compare>(__first, __middle, *__m2, __comp);
            __len11 = std::__1::distance(__first, __m1);
        }
        else
        {
            if (__len1 == 1)
            {

                swap(*__first, *__middle);
                return;
            }

            __len11 = __len1 / 2;
            __m1 = __first;
            std::__1::advance(__m1, __len11);
            __m2 = std::__1::__lower_bound<_Compare>(__middle, __last, *__m1, __comp);
            __len21 = std::__1::distance(__middle, __m2);
        }
        difference_type __len12 = __len1 - __len11;
        difference_type __len22 = __len2 - __len21;


        __middle = std::__1::rotate(__m1, __middle, __m2);


        if (__len11 + __len21 < __len12 + __len22)
        {
            std::__1::__inplace_merge<_Compare>(__first, __m1, __middle, __comp, __len11, __len21, __buff, __buff_size);

            __first = __middle;
            __middle = __m2;
            __len1 = __len12;
            __len2 = __len22;
        }
        else
        {
            std::__1::__inplace_merge<_Compare>(__middle, __m2, __last, __comp, __len12, __len22, __buff, __buff_size);

            __last = __middle;
            __middle = __m1;
            __len1 = __len11;
            __len2 = __len21;
        }
    }
}

template <class _BidirectionalIterator, class _Compare>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void
inplace_merge(_BidirectionalIterator __first, _BidirectionalIterator __middle, _BidirectionalIterator __last,
              _Compare __comp)
{
    typedef typename iterator_traits<_BidirectionalIterator>::value_type value_type;
    typedef typename iterator_traits<_BidirectionalIterator>::difference_type difference_type;
    difference_type __len1 = std::__1::distance(__first, __middle);
    difference_type __len2 = std::__1::distance(__middle, __last);
    difference_type __buf_size = std::__1::min(__len1, __len2);
    pair<value_type*, ptrdiff_t> __buf = std::__1::get_temporary_buffer<value_type>(__buf_size);
    unique_ptr<value_type, __return_temporary_buffer> __h(__buf.first);
    typedef typename __comp_ref_type<_Compare>::type _Comp_ref;
    return std::__1::__inplace_merge<_Comp_ref>(__first, __middle, __last, __comp, __len1, __len2,
                                            __buf.first, __buf.second);
}

template <class _BidirectionalIterator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void
inplace_merge(_BidirectionalIterator __first, _BidirectionalIterator __middle, _BidirectionalIterator __last)
{
    std::__1::inplace_merge(__first, __middle, __last,
                        __less<typename iterator_traits<_BidirectionalIterator>::value_type>());
}

} }
# 692 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/algorithm" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/is_heap.h" 1 3
# 14 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/is_heap.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/is_heap_until.h" 1 3
# 18 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/is_heap_until.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 22 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/is_heap_until.h" 2 3

namespace std { inline namespace __1 {

template <class _RandomAccessIterator, class _Compare>
                                                    _RandomAccessIterator
is_heap_until(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)
{
    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;
    difference_type __len = __last - __first;
    difference_type __p = 0;
    difference_type __c = 1;
    _RandomAccessIterator __pp = __first;
    while (__c < __len)
    {
        _RandomAccessIterator __cp = __first + __c;
        if (__comp(*__pp, *__cp))
            return __cp;
        ++__c;
        ++__cp;
        if (__c == __len)
            return __last;
        if (__comp(*__pp, *__cp))
            return __cp;
        ++__p;
        ++__pp;
        __c = 2 * __p + 1;
    }
    return __last;
}

template<class _RandomAccessIterator>
                      inline
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
_RandomAccessIterator
is_heap_until(_RandomAccessIterator __first, _RandomAccessIterator __last)
{
    return std::__1::is_heap_until(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());
}

} }
# 15 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/is_heap.h" 2 3
# 19 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/is_heap.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 23 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/is_heap.h" 2 3

namespace std { inline namespace __1 {

template <class _RandomAccessIterator, class _Compare>
                      inline
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
is_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)
{
    return std::__1::is_heap_until(__first, __last, __comp) == __last;
}

template<class _RandomAccessIterator>
                      inline
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
is_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
{
    return std::__1::is_heap(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());
}

} }
# 693 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/algorithm" 2 3

# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/is_partitioned.h" 1 3
# 16 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/is_partitioned.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 20 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/is_partitioned.h" 2 3

namespace std { inline namespace __1 {

template <class _InputIterator, class _Predicate>
                                                    bool
is_partitioned(_InputIterator __first, _InputIterator __last, _Predicate __pred)
{
    for (; __first != __last; ++__first)
        if (!__pred(*__first))
            break;
    if ( __first == __last )
        return true;
    ++__first;
    for (; __first != __last; ++__first)
        if (__pred(*__first))
            return false;
    return true;
}

} }
# 695 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/algorithm" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/is_permutation.h" 1 3
# 21 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/is_permutation.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 25 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/is_permutation.h" 2 3

namespace std { inline namespace __1 {

template <class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate>
                                                    bool
is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2,
               _BinaryPredicate __pred) {

  for (; __first1 != __last1; ++__first1, (void)++__first2)
    if (!__pred(*__first1, *__first2))
      break;
  if (__first1 == __last1)
    return true;


  typedef typename iterator_traits<_ForwardIterator1>::difference_type _D1;
  _D1 __l1 = std::__1::distance(__first1, __last1);
  if (__l1 == _D1(1))
    return false;
  _ForwardIterator2 __last2 = std::__1::next(__first2, __l1);


  for (_ForwardIterator1 __i = __first1; __i != __last1; ++__i) {

    _ForwardIterator1 __match = __first1;
    for (; __match != __i; ++__match)
      if (__pred(*__match, *__i))
        break;
    if (__match == __i) {

      _D1 __c2 = 0;
      for (_ForwardIterator2 __j = __first2; __j != __last2; ++__j)
        if (__pred(*__i, *__j))
          ++__c2;
      if (__c2 == 0)
        return false;

      _D1 __c1 = 1;
      for (_ForwardIterator1 __j = std::__1::next(__i); __j != __last1; ++__j)
        if (__pred(*__i, *__j))
          ++__c1;
      if (__c1 != __c2)
        return false;
    }
  }
  return true;
}

template <class _ForwardIterator1, class _ForwardIterator2>
                      inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) bool
is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2) {
  typedef typename iterator_traits<_ForwardIterator1>::value_type __v1;
  typedef typename iterator_traits<_ForwardIterator2>::value_type __v2;
  return std::__1::is_permutation(__first1, __last1, __first2, __equal_to<__v1, __v2>());
}


template <class _BinaryPredicate, class _ForwardIterator1, class _ForwardIterator2>
                              bool
__is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2,
                 _ForwardIterator2 __last2, _BinaryPredicate __pred, forward_iterator_tag, forward_iterator_tag) {

  for (; __first1 != __last1 && __first2 != __last2; ++__first1, (void)++__first2)
    if (!__pred(*__first1, *__first2))
      break;
  if (__first1 == __last1)
    return __first2 == __last2;
  else if (__first2 == __last2)
    return false;

  typedef typename iterator_traits<_ForwardIterator1>::difference_type _D1;
  _D1 __l1 = std::__1::distance(__first1, __last1);

  typedef typename iterator_traits<_ForwardIterator2>::difference_type _D2;
  _D2 __l2 = std::__1::distance(__first2, __last2);
  if (__l1 != __l2)
    return false;



  for (_ForwardIterator1 __i = __first1; __i != __last1; ++__i) {

    _ForwardIterator1 __match = __first1;
    for (; __match != __i; ++__match)
      if (__pred(*__match, *__i))
        break;
    if (__match == __i) {

      _D1 __c2 = 0;
      for (_ForwardIterator2 __j = __first2; __j != __last2; ++__j)
        if (__pred(*__i, *__j))
          ++__c2;
      if (__c2 == 0)
        return false;

      _D1 __c1 = 1;
      for (_ForwardIterator1 __j = std::__1::next(__i); __j != __last1; ++__j)
        if (__pred(*__i, *__j))
          ++__c1;
      if (__c1 != __c2)
        return false;
    }
  }
  return true;
}

template <class _BinaryPredicate, class _RandomAccessIterator1, class _RandomAccessIterator2>
                              bool __is_permutation(_RandomAccessIterator1 __first1, _RandomAccessIterator2 __last1,
                                                    _RandomAccessIterator1 __first2, _RandomAccessIterator2 __last2,
                                                    _BinaryPredicate __pred, random_access_iterator_tag,
                                                    random_access_iterator_tag) {
  if (std::__1::distance(__first1, __last1) != std::__1::distance(__first2, __last2))
    return false;
  return std::__1::is_permutation<_RandomAccessIterator1, _RandomAccessIterator2,
                               typename add_lvalue_reference<_BinaryPredicate>::type>(__first1, __last1, __first2,
                                                                                      __pred);
}

template <class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate>
                      inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) bool
is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2,
               _ForwardIterator2 __last2, _BinaryPredicate __pred) {
  return std::__1::__is_permutation<typename add_lvalue_reference<_BinaryPredicate>::type>(
      __first1, __last1, __first2, __last2, __pred, typename iterator_traits<_ForwardIterator1>::iterator_category(),
      typename iterator_traits<_ForwardIterator2>::iterator_category());
}

template <class _ForwardIterator1, class _ForwardIterator2>
                      inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) bool
is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2,
               _ForwardIterator2 __last2) {
  typedef typename iterator_traits<_ForwardIterator1>::value_type __v1;
  typedef typename iterator_traits<_ForwardIterator2>::value_type __v2;
  return std::__1::__is_permutation(__first1, __last1, __first2, __last2, __equal_to<__v1, __v2>(),
                                 typename iterator_traits<_ForwardIterator1>::iterator_category(),
                                 typename iterator_traits<_ForwardIterator2>::iterator_category());
}


} }
# 696 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/algorithm" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/is_sorted.h" 1 3
# 13 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/is_sorted.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/is_sorted_until.h" 1 3
# 18 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/is_sorted_until.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 22 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/is_sorted_until.h" 2 3

namespace std { inline namespace __1 {

template <class _ForwardIterator, class _Compare>
                                                    _ForwardIterator
is_sorted_until(_ForwardIterator __first, _ForwardIterator __last, _Compare __comp)
{
    if (__first != __last)
    {
        _ForwardIterator __i = __first;
        while (++__i != __last)
        {
            if (__comp(*__i, *__first))
                return __i;
            __first = __i;
        }
    }
    return __last;
}

template<class _ForwardIterator>
                      inline
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
_ForwardIterator
is_sorted_until(_ForwardIterator __first, _ForwardIterator __last)
{
    return std::__1::is_sorted_until(__first, __last, __less<typename iterator_traits<_ForwardIterator>::value_type>());
}

} }
# 14 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/is_sorted.h" 2 3
# 19 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/is_sorted.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 23 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/is_sorted.h" 2 3

namespace std { inline namespace __1 {

template <class _ForwardIterator, class _Compare>
                      inline
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
is_sorted(_ForwardIterator __first, _ForwardIterator __last, _Compare __comp)
{
    return std::__1::is_sorted_until(__first, __last, __comp) == __last;
}

template<class _ForwardIterator>
                      inline
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
is_sorted(_ForwardIterator __first, _ForwardIterator __last)
{
    return std::__1::is_sorted(__first, __last, __less<typename iterator_traits<_ForwardIterator>::value_type>());
}

} }
# 697 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/algorithm" 2 3

# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/iter_swap.h" 1 3
# 18 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/iter_swap.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 22 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/iter_swap.h" 2 3

namespace std { inline namespace __1 {

template <class _ForwardIterator1, class _ForwardIterator2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) void iter_swap(_ForwardIterator1 __a,
                                                                              _ForwardIterator2 __b)

    noexcept(noexcept(swap(*declval<_ForwardIterator1>(), *declval<_ForwardIterator2>()))) {
  swap(*__a, *__b);
}

} }
# 699 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/algorithm" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/lexicographical_compare.h" 1 3
# 19 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/lexicographical_compare.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 23 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/lexicographical_compare.h" 2 3

namespace std { inline namespace __1 {

template <class _Compare, class _InputIterator1, class _InputIterator2>
                              bool
__lexicographical_compare(_InputIterator1 __first1, _InputIterator1 __last1,
                          _InputIterator2 __first2, _InputIterator2 __last2, _Compare __comp)
{
    for (; __first2 != __last2; ++__first1, (void) ++__first2)
    {
        if (__first1 == __last1 || __comp(*__first1, *__first2))
            return true;
        if (__comp(*__first2, *__first1))
            return false;
    }
    return false;
}

template <class _InputIterator1, class _InputIterator2, class _Compare>
                      inline
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
lexicographical_compare(_InputIterator1 __first1, _InputIterator1 __last1,
                        _InputIterator2 __first2, _InputIterator2 __last2, _Compare __comp)
{
    typedef typename __comp_ref_type<_Compare>::type _Comp_ref;
    return std::__1::__lexicographical_compare<_Comp_ref>(__first1, __last1, __first2, __last2, __comp);
}

template <class _InputIterator1, class _InputIterator2>
                      inline
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
lexicographical_compare(_InputIterator1 __first1, _InputIterator1 __last1,
                        _InputIterator2 __first2, _InputIterator2 __last2)
{
    return std::__1::lexicographical_compare(__first1, __last1, __first2, __last2,
                                         __less<typename iterator_traits<_InputIterator1>::value_type,
                                                typename iterator_traits<_InputIterator2>::value_type>());
}

} }
# 700 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/algorithm" 2 3

# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/make_heap.h" 1 3
# 15 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/make_heap.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/sift_down.h" 1 3
# 18 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/sift_down.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 22 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/sift_down.h" 2 3

namespace std { inline namespace __1 {

template <class _Compare, class _RandomAccessIterator>
constexpr void
__sift_down(_RandomAccessIterator __first, _RandomAccessIterator ,
            _Compare __comp,
            typename iterator_traits<_RandomAccessIterator>::difference_type __len,
            _RandomAccessIterator __start)
{
    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;
    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;


    difference_type __child = __start - __first;

    if (__len < 2 || (__len - 2) / 2 < __child)
        return;

    __child = 2 * __child + 1;
    _RandomAccessIterator __child_i = __first + __child;

    if ((__child + 1) < __len && __comp(*__child_i, *(__child_i + 1))) {

        ++__child_i;
        ++__child;
    }


    if (__comp(*__child_i, *__start))

        return;

    value_type __top(std::__1::move(*__start));
    do
    {

        *__start = std::__1::move(*__child_i);
        __start = __child_i;

        if ((__len - 2) / 2 < __child)
            break;


        __child = 2 * __child + 1;
        __child_i = __first + __child;

        if ((__child + 1) < __len && __comp(*__child_i, *(__child_i + 1))) {

            ++__child_i;
            ++__child;
        }


    } while (!__comp(*__child_i, __top));
    *__start = std::__1::move(__top);
}

} }
# 16 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/make_heap.h" 2 3
# 20 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/make_heap.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 24 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/make_heap.h" 2 3

namespace std { inline namespace __1 {

template <class _Compare, class _RandomAccessIterator>
constexpr void
__make_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)
{
    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;
    difference_type __n = __last - __first;
    if (__n > 1)
    {

        for (difference_type __start = (__n - 2) / 2; __start >= 0; --__start)
        {
            std::__1::__sift_down<_Compare>(__first, __last, __comp, __n, __first + __start);
        }
    }
}

template <class _RandomAccessIterator, class _Compare>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void
make_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)
{
    typedef typename __comp_ref_type<_Compare>::type _Comp_ref;
    std::__1::__make_heap<_Comp_ref>(__first, __last, __comp);
}

template <class _RandomAccessIterator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void
make_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
{
    std::__1::make_heap(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());
}

} }
# 702 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/algorithm" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/max.h" 1 3
# 14 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/max.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/max_element.h" 1 3
# 18 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/max_element.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 22 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/max_element.h" 2 3

namespace std { inline namespace __1 {

template <class _ForwardIterator, class _Compare>
                      inline
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
_ForwardIterator
max_element(_ForwardIterator __first, _ForwardIterator __last, _Compare __comp)
{
    static_assert(__is_cpp17_forward_iterator<_ForwardIterator>::value,
        "std::max_element requires a ForwardIterator");
    if (__first != __last)
    {
        _ForwardIterator __i = __first;
        while (++__i != __last)
            if (__comp(*__first, *__i))
                __first = __i;
    }
    return __first;
}


template <class _ForwardIterator>
                      inline
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
_ForwardIterator
max_element(_ForwardIterator __first, _ForwardIterator __last)
{
    return std::__1::max_element(__first, __last,
              __less<typename iterator_traits<_ForwardIterator>::value_type>());
}

} }
# 15 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/max.h" 2 3
# 19 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/max.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 23 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/max.h" 2 3

namespace std { inline namespace __1 {

template <class _Tp, class _Compare>
                      inline
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
const _Tp&
max(const _Tp& __a, const _Tp& __b, _Compare __comp)
{
    return __comp(__a, __b) ? __b : __a;
}

template <class _Tp>
                      inline
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
const _Tp&
max(const _Tp& __a, const _Tp& __b)
{
    return std::__1::max(__a, __b, __less<_Tp>());
}



template<class _Tp, class _Compare>
                      inline
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
_Tp
max(initializer_list<_Tp> __t, _Compare __comp)
{
    return *std::__1::max_element(__t.begin(), __t.end(), __comp);
}

template<class _Tp>
                      inline
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
_Tp
max(initializer_list<_Tp> __t)
{
    return *std::__1::max_element(__t.begin(), __t.end(), __less<_Tp>());
}



} }
# 703 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/algorithm" 2 3

# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/merge.h" 1 3
# 20 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/merge.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 24 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/merge.h" 2 3

namespace std { inline namespace __1 {

template <class _Compare, class _InputIterator1, class _InputIterator2, class _OutputIterator>

_OutputIterator
__merge(_InputIterator1 __first1, _InputIterator1 __last1,
        _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)
{
    for (; __first1 != __last1; ++__result)
    {
        if (__first2 == __last2)
            return std::__1::copy(__first1, __last1, __result);
        if (__comp(*__first2, *__first1))
        {
            *__result = *__first2;
            ++__first2;
        }
        else
        {
            *__result = *__first1;
            ++__first1;
        }
    }
    return std::__1::copy(__first2, __last2, __result);
}

template <class _InputIterator1, class _InputIterator2, class _OutputIterator, class _Compare>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
_OutputIterator
merge(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)
{
    typedef typename __comp_ref_type<_Compare>::type _Comp_ref;
    return std::__1::__merge<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __comp);
}

template <class _InputIterator1, class _InputIterator2, class _OutputIterator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
_OutputIterator
merge(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result)
{
    typedef typename iterator_traits<_InputIterator1>::value_type __v1;
    typedef typename iterator_traits<_InputIterator2>::value_type __v2;
    return std::__1::merge(__first1, __last1, __first2, __last2, __result, __less<__v1, __v2>());
}

} }
# 705 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/algorithm" 2 3


# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/minmax.h" 1 3
# 20 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/minmax.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 24 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/minmax.h" 2 3

namespace std { inline namespace __1 {

template<class _Tp, class _Compare>
                      inline
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
pair<const _Tp&, const _Tp&>
minmax(const _Tp& __a, const _Tp& __b, _Compare __comp)
{
    return __comp(__b, __a) ? pair<const _Tp&, const _Tp&>(__b, __a) :
                              pair<const _Tp&, const _Tp&>(__a, __b);
}

template<class _Tp>
                      inline
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
pair<const _Tp&, const _Tp&>
minmax(const _Tp& __a, const _Tp& __b)
{
    return std::__1::minmax(__a, __b, __less<_Tp>());
}



template<class _Tp, class _Compare>
                      inline
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
pair<_Tp, _Tp>
minmax(initializer_list<_Tp> __t, _Compare __comp)
{
    typedef typename initializer_list<_Tp>::const_iterator _Iter;
    _Iter __first = __t.begin();
    _Iter __last = __t.end();
    pair<_Tp, _Tp> __result(*__first, *__first);

    ++__first;
    if (__t.size() % 2 == 0)
    {
        if (__comp(*__first, __result.first))
            __result.first = *__first;
        else
            __result.second = *__first;
        ++__first;
    }

    while (__first != __last)
    {
        _Tp __prev = *__first++;
        if (__comp(*__first, __prev)) {
            if ( __comp(*__first, __result.first)) __result.first = *__first;
            if (!__comp(__prev, __result.second)) __result.second = __prev;
            }
        else {
            if ( __comp(__prev, __result.first)) __result.first = __prev;
            if (!__comp(*__first, __result.second)) __result.second = *__first;
            }

        __first++;
    }
    return __result;
}

template<class _Tp>
                      inline
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
pair<_Tp, _Tp>
minmax(initializer_list<_Tp> __t)
{
    return std::__1::minmax(__t, __less<_Tp>());
}



} }
# 708 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/algorithm" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/minmax_element.h" 1 3
# 19 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/minmax_element.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 23 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/minmax_element.h" 2 3

namespace std { inline namespace __1 {

template <class _ForwardIterator, class _Compare>
                      constexpr
pair<_ForwardIterator, _ForwardIterator>
minmax_element(_ForwardIterator __first, _ForwardIterator __last, _Compare __comp)
{
  static_assert(__is_cpp17_forward_iterator<_ForwardIterator>::value,
        "std::minmax_element requires a ForwardIterator");
  pair<_ForwardIterator, _ForwardIterator> __result(__first, __first);
  if (__first != __last)
  {
      if (++__first != __last)
      {
          if (__comp(*__first, *__result.first))
              __result.first = __first;
          else
              __result.second = __first;
          while (++__first != __last)
          {
              _ForwardIterator __i = __first;
              if (++__first == __last)
              {
                  if (__comp(*__i, *__result.first))
                      __result.first = __i;
                  else if (!__comp(*__i, *__result.second))
                      __result.second = __i;
                  break;
              }
              else
              {
                  if (__comp(*__first, *__i))
                  {
                      if (__comp(*__first, *__result.first))
                          __result.first = __first;
                      if (!__comp(*__i, *__result.second))
                          __result.second = __i;
                  }
                  else
                  {
                      if (__comp(*__i, *__result.first))
                          __result.first = __i;
                      if (!__comp(*__first, *__result.second))
                          __result.second = __first;
                  }
              }
          }
      }
  }
  return __result;
}

template <class _ForwardIterator>
                      inline
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
pair<_ForwardIterator, _ForwardIterator>
minmax_element(_ForwardIterator __first, _ForwardIterator __last)
{
    return std::__1::minmax_element(__first, __last,
              __less<typename iterator_traits<_ForwardIterator>::value_type>());
}

} }
# 709 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/algorithm" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/mismatch.h" 1 3
# 20 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/mismatch.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 24 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/mismatch.h" 2 3

namespace std { inline namespace __1 {

template <class _InputIterator1, class _InputIterator2, class _BinaryPredicate>
                      inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
                                  pair<_InputIterator1, _InputIterator2>
    mismatch(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _BinaryPredicate __pred) {
  for (; __first1 != __last1; ++__first1, (void)++__first2)
    if (!__pred(*__first1, *__first2))
      break;
  return pair<_InputIterator1, _InputIterator2>(__first1, __first2);
}

template <class _InputIterator1, class _InputIterator2>
                      inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
                                  pair<_InputIterator1, _InputIterator2>
    mismatch(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2) {
  typedef typename iterator_traits<_InputIterator1>::value_type __v1;
  typedef typename iterator_traits<_InputIterator2>::value_type __v2;
  return std::__1::mismatch(__first1, __last1, __first2, __equal_to<__v1, __v2>());
}


template <class _InputIterator1, class _InputIterator2, class _BinaryPredicate>
                      inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
                                  pair<_InputIterator1, _InputIterator2>
    mismatch(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2,
             _BinaryPredicate __pred) {
  for (; __first1 != __last1 && __first2 != __last2; ++__first1, (void)++__first2)
    if (!__pred(*__first1, *__first2))
      break;
  return pair<_InputIterator1, _InputIterator2>(__first1, __first2);
}

template <class _InputIterator1, class _InputIterator2>
                      inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
                                  pair<_InputIterator1, _InputIterator2>
    mismatch(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2) {
  typedef typename iterator_traits<_InputIterator1>::value_type __v1;
  typedef typename iterator_traits<_InputIterator2>::value_type __v2;
  return std::__1::mismatch(__first1, __last1, __first2, __last2, __equal_to<__v1, __v2>());
}


} }
# 710 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/algorithm" 2 3


# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/next_permutation.h" 1 3
# 15 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/next_permutation.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/reverse.h" 1 3
# 18 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/reverse.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 22 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/reverse.h" 2 3

namespace std { inline namespace __1 {

template <class _BidirectionalIterator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void
__reverse(_BidirectionalIterator __first, _BidirectionalIterator __last, bidirectional_iterator_tag)
{
    while (__first != __last)
    {
        if (__first == --__last)
            break;
        std::__1::iter_swap(__first, __last);
        ++__first;
    }
}

template <class _RandomAccessIterator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void
__reverse(_RandomAccessIterator __first, _RandomAccessIterator __last, random_access_iterator_tag)
{
    if (__first != __last)
        for (; __first < --__last; ++__first)
            std::__1::iter_swap(__first, __last);
}

template <class _BidirectionalIterator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void
reverse(_BidirectionalIterator __first, _BidirectionalIterator __last)
{
    std::__1::__reverse(__first, __last, typename iterator_traits<_BidirectionalIterator>::iterator_category());
}

} }
# 16 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/next_permutation.h" 2 3
# 21 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/next_permutation.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 25 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/next_permutation.h" 2 3

namespace std { inline namespace __1 {

template <class _Compare, class _BidirectionalIterator>
                              bool
__next_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last, _Compare __comp)
{
    _BidirectionalIterator __i = __last;
    if (__first == __last || __first == --__i)
        return false;
    while (true)
    {
        _BidirectionalIterator __ip1 = __i;
        if (__comp(*--__i, *__ip1))
        {
            _BidirectionalIterator __j = __last;
            while (!__comp(*__i, *--__j))
                ;
            swap(*__i, *__j);
            std::__1::reverse(__ip1, __last);
            return true;
        }
        if (__i == __first)
        {
            std::__1::reverse(__first, __last);
            return false;
        }
    }
}

template <class _BidirectionalIterator, class _Compare>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
next_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last, _Compare __comp)
{
    typedef typename __comp_ref_type<_Compare>::type _Comp_ref;
    return std::__1::__next_permutation<_Comp_ref>(__first, __last, __comp);
}

template <class _BidirectionalIterator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
next_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last)
{
    return std::__1::next_permutation(__first, __last,
                                  __less<typename iterator_traits<_BidirectionalIterator>::value_type>());
}

} }
# 713 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/algorithm" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/none_of.h" 1 3
# 17 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/none_of.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 21 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/none_of.h" 2 3

namespace std { inline namespace __1 {

template <class _InputIterator, class _Predicate>
                      inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) bool
none_of(_InputIterator __first, _InputIterator __last, _Predicate __pred) {
  for (; __first != __last; ++__first)
    if (__pred(*__first))
      return false;
  return true;
}

} }
# 714 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/algorithm" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/nth_element.h" 1 3
# 15 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/nth_element.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/sort.h" 1 3
# 16 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/sort.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/partial_sort.h" 1 3
# 17 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/partial_sort.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/sort_heap.h" 1 3
# 15 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/sort_heap.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/pop_heap.h" 1 3
# 21 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/pop_heap.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 25 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/pop_heap.h" 2 3

namespace std { inline namespace __1 {

template <class _Compare, class _RandomAccessIterator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void
__pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp,
           typename iterator_traits<_RandomAccessIterator>::difference_type __len)
{
    if (__len > 1)
    {
        swap(*__first, *--__last);
        std::__1::__sift_down<_Compare>(__first, __last, __comp, __len - 1, __first);
    }
}

template <class _RandomAccessIterator, class _Compare>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void
pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)
{
    typedef typename __comp_ref_type<_Compare>::type _Comp_ref;
    std::__1::__pop_heap<_Comp_ref>(__first, __last, __comp, __last - __first);
}

template <class _RandomAccessIterator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void
pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
{
    std::__1::pop_heap(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());
}

} }
# 16 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/sort_heap.h" 2 3

# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 1 3
# 18 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/sort_heap.h" 2 3
# 21 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/sort_heap.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 25 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/sort_heap.h" 2 3

namespace std { inline namespace __1 {

template <class _Compare, class _RandomAccessIterator>
                              void
__sort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)
{
    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;
    for (difference_type __n = __last - __first; __n > 1; --__last, (void) --__n)
        std::__1::__pop_heap<_Compare>(__first, __last, __comp, __n);
}

template <class _RandomAccessIterator, class _Compare>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void
sort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)
{
    typedef typename __comp_ref_type<_Compare>::type _Comp_ref;
    std::__1::__sort_heap<_Comp_ref>(__first, __last, __comp);
}

template <class _RandomAccessIterator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void
sort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
{
    std::__1::sort_heap(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());
}

} }
# 18 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/partial_sort.h" 2 3
# 23 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/partial_sort.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 27 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/partial_sort.h" 2 3

namespace std { inline namespace __1 {

template <class _Compare, class _RandomAccessIterator>
                              void
__partial_sort(_RandomAccessIterator __first, _RandomAccessIterator __middle, _RandomAccessIterator __last,
             _Compare __comp)
{
    std::__1::__make_heap<_Compare>(__first, __middle, __comp);
    typename iterator_traits<_RandomAccessIterator>::difference_type __len = __middle - __first;
    for (_RandomAccessIterator __i = __middle; __i != __last; ++__i)
    {
        if (__comp(*__i, *__first))
        {
            swap(*__i, *__first);
            std::__1::__sift_down<_Compare>(__first, __middle, __comp, __len, __first);
        }
    }
    std::__1::__sort_heap<_Compare>(__first, __middle, __comp);
}

template <class _RandomAccessIterator, class _Compare>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void
partial_sort(_RandomAccessIterator __first, _RandomAccessIterator __middle, _RandomAccessIterator __last,
             _Compare __comp)
{
    typedef typename __comp_ref_type<_Compare>::type _Comp_ref;
    std::__1::__partial_sort<_Comp_ref>(__first, __middle, __last, __comp);
}

template <class _RandomAccessIterator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void
partial_sort(_RandomAccessIterator __first, _RandomAccessIterator __middle, _RandomAccessIterator __last)
{
    std::__1::partial_sort(__first, __middle, __last,
                       __less<typename iterator_traits<_RandomAccessIterator>::value_type>());
}

} }
# 17 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/sort.h" 2 3


# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/memory" 1 3
# 974 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/memory" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 1 3
# 20 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/assert.h" 1 3 4
# 44 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/assert.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/stdlib.h" 1 3 4
# 45 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/assert.h" 2 3 4
# 81 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/assert.h" 3 4
extern "C" {
void __assert_rtn(const char *, const char *, int, const char *) __attribute__((__noreturn__)) __attribute__((__cold__)) __attribute__((__disable_tail_calls__));



}
# 21 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 2 3
# 24 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 3
# 975 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/memory" 2 3
# 20 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/sort.h" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 1 3
# 21 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/sort.h" 2 3
# 24 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/sort.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 28 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/sort.h" 2 3

namespace std { inline namespace __1 {



template <class _Compare, class _ForwardIterator>
constexpr unsigned
__sort3(_ForwardIterator __x, _ForwardIterator __y, _ForwardIterator __z, _Compare __c)
{
    unsigned __r = 0;
    if (!__c(*__y, *__x))
    {
        if (!__c(*__z, *__y))
            return __r;

        swap(*__y, *__z);
        __r = 1;
        if (__c(*__y, *__x))
        {
            swap(*__x, *__y);
            __r = 2;
        }
        return __r;
    }
    if (__c(*__z, *__y))
    {
        swap(*__x, *__z);
        __r = 1;
        return __r;
    }
    swap(*__x, *__y);
    __r = 1;
    if (__c(*__z, *__y))
    {
        swap(*__y, *__z);
        __r = 2;
    }
    return __r;
}



template <class _Compare, class _ForwardIterator>
unsigned
__sort4(_ForwardIterator __x1, _ForwardIterator __x2, _ForwardIterator __x3,
            _ForwardIterator __x4, _Compare __c)
{
    unsigned __r = std::__1::__sort3<_Compare>(__x1, __x2, __x3, __c);
    if (__c(*__x4, *__x3))
    {
        swap(*__x3, *__x4);
        ++__r;
        if (__c(*__x3, *__x2))
        {
            swap(*__x2, *__x3);
            ++__r;
            if (__c(*__x2, *__x1))
            {
                swap(*__x1, *__x2);
                ++__r;
            }
        }
    }
    return __r;
}



template <class _Compare, class _ForwardIterator>
__attribute__ ((__visibility__("hidden")))
unsigned
__sort5(_ForwardIterator __x1, _ForwardIterator __x2, _ForwardIterator __x3,
            _ForwardIterator __x4, _ForwardIterator __x5, _Compare __c)
{
    unsigned __r = std::__1::__sort4<_Compare>(__x1, __x2, __x3, __x4, __c);
    if (__c(*__x5, *__x4))
    {
        swap(*__x4, *__x5);
        ++__r;
        if (__c(*__x4, *__x3))
        {
            swap(*__x3, *__x4);
            ++__r;
            if (__c(*__x3, *__x2))
            {
                swap(*__x2, *__x3);
                ++__r;
                if (__c(*__x2, *__x1))
                {
                    swap(*__x1, *__x2);
                    ++__r;
                }
            }
        }
    }
    return __r;
}


template <class _Compare, class _BidirectionalIterator>
constexpr void
__selection_sort(_BidirectionalIterator __first, _BidirectionalIterator __last, _Compare __comp)
{
    _BidirectionalIterator __lm1 = __last;
    for (--__lm1; __first != __lm1; ++__first)
    {
        _BidirectionalIterator __i = std::__1::min_element<_BidirectionalIterator,
                                                        typename add_lvalue_reference<_Compare>::type>
                                                       (__first, __last, __comp);
        if (__i != __first)
            swap(*__first, *__i);
    }
}

template <class _Compare, class _BidirectionalIterator>
void
__insertion_sort(_BidirectionalIterator __first, _BidirectionalIterator __last, _Compare __comp)
{
    typedef typename iterator_traits<_BidirectionalIterator>::value_type value_type;
    if (__first != __last)
    {
        _BidirectionalIterator __i = __first;
        for (++__i; __i != __last; ++__i)
        {
            _BidirectionalIterator __j = __i;
            value_type __t(std::__1::move(*__j));
            for (_BidirectionalIterator __k = __i; __k != __first && __comp(__t, *--__k); --__j)
                *__j = std::__1::move(*__k);
            *__j = std::__1::move(__t);
        }
    }
}

template <class _Compare, class _RandomAccessIterator>
void
__insertion_sort_3(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)
{
    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;
    _RandomAccessIterator __j = __first+2;
    std::__1::__sort3<_Compare>(__first, __first+1, __j, __comp);
    for (_RandomAccessIterator __i = __j+1; __i != __last; ++__i)
    {
        if (__comp(*__i, *__j))
        {
            value_type __t(std::__1::move(*__i));
            _RandomAccessIterator __k = __j;
            __j = __i;
            do
            {
                *__j = std::__1::move(*__k);
                __j = __k;
            } while (__j != __first && __comp(__t, *--__k));
            *__j = std::__1::move(__t);
        }
        __j = __i;
    }
}

template <class _Compare, class _RandomAccessIterator>
bool
__insertion_sort_incomplete(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)
{
    switch (__last - __first)
    {
    case 0:
    case 1:
        return true;
    case 2:
        if (__comp(*--__last, *__first))
            swap(*__first, *__last);
        return true;
    case 3:
        std::__1::__sort3<_Compare>(__first, __first+1, --__last, __comp);
        return true;
    case 4:
        std::__1::__sort4<_Compare>(__first, __first+1, __first+2, --__last, __comp);
        return true;
    case 5:
        std::__1::__sort5<_Compare>(__first, __first+1, __first+2, __first+3, --__last, __comp);
        return true;
    }
    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;
    _RandomAccessIterator __j = __first+2;
    std::__1::__sort3<_Compare>(__first, __first+1, __j, __comp);
    const unsigned __limit = 8;
    unsigned __count = 0;
    for (_RandomAccessIterator __i = __j+1; __i != __last; ++__i)
    {
        if (__comp(*__i, *__j))
        {
            value_type __t(std::__1::move(*__i));
            _RandomAccessIterator __k = __j;
            __j = __i;
            do
            {
                *__j = std::__1::move(*__k);
                __j = __k;
            } while (__j != __first && __comp(__t, *--__k));
            *__j = std::__1::move(__t);
            if (++__count == __limit)
                return ++__i == __last;
        }
        __j = __i;
    }
    return true;
}

template <class _Compare, class _BidirectionalIterator>
void
__insertion_sort_move(_BidirectionalIterator __first1, _BidirectionalIterator __last1,
                      typename iterator_traits<_BidirectionalIterator>::value_type* __first2, _Compare __comp)
{
    typedef typename iterator_traits<_BidirectionalIterator>::value_type value_type;
    if (__first1 != __last1)
    {
        __destruct_n __d(0);
        unique_ptr<value_type, __destruct_n&> __h(__first2, __d);
        value_type* __last2 = __first2;
        ::new ((void*)__last2) value_type(std::__1::move(*__first1));
        __d.template __incr<value_type>();
        for (++__last2; ++__first1 != __last1; ++__last2)
        {
            value_type* __j2 = __last2;
            value_type* __i2 = __j2;
            if (__comp(*__first1, *--__i2))
            {
                ::new ((void*)__j2) value_type(std::__1::move(*__i2));
                __d.template __incr<value_type>();
                for (--__j2; __i2 != __first2 && __comp(*__first1, *--__i2); --__j2)
                    *__j2 = std::__1::move(*__i2);
                *__j2 = std::__1::move(*__first1);
            }
            else
            {
                ::new ((void*)__j2) value_type(std::__1::move(*__first1));
                __d.template __incr<value_type>();
            }
        }
        __h.release();
    }
}

template <class _Compare, class _RandomAccessIterator>
void
__sort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)
{
    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;
    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;
    const difference_type __limit = is_trivially_copy_constructible<value_type>::value &&
                                    is_trivially_copy_assignable<value_type>::value ? 30 : 6;
    while (true)
    {
    __restart:
        difference_type __len = __last - __first;
        switch (__len)
        {
        case 0:
        case 1:
            return;
        case 2:
            if (__comp(*--__last, *__first))
                swap(*__first, *__last);
            return;
        case 3:
            std::__1::__sort3<_Compare>(__first, __first+1, --__last, __comp);
            return;
        case 4:
            std::__1::__sort4<_Compare>(__first, __first+1, __first+2, --__last, __comp);
            return;
        case 5:
            std::__1::__sort5<_Compare>(__first, __first+1, __first+2, __first+3, --__last, __comp);
            return;
        }
        if (__len <= __limit)
        {
            std::__1::__insertion_sort_3<_Compare>(__first, __last, __comp);
            return;
        }

        _RandomAccessIterator __m = __first;
        _RandomAccessIterator __lm1 = __last;
        --__lm1;
        unsigned __n_swaps;
        {
        difference_type __delta;
        if (__len >= 1000)
        {
            __delta = __len/2;
            __m += __delta;
            __delta /= 2;
            __n_swaps = std::__1::__sort5<_Compare>(__first, __first + __delta, __m, __m+__delta, __lm1, __comp);
        }
        else
        {
            __delta = __len/2;
            __m += __delta;
            __n_swaps = std::__1::__sort3<_Compare>(__first, __m, __lm1, __comp);
        }
        }



        _RandomAccessIterator __i = __first;
        _RandomAccessIterator __j = __lm1;



        if (!__comp(*__i, *__m))
        {


            while (true)
            {
                if (__i == --__j)
                {


                    ++__i;
                    __j = __last;
                    if (!__comp(*__first, *--__j))
                    {
                        while (true)
                        {
                            if (__i == __j)
                                return;
                            if (__comp(*__first, *__i))
                            {
                                swap(*__i, *__j);
                                ++__n_swaps;
                                ++__i;
                                break;
                            }
                            ++__i;
                        }
                    }

                    if (__i == __j)
                        return;
                    while (true)
                    {
                        while (!__comp(*__first, *__i))
                            ++__i;
                        while (__comp(*__first, *--__j))
                            ;
                        if (__i >= __j)
                            break;
                        swap(*__i, *__j);
                        ++__n_swaps;
                        ++__i;
                    }



                    __first = __i;
                    goto __restart;
                }
                if (__comp(*__j, *__m))
                {
                    swap(*__i, *__j);
                    ++__n_swaps;
                    break;
                }
            }
        }

        ++__i;


        if (__i < __j)
        {


            while (true)
            {

                while (__comp(*__i, *__m))
                    ++__i;

                while (!__comp(*--__j, *__m))
                    ;
                if (__i > __j)
                    break;
                swap(*__i, *__j);
                ++__n_swaps;


                if (__m == __i)
                    __m = __j;
                ++__i;
            }
        }

        if (__i != __m && __comp(*__m, *__i))
        {
            swap(*__i, *__m);
            ++__n_swaps;
        }


        if (__n_swaps == 0)
        {
            bool __fs = std::__1::__insertion_sort_incomplete<_Compare>(__first, __i, __comp);
            if (std::__1::__insertion_sort_incomplete<_Compare>(__i+1, __last, __comp))
            {
                if (__fs)
                    return;
                __last = __i;
                continue;
            }
            else
            {
                if (__fs)
                {
                    __first = ++__i;
                    continue;
                }
            }
        }

        if (__i - __first < __last - __i)
        {
            std::__1::__sort<_Compare>(__first, __i, __comp);

            __first = ++__i;
        }
        else
        {
            std::__1::__sort<_Compare>(__i+1, __last, __comp);

            __last = __i;
        }
    }
}

template <class _Compare, class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void
__sort(_Tp** __first, _Tp** __last, __less<_Tp*>&)
{
    __less<uintptr_t> __comp;
    std::__1::__sort<__less<uintptr_t>&, uintptr_t*>((uintptr_t*)__first, (uintptr_t*)__last, __comp);
}

extern template __attribute__ ((__visibility__("default"))) void __sort<__less<char>&, char*>(char*, char*, __less<char>&);

extern template __attribute__ ((__visibility__("default"))) void __sort<__less<wchar_t>&, wchar_t*>(wchar_t*, wchar_t*, __less<wchar_t>&);

extern template __attribute__ ((__visibility__("default"))) void __sort<__less<signed char>&, signed char*>(signed char*, signed char*, __less<signed char>&);
extern template __attribute__ ((__visibility__("default"))) void __sort<__less<unsigned char>&, unsigned char*>(unsigned char*, unsigned char*, __less<unsigned char>&);
extern template __attribute__ ((__visibility__("default"))) void __sort<__less<short>&, short*>(short*, short*, __less<short>&);
extern template __attribute__ ((__visibility__("default"))) void __sort<__less<unsigned short>&, unsigned short*>(unsigned short*, unsigned short*, __less<unsigned short>&);
extern template __attribute__ ((__visibility__("default"))) void __sort<__less<int>&, int*>(int*, int*, __less<int>&);
extern template __attribute__ ((__visibility__("default"))) void __sort<__less<unsigned>&, unsigned*>(unsigned*, unsigned*, __less<unsigned>&);
extern template __attribute__ ((__visibility__("default"))) void __sort<__less<long>&, long*>(long*, long*, __less<long>&);
extern template __attribute__ ((__visibility__("default"))) void __sort<__less<unsigned long>&, unsigned long*>(unsigned long*, unsigned long*, __less<unsigned long>&);
extern template __attribute__ ((__visibility__("default"))) void __sort<__less<long long>&, long long*>(long long*, long long*, __less<long long>&);
extern template __attribute__ ((__visibility__("default"))) void __sort<__less<unsigned long long>&, unsigned long long*>(unsigned long long*, unsigned long long*, __less<unsigned long long>&);
extern template __attribute__ ((__visibility__("default"))) void __sort<__less<float>&, float*>(float*, float*, __less<float>&);
extern template __attribute__ ((__visibility__("default"))) void __sort<__less<double>&, double*>(double*, double*, __less<double>&);
extern template __attribute__ ((__visibility__("default"))) void __sort<__less<long double>&, long double*>(long double*, long double*, __less<long double>&);

extern template __attribute__ ((__visibility__("default"))) bool __insertion_sort_incomplete<__less<char>&, char*>(char*, char*, __less<char>&);

extern template __attribute__ ((__visibility__("default"))) bool __insertion_sort_incomplete<__less<wchar_t>&, wchar_t*>(wchar_t*, wchar_t*, __less<wchar_t>&);

extern template __attribute__ ((__visibility__("default"))) bool __insertion_sort_incomplete<__less<signed char>&, signed char*>(signed char*, signed char*, __less<signed char>&);
extern template __attribute__ ((__visibility__("default"))) bool __insertion_sort_incomplete<__less<unsigned char>&, unsigned char*>(unsigned char*, unsigned char*, __less<unsigned char>&);
extern template __attribute__ ((__visibility__("default"))) bool __insertion_sort_incomplete<__less<short>&, short*>(short*, short*, __less<short>&);
extern template __attribute__ ((__visibility__("default"))) bool __insertion_sort_incomplete<__less<unsigned short>&, unsigned short*>(unsigned short*, unsigned short*, __less<unsigned short>&);
extern template __attribute__ ((__visibility__("default"))) bool __insertion_sort_incomplete<__less<int>&, int*>(int*, int*, __less<int>&);
extern template __attribute__ ((__visibility__("default"))) bool __insertion_sort_incomplete<__less<unsigned>&, unsigned*>(unsigned*, unsigned*, __less<unsigned>&);
extern template __attribute__ ((__visibility__("default"))) bool __insertion_sort_incomplete<__less<long>&, long*>(long*, long*, __less<long>&);
extern template __attribute__ ((__visibility__("default"))) bool __insertion_sort_incomplete<__less<unsigned long>&, unsigned long*>(unsigned long*, unsigned long*, __less<unsigned long>&);
extern template __attribute__ ((__visibility__("default"))) bool __insertion_sort_incomplete<__less<long long>&, long long*>(long long*, long long*, __less<long long>&);
extern template __attribute__ ((__visibility__("default"))) bool __insertion_sort_incomplete<__less<unsigned long long>&, unsigned long long*>(unsigned long long*, unsigned long long*, __less<unsigned long long>&);
extern template __attribute__ ((__visibility__("default"))) bool __insertion_sort_incomplete<__less<float>&, float*>(float*, float*, __less<float>&);
extern template __attribute__ ((__visibility__("default"))) bool __insertion_sort_incomplete<__less<double>&, double*>(double*, double*, __less<double>&);
extern template __attribute__ ((__visibility__("default"))) bool __insertion_sort_incomplete<__less<long double>&, long double*>(long double*, long double*, __less<long double>&);

extern template __attribute__ ((__visibility__("default"))) unsigned __sort5<__less<long double>&, long double*>(long double*, long double*, long double*, long double*, long double*, __less<long double>&);

template <class _RandomAccessIterator, class _Compare>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void
sort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)
{
    typedef typename __comp_ref_type<_Compare>::type _Comp_ref;
    if (__libcpp_is_constant_evaluated()) {
        std::__1::__partial_sort<_Comp_ref>(__first, __last, __last, _Comp_ref(__comp));
    } else {
        std::__1::__sort<_Comp_ref>(std::__1::__unwrap_iter(__first), std::__1::__unwrap_iter(__last), _Comp_ref(__comp));
    }
}

template <class _RandomAccessIterator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void
sort(_RandomAccessIterator __first, _RandomAccessIterator __last)
{
    std::__1::sort(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());
}

} }
# 16 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/nth_element.h" 2 3
# 21 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/nth_element.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 25 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/nth_element.h" 2 3

namespace std { inline namespace __1 {

template<class _Compare, class _RandomAccessIterator>
constexpr bool
__nth_element_find_guard(_RandomAccessIterator& __i, _RandomAccessIterator& __j,
                         _RandomAccessIterator __m, _Compare __comp)
{

    while (true) {
        if (__i == --__j) {
            return false;
        }
        if (__comp(*__j, *__m)) {
            return true;
        }
    }
}

template <class _Compare, class _RandomAccessIterator>
constexpr void
__nth_element(_RandomAccessIterator __first, _RandomAccessIterator __nth, _RandomAccessIterator __last, _Compare __comp)
{

    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;
    const difference_type __limit = 7;
    while (true)
    {
        if (__nth == __last)
            return;
        difference_type __len = __last - __first;
        switch (__len)
        {
        case 0:
        case 1:
            return;
        case 2:
            if (__comp(*--__last, *__first))
                swap(*__first, *__last);
            return;
        case 3:
            {
            _RandomAccessIterator __m = __first;
            std::__1::__sort3<_Compare>(__first, ++__m, --__last, __comp);
            return;
            }
        }
        if (__len <= __limit)
        {
            std::__1::__selection_sort<_Compare>(__first, __last, __comp);
            return;
        }

        _RandomAccessIterator __m = __first + __len/2;
        _RandomAccessIterator __lm1 = __last;
        unsigned __n_swaps = std::__1::__sort3<_Compare>(__first, __m, --__lm1, __comp);



        _RandomAccessIterator __i = __first;
        _RandomAccessIterator __j = __lm1;



        if (!__comp(*__i, *__m))
        {

            if (std::__1::__nth_element_find_guard<_Compare>(__i, __j, __m, __comp)) {
                swap(*__i, *__j);
                ++__n_swaps;
            } else {


                ++__i;
                __j = __last;
                if (!__comp(*__first, *--__j)) {
                    while (true) {
                        if (__i == __j) {
                            return;
                        } else if (__comp(*__first, *__i)) {
                            swap(*__i, *__j);
                            ++__n_swaps;
                            ++__i;
                            break;
                        }
                        ++__i;
                    }
                }

                if (__i == __j) {
                    return;
                }
                while (true) {
                    while (!__comp(*__first, *__i))
                        ++__i;
                    while (__comp(*__first, *--__j))
                        ;
                    if (__i >= __j)
                        break;
                    swap(*__i, *__j);
                    ++__n_swaps;
                    ++__i;
                }


                if (__nth < __i) {
                    return;
                }


                __first = __i;
                continue;
            }
        }
        ++__i;


        if (__i < __j)
        {

            while (true)
            {

                while (__comp(*__i, *__m))
                    ++__i;

                while (!__comp(*--__j, *__m))
                    ;
                if (__i >= __j)
                    break;
                swap(*__i, *__j);
                ++__n_swaps;


                if (__m == __i)
                    __m = __j;
                ++__i;
            }
        }

        if (__i != __m && __comp(*__m, *__i))
        {
            swap(*__i, *__m);
            ++__n_swaps;
        }

        if (__nth == __i)
            return;
        if (__n_swaps == 0)
        {

            if (__nth < __i)
            {

                __j = __m = __first;
                while (true) {
                    if (++__j == __i) {

                        return;
                    }
                    if (__comp(*__j, *__m)) {

                        break;
                    }
                    __m = __j;
                }
            }
            else
            {

                __j = __m = __i;
                while (true) {
                    if (++__j == __last) {

                        return;
                    }
                    if (__comp(*__j, *__m)) {

                        break;
                    }
                    __m = __j;
                }
            }
        }

        if (__nth < __i)
        {

            __last = __i;
        }
        else
        {

            __first = ++__i;
        }
    }
}

template <class _RandomAccessIterator, class _Compare>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void
nth_element(_RandomAccessIterator __first, _RandomAccessIterator __nth, _RandomAccessIterator __last, _Compare __comp)
{
    typedef typename __comp_ref_type<_Compare>::type _Comp_ref;
    std::__1::__nth_element<_Comp_ref>(__first, __nth, __last, __comp);
}

template <class _RandomAccessIterator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void
nth_element(_RandomAccessIterator __first, _RandomAccessIterator __nth, _RandomAccessIterator __last)
{
    std::__1::nth_element(__first, __nth, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());
}

} }
# 715 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/algorithm" 2 3

# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/partial_sort_copy.h" 1 3
# 19 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/partial_sort_copy.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 1 3
# 20 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/partial_sort_copy.h" 2 3
# 23 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/partial_sort_copy.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 27 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/partial_sort_copy.h" 2 3

namespace std { inline namespace __1 {

template <class _Compare, class _InputIterator, class _RandomAccessIterator>
                              _RandomAccessIterator
__partial_sort_copy(_InputIterator __first, _InputIterator __last,
                    _RandomAccessIterator __result_first, _RandomAccessIterator __result_last, _Compare __comp)
{
    _RandomAccessIterator __r = __result_first;
    if (__r != __result_last)
    {
        for (; __first != __last && __r != __result_last; ++__first, (void) ++__r)
            *__r = *__first;
        std::__1::__make_heap<_Compare>(__result_first, __r, __comp);
        typename iterator_traits<_RandomAccessIterator>::difference_type __len = __r - __result_first;
        for (; __first != __last; ++__first)
            if (__comp(*__first, *__result_first))
            {
                *__result_first = *__first;
                std::__1::__sift_down<_Compare>(__result_first, __r, __comp, __len, __result_first);
            }
        std::__1::__sort_heap<_Compare>(__result_first, __r, __comp);
    }
    return __r;
}

template <class _InputIterator, class _RandomAccessIterator, class _Compare>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
_RandomAccessIterator
partial_sort_copy(_InputIterator __first, _InputIterator __last,
                  _RandomAccessIterator __result_first, _RandomAccessIterator __result_last, _Compare __comp)
{
    typedef typename __comp_ref_type<_Compare>::type _Comp_ref;
    return std::__1::__partial_sort_copy<_Comp_ref>(__first, __last, __result_first, __result_last, __comp);
}

template <class _InputIterator, class _RandomAccessIterator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
_RandomAccessIterator
partial_sort_copy(_InputIterator __first, _InputIterator __last,
                  _RandomAccessIterator __result_first, _RandomAccessIterator __result_last)
{
    return std::__1::partial_sort_copy(__first, __last, __result_first, __result_last,
                                   __less<typename iterator_traits<_RandomAccessIterator>::value_type>());
}

} }
# 717 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/algorithm" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/partition.h" 1 3
# 16 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/partition.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 1 3
# 17 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/partition.h" 2 3
# 20 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/partition.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 24 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/partition.h" 2 3

namespace std { inline namespace __1 {

template <class _Predicate, class _ForwardIterator>
                              _ForwardIterator
__partition(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred, forward_iterator_tag)
{
    while (true)
    {
        if (__first == __last)
            return __first;
        if (!__pred(*__first))
            break;
        ++__first;
    }
    for (_ForwardIterator __p = __first; ++__p != __last;)
    {
        if (__pred(*__p))
        {
            swap(*__first, *__p);
            ++__first;
        }
    }
    return __first;
}

template <class _Predicate, class _BidirectionalIterator>
                              _BidirectionalIterator
__partition(_BidirectionalIterator __first, _BidirectionalIterator __last, _Predicate __pred,
            bidirectional_iterator_tag)
{
    while (true)
    {
        while (true)
        {
            if (__first == __last)
                return __first;
            if (!__pred(*__first))
                break;
            ++__first;
        }
        do
        {
            if (__first == --__last)
                return __first;
        } while (!__pred(*__last));
        swap(*__first, *__last);
        ++__first;
    }
}

template <class _ForwardIterator, class _Predicate>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
_ForwardIterator
partition(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred)
{
    return std::__1::__partition<typename add_lvalue_reference<_Predicate>::type>
                            (__first, __last, __pred, typename iterator_traits<_ForwardIterator>::iterator_category());
}

} }
# 718 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/algorithm" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/partition_copy.h" 1 3
# 18 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/partition_copy.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 22 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/partition_copy.h" 2 3

namespace std { inline namespace __1 {

template <class _InputIterator, class _OutputIterator1,
          class _OutputIterator2, class _Predicate>
                              pair<_OutputIterator1, _OutputIterator2>
partition_copy(_InputIterator __first, _InputIterator __last,
               _OutputIterator1 __out_true, _OutputIterator2 __out_false,
               _Predicate __pred)
{
    for (; __first != __last; ++__first)
    {
        if (__pred(*__first))
        {
            *__out_true = *__first;
            ++__out_true;
        }
        else
        {
            *__out_false = *__first;
            ++__out_false;
        }
    }
    return pair<_OutputIterator1, _OutputIterator2>(__out_true, __out_false);
}

} }
# 719 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/algorithm" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/partition_point.h" 1 3
# 18 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/partition_point.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 22 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/partition_point.h" 2 3

namespace std { inline namespace __1 {

template<class _ForwardIterator, class _Predicate>
                              _ForwardIterator
partition_point(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred)
{
    typedef typename iterator_traits<_ForwardIterator>::difference_type difference_type;
    difference_type __len = std::__1::distance(__first, __last);
    while (__len != 0)
    {
        difference_type __l2 = std::__1::__half_positive(__len);
        _ForwardIterator __m = __first;
        std::__1::advance(__m, __l2);
        if (__pred(*__m))
        {
            __first = ++__m;
            __len -= __l2 + 1;
        }
        else
            __len = __l2;
    }
    return __first;
}

} }
# 720 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/algorithm" 2 3

# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/prev_permutation.h" 1 3
# 21 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/prev_permutation.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 25 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/prev_permutation.h" 2 3

namespace std { inline namespace __1 {

template <class _Compare, class _BidirectionalIterator>
                              bool
__prev_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last, _Compare __comp)
{
    _BidirectionalIterator __i = __last;
    if (__first == __last || __first == --__i)
        return false;
    while (true)
    {
        _BidirectionalIterator __ip1 = __i;
        if (__comp(*__ip1, *--__i))
        {
            _BidirectionalIterator __j = __last;
            while (!__comp(*--__j, *__i))
                ;
            swap(*__i, *__j);
            std::__1::reverse(__ip1, __last);
            return true;
        }
        if (__i == __first)
        {
            std::__1::reverse(__first, __last);
            return false;
        }
    }
}

template <class _BidirectionalIterator, class _Compare>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
prev_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last, _Compare __comp)
{
    typedef typename __comp_ref_type<_Compare>::type _Comp_ref;
    return std::__1::__prev_permutation<_Comp_ref>(__first, __last, __comp);
}

template <class _BidirectionalIterator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
prev_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last)
{
    return std::__1::prev_permutation(__first, __last,
                                  __less<typename iterator_traits<_BidirectionalIterator>::value_type>());
}

} }
# 722 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/algorithm" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/push_heap.h" 1 3
# 20 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/push_heap.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 24 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/push_heap.h" 2 3

namespace std { inline namespace __1 {

template <class _Compare, class _RandomAccessIterator>
constexpr void
__sift_up(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp,
          typename iterator_traits<_RandomAccessIterator>::difference_type __len)
{
    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;
    if (__len > 1)
    {
        __len = (__len - 2) / 2;
        _RandomAccessIterator __ptr = __first + __len;
        if (__comp(*__ptr, *--__last))
        {
            value_type __t(std::__1::move(*__last));
            do
            {
                *__last = std::__1::move(*__ptr);
                __last = __ptr;
                if (__len == 0)
                    break;
                __len = (__len - 1) / 2;
                __ptr = __first + __len;
            } while (__comp(*__ptr, __t));
            *__last = std::__1::move(__t);
        }
    }
}

template <class _RandomAccessIterator, class _Compare>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void
push_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)
{
    typedef typename __comp_ref_type<_Compare>::type _Comp_ref;
    std::__1::__sift_up<_Comp_ref>(__first, __last, __comp, __last - __first);
}

template <class _RandomAccessIterator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void
push_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
{
    std::__1::push_heap(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());
}

} }
# 723 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/algorithm" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/remove.h" 1 3
# 19 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/remove.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 23 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/remove.h" 2 3

namespace std { inline namespace __1 {

template <class _ForwardIterator, class _Tp>
                                                    _ForwardIterator
remove(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_)
{
    __first = std::__1::find(__first, __last, __value_);
    if (__first != __last)
    {
        _ForwardIterator __i = __first;
        while (++__i != __last)
        {
            if (!(*__i == __value_))
            {
                *__first = std::__1::move(*__i);
                ++__first;
            }
        }
    }
    return __first;
}

} }
# 724 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/algorithm" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/remove_copy.h" 1 3
# 16 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/remove_copy.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 20 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/remove_copy.h" 2 3

namespace std { inline namespace __1 {

template <class _InputIterator, class _OutputIterator, class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
_OutputIterator
remove_copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result, const _Tp& __value_)
{
    for (; __first != __last; ++__first)
    {
        if (!(*__first == __value_))
        {
            *__result = *__first;
            ++__result;
        }
    }
    return __result;
}

} }
# 725 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/algorithm" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/remove_copy_if.h" 1 3
# 16 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/remove_copy_if.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 20 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/remove_copy_if.h" 2 3

namespace std { inline namespace __1 {

template <class _InputIterator, class _OutputIterator, class _Predicate>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
_OutputIterator
remove_copy_if(_InputIterator __first, _InputIterator __last, _OutputIterator __result, _Predicate __pred)
{
    for (; __first != __last; ++__first)
    {
        if (!__pred(*__first))
        {
            *__result = *__first;
            ++__result;
        }
    }
    return __result;
}

} }
# 726 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/algorithm" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/remove_if.h" 1 3
# 15 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/remove_if.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 1 3
# 16 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/remove_if.h" 2 3
# 19 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/remove_if.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 23 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/remove_if.h" 2 3

namespace std { inline namespace __1 {

template <class _ForwardIterator, class _Predicate>
                                                    _ForwardIterator
remove_if(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred)
{
    __first = std::__1::find_if<_ForwardIterator, typename add_lvalue_reference<_Predicate>::type>
                           (__first, __last, __pred);
    if (__first != __last)
    {
        _ForwardIterator __i = __first;
        while (++__i != __last)
        {
            if (!__pred(*__i))
            {
                *__first = std::__1::move(*__i);
                ++__first;
            }
        }
    }
    return __first;
}

} }
# 727 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/algorithm" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/replace.h" 1 3
# 16 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/replace.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 20 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/replace.h" 2 3

namespace std { inline namespace __1 {

template <class _ForwardIterator, class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void
replace(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __old_value, const _Tp& __new_value)
{
    for (; __first != __last; ++__first)
        if (*__first == __old_value)
            *__first = __new_value;
}

} }
# 728 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/algorithm" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/replace_copy.h" 1 3
# 16 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/replace_copy.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 20 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/replace_copy.h" 2 3

namespace std { inline namespace __1 {

template <class _InputIterator, class _OutputIterator, class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
_OutputIterator
replace_copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result,
             const _Tp& __old_value, const _Tp& __new_value)
{
    for (; __first != __last; ++__first, (void) ++__result)
        if (*__first == __old_value)
            *__result = __new_value;
        else
            *__result = *__first;
    return __result;
}

} }
# 729 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/algorithm" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/replace_copy_if.h" 1 3
# 16 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/replace_copy_if.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 20 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/replace_copy_if.h" 2 3

namespace std { inline namespace __1 {

template <class _InputIterator, class _OutputIterator, class _Predicate, class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
_OutputIterator
replace_copy_if(_InputIterator __first, _InputIterator __last, _OutputIterator __result,
                _Predicate __pred, const _Tp& __new_value)
{
    for (; __first != __last; ++__first, (void) ++__result)
        if (__pred(*__first))
            *__result = __new_value;
        else
            *__result = *__first;
    return __result;
}

} }
# 730 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/algorithm" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/replace_if.h" 1 3
# 16 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/replace_if.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 20 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/replace_if.h" 2 3

namespace std { inline namespace __1 {

template <class _ForwardIterator, class _Predicate, class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void
replace_if(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred, const _Tp& __new_value)
{
    for (; __first != __last; ++__first)
        if (__pred(*__first))
            *__first = __new_value;
}

} }
# 731 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/algorithm" 2 3

# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/reverse_copy.h" 1 3
# 16 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/reverse_copy.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 20 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/reverse_copy.h" 2 3

namespace std { inline namespace __1 {

template <class _BidirectionalIterator, class _OutputIterator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
_OutputIterator
reverse_copy(_BidirectionalIterator __first, _BidirectionalIterator __last, _OutputIterator __result)
{
    for (; __first != __last; ++__result)
        *__result = *--__last;
    return __result;
}

} }
# 733 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/algorithm" 2 3

# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/rotate_copy.h" 1 3
# 15 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/rotate_copy.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 1 3
# 16 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/rotate_copy.h" 2 3
# 19 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/rotate_copy.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 23 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/rotate_copy.h" 2 3

namespace std { inline namespace __1 {

template <class _ForwardIterator, class _OutputIterator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
_OutputIterator
rotate_copy(_ForwardIterator __first, _ForwardIterator __middle, _ForwardIterator __last, _OutputIterator __result)
{
    return std::__1::copy(__first, __middle, std::__1::copy(__middle, __last, __result));
}

} }
# 735 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/algorithm" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/sample.h" 1 3
# 14 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/sample.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__random/uniform_int_distribution.h" 1 3
# 18 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__random/uniform_int_distribution.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 1 3
# 19 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__random/uniform_int_distribution.h" 2 3
# 22 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__random/uniform_int_distribution.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 26 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__random/uniform_int_distribution.h" 2 3

namespace std { inline namespace __1 {



template <unsigned long long _Xp, size_t _Rp>
struct __log2_imp
{
    static const size_t value = _Xp & ((unsigned long long)(1) << _Rp) ? _Rp
                                           : __log2_imp<_Xp, _Rp - 1>::value;
};

template <unsigned long long _Xp>
struct __log2_imp<_Xp, 0>
{
    static const size_t value = 0;
};

template <size_t _Rp>
struct __log2_imp<0, _Rp>
{
    static const size_t value = _Rp + 1;
};

template <class _UIntType, _UIntType _Xp>
struct __log2
{
    static const size_t value = __log2_imp<_Xp,
                                         sizeof(_UIntType) * 8 - 1>::value;
};

template<class _Engine, class _UIntType>
class __independent_bits_engine
{
public:

    typedef _UIntType result_type;

private:
    typedef typename _Engine::result_type _Engine_result_type;
    typedef typename conditional
        <
            sizeof(_Engine_result_type) <= sizeof(result_type),
                result_type,
                _Engine_result_type
        >::type _Working_result_type;

    _Engine& __e_;
    size_t __w_;
    size_t __w0_;
    size_t __n_;
    size_t __n0_;
    _Working_result_type __y0_;
    _Working_result_type __y1_;
    _Engine_result_type __mask0_;
    _Engine_result_type __mask1_;





    static constexpr const _Working_result_type _Rp = _Engine::max() - _Engine::min()
                                                      + _Working_result_type(1);

    static constexpr const size_t __m = __log2<_Working_result_type, _Rp>::value;
    static constexpr const size_t _WDt = numeric_limits<_Working_result_type>::digits;
    static constexpr const size_t _EDt = numeric_limits<_Engine_result_type>::digits;

public:

    __independent_bits_engine(_Engine& __e, size_t __w);


    result_type operator()() {return __eval(integral_constant<bool, _Rp != 0>());}

private:
    result_type __eval(false_type);
    result_type __eval(true_type);
};

template<class _Engine, class _UIntType>
__independent_bits_engine<_Engine, _UIntType>
    ::__independent_bits_engine(_Engine& __e, size_t __w)
        : __e_(__e),
          __w_(__w)
{
    __n_ = __w_ / __m + (__w_ % __m != 0);
    __w0_ = __w_ / __n_;
    if (_Rp == 0)
        __y0_ = _Rp;
    else if (__w0_ < _WDt)
        __y0_ = (_Rp >> __w0_) << __w0_;
    else
        __y0_ = 0;
    if (_Rp - __y0_ > __y0_ / __n_)
    {
        ++__n_;
        __w0_ = __w_ / __n_;
        if (__w0_ < _WDt)
            __y0_ = (_Rp >> __w0_) << __w0_;
        else
            __y0_ = 0;
    }
    __n0_ = __n_ - __w_ % __n_;
    if (__w0_ < _WDt - 1)
        __y1_ = (_Rp >> (__w0_ + 1)) << (__w0_ + 1);
    else
        __y1_ = 0;
    __mask0_ = __w0_ > 0 ? _Engine_result_type(~0) >> (_EDt - __w0_) :
                          _Engine_result_type(0);
    __mask1_ = __w0_ < _EDt - 1 ?
                               _Engine_result_type(~0) >> (_EDt - (__w0_ + 1)) :
                               _Engine_result_type(~0);
}

template<class _Engine, class _UIntType>
inline
_UIntType
__independent_bits_engine<_Engine, _UIntType>::__eval(false_type)
{
    return static_cast<result_type>(__e_() & __mask0_);
}

template<class _Engine, class _UIntType>
_UIntType
__independent_bits_engine<_Engine, _UIntType>::__eval(true_type)
{
    const size_t _WRt = numeric_limits<result_type>::digits;
    result_type _Sp = 0;
    for (size_t __k = 0; __k < __n0_; ++__k)
    {
        _Engine_result_type __u;
        do
        {
            __u = __e_() - _Engine::min();
        } while (__u >= __y0_);
        if (__w0_ < _WRt)
            _Sp <<= __w0_;
        else
            _Sp = 0;
        _Sp += __u & __mask0_;
    }
    for (size_t __k = __n0_; __k < __n_; ++__k)
    {
        _Engine_result_type __u;
        do
        {
            __u = __e_() - _Engine::min();
        } while (__u >= __y1_);
        if (__w0_ < _WRt - 1)
            _Sp <<= __w0_ + 1;
        else
            _Sp = 0;
        _Sp += __u & __mask1_;
    }
    return _Sp;
}

template<class _IntType = int>
class uniform_int_distribution
{
public:

    typedef _IntType result_type;

    class param_type
    {
        result_type __a_;
        result_type __b_;
    public:
        typedef uniform_int_distribution distribution_type;

        explicit param_type(result_type __a = 0,
                            result_type __b = numeric_limits<result_type>::max())
            : __a_(__a), __b_(__b) {}

        result_type a() const {return __a_;}
        result_type b() const {return __b_;}

        friend bool operator==(const param_type& __x, const param_type& __y)
            {return __x.__a_ == __y.__a_ && __x.__b_ == __y.__b_;}
        friend bool operator!=(const param_type& __x, const param_type& __y)
            {return !(__x == __y);}
    };

private:
    param_type __p_;

public:


    uniform_int_distribution() : uniform_int_distribution(0) {}
    explicit uniform_int_distribution(
        result_type __a, result_type __b = numeric_limits<result_type>::max())
        : __p_(param_type(__a, __b)) {}






    explicit uniform_int_distribution(const param_type& __p) : __p_(__p) {}
    void reset() {}


    template<class _URNG> result_type operator()(_URNG& __g)
        {return (*this)(__g, __p_);}
    template<class _URNG> result_type operator()(_URNG& __g, const param_type& __p);


    result_type a() const {return __p_.a();}
    result_type b() const {return __p_.b();}

    param_type param() const {return __p_;}
    void param(const param_type& __p) {__p_ = __p;}

    result_type min() const {return a();}
    result_type max() const {return b();}

    friend bool operator==(const uniform_int_distribution& __x,
                           const uniform_int_distribution& __y)
        {return __x.__p_ == __y.__p_;}
    friend bool operator!=(const uniform_int_distribution& __x,
                           const uniform_int_distribution& __y)
            {return !(__x == __y);}
};

template<class _IntType>
template<class _URNG>
typename uniform_int_distribution<_IntType>::result_type
uniform_int_distribution<_IntType>::operator()(_URNG& __g, const param_type& __p)
__attribute__((__no_sanitize__("unsigned-integer-overflow")))
{
    typedef typename conditional<sizeof(result_type) <= sizeof(uint32_t),
                                            uint32_t, uint64_t>::type _UIntType;
    const _UIntType _Rp = _UIntType(__p.b()) - _UIntType(__p.a()) + _UIntType(1);
    if (_Rp == 1)
        return __p.a();
    const size_t _Dt = numeric_limits<_UIntType>::digits;
    typedef __independent_bits_engine<_URNG, _UIntType> _Eng;
    if (_Rp == 0)
        return static_cast<result_type>(_Eng(__g, _Dt)());
    size_t __w = _Dt - __libcpp_clz(_Rp) - 1;
    if ((_Rp & (numeric_limits<_UIntType>::max() >> (_Dt - __w))) != 0)
        ++__w;
    _Eng __e(__g, __w);
    _UIntType __u;
    do
    {
        __u = __e();
    } while (__u >= _Rp);
    return static_cast<result_type>(__u + __p.a());
}

template <class _CharT, class _Traits, class _IT>
basic_ostream<_CharT, _Traits>&
operator<<(basic_ostream<_CharT, _Traits>& __os,
           const uniform_int_distribution<_IT>& __x)
{
    __save_flags<_CharT, _Traits> __lx(__os);
    typedef basic_ostream<_CharT, _Traits> _Ostream;
    __os.flags(_Ostream::dec | _Ostream::left);
    _CharT __sp = __os.widen(' ');
    __os.fill(__sp);
    return __os << __x.a() << __sp << __x.b();
}

template <class _CharT, class _Traits, class _IT>
basic_istream<_CharT, _Traits>&
operator>>(basic_istream<_CharT, _Traits>& __is,
           uniform_int_distribution<_IT>& __x)
{
    typedef uniform_int_distribution<_IT> _Eng;
    typedef typename _Eng::result_type result_type;
    typedef typename _Eng::param_type param_type;
    __save_flags<_CharT, _Traits> __lx(__is);
    typedef basic_istream<_CharT, _Traits> _Istream;
    __is.flags(_Istream::dec | _Istream::skipws);
    result_type __a;
    result_type __b;
    __is >> __a >> __b;
    if (!__is.fail())
        __x.param(param_type(__a, __b));
    return __is;
}

} }
# 15 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/sample.h" 2 3
# 19 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/sample.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 23 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/sample.h" 2 3

namespace std { inline namespace __1 {

template <class _PopulationIterator, class _SampleIterator, class _Distance,
          class _UniformRandomNumberGenerator>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
_SampleIterator __sample(_PopulationIterator __first,
                         _PopulationIterator __last, _SampleIterator __output_iter,
                         _Distance __n,
                         _UniformRandomNumberGenerator & __g,
                         input_iterator_tag) {

  _Distance __k = 0;
  for (; __first != __last && __k < __n; ++__first, (void) ++__k)
    __output_iter[__k] = *__first;
  _Distance __sz = __k;
  for (; __first != __last; ++__first, (void) ++__k) {
    _Distance __r = uniform_int_distribution<_Distance>(0, __k)(__g);
    if (__r < __sz)
      __output_iter[__r] = *__first;
  }
  return __output_iter + std::__1::min(__n, __k);
}

template <class _PopulationIterator, class _SampleIterator, class _Distance,
          class _UniformRandomNumberGenerator>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
_SampleIterator __sample(_PopulationIterator __first,
                         _PopulationIterator __last, _SampleIterator __output_iter,
                         _Distance __n,
                         _UniformRandomNumberGenerator& __g,
                         forward_iterator_tag) {
  _Distance __unsampled_sz = std::__1::distance(__first, __last);
  for (__n = std::__1::min(__n, __unsampled_sz); __n != 0; ++__first) {
    _Distance __r = uniform_int_distribution<_Distance>(0, --__unsampled_sz)(__g);
    if (__r < __n) {
      *__output_iter++ = *__first;
      --__n;
    }
  }
  return __output_iter;
}

template <class _PopulationIterator, class _SampleIterator, class _Distance,
          class _UniformRandomNumberGenerator>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
_SampleIterator __sample(_PopulationIterator __first,
                         _PopulationIterator __last, _SampleIterator __output_iter,
                         _Distance __n, _UniformRandomNumberGenerator& __g) {
  typedef typename iterator_traits<_PopulationIterator>::iterator_category
        _PopCategory;
  typedef typename iterator_traits<_PopulationIterator>::difference_type
        _Difference;
  static_assert(__is_cpp17_forward_iterator<_PopulationIterator>::value ||
                __is_cpp17_random_access_iterator<_SampleIterator>::value,
                "SampleIterator must meet the requirements of RandomAccessIterator");
  typedef typename common_type<_Distance, _Difference>::type _CommonType;
  ((void)0);
  return std::__1::__sample(
      __first, __last, __output_iter, _CommonType(__n),
      __g, _PopCategory());
}


template <class _PopulationIterator, class _SampleIterator, class _Distance,
          class _UniformRandomNumberGenerator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
_SampleIterator sample(_PopulationIterator __first,
                       _PopulationIterator __last, _SampleIterator __output_iter,
                       _Distance __n, _UniformRandomNumberGenerator&& __g) {
    return std::__1::__sample(__first, __last, __output_iter, __n, __g);
}


} }
# 736 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/algorithm" 2 3

# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/search_n.h" 1 3
# 16 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/search_n.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 1 3
# 17 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/search_n.h" 2 3
# 20 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/search_n.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 24 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/search_n.h" 2 3

namespace std { inline namespace __1 {

template <class _BinaryPredicate, class _ForwardIterator, class _Size, class _Tp>
                              _ForwardIterator __search_n(_ForwardIterator __first, _ForwardIterator __last,
                                                          _Size __count, const _Tp& __value_, _BinaryPredicate __pred,
                                                          forward_iterator_tag) {
  if (__count <= 0)
    return __first;
  while (true) {

    while (true) {
      if (__first == __last)
        return __last;
      if (__pred(*__first, __value_))
        break;
      ++__first;
    }

    _ForwardIterator __m = __first;
    _Size __c(0);
    while (true) {
      if (++__c == __count)
        return __first;
      if (++__m == __last)
        return __last;
      if (!__pred(*__m, __value_))
      {
        __first = __m;
        ++__first;
        break;
      }
    }
  }
}

template <class _BinaryPredicate, class _RandomAccessIterator, class _Size, class _Tp>
                              _RandomAccessIterator __search_n(_RandomAccessIterator __first,
                                                               _RandomAccessIterator __last, _Size __count,
                                                               const _Tp& __value_, _BinaryPredicate __pred,
                                                               random_access_iterator_tag) {
  if (__count <= 0)
    return __first;
  _Size __len = static_cast<_Size>(__last - __first);
  if (__len < __count)
    return __last;
  const _RandomAccessIterator __s = __last - (__count - 1);
  while (true) {

    while (true) {
      if (__first >= __s)
        return __last;
      if (__pred(*__first, __value_))
        break;
      ++__first;
    }

    _RandomAccessIterator __m = __first;
    _Size __c(0);
    while (true) {
      if (++__c == __count)
        return __first;
      ++__m;
      if (!__pred(*__m, __value_))
      {
        __first = __m;
        ++__first;
        break;
      }
    }
  }
}

template <class _ForwardIterator, class _Size, class _Tp, class _BinaryPredicate>
                      inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) _ForwardIterator search_n(
    _ForwardIterator __first, _ForwardIterator __last, _Size __count, const _Tp& __value_, _BinaryPredicate __pred) {
  return std::__1::__search_n<typename add_lvalue_reference<_BinaryPredicate>::type>(
      __first, __last, std::__1::__convert_to_integral(__count), __value_, __pred,
      typename iterator_traits<_ForwardIterator>::iterator_category());
}

template <class _ForwardIterator, class _Size, class _Tp>
                      inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) _ForwardIterator
search_n(_ForwardIterator __first, _ForwardIterator __last, _Size __count, const _Tp& __value_) {
  typedef typename iterator_traits<_ForwardIterator>::value_type __v;
  return std::__1::search_n(__first, __last, std::__1::__convert_to_integral(__count), __value_, __equal_to<__v, _Tp>());
}

} }
# 738 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/algorithm" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/set_difference.h" 1 3
# 20 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/set_difference.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 24 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/set_difference.h" 2 3

namespace std { inline namespace __1 {

template <class _Compare, class _InputIterator1, class _InputIterator2, class _OutputIterator>
                              _OutputIterator
__set_difference(_InputIterator1 __first1, _InputIterator1 __last1,
                 _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)
{
    while (__first1 != __last1)
    {
        if (__first2 == __last2)
            return std::__1::copy(__first1, __last1, __result);
        if (__comp(*__first1, *__first2))
        {
            *__result = *__first1;
            ++__result;
            ++__first1;
        }
        else
        {
            if (!__comp(*__first2, *__first1))
                ++__first1;
            ++__first2;
        }
    }
    return __result;
}

template <class _InputIterator1, class _InputIterator2, class _OutputIterator, class _Compare>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
_OutputIterator
set_difference(_InputIterator1 __first1, _InputIterator1 __last1,
               _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)
{
    typedef typename __comp_ref_type<_Compare>::type _Comp_ref;
    return std::__1::__set_difference<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __comp);
}

template <class _InputIterator1, class _InputIterator2, class _OutputIterator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
_OutputIterator
set_difference(_InputIterator1 __first1, _InputIterator1 __last1,
               _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result)
{
    return std::__1::set_difference(__first1, __last1, __first2, __last2, __result,
                                __less<typename iterator_traits<_InputIterator1>::value_type,
                                       typename iterator_traits<_InputIterator2>::value_type>());
}

} }
# 739 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/algorithm" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/set_intersection.h" 1 3
# 19 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/set_intersection.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 23 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/set_intersection.h" 2 3

namespace std { inline namespace __1 {

template <class _Compare, class _InputIterator1, class _InputIterator2, class _OutputIterator>
                              _OutputIterator
__set_intersection(_InputIterator1 __first1, _InputIterator1 __last1,
                   _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)
{
    while (__first1 != __last1 && __first2 != __last2)
    {
        if (__comp(*__first1, *__first2))
            ++__first1;
        else
        {
            if (!__comp(*__first2, *__first1))
            {
                *__result = *__first1;
                ++__result;
                ++__first1;
            }
            ++__first2;
        }
    }
    return __result;
}

template <class _InputIterator1, class _InputIterator2, class _OutputIterator, class _Compare>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
_OutputIterator
set_intersection(_InputIterator1 __first1, _InputIterator1 __last1,
                 _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)
{
    typedef typename __comp_ref_type<_Compare>::type _Comp_ref;
    return std::__1::__set_intersection<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __comp);
}

template <class _InputIterator1, class _InputIterator2, class _OutputIterator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
_OutputIterator
set_intersection(_InputIterator1 __first1, _InputIterator1 __last1,
                 _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result)
{
    return std::__1::set_intersection(__first1, __last1, __first2, __last2, __result,
                                  __less<typename iterator_traits<_InputIterator1>::value_type,
                                         typename iterator_traits<_InputIterator2>::value_type>());
}

} }
# 740 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/algorithm" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/set_symmetric_difference.h" 1 3
# 20 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/set_symmetric_difference.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 24 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/set_symmetric_difference.h" 2 3

namespace std { inline namespace __1 {

template <class _Compare, class _InputIterator1, class _InputIterator2, class _OutputIterator>
                              _OutputIterator
__set_symmetric_difference(_InputIterator1 __first1, _InputIterator1 __last1,
                           _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)
{
    while (__first1 != __last1)
    {
        if (__first2 == __last2)
            return std::__1::copy(__first1, __last1, __result);
        if (__comp(*__first1, *__first2))
        {
            *__result = *__first1;
            ++__result;
            ++__first1;
        }
        else
        {
            if (__comp(*__first2, *__first1))
            {
                *__result = *__first2;
                ++__result;
            }
            else
                ++__first1;
            ++__first2;
        }
    }
    return std::__1::copy(__first2, __last2, __result);
}

template <class _InputIterator1, class _InputIterator2, class _OutputIterator, class _Compare>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
_OutputIterator
set_symmetric_difference(_InputIterator1 __first1, _InputIterator1 __last1,
                         _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)
{
    typedef typename __comp_ref_type<_Compare>::type _Comp_ref;
    return std::__1::__set_symmetric_difference<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __comp);
}

template <class _InputIterator1, class _InputIterator2, class _OutputIterator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
_OutputIterator
set_symmetric_difference(_InputIterator1 __first1, _InputIterator1 __last1,
                         _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result)
{
    return std::__1::set_symmetric_difference(__first1, __last1, __first2, __last2, __result,
                                          __less<typename iterator_traits<_InputIterator1>::value_type,
                                                 typename iterator_traits<_InputIterator2>::value_type>());
}

} }
# 741 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/algorithm" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/set_union.h" 1 3
# 20 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/set_union.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 24 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/set_union.h" 2 3

namespace std { inline namespace __1 {

template <class _Compare, class _InputIterator1, class _InputIterator2, class _OutputIterator>
                              _OutputIterator
__set_union(_InputIterator1 __first1, _InputIterator1 __last1,
            _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)
{
    for (; __first1 != __last1; ++__result)
    {
        if (__first2 == __last2)
            return std::__1::copy(__first1, __last1, __result);
        if (__comp(*__first2, *__first1))
        {
            *__result = *__first2;
            ++__first2;
        }
        else
        {
            if (!__comp(*__first1, *__first2))
                ++__first2;
            *__result = *__first1;
            ++__first1;
        }
    }
    return std::__1::copy(__first2, __last2, __result);
}

template <class _InputIterator1, class _InputIterator2, class _OutputIterator, class _Compare>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
_OutputIterator
set_union(_InputIterator1 __first1, _InputIterator1 __last1,
          _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)
{
    typedef typename __comp_ref_type<_Compare>::type _Comp_ref;
    return std::__1::__set_union<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __comp);
}

template <class _InputIterator1, class _InputIterator2, class _OutputIterator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
_OutputIterator
set_union(_InputIterator1 __first1, _InputIterator1 __last1,
          _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result)
{
    return std::__1::set_union(__first1, __last1, __first2, __last2, __result,
                          __less<typename iterator_traits<_InputIterator1>::value_type,
                                 typename iterator_traits<_InputIterator2>::value_type>());
}

} }
# 742 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/algorithm" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/shift_left.h" 1 3
# 15 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/shift_left.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 1 3
# 16 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/shift_left.h" 2 3
# 19 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/shift_left.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 23 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/shift_left.h" 2 3

namespace std { inline namespace __1 {
# 57 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/shift_left.h" 3
} }
# 743 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/algorithm" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/shift_right.h" 1 3
# 17 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/shift_right.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 1 3
# 18 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/shift_right.h" 2 3
# 21 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/shift_right.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 25 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/shift_right.h" 2 3

namespace std { inline namespace __1 {
# 102 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/shift_right.h" 3
} }
# 744 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/algorithm" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/shuffle.h" 1 3
# 21 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/shuffle.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 25 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/shuffle.h" 2 3

namespace std { inline namespace __1 {
# 103 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/shuffle.h" 3
template<class _RandomAccessIterator, class _UniformRandomNumberGenerator>
    void shuffle(_RandomAccessIterator __first, _RandomAccessIterator __last,
                 _UniformRandomNumberGenerator&& __g)
{
    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;
    typedef uniform_int_distribution<ptrdiff_t> _Dp;
    typedef typename _Dp::param_type _Pp;
    difference_type __d = __last - __first;
    if (__d > 1)
    {
        _Dp __uid;
        for (--__last, (void) --__d; __first < __last; ++__first, (void) --__d)
        {
            difference_type __i = __uid(__g, _Pp(0, __d));
            if (__i != difference_type(0))
                swap(*__first, *(__first + __i));
        }
    }
}

} }
# 745 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/algorithm" 2 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/stable_partition.h" 1 3
# 16 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/stable_partition.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/memory" 1 3
# 974 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/memory" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 1 3
# 20 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/assert.h" 1 3 4
# 44 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/assert.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/stdlib.h" 1 3 4
# 45 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/assert.h" 2 3 4
# 81 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/assert.h" 3 4
extern "C" {
void __assert_rtn(const char *, const char *, int, const char *) __attribute__((__noreturn__)) __attribute__((__cold__)) __attribute__((__disable_tail_calls__));



}
# 21 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 2 3
# 24 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 3
# 975 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/memory" 2 3
# 17 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/stable_partition.h" 2 3
# 20 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/stable_partition.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 24 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/stable_partition.h" 2 3

namespace std { inline namespace __1 {

template <class _Predicate, class _ForwardIterator, class _Distance, class _Pair>
_ForwardIterator
__stable_partition(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred,
                   _Distance __len, _Pair __p, forward_iterator_tag __fit)
{


    if (__len == 1)
        return __first;
    if (__len == 2)
    {
        _ForwardIterator __m = __first;
        if (__pred(*++__m))
        {
            swap(*__first, *__m);
            return __m;
        }
        return __first;
    }
    if (__len <= __p.second)
    {
        typedef typename iterator_traits<_ForwardIterator>::value_type value_type;
        __destruct_n __d(0);
        unique_ptr<value_type, __destruct_n&> __h(__p.first, __d);


        value_type* __t = __p.first;
        ::new ((void*)__t) value_type(std::__1::move(*__first));
        __d.template __incr<value_type>();
        ++__t;
        _ForwardIterator __i = __first;
        while (++__i != __last)
        {
            if (__pred(*__i))
            {
                *__first = std::__1::move(*__i);
                ++__first;
            }
            else
            {
                ::new ((void*)__t) value_type(std::__1::move(*__i));
                __d.template __incr<value_type>();
                ++__t;
            }
        }


        __i = __first;
        for (value_type* __t2 = __p.first; __t2 < __t; ++__t2, (void) ++__i)
            *__i = std::__1::move(*__t2);

        return __first;
    }


    _ForwardIterator __m = __first;
    _Distance __len2 = __len / 2;
    std::__1::advance(__m, __len2);



    typedef typename add_lvalue_reference<_Predicate>::type _PredRef;
    _ForwardIterator __first_false = std::__1::__stable_partition<_PredRef>(__first, __m, __pred, __len2, __p, __fit);



    _ForwardIterator __m1 = __m;
    _ForwardIterator __second_false = __last;
    _Distance __len_half = __len - __len2;
    while (__pred(*__m1))
    {
        if (++__m1 == __last)
            goto __second_half_done;
        --__len_half;
    }


    __second_false = std::__1::__stable_partition<_PredRef>(__m1, __last, __pred, __len_half, __p, __fit);
__second_half_done:


    return std::__1::rotate(__first_false, __m, __second_false);


}

template <class _Predicate, class _ForwardIterator>
_ForwardIterator
__stable_partition(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred,
                   forward_iterator_tag)
{
    const unsigned __alloc_limit = 3;

    while (true)
    {
        if (__first == __last)
            return __first;
        if (!__pred(*__first))
            break;
        ++__first;
    }


    typedef typename iterator_traits<_ForwardIterator>::difference_type difference_type;
    typedef typename iterator_traits<_ForwardIterator>::value_type value_type;
    difference_type __len = std::__1::distance(__first, __last);
    pair<value_type*, ptrdiff_t> __p(0, 0);
    unique_ptr<value_type, __return_temporary_buffer> __h;
    if (__len >= __alloc_limit)
    {
        __p = std::__1::get_temporary_buffer<value_type>(__len);
        __h.reset(__p.first);
    }
    return std::__1::__stable_partition<typename add_lvalue_reference<_Predicate>::type>
                             (__first, __last, __pred, __len, __p, forward_iterator_tag());
}

template <class _Predicate, class _BidirectionalIterator, class _Distance, class _Pair>
_BidirectionalIterator
__stable_partition(_BidirectionalIterator __first, _BidirectionalIterator __last, _Predicate __pred,
                   _Distance __len, _Pair __p, bidirectional_iterator_tag __bit)
{



    if (__len == 2)
    {
        swap(*__first, *__last);
        return __last;
    }
    if (__len == 3)
    {
        _BidirectionalIterator __m = __first;
        if (__pred(*++__m))
        {
            swap(*__first, *__m);
            swap(*__m, *__last);
            return __last;
        }
        swap(*__m, *__last);
        swap(*__first, *__m);
        return __m;
    }
    if (__len <= __p.second)
    {
        typedef typename iterator_traits<_BidirectionalIterator>::value_type value_type;
        __destruct_n __d(0);
        unique_ptr<value_type, __destruct_n&> __h(__p.first, __d);


        value_type* __t = __p.first;
        ::new ((void*)__t) value_type(std::__1::move(*__first));
        __d.template __incr<value_type>();
        ++__t;
        _BidirectionalIterator __i = __first;
        while (++__i != __last)
        {
            if (__pred(*__i))
            {
                *__first = std::__1::move(*__i);
                ++__first;
            }
            else
            {
                ::new ((void*)__t) value_type(std::__1::move(*__i));
                __d.template __incr<value_type>();
                ++__t;
            }
        }

        *__first = std::__1::move(*__i);
        __i = ++__first;


        for (value_type* __t2 = __p.first; __t2 < __t; ++__t2, (void) ++__i)
            *__i = std::__1::move(*__t2);

        return __first;
    }


    _BidirectionalIterator __m = __first;
    _Distance __len2 = __len / 2;
    std::__1::advance(__m, __len2);



    _BidirectionalIterator __m1 = __m;
    _BidirectionalIterator __first_false = __first;
    _Distance __len_half = __len2;
    while (!__pred(*--__m1))
    {
        if (__m1 == __first)
            goto __first_half_done;
        --__len_half;
    }


    typedef typename add_lvalue_reference<_Predicate>::type _PredRef;
    __first_false = std::__1::__stable_partition<_PredRef>(__first, __m1, __pred, __len_half, __p, __bit);
__first_half_done:



    __m1 = __m;
    _BidirectionalIterator __second_false = __last;
    ++__second_false;
    __len_half = __len - __len2;
    while (__pred(*__m1))
    {
        if (++__m1 == __last)
            goto __second_half_done;
        --__len_half;
    }


    __second_false = std::__1::__stable_partition<_PredRef>(__m1, __last, __pred, __len_half, __p, __bit);
__second_half_done:


    return std::__1::rotate(__first_false, __m, __second_false);


}

template <class _Predicate, class _BidirectionalIterator>
_BidirectionalIterator
__stable_partition(_BidirectionalIterator __first, _BidirectionalIterator __last, _Predicate __pred,
                   bidirectional_iterator_tag)
{
    typedef typename iterator_traits<_BidirectionalIterator>::difference_type difference_type;
    typedef typename iterator_traits<_BidirectionalIterator>::value_type value_type;
    const difference_type __alloc_limit = 4;

    while (true)
    {
        if (__first == __last)
            return __first;
        if (!__pred(*__first))
            break;
        ++__first;
    }


    do
    {
        if (__first == --__last)
            return __first;
    } while (!__pred(*__last));




    difference_type __len = std::__1::distance(__first, __last) + 1;
    pair<value_type*, ptrdiff_t> __p(0, 0);
    unique_ptr<value_type, __return_temporary_buffer> __h;
    if (__len >= __alloc_limit)
    {
        __p = std::__1::get_temporary_buffer<value_type>(__len);
        __h.reset(__p.first);
    }
    return std::__1::__stable_partition<typename add_lvalue_reference<_Predicate>::type>
                             (__first, __last, __pred, __len, __p, bidirectional_iterator_tag());
}

template <class _ForwardIterator, class _Predicate>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
_ForwardIterator
stable_partition(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred)
{
    return std::__1::__stable_partition<typename add_lvalue_reference<_Predicate>::type>
                             (__first, __last, __pred, typename iterator_traits<_ForwardIterator>::iterator_category());
}

} }
# 749 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/algorithm" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/stable_sort.h" 1 3
# 19 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/stable_sort.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/memory" 1 3
# 974 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/memory" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 1 3
# 20 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/assert.h" 1 3 4
# 44 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/assert.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/stdlib.h" 1 3 4
# 45 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/assert.h" 2 3 4
# 81 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/assert.h" 3 4
extern "C" {
void __assert_rtn(const char *, const char *, int, const char *) __attribute__((__noreturn__)) __attribute__((__cold__)) __attribute__((__disable_tail_calls__));



}
# 21 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 2 3
# 24 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 3
# 975 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/memory" 2 3
# 20 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/stable_sort.h" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 1 3
# 21 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/stable_sort.h" 2 3
# 24 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/stable_sort.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 28 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/stable_sort.h" 2 3

namespace std { inline namespace __1 {

template <class _Compare, class _InputIterator1, class _InputIterator2>
void
__merge_move_construct(_InputIterator1 __first1, _InputIterator1 __last1,
        _InputIterator2 __first2, _InputIterator2 __last2,
        typename iterator_traits<_InputIterator1>::value_type* __result, _Compare __comp)
{
    typedef typename iterator_traits<_InputIterator1>::value_type value_type;
    __destruct_n __d(0);
    unique_ptr<value_type, __destruct_n&> __h(__result, __d);
    for (; true; ++__result)
    {
        if (__first1 == __last1)
        {
            for (; __first2 != __last2; ++__first2, ++__result, (void)__d.template __incr<value_type>())
                ::new ((void*)__result) value_type(std::__1::move(*__first2));
            __h.release();
            return;
        }
        if (__first2 == __last2)
        {
            for (; __first1 != __last1; ++__first1, ++__result, (void)__d.template __incr<value_type>())
                ::new ((void*)__result) value_type(std::__1::move(*__first1));
            __h.release();
            return;
        }
        if (__comp(*__first2, *__first1))
        {
            ::new ((void*)__result) value_type(std::__1::move(*__first2));
            __d.template __incr<value_type>();
            ++__first2;
        }
        else
        {
            ::new ((void*)__result) value_type(std::__1::move(*__first1));
            __d.template __incr<value_type>();
            ++__first1;
        }
    }
}

template <class _Compare, class _InputIterator1, class _InputIterator2, class _OutputIterator>
void
__merge_move_assign(_InputIterator1 __first1, _InputIterator1 __last1,
        _InputIterator2 __first2, _InputIterator2 __last2,
        _OutputIterator __result, _Compare __comp)
{
    for (; __first1 != __last1; ++__result)
    {
        if (__first2 == __last2)
        {
            for (; __first1 != __last1; ++__first1, (void) ++__result)
                *__result = std::__1::move(*__first1);
            return;
        }
        if (__comp(*__first2, *__first1))
        {
            *__result = std::__1::move(*__first2);
            ++__first2;
        }
        else
        {
            *__result = std::__1::move(*__first1);
            ++__first1;
        }
    }
    for (; __first2 != __last2; ++__first2, (void) ++__result)
        *__result = std::__1::move(*__first2);
}

template <class _Compare, class _RandomAccessIterator>
void
__stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp,
              typename iterator_traits<_RandomAccessIterator>::difference_type __len,
              typename iterator_traits<_RandomAccessIterator>::value_type* __buff, ptrdiff_t __buff_size);

template <class _Compare, class _RandomAccessIterator>
void
__stable_sort_move(_RandomAccessIterator __first1, _RandomAccessIterator __last1, _Compare __comp,
                   typename iterator_traits<_RandomAccessIterator>::difference_type __len,
                   typename iterator_traits<_RandomAccessIterator>::value_type* __first2)
{
    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;
    switch (__len)
    {
    case 0:
        return;
    case 1:
        ::new ((void*)__first2) value_type(std::__1::move(*__first1));
        return;
    case 2:
        __destruct_n __d(0);
        unique_ptr<value_type, __destruct_n&> __h2(__first2, __d);
        if (__comp(*--__last1, *__first1))
        {
            ::new ((void*)__first2) value_type(std::__1::move(*__last1));
            __d.template __incr<value_type>();
            ++__first2;
            ::new ((void*)__first2) value_type(std::__1::move(*__first1));
        }
        else
        {
            ::new ((void*)__first2) value_type(std::__1::move(*__first1));
            __d.template __incr<value_type>();
            ++__first2;
            ::new ((void*)__first2) value_type(std::__1::move(*__last1));
        }
        __h2.release();
        return;
    }
    if (__len <= 8)
    {
        std::__1::__insertion_sort_move<_Compare>(__first1, __last1, __first2, __comp);
        return;
    }
    typename iterator_traits<_RandomAccessIterator>::difference_type __l2 = __len / 2;
    _RandomAccessIterator __m = __first1 + __l2;
    std::__1::__stable_sort<_Compare>(__first1, __m, __comp, __l2, __first2, __l2);
    std::__1::__stable_sort<_Compare>(__m, __last1, __comp, __len - __l2, __first2 + __l2, __len - __l2);
    std::__1::__merge_move_construct<_Compare>(__first1, __m, __m, __last1, __first2, __comp);
}

template <class _Tp>
struct __stable_sort_switch
{
    static const unsigned value = 128*is_trivially_copy_assignable<_Tp>::value;
};

template <class _Compare, class _RandomAccessIterator>
void
__stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp,
              typename iterator_traits<_RandomAccessIterator>::difference_type __len,
              typename iterator_traits<_RandomAccessIterator>::value_type* __buff, ptrdiff_t __buff_size)
{
    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;
    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;
    switch (__len)
    {
    case 0:
    case 1:
        return;
    case 2:
        if (__comp(*--__last, *__first))
            swap(*__first, *__last);
        return;
    }
    if (__len <= static_cast<difference_type>(__stable_sort_switch<value_type>::value))
    {
        std::__1::__insertion_sort<_Compare>(__first, __last, __comp);
        return;
    }
    typename iterator_traits<_RandomAccessIterator>::difference_type __l2 = __len / 2;
    _RandomAccessIterator __m = __first + __l2;
    if (__len <= __buff_size)
    {
        __destruct_n __d(0);
        unique_ptr<value_type, __destruct_n&> __h2(__buff, __d);
        std::__1::__stable_sort_move<_Compare>(__first, __m, __comp, __l2, __buff);
        __d.__set(__l2, (value_type*)nullptr);
        std::__1::__stable_sort_move<_Compare>(__m, __last, __comp, __len - __l2, __buff + __l2);
        __d.__set(__len, (value_type*)nullptr);
        std::__1::__merge_move_assign<_Compare>(__buff, __buff + __l2, __buff + __l2, __buff + __len, __first, __comp);





        return;
    }
    std::__1::__stable_sort<_Compare>(__first, __m, __comp, __l2, __buff, __buff_size);
    std::__1::__stable_sort<_Compare>(__m, __last, __comp, __len - __l2, __buff, __buff_size);
    std::__1::__inplace_merge<_Compare>(__first, __m, __last, __comp, __l2, __len - __l2, __buff, __buff_size);
}

template <class _RandomAccessIterator, class _Compare>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void
stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)
{
    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;
    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;
    difference_type __len = __last - __first;
    pair<value_type*, ptrdiff_t> __buf(0, 0);
    unique_ptr<value_type, __return_temporary_buffer> __h;
    if (__len > static_cast<difference_type>(__stable_sort_switch<value_type>::value))
    {
        __buf = std::__1::get_temporary_buffer<value_type>(__len);
        __h.reset(__buf.first);
    }
    typedef typename __comp_ref_type<_Compare>::type _Comp_ref;
    std::__1::__stable_sort<_Comp_ref>(__first, __last, __comp, __len, __buf.first, __buf.second);
}

template <class _RandomAccessIterator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void
stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last)
{
    std::__1::stable_sort(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());
}

} }
# 750 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/algorithm" 2 3

# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/transform.h" 1 3
# 16 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/transform.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 20 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/transform.h" 2 3

namespace std { inline namespace __1 {

template <class _InputIterator, class _OutputIterator, class _UnaryOperation>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
_OutputIterator
transform(_InputIterator __first, _InputIterator __last, _OutputIterator __result, _UnaryOperation __op)
{
    for (; __first != __last; ++__first, (void) ++__result)
        *__result = __op(*__first);
    return __result;
}

template <class _InputIterator1, class _InputIterator2, class _OutputIterator, class _BinaryOperation>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
_OutputIterator
transform(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2,
          _OutputIterator __result, _BinaryOperation __binary_op)
{
    for (; __first1 != __last1; ++__first1, (void) ++__first2, ++__result)
        *__result = __binary_op(*__first1, *__first2);
    return __result;
}

} }
# 752 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/algorithm" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/unique_copy.h" 1 3
# 16 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/unique_copy.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 1 3
# 17 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/unique_copy.h" 2 3
# 20 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/unique_copy.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 24 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/unique_copy.h" 2 3

namespace std { inline namespace __1 {

template <class _BinaryPredicate, class _InputIterator, class _OutputIterator>
                              _OutputIterator
__unique_copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result, _BinaryPredicate __pred,
              input_iterator_tag, output_iterator_tag)
{
    if (__first != __last)
    {
        typename iterator_traits<_InputIterator>::value_type __t(*__first);
        *__result = __t;
        ++__result;
        while (++__first != __last)
        {
            if (!__pred(__t, *__first))
            {
                __t = *__first;
                *__result = __t;
                ++__result;
            }
        }
    }
    return __result;
}

template <class _BinaryPredicate, class _ForwardIterator, class _OutputIterator>
                              _OutputIterator
__unique_copy(_ForwardIterator __first, _ForwardIterator __last, _OutputIterator __result, _BinaryPredicate __pred,
              forward_iterator_tag, output_iterator_tag)
{
    if (__first != __last)
    {
        _ForwardIterator __i = __first;
        *__result = *__i;
        ++__result;
        while (++__first != __last)
        {
            if (!__pred(*__i, *__first))
            {
                *__result = *__first;
                ++__result;
                __i = __first;
            }
        }
    }
    return __result;
}

template <class _BinaryPredicate, class _InputIterator, class _ForwardIterator>
                              _ForwardIterator
__unique_copy(_InputIterator __first, _InputIterator __last, _ForwardIterator __result, _BinaryPredicate __pred,
              input_iterator_tag, forward_iterator_tag)
{
    if (__first != __last)
    {
        *__result = *__first;
        while (++__first != __last)
            if (!__pred(*__result, *__first))
                *++__result = *__first;
        ++__result;
    }
    return __result;
}

template <class _InputIterator, class _OutputIterator, class _BinaryPredicate>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
_OutputIterator
unique_copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result, _BinaryPredicate __pred)
{
    return std::__1::__unique_copy<typename add_lvalue_reference<_BinaryPredicate>::type>
                              (__first, __last, __result, __pred,
                               typename iterator_traits<_InputIterator>::iterator_category(),
                               typename iterator_traits<_OutputIterator>::iterator_category());
}

template <class _InputIterator, class _OutputIterator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
_OutputIterator
unique_copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result)
{
    typedef typename iterator_traits<_InputIterator>::value_type __v;
    return std::__1::unique_copy(__first, __last, __result, __equal_to<__v>());
}


} }
# 753 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/algorithm" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/unique.h" 1 3
# 17 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/unique.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 1 3
# 18 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/unique.h" 2 3
# 21 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/unique.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 25 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/unique.h" 2 3

namespace std { inline namespace __1 {



template <class _ForwardIterator, class _BinaryPredicate>
                                                    _ForwardIterator
unique(_ForwardIterator __first, _ForwardIterator __last, _BinaryPredicate __pred)
{
    __first = std::__1::adjacent_find<_ForwardIterator, typename add_lvalue_reference<_BinaryPredicate>::type>
                                 (__first, __last, __pred);
    if (__first != __last)
    {


        _ForwardIterator __i = __first;
        for (++__i; ++__i != __last;)
            if (!__pred(*__first, *__i))
                *++__first = std::__1::move(*__i);
        ++__first;
    }
    return __first;
}

template <class _ForwardIterator>
                      inline
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
_ForwardIterator
unique(_ForwardIterator __first, _ForwardIterator __last)
{
    typedef typename iterator_traits<_ForwardIterator>::value_type __v;
    return std::__1::unique(__first, __last, __equal_to<__v>());
}

} }
# 754 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/algorithm" 2 3
# 759 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/algorithm" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 763 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/algorithm" 2 3
# 16 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__bit_reference" 2 3
# 19 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__bit_reference" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 23 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__bit_reference" 2 3


namespace std { inline namespace __1 {

template <class _Cp, bool _IsConst, typename _Cp::__storage_type = 0> class __bit_iterator;
template <class _Cp> class __bit_const_reference;

template <class _Tp>
struct __has_storage_type
{
    static const bool value = false;
};

template <class _Cp, bool = __has_storage_type<_Cp>::value>
class __bit_reference
{
    typedef typename _Cp::__storage_type __storage_type;
    typedef typename _Cp::__storage_pointer __storage_pointer;

    __storage_pointer __seg_;
    __storage_type __mask_;

    friend typename _Cp::__self;

    friend class __bit_const_reference<_Cp>;
    friend class __bit_iterator<_Cp, false>;
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __bit_reference(const __bit_reference&) = default;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) operator bool() const noexcept
        {return static_cast<bool>(*__seg_ & __mask_);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) bool operator ~() const noexcept
        {return !static_cast<bool>(*this);}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __bit_reference& operator=(bool __x) noexcept
    {
        if (__x)
            *__seg_ |= __mask_;
        else
            *__seg_ &= ~__mask_;
        return *this;
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __bit_reference& operator=(const __bit_reference& __x) noexcept
        {return operator=(static_cast<bool>(__x));}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) void flip() noexcept {*__seg_ ^= __mask_;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) __bit_iterator<_Cp, false> operator&() const noexcept
        {return __bit_iterator<_Cp, false>(__seg_, static_cast<unsigned>(__libcpp_ctz(__mask_)));}
private:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __bit_reference(__storage_pointer __s, __storage_type __m) noexcept
        : __seg_(__s), __mask_(__m) {}
};

template <class _Cp>
class __bit_reference<_Cp, false>
{
};

template <class _Cp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void
swap(__bit_reference<_Cp> __x, __bit_reference<_Cp> __y) noexcept
{
    bool __t = __x;
    __x = __y;
    __y = __t;
}

template <class _Cp, class _Dp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void
swap(__bit_reference<_Cp> __x, __bit_reference<_Dp> __y) noexcept
{
    bool __t = __x;
    __x = __y;
    __y = __t;
}

template <class _Cp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void
swap(__bit_reference<_Cp> __x, bool& __y) noexcept
{
    bool __t = __x;
    __x = __y;
    __y = __t;
}

template <class _Cp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void
swap(bool& __x, __bit_reference<_Cp> __y) noexcept
{
    bool __t = __x;
    __x = __y;
    __y = __t;
}

template <class _Cp>
class __bit_const_reference
{
    typedef typename _Cp::__storage_type __storage_type;
    typedef typename _Cp::__const_storage_pointer __storage_pointer;

    __storage_pointer __seg_;
    __storage_type __mask_;

    friend typename _Cp::__self;
    friend class __bit_iterator<_Cp, true>;
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __bit_const_reference(const __bit_const_reference&) = default;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __bit_const_reference(const __bit_reference<_Cp>& __x) noexcept
        : __seg_(__x.__seg_), __mask_(__x.__mask_) {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr operator bool() const noexcept
        {return static_cast<bool>(*__seg_ & __mask_);}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) __bit_iterator<_Cp, true> operator&() const noexcept
        {return __bit_iterator<_Cp, true>(__seg_, static_cast<unsigned>(__libcpp_ctz(__mask_)));}
private:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    constexpr
    __bit_const_reference(__storage_pointer __s, __storage_type __m) noexcept
        : __seg_(__s), __mask_(__m) {}

    __bit_const_reference& operator=(const __bit_const_reference&) = delete;
};



template <class _Cp, bool _IsConst>
__bit_iterator<_Cp, _IsConst>
__find_bool_true(__bit_iterator<_Cp, _IsConst> __first, typename _Cp::size_type __n)
{
    typedef __bit_iterator<_Cp, _IsConst> _It;
    typedef typename _It::__storage_type __storage_type;
    static const int __bits_per_word = _It::__bits_per_word;

    if (__first.__ctz_ != 0)
    {
        __storage_type __clz_f = static_cast<__storage_type>(__bits_per_word - __first.__ctz_);
        __storage_type __dn = std::__1::min(__clz_f, __n);
        __storage_type __m = (~__storage_type(0) << __first.__ctz_) & (~__storage_type(0) >> (__clz_f - __dn));
        __storage_type __b = *__first.__seg_ & __m;
        if (__b)
            return _It(__first.__seg_, static_cast<unsigned>(std::__1::__libcpp_ctz(__b)));
        if (__n == __dn)
            return __first + __n;
        __n -= __dn;
        ++__first.__seg_;
    }

    for (; __n >= __bits_per_word; ++__first.__seg_, __n -= __bits_per_word)
        if (*__first.__seg_)
            return _It(__first.__seg_, static_cast<unsigned>(std::__1::__libcpp_ctz(*__first.__seg_)));

    if (__n > 0)
    {
        __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
        __storage_type __b = *__first.__seg_ & __m;
        if (__b)
            return _It(__first.__seg_, static_cast<unsigned>(std::__1::__libcpp_ctz(__b)));
    }
    return _It(__first.__seg_, static_cast<unsigned>(__n));
}

template <class _Cp, bool _IsConst>
__bit_iterator<_Cp, _IsConst>
__find_bool_false(__bit_iterator<_Cp, _IsConst> __first, typename _Cp::size_type __n)
{
    typedef __bit_iterator<_Cp, _IsConst> _It;
    typedef typename _It::__storage_type __storage_type;
    const int __bits_per_word = _It::__bits_per_word;

    if (__first.__ctz_ != 0)
    {
        __storage_type __clz_f = static_cast<__storage_type>(__bits_per_word - __first.__ctz_);
        __storage_type __dn = std::__1::min(__clz_f, __n);
        __storage_type __m = (~__storage_type(0) << __first.__ctz_) & (~__storage_type(0) >> (__clz_f - __dn));
        __storage_type __b = ~*__first.__seg_ & __m;
        if (__b)
            return _It(__first.__seg_, static_cast<unsigned>(std::__1::__libcpp_ctz(__b)));
        if (__n == __dn)
            return __first + __n;
        __n -= __dn;
        ++__first.__seg_;
    }

    for (; __n >= __bits_per_word; ++__first.__seg_, __n -= __bits_per_word)
    {
        __storage_type __b = ~*__first.__seg_;
        if (__b)
            return _It(__first.__seg_, static_cast<unsigned>(std::__1::__libcpp_ctz(__b)));
    }

    if (__n > 0)
    {
        __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
        __storage_type __b = ~*__first.__seg_ & __m;
        if (__b)
            return _It(__first.__seg_, static_cast<unsigned>(std::__1::__libcpp_ctz(__b)));
    }
    return _It(__first.__seg_, static_cast<unsigned>(__n));
}

template <class _Cp, bool _IsConst, class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
__bit_iterator<_Cp, _IsConst>
find(__bit_iterator<_Cp, _IsConst> __first, __bit_iterator<_Cp, _IsConst> __last, const _Tp& __value_)
{
    if (static_cast<bool>(__value_))
        return std::__1::__find_bool_true(__first, static_cast<typename _Cp::size_type>(__last - __first));
    return std::__1::__find_bool_false(__first, static_cast<typename _Cp::size_type>(__last - __first));
}



template <class _Cp, bool _IsConst>
typename __bit_iterator<_Cp, _IsConst>::difference_type
__count_bool_true(__bit_iterator<_Cp, _IsConst> __first, typename _Cp::size_type __n)
{
    typedef __bit_iterator<_Cp, _IsConst> _It;
    typedef typename _It::__storage_type __storage_type;
    typedef typename _It::difference_type difference_type;
    const int __bits_per_word = _It::__bits_per_word;
    difference_type __r = 0;

    if (__first.__ctz_ != 0)
    {
        __storage_type __clz_f = static_cast<__storage_type>(__bits_per_word - __first.__ctz_);
        __storage_type __dn = std::__1::min(__clz_f, __n);
        __storage_type __m = (~__storage_type(0) << __first.__ctz_) & (~__storage_type(0) >> (__clz_f - __dn));
        __r = std::__1::__libcpp_popcount(*__first.__seg_ & __m);
        __n -= __dn;
        ++__first.__seg_;
    }

    for (; __n >= __bits_per_word; ++__first.__seg_, __n -= __bits_per_word)
        __r += std::__1::__libcpp_popcount(*__first.__seg_);

    if (__n > 0)
    {
        __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
        __r += std::__1::__libcpp_popcount(*__first.__seg_ & __m);
    }
    return __r;
}

template <class _Cp, bool _IsConst>
typename __bit_iterator<_Cp, _IsConst>::difference_type
__count_bool_false(__bit_iterator<_Cp, _IsConst> __first, typename _Cp::size_type __n)
{
    typedef __bit_iterator<_Cp, _IsConst> _It;
    typedef typename _It::__storage_type __storage_type;
    typedef typename _It::difference_type difference_type;
    const int __bits_per_word = _It::__bits_per_word;
    difference_type __r = 0;

    if (__first.__ctz_ != 0)
    {
        __storage_type __clz_f = static_cast<__storage_type>(__bits_per_word - __first.__ctz_);
        __storage_type __dn = std::__1::min(__clz_f, __n);
        __storage_type __m = (~__storage_type(0) << __first.__ctz_) & (~__storage_type(0) >> (__clz_f - __dn));
        __r = std::__1::__libcpp_popcount(~*__first.__seg_ & __m);
        __n -= __dn;
        ++__first.__seg_;
    }

    for (; __n >= __bits_per_word; ++__first.__seg_, __n -= __bits_per_word)
        __r += std::__1::__libcpp_popcount(~*__first.__seg_);

    if (__n > 0)
    {
        __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
        __r += std::__1::__libcpp_popcount(~*__first.__seg_ & __m);
    }
    return __r;
}

template <class _Cp, bool _IsConst, class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename __bit_iterator<_Cp, _IsConst>::difference_type
count(__bit_iterator<_Cp, _IsConst> __first, __bit_iterator<_Cp, _IsConst> __last, const _Tp& __value_)
{
    if (static_cast<bool>(__value_))
        return std::__1::__count_bool_true(__first, static_cast<typename _Cp::size_type>(__last - __first));
    return std::__1::__count_bool_false(__first, static_cast<typename _Cp::size_type>(__last - __first));
}



template <class _Cp>
void
__fill_n_false(__bit_iterator<_Cp, false> __first, typename _Cp::size_type __n)
{
    typedef __bit_iterator<_Cp, false> _It;
    typedef typename _It::__storage_type __storage_type;
    const int __bits_per_word = _It::__bits_per_word;

    if (__first.__ctz_ != 0)
    {
        __storage_type __clz_f = static_cast<__storage_type>(__bits_per_word - __first.__ctz_);
        __storage_type __dn = std::__1::min(__clz_f, __n);
        __storage_type __m = (~__storage_type(0) << __first.__ctz_) & (~__storage_type(0) >> (__clz_f - __dn));
        *__first.__seg_ &= ~__m;
        __n -= __dn;
        ++__first.__seg_;
    }

    __storage_type __nw = __n / __bits_per_word;
    std::__1::memset(std::__1::__to_address(__first.__seg_), 0, __nw * sizeof(__storage_type));
    __n -= __nw * __bits_per_word;

    if (__n > 0)
    {
        __first.__seg_ += __nw;
        __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
        *__first.__seg_ &= ~__m;
    }
}

template <class _Cp>
void
__fill_n_true(__bit_iterator<_Cp, false> __first, typename _Cp::size_type __n)
{
    typedef __bit_iterator<_Cp, false> _It;
    typedef typename _It::__storage_type __storage_type;
    const int __bits_per_word = _It::__bits_per_word;

    if (__first.__ctz_ != 0)
    {
        __storage_type __clz_f = static_cast<__storage_type>(__bits_per_word - __first.__ctz_);
        __storage_type __dn = std::__1::min(__clz_f, __n);
        __storage_type __m = (~__storage_type(0) << __first.__ctz_) & (~__storage_type(0) >> (__clz_f - __dn));
        *__first.__seg_ |= __m;
        __n -= __dn;
        ++__first.__seg_;
    }

    __storage_type __nw = __n / __bits_per_word;
    std::__1::memset(std::__1::__to_address(__first.__seg_), -1, __nw * sizeof(__storage_type));
    __n -= __nw * __bits_per_word;

    if (__n > 0)
    {
        __first.__seg_ += __nw;
        __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
        *__first.__seg_ |= __m;
    }
}

template <class _Cp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void
fill_n(__bit_iterator<_Cp, false> __first, typename _Cp::size_type __n, bool __value_)
{
    if (__n > 0)
    {
        if (__value_)
            std::__1::__fill_n_true(__first, __n);
        else
            std::__1::__fill_n_false(__first, __n);
    }
}



template <class _Cp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void
fill(__bit_iterator<_Cp, false> __first, __bit_iterator<_Cp, false> __last, bool __value_)
{
    std::__1::fill_n(__first, static_cast<typename _Cp::size_type>(__last - __first), __value_);
}



template <class _Cp, bool _IsConst>
__bit_iterator<_Cp, false>
__copy_aligned(__bit_iterator<_Cp, _IsConst> __first, __bit_iterator<_Cp, _IsConst> __last,
                                                     __bit_iterator<_Cp, false> __result)
{
    typedef __bit_iterator<_Cp, _IsConst> _In;
    typedef typename _In::difference_type difference_type;
    typedef typename _In::__storage_type __storage_type;
    const int __bits_per_word = _In::__bits_per_word;
    difference_type __n = __last - __first;
    if (__n > 0)
    {

        if (__first.__ctz_ != 0)
        {
            unsigned __clz = __bits_per_word - __first.__ctz_;
            difference_type __dn = std::__1::min(static_cast<difference_type>(__clz), __n);
            __n -= __dn;
            __storage_type __m = (~__storage_type(0) << __first.__ctz_) & (~__storage_type(0) >> (__clz - __dn));
            __storage_type __b = *__first.__seg_ & __m;
            *__result.__seg_ &= ~__m;
            *__result.__seg_ |= __b;
            __result.__seg_ += (__dn + __result.__ctz_) / __bits_per_word;
            __result.__ctz_ = static_cast<unsigned>((__dn + __result.__ctz_) % __bits_per_word);
            ++__first.__seg_;

        }


        __storage_type __nw = __n / __bits_per_word;
        std::__1::memmove(std::__1::__to_address(__result.__seg_),
                       std::__1::__to_address(__first.__seg_),
                       __nw * sizeof(__storage_type));
        __n -= __nw * __bits_per_word;
        __result.__seg_ += __nw;

        if (__n > 0)
        {
            __first.__seg_ += __nw;
            __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
            __storage_type __b = *__first.__seg_ & __m;
            *__result.__seg_ &= ~__m;
            *__result.__seg_ |= __b;
            __result.__ctz_ = static_cast<unsigned>(__n);
        }
    }
    return __result;
}

template <class _Cp, bool _IsConst>
__bit_iterator<_Cp, false>
__copy_unaligned(__bit_iterator<_Cp, _IsConst> __first, __bit_iterator<_Cp, _IsConst> __last,
                                                       __bit_iterator<_Cp, false> __result)
{
    typedef __bit_iterator<_Cp, _IsConst> _In;
    typedef typename _In::difference_type difference_type;
    typedef typename _In::__storage_type __storage_type;
    static const int __bits_per_word = _In::__bits_per_word;
    difference_type __n = __last - __first;
    if (__n > 0)
    {

        if (__first.__ctz_ != 0)
        {
            unsigned __clz_f = __bits_per_word - __first.__ctz_;
            difference_type __dn = std::__1::min(static_cast<difference_type>(__clz_f), __n);
            __n -= __dn;
            __storage_type __m = (~__storage_type(0) << __first.__ctz_) & (~__storage_type(0) >> (__clz_f - __dn));
            __storage_type __b = *__first.__seg_ & __m;
            unsigned __clz_r = __bits_per_word - __result.__ctz_;
            __storage_type __ddn = std::__1::min<__storage_type>(__dn, __clz_r);
            __m = (~__storage_type(0) << __result.__ctz_) & (~__storage_type(0) >> (__clz_r - __ddn));
            *__result.__seg_ &= ~__m;
            if (__result.__ctz_ > __first.__ctz_)
                *__result.__seg_ |= __b << (__result.__ctz_ - __first.__ctz_);
            else
                *__result.__seg_ |= __b >> (__first.__ctz_ - __result.__ctz_);
            __result.__seg_ += (__ddn + __result.__ctz_) / __bits_per_word;
            __result.__ctz_ = static_cast<unsigned>((__ddn + __result.__ctz_) % __bits_per_word);
            __dn -= __ddn;
            if (__dn > 0)
            {
                __m = ~__storage_type(0) >> (__bits_per_word - __dn);
                *__result.__seg_ &= ~__m;
                *__result.__seg_ |= __b >> (__first.__ctz_ + __ddn);
                __result.__ctz_ = static_cast<unsigned>(__dn);
            }
            ++__first.__seg_;

        }


        unsigned __clz_r = __bits_per_word - __result.__ctz_;
        __storage_type __m = ~__storage_type(0) << __result.__ctz_;
        for (; __n >= __bits_per_word; __n -= __bits_per_word, ++__first.__seg_)
        {
            __storage_type __b = *__first.__seg_;
            *__result.__seg_ &= ~__m;
            *__result.__seg_ |= __b << __result.__ctz_;
            ++__result.__seg_;
            *__result.__seg_ &= __m;
            *__result.__seg_ |= __b >> __clz_r;
        }

        if (__n > 0)
        {
            __m = ~__storage_type(0) >> (__bits_per_word - __n);
            __storage_type __b = *__first.__seg_ & __m;
            __storage_type __dn = std::__1::min(__n, static_cast<difference_type>(__clz_r));
            __m = (~__storage_type(0) << __result.__ctz_) & (~__storage_type(0) >> (__clz_r - __dn));
            *__result.__seg_ &= ~__m;
            *__result.__seg_ |= __b << __result.__ctz_;
            __result.__seg_ += (__dn + __result.__ctz_) / __bits_per_word;
            __result.__ctz_ = static_cast<unsigned>((__dn + __result.__ctz_) % __bits_per_word);
            __n -= __dn;
            if (__n > 0)
            {
                __m = ~__storage_type(0) >> (__bits_per_word - __n);
                *__result.__seg_ &= ~__m;
                *__result.__seg_ |= __b >> __dn;
                __result.__ctz_ = static_cast<unsigned>(__n);
            }
        }
    }
    return __result;
}

template <class _Cp, bool _IsConst>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
__bit_iterator<_Cp, false>
copy(__bit_iterator<_Cp, _IsConst> __first, __bit_iterator<_Cp, _IsConst> __last, __bit_iterator<_Cp, false> __result)
{
    if (__first.__ctz_ == __result.__ctz_)
        return std::__1::__copy_aligned(__first, __last, __result);
    return std::__1::__copy_unaligned(__first, __last, __result);
}



template <class _Cp, bool _IsConst>
__bit_iterator<_Cp, false>
__copy_backward_aligned(__bit_iterator<_Cp, _IsConst> __first, __bit_iterator<_Cp, _IsConst> __last,
                                                     __bit_iterator<_Cp, false> __result)
{
    typedef __bit_iterator<_Cp, _IsConst> _In;
    typedef typename _In::difference_type difference_type;
    typedef typename _In::__storage_type __storage_type;
    const int __bits_per_word = _In::__bits_per_word;
    difference_type __n = __last - __first;
    if (__n > 0)
    {

        if (__last.__ctz_ != 0)
        {
            difference_type __dn = std::__1::min(static_cast<difference_type>(__last.__ctz_), __n);
            __n -= __dn;
            unsigned __clz = __bits_per_word - __last.__ctz_;
            __storage_type __m = (~__storage_type(0) << (__last.__ctz_ - __dn)) & (~__storage_type(0) >> __clz);
            __storage_type __b = *__last.__seg_ & __m;
            *__result.__seg_ &= ~__m;
            *__result.__seg_ |= __b;
            __result.__ctz_ = static_cast<unsigned>(((-__dn & (__bits_per_word - 1)) +
                                                       __result.__ctz_) % __bits_per_word);

         }



        __storage_type __nw = __n / __bits_per_word;
        __result.__seg_ -= __nw;
        __last.__seg_ -= __nw;
        std::__1::memmove(std::__1::__to_address(__result.__seg_),
                       std::__1::__to_address(__last.__seg_),
                       __nw * sizeof(__storage_type));
        __n -= __nw * __bits_per_word;

        if (__n > 0)
        {
            __storage_type __m = ~__storage_type(0) << (__bits_per_word - __n);
            __storage_type __b = *--__last.__seg_ & __m;
            *--__result.__seg_ &= ~__m;
            *__result.__seg_ |= __b;
            __result.__ctz_ = static_cast<unsigned>(-__n & (__bits_per_word - 1));
        }
    }
    return __result;
}

template <class _Cp, bool _IsConst>
__bit_iterator<_Cp, false>
__copy_backward_unaligned(__bit_iterator<_Cp, _IsConst> __first, __bit_iterator<_Cp, _IsConst> __last,
                                                       __bit_iterator<_Cp, false> __result)
{
    typedef __bit_iterator<_Cp, _IsConst> _In;
    typedef typename _In::difference_type difference_type;
    typedef typename _In::__storage_type __storage_type;
    const int __bits_per_word = _In::__bits_per_word;
    difference_type __n = __last - __first;
    if (__n > 0)
    {

        if (__last.__ctz_ != 0)
        {
            difference_type __dn = std::__1::min(static_cast<difference_type>(__last.__ctz_), __n);
            __n -= __dn;
            unsigned __clz_l = __bits_per_word - __last.__ctz_;
            __storage_type __m = (~__storage_type(0) << (__last.__ctz_ - __dn)) & (~__storage_type(0) >> __clz_l);
            __storage_type __b = *__last.__seg_ & __m;
            unsigned __clz_r = __bits_per_word - __result.__ctz_;
            __storage_type __ddn = std::__1::min(__dn, static_cast<difference_type>(__result.__ctz_));
            if (__ddn > 0)
            {
                __m = (~__storage_type(0) << (__result.__ctz_ - __ddn)) & (~__storage_type(0) >> __clz_r);
                *__result.__seg_ &= ~__m;
                if (__result.__ctz_ > __last.__ctz_)
                    *__result.__seg_ |= __b << (__result.__ctz_ - __last.__ctz_);
                else
                    *__result.__seg_ |= __b >> (__last.__ctz_ - __result.__ctz_);
                __result.__ctz_ = static_cast<unsigned>(((-__ddn & (__bits_per_word - 1)) +
                                                         __result.__ctz_) % __bits_per_word);
                __dn -= __ddn;
            }
            if (__dn > 0)
            {

                --__result.__seg_;
                __result.__ctz_ = static_cast<unsigned>(-__dn & (__bits_per_word - 1));
                __m = ~__storage_type(0) << __result.__ctz_;
                *__result.__seg_ &= ~__m;
                __last.__ctz_ -= __dn + __ddn;
                *__result.__seg_ |= __b << (__result.__ctz_ - __last.__ctz_);
            }

         }



        unsigned __clz_r = __bits_per_word - __result.__ctz_;
        __storage_type __m = ~__storage_type(0) >> __clz_r;
        for (; __n >= __bits_per_word; __n -= __bits_per_word)
        {
            __storage_type __b = *--__last.__seg_;
            *__result.__seg_ &= ~__m;
            *__result.__seg_ |= __b >> __clz_r;
            *--__result.__seg_ &= __m;
            *__result.__seg_ |= __b << __result.__ctz_;
        }

        if (__n > 0)
        {
            __m = ~__storage_type(0) << (__bits_per_word - __n);
            __storage_type __b = *--__last.__seg_ & __m;
            __clz_r = __bits_per_word - __result.__ctz_;
            __storage_type __dn = std::__1::min(__n, static_cast<difference_type>(__result.__ctz_));
            __m = (~__storage_type(0) << (__result.__ctz_ - __dn)) & (~__storage_type(0) >> __clz_r);
            *__result.__seg_ &= ~__m;
            *__result.__seg_ |= __b >> (__bits_per_word - __result.__ctz_);
            __result.__ctz_ = static_cast<unsigned>(((-__dn & (__bits_per_word - 1)) +
                                                     __result.__ctz_) % __bits_per_word);
            __n -= __dn;
            if (__n > 0)
            {

                --__result.__seg_;
                __result.__ctz_ = static_cast<unsigned>(-__n & (__bits_per_word - 1));
                __m = ~__storage_type(0) << __result.__ctz_;
                *__result.__seg_ &= ~__m;
                *__result.__seg_ |= __b << (__result.__ctz_ - (__bits_per_word - __n - __dn));
            }
        }
    }
    return __result;
}

template <class _Cp, bool _IsConst>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
__bit_iterator<_Cp, false>
copy_backward(__bit_iterator<_Cp, _IsConst> __first, __bit_iterator<_Cp, _IsConst> __last, __bit_iterator<_Cp, false> __result)
{
    if (__last.__ctz_ == __result.__ctz_)
        return std::__1::__copy_backward_aligned(__first, __last, __result);
    return std::__1::__copy_backward_unaligned(__first, __last, __result);
}



template <class _Cp, bool _IsConst>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
__bit_iterator<_Cp, false>
move(__bit_iterator<_Cp, _IsConst> __first, __bit_iterator<_Cp, _IsConst> __last, __bit_iterator<_Cp, false> __result)
{
    return std::__1::copy(__first, __last, __result);
}



template <class _Cp, bool _IsConst>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
__bit_iterator<_Cp, false>
move_backward(__bit_iterator<_Cp, _IsConst> __first, __bit_iterator<_Cp, _IsConst> __last, __bit_iterator<_Cp, false> __result)
{
    return std::__1::copy_backward(__first, __last, __result);
}



template <class __C1, class __C2>
__bit_iterator<__C2, false>
__swap_ranges_aligned(__bit_iterator<__C1, false> __first, __bit_iterator<__C1, false> __last,
                      __bit_iterator<__C2, false> __result)
{
    typedef __bit_iterator<__C1, false> _I1;
    typedef typename _I1::difference_type difference_type;
    typedef typename _I1::__storage_type __storage_type;
    const int __bits_per_word = _I1::__bits_per_word;
    difference_type __n = __last - __first;
    if (__n > 0)
    {

        if (__first.__ctz_ != 0)
        {
            unsigned __clz = __bits_per_word - __first.__ctz_;
            difference_type __dn = std::__1::min(static_cast<difference_type>(__clz), __n);
            __n -= __dn;
            __storage_type __m = (~__storage_type(0) << __first.__ctz_) & (~__storage_type(0) >> (__clz - __dn));
            __storage_type __b1 = *__first.__seg_ & __m;
            *__first.__seg_ &= ~__m;
            __storage_type __b2 = *__result.__seg_ & __m;
            *__result.__seg_ &= ~__m;
            *__result.__seg_ |= __b1;
            *__first.__seg_ |= __b2;
            __result.__seg_ += (__dn + __result.__ctz_) / __bits_per_word;
            __result.__ctz_ = static_cast<unsigned>((__dn + __result.__ctz_) % __bits_per_word);
            ++__first.__seg_;

        }


        for (; __n >= __bits_per_word; __n -= __bits_per_word, ++__first.__seg_, ++__result.__seg_)
            swap(*__first.__seg_, *__result.__seg_);

        if (__n > 0)
        {
            __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
            __storage_type __b1 = *__first.__seg_ & __m;
            *__first.__seg_ &= ~__m;
            __storage_type __b2 = *__result.__seg_ & __m;
            *__result.__seg_ &= ~__m;
            *__result.__seg_ |= __b1;
            *__first.__seg_ |= __b2;
            __result.__ctz_ = static_cast<unsigned>(__n);
        }
    }
    return __result;
}

template <class __C1, class __C2>
__bit_iterator<__C2, false>
__swap_ranges_unaligned(__bit_iterator<__C1, false> __first, __bit_iterator<__C1, false> __last,
                        __bit_iterator<__C2, false> __result)
{
    typedef __bit_iterator<__C1, false> _I1;
    typedef typename _I1::difference_type difference_type;
    typedef typename _I1::__storage_type __storage_type;
    const int __bits_per_word = _I1::__bits_per_word;
    difference_type __n = __last - __first;
    if (__n > 0)
    {

        if (__first.__ctz_ != 0)
        {
            unsigned __clz_f = __bits_per_word - __first.__ctz_;
            difference_type __dn = std::__1::min(static_cast<difference_type>(__clz_f), __n);
            __n -= __dn;
            __storage_type __m = (~__storage_type(0) << __first.__ctz_) & (~__storage_type(0) >> (__clz_f - __dn));
            __storage_type __b1 = *__first.__seg_ & __m;
            *__first.__seg_ &= ~__m;
            unsigned __clz_r = __bits_per_word - __result.__ctz_;
            __storage_type __ddn = std::__1::min<__storage_type>(__dn, __clz_r);
            __m = (~__storage_type(0) << __result.__ctz_) & (~__storage_type(0) >> (__clz_r - __ddn));
            __storage_type __b2 = *__result.__seg_ & __m;
            *__result.__seg_ &= ~__m;
            if (__result.__ctz_ > __first.__ctz_)
            {
                unsigned __s = __result.__ctz_ - __first.__ctz_;
                *__result.__seg_ |= __b1 << __s;
                *__first.__seg_ |= __b2 >> __s;
            }
            else
            {
                unsigned __s = __first.__ctz_ - __result.__ctz_;
                *__result.__seg_ |= __b1 >> __s;
                *__first.__seg_ |= __b2 << __s;
            }
            __result.__seg_ += (__ddn + __result.__ctz_) / __bits_per_word;
            __result.__ctz_ = static_cast<unsigned>((__ddn + __result.__ctz_) % __bits_per_word);
            __dn -= __ddn;
            if (__dn > 0)
            {
                __m = ~__storage_type(0) >> (__bits_per_word - __dn);
                __b2 = *__result.__seg_ & __m;
                *__result.__seg_ &= ~__m;
                unsigned __s = __first.__ctz_ + __ddn;
                *__result.__seg_ |= __b1 >> __s;
                *__first.__seg_ |= __b2 << __s;
                __result.__ctz_ = static_cast<unsigned>(__dn);
            }
            ++__first.__seg_;

        }


        __storage_type __m = ~__storage_type(0) << __result.__ctz_;
        unsigned __clz_r = __bits_per_word - __result.__ctz_;
        for (; __n >= __bits_per_word; __n -= __bits_per_word, ++__first.__seg_)
        {
            __storage_type __b1 = *__first.__seg_;
            __storage_type __b2 = *__result.__seg_ & __m;
            *__result.__seg_ &= ~__m;
            *__result.__seg_ |= __b1 << __result.__ctz_;
            *__first.__seg_ = __b2 >> __result.__ctz_;
            ++__result.__seg_;
            __b2 = *__result.__seg_ & ~__m;
            *__result.__seg_ &= __m;
            *__result.__seg_ |= __b1 >> __clz_r;
            *__first.__seg_ |= __b2 << __clz_r;
        }

        if (__n > 0)
        {
            __m = ~__storage_type(0) >> (__bits_per_word - __n);
            __storage_type __b1 = *__first.__seg_ & __m;
            *__first.__seg_ &= ~__m;
            __storage_type __dn = std::__1::min<__storage_type>(__n, __clz_r);
            __m = (~__storage_type(0) << __result.__ctz_) & (~__storage_type(0) >> (__clz_r - __dn));
            __storage_type __b2 = *__result.__seg_ & __m;
            *__result.__seg_ &= ~__m;
            *__result.__seg_ |= __b1 << __result.__ctz_;
            *__first.__seg_ |= __b2 >> __result.__ctz_;
            __result.__seg_ += (__dn + __result.__ctz_) / __bits_per_word;
            __result.__ctz_ = static_cast<unsigned>((__dn + __result.__ctz_) % __bits_per_word);
            __n -= __dn;
            if (__n > 0)
            {
                __m = ~__storage_type(0) >> (__bits_per_word - __n);
                __b2 = *__result.__seg_ & __m;
                *__result.__seg_ &= ~__m;
                *__result.__seg_ |= __b1 >> __dn;
                *__first.__seg_ |= __b2 << __dn;
                __result.__ctz_ = static_cast<unsigned>(__n);
            }
        }
    }
    return __result;
}

template <class __C1, class __C2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
__bit_iterator<__C2, false>
swap_ranges(__bit_iterator<__C1, false> __first1, __bit_iterator<__C1, false> __last1,
            __bit_iterator<__C2, false> __first2)
{
    if (__first1.__ctz_ == __first2.__ctz_)
        return std::__1::__swap_ranges_aligned(__first1, __last1, __first2);
    return std::__1::__swap_ranges_unaligned(__first1, __last1, __first2);
}



template <class _Cp>
struct __bit_array
{
    typedef typename _Cp::difference_type difference_type;
    typedef typename _Cp::__storage_type __storage_type;
    typedef typename _Cp::__storage_pointer __storage_pointer;
    typedef typename _Cp::iterator iterator;
    static const unsigned __bits_per_word = _Cp::__bits_per_word;
    static const unsigned _Np = 4;

    difference_type __size_;
    __storage_type __word_[_Np];

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) static difference_type capacity()
        {return static_cast<difference_type>(_Np * __bits_per_word);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) explicit __bit_array(difference_type __s) : __size_(__s) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) iterator begin()
    {
        return iterator(pointer_traits<__storage_pointer>::pointer_to(__word_[0]), 0);
    }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) iterator end()
    {
        return iterator(pointer_traits<__storage_pointer>::pointer_to(__word_[0]) + __size_ / __bits_per_word,
                                                  static_cast<unsigned>(__size_ % __bits_per_word));
    }
};

template <class _Cp>
__bit_iterator<_Cp, false>
rotate(__bit_iterator<_Cp, false> __first, __bit_iterator<_Cp, false> __middle, __bit_iterator<_Cp, false> __last)
{
    typedef __bit_iterator<_Cp, false> _I1;
    typedef typename _I1::difference_type difference_type;
    difference_type __d1 = __middle - __first;
    difference_type __d2 = __last - __middle;
    _I1 __r = __first + __d2;
    while (__d1 != 0 && __d2 != 0)
    {
        if (__d1 <= __d2)
        {
            if (__d1 <= __bit_array<_Cp>::capacity())
            {
                __bit_array<_Cp> __b(__d1);
                std::__1::copy(__first, __middle, __b.begin());
                std::__1::copy(__b.begin(), __b.end(), std::__1::copy(__middle, __last, __first));
                break;
            }
            else
            {
                __bit_iterator<_Cp, false> __mp = std::__1::swap_ranges(__first, __middle, __middle);
                __first = __middle;
                __middle = __mp;
                __d2 -= __d1;
            }
        }
        else
        {
            if (__d2 <= __bit_array<_Cp>::capacity())
            {
                __bit_array<_Cp> __b(__d2);
                std::__1::copy(__middle, __last, __b.begin());
                std::__1::copy_backward(__b.begin(), __b.end(), std::__1::copy_backward(__first, __middle, __last));
                break;
            }
            else
            {
                __bit_iterator<_Cp, false> __mp = __first + __d2;
                std::__1::swap_ranges(__first, __mp, __middle);
                __first = __mp;
                __d1 -= __d2;
            }
        }
    }
    return __r;
}



template <class _Cp, bool _IC1, bool _IC2>
bool
__equal_unaligned(__bit_iterator<_Cp, _IC1> __first1, __bit_iterator<_Cp, _IC1> __last1,
                  __bit_iterator<_Cp, _IC2> __first2)
{
    typedef __bit_iterator<_Cp, _IC1> _It;
    typedef typename _It::difference_type difference_type;
    typedef typename _It::__storage_type __storage_type;
    static const int __bits_per_word = _It::__bits_per_word;
    difference_type __n = __last1 - __first1;
    if (__n > 0)
    {

        if (__first1.__ctz_ != 0)
        {
            unsigned __clz_f = __bits_per_word - __first1.__ctz_;
            difference_type __dn = std::__1::min(static_cast<difference_type>(__clz_f), __n);
            __n -= __dn;
            __storage_type __m = (~__storage_type(0) << __first1.__ctz_) & (~__storage_type(0) >> (__clz_f - __dn));
            __storage_type __b = *__first1.__seg_ & __m;
            unsigned __clz_r = __bits_per_word - __first2.__ctz_;
            __storage_type __ddn = std::__1::min<__storage_type>(__dn, __clz_r);
            __m = (~__storage_type(0) << __first2.__ctz_) & (~__storage_type(0) >> (__clz_r - __ddn));
            if (__first2.__ctz_ > __first1.__ctz_)
            {
                if ((*__first2.__seg_ & __m) != (__b << (__first2.__ctz_ - __first1.__ctz_)))
                    return false;
            }
            else
            {
                if ((*__first2.__seg_ & __m) != (__b >> (__first1.__ctz_ - __first2.__ctz_)))
                    return false;
            }
            __first2.__seg_ += (__ddn + __first2.__ctz_) / __bits_per_word;
            __first2.__ctz_ = static_cast<unsigned>((__ddn + __first2.__ctz_) % __bits_per_word);
            __dn -= __ddn;
            if (__dn > 0)
            {
                __m = ~__storage_type(0) >> (__bits_per_word - __dn);
                if ((*__first2.__seg_ & __m) != (__b >> (__first1.__ctz_ + __ddn)))
                    return false;
                __first2.__ctz_ = static_cast<unsigned>(__dn);
            }
            ++__first1.__seg_;

        }


        unsigned __clz_r = __bits_per_word - __first2.__ctz_;
        __storage_type __m = ~__storage_type(0) << __first2.__ctz_;
        for (; __n >= __bits_per_word; __n -= __bits_per_word, ++__first1.__seg_)
        {
            __storage_type __b = *__first1.__seg_;
            if ((*__first2.__seg_ & __m) != (__b << __first2.__ctz_))
                return false;
            ++__first2.__seg_;
            if ((*__first2.__seg_ & ~__m) != (__b >> __clz_r))
                return false;
        }

        if (__n > 0)
        {
            __m = ~__storage_type(0) >> (__bits_per_word - __n);
            __storage_type __b = *__first1.__seg_ & __m;
            __storage_type __dn = std::__1::min(__n, static_cast<difference_type>(__clz_r));
            __m = (~__storage_type(0) << __first2.__ctz_) & (~__storage_type(0) >> (__clz_r - __dn));
            if ((*__first2.__seg_ & __m) != (__b << __first2.__ctz_))
                return false;
            __first2.__seg_ += (__dn + __first2.__ctz_) / __bits_per_word;
            __first2.__ctz_ = static_cast<unsigned>((__dn + __first2.__ctz_) % __bits_per_word);
            __n -= __dn;
            if (__n > 0)
            {
                __m = ~__storage_type(0) >> (__bits_per_word - __n);
                if ((*__first2.__seg_ & __m) != (__b >> __dn))
                    return false;
            }
        }
    }
    return true;
}

template <class _Cp, bool _IC1, bool _IC2>
bool
__equal_aligned(__bit_iterator<_Cp, _IC1> __first1, __bit_iterator<_Cp, _IC1> __last1,
                __bit_iterator<_Cp, _IC2> __first2)
{
    typedef __bit_iterator<_Cp, _IC1> _It;
    typedef typename _It::difference_type difference_type;
    typedef typename _It::__storage_type __storage_type;
    static const int __bits_per_word = _It::__bits_per_word;
    difference_type __n = __last1 - __first1;
    if (__n > 0)
    {

        if (__first1.__ctz_ != 0)
        {
            unsigned __clz = __bits_per_word - __first1.__ctz_;
            difference_type __dn = std::__1::min(static_cast<difference_type>(__clz), __n);
            __n -= __dn;
            __storage_type __m = (~__storage_type(0) << __first1.__ctz_) & (~__storage_type(0) >> (__clz - __dn));
            if ((*__first2.__seg_ & __m) != (*__first1.__seg_ & __m))
                return false;
            ++__first2.__seg_;
            ++__first1.__seg_;


        }



        for (; __n >= __bits_per_word; __n -= __bits_per_word, ++__first1.__seg_, ++__first2.__seg_)
            if (*__first2.__seg_ != *__first1.__seg_)
                return false;

        if (__n > 0)
        {
            __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
            if ((*__first2.__seg_ & __m) != (*__first1.__seg_ & __m))
                return false;
        }
    }
    return true;
}

template <class _Cp, bool _IC1, bool _IC2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
equal(__bit_iterator<_Cp, _IC1> __first1, __bit_iterator<_Cp, _IC1> __last1, __bit_iterator<_Cp, _IC2> __first2)
{
    if (__first1.__ctz_ == __first2.__ctz_)
        return std::__1::__equal_aligned(__first1, __last1, __first2);
    return std::__1::__equal_unaligned(__first1, __last1, __first2);
}

template <class _Cp, bool _IsConst,
          typename _Cp::__storage_type>
class __bit_iterator
{
public:
    typedef typename _Cp::difference_type difference_type;
    typedef bool value_type;
    typedef __bit_iterator pointer;
    typedef typename conditional<_IsConst, __bit_const_reference<_Cp>, __bit_reference<_Cp> >::type reference;
    typedef random_access_iterator_tag iterator_category;

private:
    typedef typename _Cp::__storage_type __storage_type;
    typedef typename conditional<_IsConst, typename _Cp::__const_storage_pointer,
                                           typename _Cp::__storage_pointer>::type __storage_pointer;
    static const unsigned __bits_per_word = _Cp::__bits_per_word;

    __storage_pointer __seg_;
    unsigned __ctz_;

public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) __bit_iterator() noexcept

    : __seg_(nullptr), __ctz_(0)

    {}






    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __bit_iterator(const __bit_iterator<_Cp, false>& __it) noexcept
        : __seg_(__it.__seg_), __ctz_(__it.__ctz_) {}






    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __bit_iterator& operator=(const _If<_IsConst, struct __private_nat, __bit_iterator>& __it) {
        __seg_ = __it.__seg_;
        __ctz_ = __it.__ctz_;
        return *this;
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) reference operator*() const noexcept
        {return reference(__seg_, __storage_type(1) << __ctz_);}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) __bit_iterator& operator++()
    {
        if (__ctz_ != __bits_per_word-1)
            ++__ctz_;
        else
        {
            __ctz_ = 0;
            ++__seg_;
        }
        return *this;
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) __bit_iterator operator++(int)
    {
        __bit_iterator __tmp = *this;
        ++(*this);
        return __tmp;
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) __bit_iterator& operator--()
    {
        if (__ctz_ != 0)
            --__ctz_;
        else
        {
            __ctz_ = __bits_per_word - 1;
            --__seg_;
        }
        return *this;
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) __bit_iterator operator--(int)
    {
        __bit_iterator __tmp = *this;
        --(*this);
        return __tmp;
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) __bit_iterator& operator+=(difference_type __n)
    {
        if (__n >= 0)
            __seg_ += (__n + __ctz_) / __bits_per_word;
        else
            __seg_ += static_cast<difference_type>(__n - __bits_per_word + __ctz_ + 1)
                    / static_cast<difference_type>(__bits_per_word);
        __n &= (__bits_per_word - 1);
        __ctz_ = static_cast<unsigned>((__n + __ctz_) % __bits_per_word);
        return *this;
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) __bit_iterator& operator-=(difference_type __n)
    {
        return *this += -__n;
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) __bit_iterator operator+(difference_type __n) const
    {
        __bit_iterator __t(*this);
        __t += __n;
        return __t;
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) __bit_iterator operator-(difference_type __n) const
    {
        __bit_iterator __t(*this);
        __t -= __n;
        return __t;
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    friend __bit_iterator operator+(difference_type __n, const __bit_iterator& __it) {return __it + __n;}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    friend difference_type operator-(const __bit_iterator& __x, const __bit_iterator& __y)
        {return (__x.__seg_ - __y.__seg_) * __bits_per_word + __x.__ctz_ - __y.__ctz_;}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) reference operator[](difference_type __n) const {return *(*this + __n);}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) friend bool operator==(const __bit_iterator& __x, const __bit_iterator& __y)
        {return __x.__seg_ == __y.__seg_ && __x.__ctz_ == __y.__ctz_;}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) friend bool operator!=(const __bit_iterator& __x, const __bit_iterator& __y)
        {return !(__x == __y);}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) friend bool operator<(const __bit_iterator& __x, const __bit_iterator& __y)
        {return __x.__seg_ < __y.__seg_ || (__x.__seg_ == __y.__seg_ && __x.__ctz_ < __y.__ctz_);}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) friend bool operator>(const __bit_iterator& __x, const __bit_iterator& __y)
        {return __y < __x;}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) friend bool operator<=(const __bit_iterator& __x, const __bit_iterator& __y)
        {return !(__y < __x);}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) friend bool operator>=(const __bit_iterator& __x, const __bit_iterator& __y)
        {return !(__x < __y);}

private:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __bit_iterator(__storage_pointer __s, unsigned __ctz) noexcept
        : __seg_(__s), __ctz_(__ctz) {}

    friend typename _Cp::__self;

    friend class __bit_reference<_Cp>;
    friend class __bit_const_reference<_Cp>;
    friend class __bit_iterator<_Cp, true>;
    template <class _Dp> friend struct __bit_array;
    template <class _Dp> friend void __fill_n_false(__bit_iterator<_Dp, false> __first, typename _Dp::size_type __n);
    template <class _Dp> friend void __fill_n_true(__bit_iterator<_Dp, false> __first, typename _Dp::size_type __n);
    template <class _Dp, bool _IC> friend __bit_iterator<_Dp, false> __copy_aligned(__bit_iterator<_Dp, _IC> __first,
                                                                                  __bit_iterator<_Dp, _IC> __last,
                                                                                  __bit_iterator<_Dp, false> __result);
    template <class _Dp, bool _IC> friend __bit_iterator<_Dp, false> __copy_unaligned(__bit_iterator<_Dp, _IC> __first,
                                                                                    __bit_iterator<_Dp, _IC> __last,
                                                                                    __bit_iterator<_Dp, false> __result);
    template <class _Dp, bool _IC> friend __bit_iterator<_Dp, false> copy(__bit_iterator<_Dp, _IC> __first,
                                                                        __bit_iterator<_Dp, _IC> __last,
                                                                        __bit_iterator<_Dp, false> __result);
    template <class _Dp, bool _IC> friend __bit_iterator<_Dp, false> __copy_backward_aligned(__bit_iterator<_Dp, _IC> __first,
                                                                                           __bit_iterator<_Dp, _IC> __last,
                                                                                           __bit_iterator<_Dp, false> __result);
    template <class _Dp, bool _IC> friend __bit_iterator<_Dp, false> __copy_backward_unaligned(__bit_iterator<_Dp, _IC> __first,
                                                                                             __bit_iterator<_Dp, _IC> __last,
                                                                                             __bit_iterator<_Dp, false> __result);
    template <class _Dp, bool _IC> friend __bit_iterator<_Dp, false> copy_backward(__bit_iterator<_Dp, _IC> __first,
                                                                                 __bit_iterator<_Dp, _IC> __last,
                                                                                 __bit_iterator<_Dp, false> __result);
    template <class __C1, class __C2>friend __bit_iterator<__C2, false> __swap_ranges_aligned(__bit_iterator<__C1, false>,
                                                                                           __bit_iterator<__C1, false>,
                                                                                           __bit_iterator<__C2, false>);
    template <class __C1, class __C2>friend __bit_iterator<__C2, false> __swap_ranges_unaligned(__bit_iterator<__C1, false>,
                                                                                             __bit_iterator<__C1, false>,
                                                                                             __bit_iterator<__C2, false>);
    template <class __C1, class __C2>friend __bit_iterator<__C2, false> swap_ranges(__bit_iterator<__C1, false>,
                                                                                 __bit_iterator<__C1, false>,
                                                                                 __bit_iterator<__C2, false>);
    template <class _Dp> friend __bit_iterator<_Dp, false> rotate(__bit_iterator<_Dp, false>,
                                                                __bit_iterator<_Dp, false>,
                                                                __bit_iterator<_Dp, false>);
    template <class _Dp, bool _IC1, bool _IC2> friend bool __equal_aligned(__bit_iterator<_Dp, _IC1>,
                                                    __bit_iterator<_Dp, _IC1>,
                                                    __bit_iterator<_Dp, _IC2>);
    template <class _Dp, bool _IC1, bool _IC2> friend bool __equal_unaligned(__bit_iterator<_Dp, _IC1>,
                                                      __bit_iterator<_Dp, _IC1>,
                                                      __bit_iterator<_Dp, _IC2>);
    template <class _Dp, bool _IC1, bool _IC2> friend bool equal(__bit_iterator<_Dp, _IC1>,
                                                                __bit_iterator<_Dp, _IC1>,
                                                                __bit_iterator<_Dp, _IC2>);
    template <class _Dp, bool _IC> friend __bit_iterator<_Dp, _IC> __find_bool_true(__bit_iterator<_Dp, _IC>,
                                                                          typename _Dp::size_type);
    template <class _Dp, bool _IC> friend __bit_iterator<_Dp, _IC> __find_bool_false(__bit_iterator<_Dp, _IC>,
                                                                           typename _Dp::size_type);
    template <class _Dp, bool _IC> friend typename __bit_iterator<_Dp, _IC>::difference_type
                   __count_bool_true(__bit_iterator<_Dp, _IC>, typename _Dp::size_type);
    template <class _Dp, bool _IC> friend typename __bit_iterator<_Dp, _IC>::difference_type
                   __count_bool_false(__bit_iterator<_Dp, _IC>, typename _Dp::size_type);
};

} }
# 117 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/bitset" 2 3





# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/string" 1 3
# 530 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/string" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/memory" 1 3
# 974 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/memory" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 1 3
# 20 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/assert.h" 1 3 4
# 44 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/assert.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/stdlib.h" 1 3 4
# 45 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/assert.h" 2 3 4
# 81 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/assert.h" 3 4
extern "C" {
void __assert_rtn(const char *, const char *, int, const char *) __attribute__((__noreturn__)) __attribute__((__cold__)) __attribute__((__disable_tail_calls__));



}
# 21 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 2 3
# 24 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 3
# 975 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/memory" 2 3
# 531 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/string" 2 3

# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/string_view" 1 3
# 191 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/string_view" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__ranges/enable_view.h" 1 3
# 18 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__ranges/enable_view.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 22 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__ranges/enable_view.h" 2 3

namespace std { inline namespace __1 {
# 38 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__ranges/enable_view.h" 3
} }
# 192 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/string_view" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__string" 1 3
# 26 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__string" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 1 3
# 27 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__string" 2 3
# 37 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__string" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 41 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__string" 2 3


namespace std { inline namespace __1 {
# 164 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__string" 3
template <class _CharT>
struct __attribute__ ((__type_visibility__("default"))) char_traits
{
    typedef _CharT char_type;
    typedef int int_type;
    typedef streamoff off_type;
    typedef streampos pos_type;
    typedef mbstate_t state_type;

    static inline void constexpr
        assign(char_type& __c1, const char_type& __c2) noexcept {__c1 = __c2;}
    static inline constexpr bool eq(char_type __c1, char_type __c2) noexcept
        {return __c1 == __c2;}
    static inline constexpr bool lt(char_type __c1, char_type __c2) noexcept
        {return __c1 < __c2;}

    static constexpr
    int compare(const char_type* __s1, const char_type* __s2, size_t __n);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) static constexpr
    size_t length(const char_type* __s);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) static constexpr
    const char_type* find(const char_type* __s, size_t __n, const char_type& __a);
    static
    char_type* move(char_type* __s1, const char_type* __s2, size_t __n);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    static
    char_type* copy(char_type* __s1, const char_type* __s2, size_t __n);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    static
    char_type* assign(char_type* __s, size_t __n, char_type __a);

    static inline constexpr int_type not_eof(int_type __c) noexcept
        {return eq_int_type(__c, eof()) ? ~eof() : __c;}
    static inline constexpr char_type to_char_type(int_type __c) noexcept
        {return char_type(__c);}
    static inline constexpr int_type to_int_type(char_type __c) noexcept
        {return int_type(__c);}
    static inline constexpr bool eq_int_type(int_type __c1, int_type __c2) noexcept
        {return __c1 == __c2;}
    static inline constexpr int_type eof() noexcept
        {return int_type((-1));}
};

template <class _CharT>
constexpr int
char_traits<_CharT>::compare(const char_type* __s1, const char_type* __s2, size_t __n)
{
    for (; __n; --__n, ++__s1, ++__s2)
    {
        if (lt(*__s1, *__s2))
            return -1;
        if (lt(*__s2, *__s1))
            return 1;
    }
    return 0;
}

template <class _CharT>
inline
constexpr size_t
char_traits<_CharT>::length(const char_type* __s)
{
    size_t __len = 0;
    for (; !eq(*__s, char_type(0)); ++__s)
        ++__len;
    return __len;
}

template <class _CharT>
inline
constexpr const _CharT*
char_traits<_CharT>::find(const char_type* __s, size_t __n, const char_type& __a)
{
    for (; __n; --__n)
    {
        if (eq(*__s, __a))
            return __s;
        ++__s;
    }
    return nullptr;
}

template <class _CharT>
                              _CharT*
char_traits<_CharT>::move(char_type* __s1, const char_type* __s2, size_t __n)
{
    if (__n == 0) return __s1;
    char_type* __r = __s1;
    if (__s1 < __s2)
    {
        for (; __n; --__n, ++__s1, ++__s2)
            assign(*__s1, *__s2);
    }
    else if (__s2 < __s1)
    {
        __s1 += __n;
        __s2 += __n;
        for (; __n; --__n)
            assign(*--__s1, *--__s2);
    }
    return __r;
}

template <class _CharT>
inline
_CharT*
char_traits<_CharT>::copy(char_type* __s1, const char_type* __s2, size_t __n)
{
    ((void)0);
    char_type* __r = __s1;
    for (; __n; --__n, ++__s1, ++__s2)
        assign(*__s1, *__s2);
    return __r;
}

template <class _CharT>
inline
_CharT*
char_traits<_CharT>::assign(char_type* __s, size_t __n, char_type __a)
{
    char_type* __r = __s;
    for (; __n; --__n, ++__s)
        assign(*__s, __a);
    return __r;
}



template <class _CharT>
static inline
_CharT* __move_constexpr(_CharT* __s1, const _CharT* __s2, size_t __n) noexcept
{
    if (__n == 0) return __s1;
    if (__s1 < __s2) {
      std::__1::copy(__s2, __s2 + __n, __s1);
    } else if (__s2 < __s1) {
      std::__1::copy_backward(__s2, __s2 + __n, __s1 + __n);
    }
    return __s1;
}

template <class _CharT>
static inline
_CharT* __copy_constexpr(_CharT* __s1, const _CharT* __s2, size_t __n) noexcept
{
    std::__1::copy_n(__s2, __n, __s1);
    return __s1;
}

template <class _CharT>
static inline
_CharT* __assign_constexpr(_CharT* __s, size_t __n, _CharT __a) noexcept
{
     std::__1::fill_n(__s, __n, __a);
     return __s;
}



template <>
struct __attribute__ ((__type_visibility__("default"))) char_traits<char>
{
    typedef char char_type;
    typedef int int_type;
    typedef streamoff off_type;
    typedef streampos pos_type;
    typedef mbstate_t state_type;

    static inline constexpr
    void assign(char_type& __c1, const char_type& __c2) noexcept {__c1 = __c2;}
    static inline constexpr bool eq(char_type __c1, char_type __c2) noexcept
            {return __c1 == __c2;}
    static inline constexpr bool lt(char_type __c1, char_type __c2) noexcept
        {return (unsigned char)__c1 < (unsigned char)__c2;}

    static constexpr
    int compare(const char_type* __s1, const char_type* __s2, size_t __n) noexcept;
    static inline size_t constexpr
    length(const char_type* __s) noexcept {return __builtin_strlen(__s);}
    static constexpr
    const char_type* find(const char_type* __s, size_t __n, const char_type& __a) noexcept;
    static inline
    char_type* move(char_type* __s1, const char_type* __s2, size_t __n) noexcept
        {
            return __libcpp_is_constant_evaluated()
                       ? std::__1::__move_constexpr(__s1, __s2, __n)
                       : __n == 0 ? __s1 : (char_type*)std::__1::memmove(__s1, __s2, __n);
        }
    static inline
    char_type* copy(char_type* __s1, const char_type* __s2, size_t __n) noexcept
        {
            ((void)0);
            return __libcpp_is_constant_evaluated()
                       ? std::__1::__copy_constexpr(__s1, __s2, __n)
                       : __n == 0 ? __s1 : (char_type*)std::__1::memcpy(__s1, __s2, __n);
        }
    static inline
    char_type* assign(char_type* __s, size_t __n, char_type __a) noexcept
        {
            return __libcpp_is_constant_evaluated()
                       ? std::__1::__assign_constexpr(__s, __n, __a)
                       : __n == 0 ? __s : (char_type*)std::__1::memset(__s, to_int_type(__a), __n);
        }

    static inline constexpr int_type not_eof(int_type __c) noexcept
        {return eq_int_type(__c, eof()) ? ~eof() : __c;}
    static inline constexpr char_type to_char_type(int_type __c) noexcept
        {return char_type(__c);}
    static inline constexpr int_type to_int_type(char_type __c) noexcept
        {return int_type((unsigned char)__c);}
    static inline constexpr bool eq_int_type(int_type __c1, int_type __c2) noexcept
        {return __c1 == __c2;}
    static inline constexpr int_type eof() noexcept
        {return int_type((-1));}
};

inline constexpr
int
char_traits<char>::compare(const char_type* __s1, const char_type* __s2, size_t __n) noexcept
{
    if (__n == 0)
        return 0;

    return __builtin_memcmp(__s1, __s2, __n);
# 400 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__string" 3
}

inline constexpr
const char*
char_traits<char>::find(const char_type* __s, size_t __n, const char_type& __a) noexcept
{
    if (__n == 0)
        return nullptr;

    return __builtin_char_memchr(__s, to_int_type(__a), __n);
# 421 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__string" 3
}





template <>
struct __attribute__ ((__type_visibility__("default"))) char_traits<wchar_t>
{
    typedef wchar_t char_type;
    typedef wint_t int_type;
    typedef streamoff off_type;
    typedef streampos pos_type;
    typedef mbstate_t state_type;

    static inline constexpr
    void assign(char_type& __c1, const char_type& __c2) noexcept {__c1 = __c2;}
    static inline constexpr bool eq(char_type __c1, char_type __c2) noexcept
        {return __c1 == __c2;}
    static inline constexpr bool lt(char_type __c1, char_type __c2) noexcept
        {return __c1 < __c2;}

    static constexpr
    int compare(const char_type* __s1, const char_type* __s2, size_t __n) noexcept;
    static constexpr
    size_t length(const char_type* __s) noexcept;
    static constexpr
    const char_type* find(const char_type* __s, size_t __n, const char_type& __a) noexcept;
    static inline
    char_type* move(char_type* __s1, const char_type* __s2, size_t __n) noexcept
        {
            return __libcpp_is_constant_evaluated()
                       ? std::__1::__move_constexpr(__s1, __s2, __n)
                       : __n == 0 ? __s1 : std::__1::wmemmove(__s1, __s2, __n);
        }
    static inline
    char_type* copy(char_type* __s1, const char_type* __s2, size_t __n) noexcept
        {
            ((void)0);
            return __libcpp_is_constant_evaluated()
                       ? std::__1::__copy_constexpr(__s1, __s2, __n)
                       : __n == 0 ? __s1 : std::__1::wmemcpy(__s1, __s2, __n);
        }
    static inline
    char_type* assign(char_type* __s, size_t __n, char_type __a) noexcept
        {
            return __libcpp_is_constant_evaluated()
                       ? std::__1::__assign_constexpr(__s, __n, __a)
                       : __n == 0 ? __s : std::__1::wmemset(__s, __a, __n);
        }
    static inline constexpr int_type not_eof(int_type __c) noexcept
        {return eq_int_type(__c, eof()) ? ~eof() : __c;}
    static inline constexpr char_type to_char_type(int_type __c) noexcept
        {return char_type(__c);}
    static inline constexpr int_type to_int_type(char_type __c) noexcept
        {return int_type(__c);}
    static inline constexpr bool eq_int_type(int_type __c1, int_type __c2) noexcept
        {return __c1 == __c2;}
    static inline constexpr int_type eof() noexcept
        {return int_type(((__darwin_wint_t)-1));}
};

inline constexpr
int
char_traits<wchar_t>::compare(const char_type* __s1, const char_type* __s2, size_t __n) noexcept
{
    if (__n == 0)
        return 0;

    return __builtin_wmemcmp(__s1, __s2, __n);
# 503 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__string" 3
}

inline constexpr
size_t
char_traits<wchar_t>::length(const char_type* __s) noexcept
{

    return __builtin_wcslen(__s);
# 519 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__string" 3
}

inline constexpr
const wchar_t*
char_traits<wchar_t>::find(const char_type* __s, size_t __n, const char_type& __a) noexcept
{
    if (__n == 0)
        return nullptr;

    return __builtin_wmemchr(__s, __a, __n);
# 540 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__string" 3
}


template <class _Traits>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
constexpr
inline size_t __char_traits_length_checked(const typename _Traits::char_type* __s) noexcept {



  return _Traits::length(__s);

}
# 665 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__string" 3
template <>
struct __attribute__ ((__type_visibility__("default"))) char_traits<char16_t>
{
    typedef char16_t char_type;
    typedef uint_least16_t int_type;
    typedef streamoff off_type;
    typedef u16streampos pos_type;
    typedef mbstate_t state_type;

    static inline constexpr
    void assign(char_type& __c1, const char_type& __c2) noexcept {__c1 = __c2;}
    static inline constexpr bool eq(char_type __c1, char_type __c2) noexcept
        {return __c1 == __c2;}
    static inline constexpr bool lt(char_type __c1, char_type __c2) noexcept
        {return __c1 < __c2;}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) static constexpr
    int compare(const char_type* __s1, const char_type* __s2, size_t __n) noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) static constexpr
    size_t length(const char_type* __s) noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) static constexpr
    const char_type* find(const char_type* __s, size_t __n, const char_type& __a) noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    static char_type* move(char_type* __s1, const char_type* __s2, size_t __n) noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    static char_type* copy(char_type* __s1, const char_type* __s2, size_t __n) noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    static char_type* assign(char_type* __s, size_t __n, char_type __a) noexcept;

    static inline constexpr int_type not_eof(int_type __c) noexcept
        {return eq_int_type(__c, eof()) ? ~eof() : __c;}
    static inline constexpr char_type to_char_type(int_type __c) noexcept
        {return char_type(__c);}
    static inline constexpr int_type to_int_type(char_type __c) noexcept
        {return int_type(__c);}
    static inline constexpr bool eq_int_type(int_type __c1, int_type __c2) noexcept
        {return __c1 == __c2;}
    static inline constexpr int_type eof() noexcept
        {return int_type(0xFFFF);}
};

inline constexpr
int
char_traits<char16_t>::compare(const char_type* __s1, const char_type* __s2, size_t __n) noexcept
{
    for (; __n; --__n, ++__s1, ++__s2)
    {
        if (lt(*__s1, *__s2))
            return -1;
        if (lt(*__s2, *__s1))
            return 1;
    }
    return 0;
}

inline constexpr
size_t
char_traits<char16_t>::length(const char_type* __s) noexcept
{
    size_t __len = 0;
    for (; !eq(*__s, char_type(0)); ++__s)
        ++__len;
    return __len;
}

inline constexpr
const char16_t*
char_traits<char16_t>::find(const char_type* __s, size_t __n, const char_type& __a) noexcept
{
    for (; __n; --__n)
    {
        if (eq(*__s, __a))
            return __s;
        ++__s;
    }
    return nullptr;
}

inline
char16_t*
char_traits<char16_t>::move(char_type* __s1, const char_type* __s2, size_t __n) noexcept
{
    if (__n == 0) return __s1;
    char_type* __r = __s1;
    if (__s1 < __s2)
    {
        for (; __n; --__n, ++__s1, ++__s2)
            assign(*__s1, *__s2);
    }
    else if (__s2 < __s1)
    {
        __s1 += __n;
        __s2 += __n;
        for (; __n; --__n)
            assign(*--__s1, *--__s2);
    }
    return __r;
}

inline
char16_t*
char_traits<char16_t>::copy(char_type* __s1, const char_type* __s2, size_t __n) noexcept
{
    ((void)0);
    char_type* __r = __s1;
    for (; __n; --__n, ++__s1, ++__s2)
        assign(*__s1, *__s2);
    return __r;
}

inline
char16_t*
char_traits<char16_t>::assign(char_type* __s, size_t __n, char_type __a) noexcept
{
    char_type* __r = __s;
    for (; __n; --__n, ++__s)
        assign(*__s, __a);
    return __r;
}

template <>
struct __attribute__ ((__type_visibility__("default"))) char_traits<char32_t>
{
    typedef char32_t char_type;
    typedef uint_least32_t int_type;
    typedef streamoff off_type;
    typedef u32streampos pos_type;
    typedef mbstate_t state_type;

    static inline constexpr
    void assign(char_type& __c1, const char_type& __c2) noexcept {__c1 = __c2;}
    static inline constexpr bool eq(char_type __c1, char_type __c2) noexcept
        {return __c1 == __c2;}
    static inline constexpr bool lt(char_type __c1, char_type __c2) noexcept
        {return __c1 < __c2;}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) static constexpr
    int compare(const char_type* __s1, const char_type* __s2, size_t __n) noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) static constexpr
    size_t length(const char_type* __s) noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) static constexpr
    const char_type* find(const char_type* __s, size_t __n, const char_type& __a) noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    static char_type* move(char_type* __s1, const char_type* __s2, size_t __n) noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    static char_type* copy(char_type* __s1, const char_type* __s2, size_t __n) noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    static char_type* assign(char_type* __s, size_t __n, char_type __a) noexcept;

    static inline constexpr int_type not_eof(int_type __c) noexcept
        {return eq_int_type(__c, eof()) ? ~eof() : __c;}
    static inline constexpr char_type to_char_type(int_type __c) noexcept
        {return char_type(__c);}
    static inline constexpr int_type to_int_type(char_type __c) noexcept
        {return int_type(__c);}
    static inline constexpr bool eq_int_type(int_type __c1, int_type __c2) noexcept
        {return __c1 == __c2;}
    static inline constexpr int_type eof() noexcept
        {return int_type(0xFFFFFFFF);}
};

inline constexpr
int
char_traits<char32_t>::compare(const char_type* __s1, const char_type* __s2, size_t __n) noexcept
{
    for (; __n; --__n, ++__s1, ++__s2)
    {
        if (lt(*__s1, *__s2))
            return -1;
        if (lt(*__s2, *__s1))
            return 1;
    }
    return 0;
}

inline constexpr
size_t
char_traits<char32_t>::length(const char_type* __s) noexcept
{
    size_t __len = 0;
    for (; !eq(*__s, char_type(0)); ++__s)
        ++__len;
    return __len;
}

inline constexpr
const char32_t*
char_traits<char32_t>::find(const char_type* __s, size_t __n, const char_type& __a) noexcept
{
    for (; __n; --__n)
    {
        if (eq(*__s, __a))
            return __s;
        ++__s;
    }
    return nullptr;
}

inline
char32_t*
char_traits<char32_t>::move(char_type* __s1, const char_type* __s2, size_t __n) noexcept
{
    if (__n == 0) return __s1;
    char_type* __r = __s1;
    if (__s1 < __s2)
    {
        for (; __n; --__n, ++__s1, ++__s2)
            assign(*__s1, *__s2);
    }
    else if (__s2 < __s1)
    {
        __s1 += __n;
        __s2 += __n;
        for (; __n; --__n)
            assign(*--__s1, *--__s2);
    }
    return __r;
}

inline
char32_t*
char_traits<char32_t>::copy(char_type* __s1, const char_type* __s2, size_t __n) noexcept
{
    ((void)0);
    char_type* __r = __s1;
    for (; __n; --__n, ++__s1, ++__s2)
        assign(*__s1, *__s2);
    return __r;
}

inline
char32_t*
char_traits<char32_t>::assign(char_type* __s, size_t __n, char_type __a) noexcept
{
    char_type* __r = __s;
    for (; __n; --__n, ++__s)
        assign(*__s, __a);
    return __r;
}






template<class _CharT, class _SizeT, class _Traits, _SizeT __npos>
inline _SizeT constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
__str_find(const _CharT *__p, _SizeT __sz,
             _CharT __c, _SizeT __pos) noexcept
{
    if (__pos >= __sz)
        return __npos;
    const _CharT* __r = _Traits::find(__p + __pos, __sz - __pos, __c);
    if (__r == nullptr)
        return __npos;
    return static_cast<_SizeT>(__r - __p);
}

template <class _CharT, class _Traits>
inline constexpr const _CharT *
__search_substring(const _CharT *__first1, const _CharT *__last1,
                   const _CharT *__first2, const _CharT *__last2) noexcept {


  const ptrdiff_t __len2 = __last2 - __first2;
  if (__len2 == 0)
    return __first1;

  ptrdiff_t __len1 = __last1 - __first1;
  if (__len1 < __len2)
    return __last1;


  _CharT __f2 = *__first2;
  while (true) {
    __len1 = __last1 - __first1;

    if (__len1 < __len2)
      return __last1;


    __first1 = _Traits::find(__first1, __len1 - __len2 + 1, __f2);
    if (__first1 == nullptr)
      return __last1;






    if (_Traits::compare(__first1, __first2, __len2) == 0)
      return __first1;

    ++__first1;
  }
}

template<class _CharT, class _SizeT, class _Traits, _SizeT __npos>
inline _SizeT constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
__str_find(const _CharT *__p, _SizeT __sz,
       const _CharT* __s, _SizeT __pos, _SizeT __n) noexcept
{
    if (__pos > __sz)
        return __npos;

    if (__n == 0)
        return __pos;

    const _CharT *__r = __search_substring<_CharT, _Traits>(
        __p + __pos, __p + __sz, __s, __s + __n);

    if (__r == __p + __sz)
        return __npos;
    return static_cast<_SizeT>(__r - __p);
}




template<class _CharT, class _SizeT, class _Traits, _SizeT __npos>
inline _SizeT constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
__str_rfind(const _CharT *__p, _SizeT __sz,
              _CharT __c, _SizeT __pos) noexcept
{
    if (__sz < 1)
        return __npos;
    if (__pos < __sz)
        ++__pos;
    else
        __pos = __sz;
    for (const _CharT* __ps = __p + __pos; __ps != __p;)
    {
        if (_Traits::eq(*--__ps, __c))
            return static_cast<_SizeT>(__ps - __p);
    }
    return __npos;
}

template<class _CharT, class _SizeT, class _Traits, _SizeT __npos>
inline _SizeT constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
__str_rfind(const _CharT *__p, _SizeT __sz,
        const _CharT* __s, _SizeT __pos, _SizeT __n) noexcept
{
    __pos = std::__1::min(__pos, __sz);
    if (__n < __sz - __pos)
        __pos += __n;
    else
        __pos = __sz;
    const _CharT* __r = std::__1::__find_end(
                  __p, __p + __pos, __s, __s + __n, _Traits::eq,
                        random_access_iterator_tag(), random_access_iterator_tag());
    if (__n > 0 && __r == __p + __pos)
        return __npos;
    return static_cast<_SizeT>(__r - __p);
}


template<class _CharT, class _SizeT, class _Traits, _SizeT __npos>
inline _SizeT constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
__str_find_first_of(const _CharT *__p, _SizeT __sz,
                const _CharT* __s, _SizeT __pos, _SizeT __n) noexcept
{
    if (__pos >= __sz || __n == 0)
        return __npos;
    const _CharT* __r = std::__1::__find_first_of_ce
        (__p + __pos, __p + __sz, __s, __s + __n, _Traits::eq );
    if (__r == __p + __sz)
        return __npos;
    return static_cast<_SizeT>(__r - __p);
}



template<class _CharT, class _SizeT, class _Traits, _SizeT __npos>
inline _SizeT constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
__str_find_last_of(const _CharT *__p, _SizeT __sz,
               const _CharT* __s, _SizeT __pos, _SizeT __n) noexcept
    {
    if (__n != 0)
    {
        if (__pos < __sz)
            ++__pos;
        else
            __pos = __sz;
        for (const _CharT* __ps = __p + __pos; __ps != __p;)
        {
            const _CharT* __r = _Traits::find(__s, __n, *--__ps);
            if (__r)
                return static_cast<_SizeT>(__ps - __p);
        }
    }
    return __npos;
}



template<class _CharT, class _SizeT, class _Traits, _SizeT __npos>
inline _SizeT constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
__str_find_first_not_of(const _CharT *__p, _SizeT __sz,
                    const _CharT* __s, _SizeT __pos, _SizeT __n) noexcept
{
    if (__pos < __sz)
    {
        const _CharT* __pe = __p + __sz;
        for (const _CharT* __ps = __p + __pos; __ps != __pe; ++__ps)
            if (_Traits::find(__s, __n, *__ps) == nullptr)
                return static_cast<_SizeT>(__ps - __p);
    }
    return __npos;
}


template<class _CharT, class _SizeT, class _Traits, _SizeT __npos>
inline _SizeT constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
__str_find_first_not_of(const _CharT *__p, _SizeT __sz,
                          _CharT __c, _SizeT __pos) noexcept
{
    if (__pos < __sz)
    {
        const _CharT* __pe = __p + __sz;
        for (const _CharT* __ps = __p + __pos; __ps != __pe; ++__ps)
            if (!_Traits::eq(*__ps, __c))
                return static_cast<_SizeT>(__ps - __p);
    }
    return __npos;
}



template<class _CharT, class _SizeT, class _Traits, _SizeT __npos>
inline _SizeT constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
__str_find_last_not_of(const _CharT *__p, _SizeT __sz,
                   const _CharT* __s, _SizeT __pos, _SizeT __n) noexcept
{
    if (__pos < __sz)
        ++__pos;
    else
        __pos = __sz;
    for (const _CharT* __ps = __p + __pos; __ps != __p;)
        if (_Traits::find(__s, __n, *--__ps) == nullptr)
            return static_cast<_SizeT>(__ps - __p);
    return __npos;
}


template<class _CharT, class _SizeT, class _Traits, _SizeT __npos>
inline _SizeT constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
__str_find_last_not_of(const _CharT *__p, _SizeT __sz,
                         _CharT __c, _SizeT __pos) noexcept
{
    if (__pos < __sz)
        ++__pos;
    else
        __pos = __sz;
    for (const _CharT* __ps = __p + __pos; __ps != __p;)
        if (!_Traits::eq(*--__ps, __c))
            return static_cast<_SizeT>(__ps - __p);
    return __npos;
}

template<class _Ptr>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
size_t __do_string_hash(_Ptr __p, _Ptr __e)
{
    typedef typename iterator_traits<_Ptr>::value_type value_type;
    return __murmur2_or_cityhash<size_t>()(__p, (__e-__p)*sizeof(value_type));
}

template <class _CharT, class _Iter, class _Traits=char_traits<_CharT> >
struct __quoted_output_proxy
{
    _Iter __first;
    _Iter __last;
    _CharT __delim;
    _CharT __escape;

    __quoted_output_proxy(_Iter __f, _Iter __l, _CharT __d, _CharT __e)
    : __first(__f), __last(__l), __delim(__d), __escape(__e) {}

};

} }
# 193 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/string_view" 2 3
# 203 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/string_view" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 207 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/string_view" 2 3


namespace std { inline namespace __1 {

template<class _CharT, class _Traits = char_traits<_CharT> >
    class __attribute__ ((__type_visibility__("default"))) basic_string_view;

typedef basic_string_view<char> string_view;



typedef basic_string_view<char16_t> u16string_view;
typedef basic_string_view<char32_t> u32string_view;

typedef basic_string_view<wchar_t> wstring_view;


template<class _CharT, class _Traits>
class
    __attribute__((__preferred_name__(string_view)))



    __attribute__((__preferred_name__(u16string_view)))
    __attribute__((__preferred_name__(u32string_view)))
    __attribute__((__preferred_name__(wstring_view)))
    basic_string_view {
public:

    typedef _Traits traits_type;
    typedef _CharT value_type;
    typedef _CharT* pointer;
    typedef const _CharT* const_pointer;
    typedef _CharT& reference;
    typedef const _CharT& const_reference;
    typedef const_pointer const_iterator;
    typedef const_iterator iterator;
    typedef std::__1::reverse_iterator<const_iterator> const_reverse_iterator;
    typedef const_reverse_iterator reverse_iterator;
    typedef size_t size_type;
    typedef ptrdiff_t difference_type;
    static constexpr const size_type npos = -1;

    static_assert((!is_array<value_type>::value), "Character type of basic_string_view must not be an array");
    static_assert(( is_standard_layout<value_type>::value), "Character type of basic_string_view must be standard-layout");
    static_assert(( is_trivial<value_type>::value), "Character type of basic_string_view must be trivial");
    static_assert((is_same<_CharT, typename traits_type::char_type>::value),
                  "traits_type::char_type must be the same type as CharT");


    constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    basic_string_view() noexcept : __data (nullptr), __size(0) {}

    constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    basic_string_view(const basic_string_view&) noexcept = default;

    constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    basic_string_view& operator=(const basic_string_view&) noexcept = default;

    constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    basic_string_view(const _CharT* __s, size_type __len) noexcept
        : __data(__s), __size(__len)
    {

    ((void)0);

    }

    constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    basic_string_view(const _CharT* __s)
        : __data(__s), __size(std::__1::__char_traits_length_checked<_Traits>(__s)) {}






    constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_iterator begin() const noexcept { return cbegin(); }

    constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_iterator end() const noexcept { return cend(); }

    constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_iterator cbegin() const noexcept { return __data; }

    constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_iterator cend() const noexcept { return __data + __size; }

    constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_reverse_iterator rbegin() const noexcept { return const_reverse_iterator(cend()); }

    constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_reverse_iterator rend() const noexcept { return const_reverse_iterator(cbegin()); }

    constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_reverse_iterator crbegin() const noexcept { return const_reverse_iterator(cend()); }

    constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_reverse_iterator crend() const noexcept { return const_reverse_iterator(cbegin()); }


    constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_type size() const noexcept { return __size; }

    constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_type length() const noexcept { return __size; }

    constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_type max_size() const noexcept { return numeric_limits<size_type>::max(); }

                                  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
    bool empty() const noexcept { return __size == 0; }


    constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_reference operator[](size_type __pos) const noexcept {
      return ((void)0), __data[__pos];
    }

    constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_reference at(size_type __pos) const
    {
        return __pos >= size()
            ? (__throw_out_of_range("string_view::at"), __data[0])
            : __data[__pos];
    }

    constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_reference front() const noexcept
    {
        return ((void)0), __data[0];
    }

    constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_reference back() const noexcept
    {
        return ((void)0), __data[__size-1];
    }

    constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_pointer data() const noexcept { return __data; }


    constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void remove_prefix(size_type __n) noexcept
    {
        ((void)0);
        __data += __n;
        __size -= __n;
    }

    constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void remove_suffix(size_type __n) noexcept
    {
        ((void)0);
        __size -= __n;
    }

    constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void swap(basic_string_view& __other) noexcept
    {
        const value_type *__p = __data;
        __data = __other.__data;
        __other.__data = __p;

        size_type __sz = __size;
        __size = __other.__size;
        __other.__size = __sz;
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_type copy(_CharT* __s, size_type __n, size_type __pos = 0) const
    {
        if (__pos > size())
            __throw_out_of_range("string_view::copy");
        size_type __rlen = std::__1::min(__n, size() - __pos);
        _Traits::copy(__s, data() + __pos, __rlen);
        return __rlen;
    }

    constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    basic_string_view substr(size_type __pos = 0, size_type __n = npos) const
    {
        return __pos > size()
            ? (__throw_out_of_range("string_view::substr"), basic_string_view())
            : basic_string_view(data() + __pos, std::__1::min(__n, size() - __pos));
    }

    constexpr int compare(basic_string_view __sv) const noexcept
    {
        size_type __rlen = std::__1::min( size(), __sv.size());
        int __retval = _Traits::compare(data(), __sv.data(), __rlen);
        if ( __retval == 0 )
            __retval = size() == __sv.size() ? 0 : ( size() < __sv.size() ? -1 : 1 );
        return __retval;
    }

    constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    int compare(size_type __pos1, size_type __n1, basic_string_view __sv) const
    {
        return substr(__pos1, __n1).compare(__sv);
    }

    constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    int compare( size_type __pos1, size_type __n1,
                basic_string_view __sv, size_type __pos2, size_type __n2) const
    {
        return substr(__pos1, __n1).compare(__sv.substr(__pos2, __n2));
    }

    constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    int compare(const _CharT* __s) const noexcept
    {
        return compare(basic_string_view(__s));
    }

    constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    int compare(size_type __pos1, size_type __n1, const _CharT* __s) const
    {
        return substr(__pos1, __n1).compare(basic_string_view(__s));
    }

    constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    int compare(size_type __pos1, size_type __n1, const _CharT* __s, size_type __n2) const
    {
        return substr(__pos1, __n1).compare(basic_string_view(__s, __n2));
    }


    constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_type find(basic_string_view __s, size_type __pos = 0) const noexcept
    {
        ((void)0);
        return __str_find<value_type, size_type, traits_type, npos>
            (data(), size(), __s.data(), __pos, __s.size());
    }

    constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_type find(_CharT __c, size_type __pos = 0) const noexcept
    {
        return __str_find<value_type, size_type, traits_type, npos>
            (data(), size(), __c, __pos);
    }

    constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_type find(const _CharT* __s, size_type __pos, size_type __n) const noexcept
    {
        ((void)0);
        return __str_find<value_type, size_type, traits_type, npos>
            (data(), size(), __s, __pos, __n);
    }

    constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_type find(const _CharT* __s, size_type __pos = 0) const noexcept
    {
        ((void)0);
        return __str_find<value_type, size_type, traits_type, npos>
            (data(), size(), __s, __pos, traits_type::length(__s));
    }


    constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_type rfind(basic_string_view __s, size_type __pos = npos) const noexcept
    {
        ((void)0);
        return __str_rfind<value_type, size_type, traits_type, npos>
            (data(), size(), __s.data(), __pos, __s.size());
    }

    constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_type rfind(_CharT __c, size_type __pos = npos) const noexcept
    {
        return __str_rfind<value_type, size_type, traits_type, npos>
            (data(), size(), __c, __pos);
    }

    constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_type rfind(const _CharT* __s, size_type __pos, size_type __n) const noexcept
    {
        ((void)0);
        return __str_rfind<value_type, size_type, traits_type, npos>
            (data(), size(), __s, __pos, __n);
    }

    constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_type rfind(const _CharT* __s, size_type __pos=npos) const noexcept
    {
        ((void)0);
        return __str_rfind<value_type, size_type, traits_type, npos>
            (data(), size(), __s, __pos, traits_type::length(__s));
    }


    constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_type find_first_of(basic_string_view __s, size_type __pos = 0) const noexcept
    {
        ((void)0);
        return __str_find_first_of<value_type, size_type, traits_type, npos>
            (data(), size(), __s.data(), __pos, __s.size());
    }

    constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_type find_first_of(_CharT __c, size_type __pos = 0) const noexcept
    { return find(__c, __pos); }

    constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_type find_first_of(const _CharT* __s, size_type __pos, size_type __n) const noexcept
    {
        ((void)0);
        return __str_find_first_of<value_type, size_type, traits_type, npos>
            (data(), size(), __s, __pos, __n);
    }

    constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_type find_first_of(const _CharT* __s, size_type __pos=0) const noexcept
    {
        ((void)0);
        return __str_find_first_of<value_type, size_type, traits_type, npos>
            (data(), size(), __s, __pos, traits_type::length(__s));
    }


    constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_type find_last_of(basic_string_view __s, size_type __pos=npos) const noexcept
    {
        ((void)0);
        return __str_find_last_of<value_type, size_type, traits_type, npos>
            (data(), size(), __s.data(), __pos, __s.size());
    }

    constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_type find_last_of(_CharT __c, size_type __pos = npos) const noexcept
    { return rfind(__c, __pos); }

    constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_type find_last_of(const _CharT* __s, size_type __pos, size_type __n) const noexcept
    {
        ((void)0);
        return __str_find_last_of<value_type, size_type, traits_type, npos>
            (data(), size(), __s, __pos, __n);
    }

    constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_type find_last_of(const _CharT* __s, size_type __pos=npos) const noexcept
    {
        ((void)0);
        return __str_find_last_of<value_type, size_type, traits_type, npos>
            (data(), size(), __s, __pos, traits_type::length(__s));
    }


    constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_type find_first_not_of(basic_string_view __s, size_type __pos=0) const noexcept
    {
        ((void)0);
        return __str_find_first_not_of<value_type, size_type, traits_type, npos>
            (data(), size(), __s.data(), __pos, __s.size());
    }

    constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_type find_first_not_of(_CharT __c, size_type __pos=0) const noexcept
    {
        return __str_find_first_not_of<value_type, size_type, traits_type, npos>
            (data(), size(), __c, __pos);
    }

    constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_type find_first_not_of(const _CharT* __s, size_type __pos, size_type __n) const noexcept
    {
        ((void)0);
        return __str_find_first_not_of<value_type, size_type, traits_type, npos>
            (data(), size(), __s, __pos, __n);
    }

    constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_type find_first_not_of(const _CharT* __s, size_type __pos=0) const noexcept
    {
        ((void)0);
        return __str_find_first_not_of<value_type, size_type, traits_type, npos>
            (data(), size(), __s, __pos, traits_type::length(__s));
    }


    constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_type find_last_not_of(basic_string_view __s, size_type __pos=npos) const noexcept
    {
        ((void)0);
        return __str_find_last_not_of<value_type, size_type, traits_type, npos>
            (data(), size(), __s.data(), __pos, __s.size());
    }

    constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_type find_last_not_of(_CharT __c, size_type __pos=npos) const noexcept
    {
        return __str_find_last_not_of<value_type, size_type, traits_type, npos>
            (data(), size(), __c, __pos);
    }

    constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_type find_last_not_of(const _CharT* __s, size_type __pos, size_type __n) const noexcept
    {
        ((void)0);
        return __str_find_last_not_of<value_type, size_type, traits_type, npos>
            (data(), size(), __s, __pos, __n);
    }

    constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_type find_last_not_of(const _CharT* __s, size_type __pos=npos) const noexcept
    {
        ((void)0);
        return __str_find_last_not_of<value_type, size_type, traits_type, npos>
            (data(), size(), __s, __pos, traits_type::length(__s));
    }
# 662 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/string_view" 3
private:
    const value_type* __data;
    size_type __size;
};
# 677 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/string_view" 3
template<class _CharT, class _Traits>
constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool operator==(basic_string_view<_CharT, _Traits> __lhs,
                basic_string_view<_CharT, _Traits> __rhs) noexcept
{
    if ( __lhs.size() != __rhs.size()) return false;
    return __lhs.compare(__rhs) == 0;
}

template<class _CharT, class _Traits>
constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool operator==(basic_string_view<_CharT, _Traits> __lhs,
                typename common_type<basic_string_view<_CharT, _Traits> >::type __rhs) noexcept
{
    if ( __lhs.size() != __rhs.size()) return false;
    return __lhs.compare(__rhs) == 0;
}

template<class _CharT, class _Traits>
constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool operator==(typename common_type<basic_string_view<_CharT, _Traits> >::type __lhs,
                basic_string_view<_CharT, _Traits> __rhs) noexcept
{
    if ( __lhs.size() != __rhs.size()) return false;
    return __lhs.compare(__rhs) == 0;
}



template<class _CharT, class _Traits>
constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool operator!=(basic_string_view<_CharT, _Traits> __lhs, basic_string_view<_CharT, _Traits> __rhs) noexcept
{
    if ( __lhs.size() != __rhs.size())
        return true;
    return __lhs.compare(__rhs) != 0;
}

template<class _CharT, class _Traits>
constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool operator!=(basic_string_view<_CharT, _Traits> __lhs,
                typename common_type<basic_string_view<_CharT, _Traits> >::type __rhs) noexcept
{
    if ( __lhs.size() != __rhs.size())
        return true;
    return __lhs.compare(__rhs) != 0;
}

template<class _CharT, class _Traits>
constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool operator!=(typename common_type<basic_string_view<_CharT, _Traits> >::type __lhs,
                basic_string_view<_CharT, _Traits> __rhs) noexcept
{
    if ( __lhs.size() != __rhs.size())
        return true;
    return __lhs.compare(__rhs) != 0;
}



template<class _CharT, class _Traits>
constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool operator<(basic_string_view<_CharT, _Traits> __lhs, basic_string_view<_CharT, _Traits> __rhs) noexcept
{
    return __lhs.compare(__rhs) < 0;
}

template<class _CharT, class _Traits>
constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool operator<(basic_string_view<_CharT, _Traits> __lhs,
                typename common_type<basic_string_view<_CharT, _Traits> >::type __rhs) noexcept
{
    return __lhs.compare(__rhs) < 0;
}

template<class _CharT, class _Traits>
constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool operator<(typename common_type<basic_string_view<_CharT, _Traits> >::type __lhs,
                basic_string_view<_CharT, _Traits> __rhs) noexcept
{
    return __lhs.compare(__rhs) < 0;
}



template<class _CharT, class _Traits>
constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool operator> (basic_string_view<_CharT, _Traits> __lhs, basic_string_view<_CharT, _Traits> __rhs) noexcept
{
    return __lhs.compare(__rhs) > 0;
}

template<class _CharT, class _Traits>
constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool operator>(basic_string_view<_CharT, _Traits> __lhs,
                typename common_type<basic_string_view<_CharT, _Traits> >::type __rhs) noexcept
{
    return __lhs.compare(__rhs) > 0;
}

template<class _CharT, class _Traits>
constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool operator>(typename common_type<basic_string_view<_CharT, _Traits> >::type __lhs,
                basic_string_view<_CharT, _Traits> __rhs) noexcept
{
    return __lhs.compare(__rhs) > 0;
}



template<class _CharT, class _Traits>
constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool operator<=(basic_string_view<_CharT, _Traits> __lhs, basic_string_view<_CharT, _Traits> __rhs) noexcept
{
    return __lhs.compare(__rhs) <= 0;
}

template<class _CharT, class _Traits>
constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool operator<=(basic_string_view<_CharT, _Traits> __lhs,
                typename common_type<basic_string_view<_CharT, _Traits> >::type __rhs) noexcept
{
    return __lhs.compare(__rhs) <= 0;
}

template<class _CharT, class _Traits>
constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool operator<=(typename common_type<basic_string_view<_CharT, _Traits> >::type __lhs,
                basic_string_view<_CharT, _Traits> __rhs) noexcept
{
    return __lhs.compare(__rhs) <= 0;
}



template<class _CharT, class _Traits>
constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool operator>=(basic_string_view<_CharT, _Traits> __lhs, basic_string_view<_CharT, _Traits> __rhs) noexcept
{
    return __lhs.compare(__rhs) >= 0;
}


template<class _CharT, class _Traits>
constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool operator>=(basic_string_view<_CharT, _Traits> __lhs,
                typename common_type<basic_string_view<_CharT, _Traits> >::type __rhs) noexcept
{
    return __lhs.compare(__rhs) >= 0;
}

template<class _CharT, class _Traits>
constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool operator>=(typename common_type<basic_string_view<_CharT, _Traits> >::type __lhs,
                basic_string_view<_CharT, _Traits> __rhs) noexcept
{
    return __lhs.compare(__rhs) >= 0;
}


template<class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>&
operator<<(basic_ostream<_CharT, _Traits>& __os,
           basic_string_view<_CharT, _Traits> __str);


template<class _CharT>
struct __attribute__ ((__type_visibility__("default"))) hash<basic_string_view<_CharT, char_traits<_CharT> > >
    : public unary_function<basic_string_view<_CharT, char_traits<_CharT> >, size_t>
{
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_t operator()(const basic_string_view<_CharT, char_traits<_CharT> > __val) const noexcept {
        return __do_string_hash(__val.data(), __val.data() + __val.size());
    }
};



inline namespace literals
{
  inline namespace string_view_literals
  {
    inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
    basic_string_view<char> operator "" sv(const char *__str, size_t __len) noexcept
    {
        return basic_string_view<char> (__str, __len);
    }


    inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
    basic_string_view<wchar_t> operator "" sv(const wchar_t *__str, size_t __len) noexcept
    {
        return basic_string_view<wchar_t> (__str, __len);
    }
# 881 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/string_view" 3
    inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
    basic_string_view<char16_t> operator "" sv(const char16_t *__str, size_t __len) noexcept
    {
        return basic_string_view<char16_t> (__str, __len);
    }

    inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
    basic_string_view<char32_t> operator "" sv(const char32_t *__str, size_t __len) noexcept
    {
        return basic_string_view<char32_t> (__str, __len);
    }
  }
}

} }
# 533 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/string" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 1 3
# 534 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/string" 2 3
# 547 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/string" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 551 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/string" 2 3


namespace std { inline namespace __1 {



template <class _StateT>
class __attribute__ ((__type_visibility__("default"))) fpos
{
private:
    _StateT __st_;
    streamoff __off_;
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) fpos(streamoff __off = streamoff()) : __st_(), __off_(__off) {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) operator streamoff() const {return __off_;}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) _StateT state() const {return __st_;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) void state(_StateT __st) {__st_ = __st;}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) fpos& operator+=(streamoff __off) {__off_ += __off; return *this;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) fpos operator+ (streamoff __off) const {fpos __t(*this); __t += __off; return __t;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) fpos& operator-=(streamoff __off) {__off_ -= __off; return *this;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) fpos operator- (streamoff __off) const {fpos __t(*this); __t -= __off; return __t;}
};

template <class _StateT>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
streamoff operator-(const fpos<_StateT>& __x, const fpos<_StateT>& __y)
    {return streamoff(__x) - streamoff(__y);}

template <class _StateT>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool operator==(const fpos<_StateT>& __x, const fpos<_StateT>& __y)
    {return streamoff(__x) == streamoff(__y);}

template <class _StateT>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool operator!=(const fpos<_StateT>& __x, const fpos<_StateT>& __y)
    {return streamoff(__x) != streamoff(__y);}



template<class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>
operator+(const basic_string<_CharT, _Traits, _Allocator>& __x,
          const basic_string<_CharT, _Traits, _Allocator>& __y);

template<class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>
operator+(const _CharT* __x, const basic_string<_CharT,_Traits,_Allocator>& __y);

template<class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>
operator+(_CharT __x, const basic_string<_CharT,_Traits,_Allocator>& __y);

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
basic_string<_CharT, _Traits, _Allocator>
operator+(const basic_string<_CharT, _Traits, _Allocator>& __x, const _CharT* __y);

template<class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>
operator+(const basic_string<_CharT, _Traits, _Allocator>& __x, _CharT __y);

extern template __attribute__ ((__visibility__("default"))) string operator+<char, char_traits<char>, allocator<char> >(char const*, string const&);

template <bool>
class __attribute__ ((__type_visibility__("default"))) __basic_string_common
{
protected:
    [[noreturn]] void __throw_length_error() const;
    [[noreturn]] void __throw_out_of_range() const;
};

template <bool __b>
void
__basic_string_common<__b>::__throw_length_error() const
{
    std::__1::__throw_length_error("basic_string");
}

template <bool __b>
void
__basic_string_common<__b>::__throw_out_of_range() const
{
    std::__1::__throw_out_of_range("basic_string");
}

extern template class __attribute__ ((__visibility__("default"))) __basic_string_common<true>;

template <class _Iter>
struct __string_is_trivial_iterator : public false_type {};

template <class _Tp>
struct __string_is_trivial_iterator<_Tp*>
    : public is_arithmetic<_Tp> {};

template <class _Iter>
struct __string_is_trivial_iterator<__wrap_iter<_Iter> >
    : public __string_is_trivial_iterator<_Iter> {};

template <class _CharT, class _Traits, class _Tp>
struct __can_be_converted_to_string_view : public _BoolConstant<
      is_convertible<const _Tp&, basic_string_view<_CharT, _Traits> >::value &&
     !is_convertible<const _Tp&, const _CharT*>::value
    > {};



template <class _CharT, size_t = sizeof(_CharT)>
struct __padding
{
    unsigned char __xx[sizeof(_CharT)-1];
};

template <class _CharT>
struct __padding<_CharT, 1>
{
};
# 679 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/string" 3
typedef basic_string<char16_t> u16string;
typedef basic_string<char32_t> u32string;


template<class _CharT, class _Traits, class _Allocator>
class
    __attribute__ ((__type_visibility__("default")))




    __attribute__((__preferred_name__(u16string)))
    __attribute__((__preferred_name__(u32string)))

    basic_string
    : private __basic_string_common<true>
{
public:
    typedef basic_string __self;
    typedef basic_string_view<_CharT, _Traits> __self_view;
    typedef _Traits traits_type;
    typedef _CharT value_type;
    typedef _Allocator allocator_type;
    typedef allocator_traits<allocator_type> __alloc_traits;
    typedef typename __alloc_traits::size_type size_type;
    typedef typename __alloc_traits::difference_type difference_type;
    typedef value_type& reference;
    typedef const value_type& const_reference;
    typedef typename __alloc_traits::pointer pointer;
    typedef typename __alloc_traits::const_pointer const_pointer;

    static_assert((!is_array<value_type>::value), "Character type of basic_string must not be an array");
    static_assert(( is_standard_layout<value_type>::value), "Character type of basic_string must be standard-layout");
    static_assert(( is_trivial<value_type>::value), "Character type of basic_string must be trivial");
    static_assert(( is_same<_CharT, typename traits_type::char_type>::value),
                  "traits_type::char_type must be the same type as CharT");
    static_assert(( is_same<typename allocator_type::value_type, value_type>::value),
                  "Allocator::value_type must be same type as value_type");

    typedef __wrap_iter<pointer> iterator;
    typedef __wrap_iter<const_pointer> const_iterator;
    typedef std::__1::reverse_iterator<iterator> reverse_iterator;
    typedef std::__1::reverse_iterator<const_iterator> const_reverse_iterator;

private:



    struct __long
    {
        pointer __data_;
        size_type __size_;
        size_type __cap_;
    };





    static const size_type __short_mask = 0x80;
    static const size_type __long_mask = ~(size_type(~0) >> 1);


    enum {__min_cap = (sizeof(__long) - 1)/sizeof(value_type) > 2 ?
                      (sizeof(__long) - 1)/sizeof(value_type) : 2};

    struct __short
    {
        value_type __data_[__min_cap];
        struct
            : __padding<value_type>
        {
            unsigned char __size_;
        };
    };
# 787 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/string" 3
    union __ulx{__long __lx; __short __lxx;};

    enum {__n_words = sizeof(__ulx) / sizeof(size_type)};

    struct __raw
    {
        size_type __words[__n_words];
    };

    struct __rep
    {
        union
        {
            __long __l;
            __short __s;
            __raw __r;
        };
    };

    __compressed_pair<__rep, allocator_type> __r_;

public:
    __attribute__ ((__visibility__("default")))
    static const size_type npos = -1;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) basic_string()
        noexcept(is_nothrow_default_constructible<allocator_type>::value);

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) explicit basic_string(const allocator_type& __a)



        noexcept;


    basic_string(const basic_string& __str);
    basic_string(const basic_string& __str, const allocator_type& __a);


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    basic_string(basic_string&& __str)



        noexcept;


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    basic_string(basic_string&& __str, const allocator_type& __a);


    template <class = _EnableIf<__is_allocator<_Allocator>::value, nullptr_t> >
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    basic_string(const _CharT* __s) : __r_(__default_init_tag(), __default_init_tag()) {
      ((void)0);
      __init(__s, traits_type::length(__s));



    }

    template <class = _EnableIf<__is_allocator<_Allocator>::value, nullptr_t> >
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        basic_string(const _CharT* __s, const _Allocator& __a);





    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    basic_string(const _CharT* __s, size_type __n);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    basic_string(const _CharT* __s, size_type __n, const _Allocator& __a);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    basic_string(size_type __n, _CharT __c);

    template <class = _EnableIf<__is_allocator<_Allocator>::value, nullptr_t> >
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        basic_string(size_type __n, _CharT __c, const _Allocator& __a);

    basic_string(const basic_string& __str, size_type __pos, size_type __n,
                 const _Allocator& __a = _Allocator());
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    basic_string(const basic_string& __str, size_type __pos,
                 const _Allocator& __a = _Allocator());

    template<class _Tp, class = _EnableIf<__can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value && !__is_same_uncvref<_Tp, basic_string>::value> >
        inline __attribute__ ((__visibility__("hidden")))
        basic_string(const _Tp& __t, size_type __pos, size_type __n,
                     const allocator_type& __a = allocator_type());

    template<class _Tp, class = _EnableIf<__can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value &&
                                          !__is_same_uncvref<_Tp, basic_string>::value> >
        inline __attribute__ ((__visibility__("hidden")))
        explicit basic_string(const _Tp& __t);

    template<class _Tp, class = _EnableIf<__can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value && !__is_same_uncvref<_Tp, basic_string>::value> >
        inline __attribute__ ((__visibility__("hidden")))
        explicit basic_string(const _Tp& __t, const allocator_type& __a);

    template<class _InputIterator, class = _EnableIf<__is_cpp17_input_iterator<_InputIterator>::value> >
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        basic_string(_InputIterator __first, _InputIterator __last);
    template<class _InputIterator, class = _EnableIf<__is_cpp17_input_iterator<_InputIterator>::value> >
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        basic_string(_InputIterator __first, _InputIterator __last, const allocator_type& __a);

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    basic_string(initializer_list<_CharT> __il);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    basic_string(initializer_list<_CharT> __il, const _Allocator& __a);


    inline ~basic_string();

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    operator __self_view() const noexcept { return __self_view(data(), size()); }

    basic_string& operator=(const basic_string& __str);

    template <class _Tp, class = _EnableIf<__can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value && !__is_same_uncvref<_Tp, basic_string>::value> >
    basic_string& operator=(const _Tp& __t)
        {__self_view __sv = __t; return assign(__sv);}


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    basic_string& operator=(basic_string&& __str)
        noexcept((__noexcept_move_assign_container<_Allocator, __alloc_traits>::value));
     __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    basic_string& operator=(initializer_list<value_type> __il) {return assign(__il.begin(), __il.size());}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) basic_string& operator=(const value_type* __s) {return assign(__s);}



    basic_string& operator=(value_type __c);
# 938 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/string" 3
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iterator begin() noexcept
        {return iterator(__get_pointer());}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_iterator begin() const noexcept
        {return const_iterator(__get_pointer());}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iterator end() noexcept
        {return iterator(__get_pointer() + size());}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_iterator end() const noexcept
        {return const_iterator(__get_pointer() + size());}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    reverse_iterator rbegin() noexcept
        {return reverse_iterator(end());}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_reverse_iterator rbegin() const noexcept
        {return const_reverse_iterator(end());}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    reverse_iterator rend() noexcept
        {return reverse_iterator(begin());}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_reverse_iterator rend() const noexcept
        {return const_reverse_iterator(begin());}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_iterator cbegin() const noexcept
        {return begin();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_iterator cend() const noexcept
        {return end();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_reverse_iterator crbegin() const noexcept
        {return rbegin();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_reverse_iterator crend() const noexcept
        {return rend();}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) size_type size() const noexcept
        {return __is_long() ? __get_long_size() : __get_short_size();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) size_type length() const noexcept {return size();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) size_type max_size() const noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) size_type capacity() const noexcept
        {return (__is_long() ? __get_long_cap()
                             : static_cast<size_type>(__min_cap)) - 1;}

    void resize(size_type __n, value_type __c);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) void resize(size_type __n) {resize(__n, value_type());}

    void reserve(size_type __requested_capacity);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) void __resize_default_init(size_type __n);

                                __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void reserve() noexcept {shrink_to_fit();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void shrink_to_fit() noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void clear() noexcept;
                                  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    bool empty() const noexcept {return size() == 0;}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) const_reference operator[](size_type __pos) const noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) reference operator[](size_type __pos) noexcept;

    const_reference at(size_type __n) const;
    reference at(size_type __n);

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) basic_string& operator+=(const basic_string& __str) {return append(__str);}

    template <class _Tp>
    inline __attribute__ ((__visibility__("hidden")))
    _EnableIf
        <
            __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value
            && !__is_same_uncvref<_Tp, basic_string >::value,
            basic_string&
        >
                                            operator+=(const _Tp& __t) {__self_view __sv = __t; return append(__sv);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) basic_string& operator+=(const value_type* __s) {return append(__s);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) basic_string& operator+=(value_type __c) {push_back(__c); return *this;}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) basic_string& operator+=(initializer_list<value_type> __il) {return append(__il);}


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    basic_string& append(const basic_string& __str);

    template <class _Tp>
    inline __attribute__ ((__visibility__("hidden")))
    _EnableIf<
            __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value
            && !__is_same_uncvref<_Tp, basic_string>::value,
            basic_string&
        >
                  append(const _Tp& __t) { __self_view __sv = __t; return append(__sv.data(), __sv.size()); }
    basic_string& append(const basic_string& __str, size_type __pos, size_type __n=npos);

    template <class _Tp>
    inline __attribute__ ((__visibility__("hidden")))
    _EnableIf
        <
            __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value
            && !__is_same_uncvref<_Tp, basic_string>::value,
            basic_string&
        >
                  append(const _Tp& __t, size_type __pos, size_type __n=npos);
    basic_string& append(const value_type* __s, size_type __n);
    basic_string& append(const value_type* __s);
    basic_string& append(size_type __n, value_type __c);

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void __append_default_init(size_type __n);

    template<class _InputIterator>
    inline __attribute__ ((__visibility__("hidden")))
    _EnableIf
        <
            __is_exactly_cpp17_input_iterator<_InputIterator>::value,
            basic_string&
        >
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    append(_InputIterator __first, _InputIterator __last) {
      const basic_string __temp(__first, __last, __alloc());
      append(__temp.data(), __temp.size());
      return *this;
    }
    template<class _ForwardIterator>
    inline __attribute__ ((__visibility__("hidden")))
    _EnableIf
        <
            __is_cpp17_forward_iterator<_ForwardIterator>::value,
            basic_string&
        >
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    append(_ForwardIterator __first, _ForwardIterator __last);


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    basic_string& append(initializer_list<value_type> __il) {return append(__il.begin(), __il.size());}


    void push_back(value_type __c);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void pop_back();
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) reference front() noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) const_reference front() const noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) reference back() noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) const_reference back() const noexcept;

    template <class _Tp>
    inline __attribute__ ((__visibility__("hidden")))
    _EnableIf
        <
            __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,
            basic_string&
        >
                 assign(const _Tp & __t) { __self_view __sv = __t; return assign(__sv.data(), __sv.size()); }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    basic_string& assign(const basic_string& __str) { return *this = __str; }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    basic_string& assign(basic_string&& __str)
        noexcept((__noexcept_move_assign_container<_Allocator, __alloc_traits>::value))
        {*this = std::__1::move(__str); return *this;}

    basic_string& assign(const basic_string& __str, size_type __pos, size_type __n=npos);
    template <class _Tp>
    inline __attribute__ ((__visibility__("hidden")))
    _EnableIf
        <
            __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value
            && !__is_same_uncvref<_Tp, basic_string>::value,
            basic_string&
        >
                  assign(const _Tp & __t, size_type __pos, size_type __n=npos);
    basic_string& assign(const value_type* __s, size_type __n);
    basic_string& assign(const value_type* __s);
    basic_string& assign(size_type __n, value_type __c);
    template<class _InputIterator>
    inline __attribute__ ((__visibility__("hidden")))
    _EnableIf
        <
            __is_exactly_cpp17_input_iterator<_InputIterator>::value,
            basic_string&
        >
        assign(_InputIterator __first, _InputIterator __last);
    template<class _ForwardIterator>
    inline __attribute__ ((__visibility__("hidden")))
    _EnableIf
        <
            __is_cpp17_forward_iterator<_ForwardIterator>::value,
            basic_string&
        >
        assign(_ForwardIterator __first, _ForwardIterator __last);

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    basic_string& assign(initializer_list<value_type> __il) {return assign(__il.begin(), __il.size());}


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    basic_string& insert(size_type __pos1, const basic_string& __str);

    template <class _Tp>
    inline __attribute__ ((__visibility__("hidden")))
    _EnableIf
        <
            __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,
            basic_string&
        >
                 insert(size_type __pos1, const _Tp& __t)
    { __self_view __sv = __t; return insert(__pos1, __sv.data(), __sv.size()); }

    template <class _Tp>
    inline __attribute__ ((__visibility__("hidden")))
    _EnableIf
        <
            __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value && !__is_same_uncvref<_Tp, basic_string>::value,
            basic_string&
        >
                  insert(size_type __pos1, const _Tp& __t, size_type __pos2, size_type __n=npos);
    basic_string& insert(size_type __pos1, const basic_string& __str, size_type __pos2, size_type __n=npos);
    basic_string& insert(size_type __pos, const value_type* __s, size_type __n);
    basic_string& insert(size_type __pos, const value_type* __s);
    basic_string& insert(size_type __pos, size_type __n, value_type __c);
    iterator insert(const_iterator __pos, value_type __c);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iterator insert(const_iterator __pos, size_type __n, value_type __c);
    template<class _InputIterator>
    inline __attribute__ ((__visibility__("hidden")))
    _EnableIf
        <
            __is_exactly_cpp17_input_iterator<_InputIterator>::value,
            iterator
        >
        insert(const_iterator __pos, _InputIterator __first, _InputIterator __last);
    template<class _ForwardIterator>
    inline __attribute__ ((__visibility__("hidden")))
    _EnableIf
        <
            __is_cpp17_forward_iterator<_ForwardIterator>::value,
            iterator
        >
        insert(const_iterator __pos, _ForwardIterator __first, _ForwardIterator __last);

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iterator insert(const_iterator __pos, initializer_list<value_type> __il)
                    {return insert(__pos, __il.begin(), __il.end());}


    basic_string& erase(size_type __pos = 0, size_type __n = npos);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iterator erase(const_iterator __pos);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iterator erase(const_iterator __first, const_iterator __last);

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    basic_string& replace(size_type __pos1, size_type __n1, const basic_string& __str);

    template <class _Tp>
    inline __attribute__ ((__visibility__("hidden")))
    _EnableIf
        <
            __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,
            basic_string&
        >
                  replace(size_type __pos1, size_type __n1, const _Tp& __t) { __self_view __sv = __t; return replace(__pos1, __n1, __sv.data(), __sv.size()); }
    basic_string& replace(size_type __pos1, size_type __n1, const basic_string& __str, size_type __pos2, size_type __n2=npos);
    template <class _Tp>
    inline __attribute__ ((__visibility__("hidden")))
    _EnableIf
        <
            __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value && !__is_same_uncvref<_Tp, basic_string>::value,
            basic_string&
        >
                  replace(size_type __pos1, size_type __n1, const _Tp& __t, size_type __pos2, size_type __n2=npos);
    basic_string& replace(size_type __pos, size_type __n1, const value_type* __s, size_type __n2);
    basic_string& replace(size_type __pos, size_type __n1, const value_type* __s);
    basic_string& replace(size_type __pos, size_type __n1, size_type __n2, value_type __c);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    basic_string& replace(const_iterator __i1, const_iterator __i2, const basic_string& __str);

    template <class _Tp>
    inline __attribute__ ((__visibility__("hidden")))
    _EnableIf
        <
            __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,
            basic_string&
        >
                  replace(const_iterator __i1, const_iterator __i2, const _Tp& __t) { __self_view __sv = __t; return replace(__i1 - begin(), __i2 - __i1, __sv); }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    basic_string& replace(const_iterator __i1, const_iterator __i2, const value_type* __s, size_type __n);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    basic_string& replace(const_iterator __i1, const_iterator __i2, const value_type* __s);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    basic_string& replace(const_iterator __i1, const_iterator __i2, size_type __n, value_type __c);
    template<class _InputIterator>
    inline __attribute__ ((__visibility__("hidden")))
    _EnableIf
        <
            __is_cpp17_input_iterator<_InputIterator>::value,
            basic_string&
        >
        replace(const_iterator __i1, const_iterator __i2, _InputIterator __j1, _InputIterator __j2);

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    basic_string& replace(const_iterator __i1, const_iterator __i2, initializer_list<value_type> __il)
        {return replace(__i1, __i2, __il.begin(), __il.end());}


    size_type copy(value_type* __s, size_type __n, size_type __pos = 0) const;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    basic_string substr(size_type __pos = 0, size_type __n = npos) const;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void swap(basic_string& __str)

        noexcept;





    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const value_type* c_str() const noexcept {return data();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const value_type* data() const noexcept {return std::__1::__to_address(__get_pointer());}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    value_type* data() noexcept {return std::__1::__to_address(__get_pointer());}


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    allocator_type get_allocator() const noexcept {return __alloc();}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_type find(const basic_string& __str, size_type __pos = 0) const noexcept;

    template <class _Tp>
    inline __attribute__ ((__visibility__("hidden")))
    _EnableIf
        <
            __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,
            size_type
        >
              find(const _Tp& __t, size_type __pos = 0) const noexcept;
    size_type find(const value_type* __s, size_type __pos, size_type __n) const noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_type find(const value_type* __s, size_type __pos = 0) const noexcept;
    size_type find(value_type __c, size_type __pos = 0) const noexcept;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_type rfind(const basic_string& __str, size_type __pos = npos) const noexcept;

    template <class _Tp>
    inline __attribute__ ((__visibility__("hidden")))
    _EnableIf
        <
            __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,
            size_type
        >
              rfind(const _Tp& __t, size_type __pos = npos) const noexcept;
    size_type rfind(const value_type* __s, size_type __pos, size_type __n) const noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_type rfind(const value_type* __s, size_type __pos = npos) const noexcept;
    size_type rfind(value_type __c, size_type __pos = npos) const noexcept;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_type find_first_of(const basic_string& __str, size_type __pos = 0) const noexcept;

    template <class _Tp>
    inline __attribute__ ((__visibility__("hidden")))
    _EnableIf
        <
            __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,
            size_type
        >
              find_first_of(const _Tp& __t, size_type __pos = 0) const noexcept;
    size_type find_first_of(const value_type* __s, size_type __pos, size_type __n) const noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_type find_first_of(const value_type* __s, size_type __pos = 0) const noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_type find_first_of(value_type __c, size_type __pos = 0) const noexcept;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_type find_last_of(const basic_string& __str, size_type __pos = npos) const noexcept;

    template <class _Tp>
    inline __attribute__ ((__visibility__("hidden")))
    _EnableIf
        <
            __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,
            size_type
        >
              find_last_of(const _Tp& __t, size_type __pos = npos) const noexcept;
    size_type find_last_of(const value_type* __s, size_type __pos, size_type __n) const noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_type find_last_of(const value_type* __s, size_type __pos = npos) const noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_type find_last_of(value_type __c, size_type __pos = npos) const noexcept;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_type find_first_not_of(const basic_string& __str, size_type __pos = 0) const noexcept;

    template <class _Tp>
    inline __attribute__ ((__visibility__("hidden")))
    _EnableIf
        <
            __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,
            size_type
        >
              find_first_not_of(const _Tp &__t, size_type __pos = 0) const noexcept;
    size_type find_first_not_of(const value_type* __s, size_type __pos, size_type __n) const noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_type find_first_not_of(const value_type* __s, size_type __pos = 0) const noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_type find_first_not_of(value_type __c, size_type __pos = 0) const noexcept;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_type find_last_not_of(const basic_string& __str, size_type __pos = npos) const noexcept;

    template <class _Tp>
    inline __attribute__ ((__visibility__("hidden")))
    _EnableIf
        <
            __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,
            size_type
        >
              find_last_not_of(const _Tp& __t, size_type __pos = npos) const noexcept;
    size_type find_last_not_of(const value_type* __s, size_type __pos, size_type __n) const noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_type find_last_not_of(const value_type* __s, size_type __pos = npos) const noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_type find_last_not_of(value_type __c, size_type __pos = npos) const noexcept;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    int compare(const basic_string& __str) const noexcept;

    template <class _Tp>
    inline __attribute__ ((__visibility__("hidden")))
    _EnableIf
        <
            __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,
            int
        >
        compare(const _Tp &__t) const noexcept;

    template <class _Tp>
    inline __attribute__ ((__visibility__("hidden")))
    _EnableIf
        <
            __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,
            int
        >
         compare(size_type __pos1, size_type __n1, const _Tp& __t) const;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    int compare(size_type __pos1, size_type __n1, const basic_string& __str) const;
    int compare(size_type __pos1, size_type __n1, const basic_string& __str, size_type __pos2, size_type __n2=npos) const;

    template <class _Tp>
    inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        _EnableIf
        <
            __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value && !__is_same_uncvref<_Tp, basic_string>::value,
            int
        >
        compare(size_type __pos1, size_type __n1, const _Tp& __t, size_type __pos2, size_type __n2=npos) const;
    int compare(const value_type* __s) const noexcept;
    int compare(size_type __pos1, size_type __n1, const value_type* __s) const;
    int compare(size_type __pos1, size_type __n1, const value_type* __s, size_type __n2) const;
# 1451 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/string" 3
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) bool __invariants() const;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) void __clear_and_shrink() noexcept;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) void __shrink_or_extend(size_type __target_capacity);

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    bool __is_long() const noexcept
        {return bool(__r_.first().__s.__size_ & __short_mask);}
# 1470 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/string" 3
private:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    allocator_type& __alloc() noexcept
        {return __r_.second();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const allocator_type& __alloc() const noexcept
        {return __r_.second();}



    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void __set_short_size(size_type __s) noexcept



        {__r_.first().__s.__size_ = (unsigned char)(__s);}


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_type __get_short_size() const noexcept



        {return __r_.first().__s.__size_;}
# 1516 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/string" 3
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void __set_long_size(size_type __s) noexcept
        {__r_.first().__l.__size_ = __s;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_type __get_long_size() const noexcept
        {return __r_.first().__l.__size_;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void __set_size(size_type __s) noexcept
        {if (__is_long()) __set_long_size(__s); else __set_short_size(__s);}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void __set_long_cap(size_type __s) noexcept
        {__r_.first().__l.__cap_ = __long_mask | __s;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_type __get_long_cap() const noexcept
        {return __r_.first().__l.__cap_ & size_type(~__long_mask);}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void __set_long_pointer(pointer __p) noexcept
        {__r_.first().__l.__data_ = __p;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    pointer __get_long_pointer() noexcept
        {return __r_.first().__l.__data_;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_pointer __get_long_pointer() const noexcept
        {return __r_.first().__l.__data_;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    pointer __get_short_pointer() noexcept
        {return pointer_traits<pointer>::pointer_to(__r_.first().__s.__data_[0]);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_pointer __get_short_pointer() const noexcept
        {return pointer_traits<const_pointer>::pointer_to(__r_.first().__s.__data_[0]);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    pointer __get_pointer() noexcept
        {return __is_long() ? __get_long_pointer() : __get_short_pointer();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_pointer __get_pointer() const noexcept
        {return __is_long() ? __get_long_pointer() : __get_short_pointer();}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void __zero() noexcept
        {
            size_type (&__a)[__n_words] = __r_.first().__r.__words;
            for (unsigned __i = 0; __i < __n_words; ++__i)
                __a[__i] = 0;
        }

    template <size_type __a> static
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        size_type __align_it(size_type __s) noexcept
            {return (__s + (__a-1)) & ~(__a-1);}
    enum {__alignment = 16};
    static __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_type __recommend(size_type __s) noexcept
        {
        if (__s < __min_cap) return static_cast<size_type>(__min_cap) - 1;
        size_type __guess = __align_it<sizeof(value_type) < __alignment ?
                     __alignment/sizeof(value_type) : 1 > (__s+1) - 1;
        if (__guess == __min_cap) ++__guess;
        return __guess;
        }

    inline
    void __init(const value_type* __s, size_type __sz, size_type __reserve);
    inline
    void __init(const value_type* __s, size_type __sz);
    inline
    void __init(size_type __n, value_type __c);
# 1593 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/string" 3
    void __init_copy_ctor_external(const value_type* __s, size_type __sz);

    template <class _InputIterator>
    inline
    _EnableIf
    <
        __is_exactly_cpp17_input_iterator<_InputIterator>::value
    >
    __init(_InputIterator __first, _InputIterator __last);

    template <class _ForwardIterator>
    inline
    _EnableIf
    <
        __is_cpp17_forward_iterator<_ForwardIterator>::value
    >
    __init(_ForwardIterator __first, _ForwardIterator __last);

    void __grow_by(size_type __old_cap, size_type __delta_cap, size_type __old_sz,
                   size_type __n_copy, size_type __n_del, size_type __n_add = 0);
    void __grow_by_and_replace(size_type __old_cap, size_type __delta_cap, size_type __old_sz,
                               size_type __n_copy, size_type __n_del,
                               size_type __n_add, const value_type* __p_new_stuff);




    template <bool __is_short>
    basic_string& __assign_no_alias(const value_type* __s, size_type __n);

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void __erase_to_end(size_type __pos);



    void __erase_external_with_move(size_type __pos, size_type __n);

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void __copy_assign_alloc(const basic_string& __str)
        {__copy_assign_alloc(__str, integral_constant<bool,
                      __alloc_traits::propagate_on_container_copy_assignment::value>());}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void __copy_assign_alloc(const basic_string& __str, true_type)
        {
            if (__alloc() == __str.__alloc())
                __alloc() = __str.__alloc();
            else
            {
                if (!__str.__is_long())
                {
                    __clear_and_shrink();
                    __alloc() = __str.__alloc();
                }
                else
                {
                    allocator_type __a = __str.__alloc();
                    pointer __p = __alloc_traits::allocate(__a, __str.__get_long_cap());
                    __clear_and_shrink();
                    __alloc() = std::__1::move(__a);
                    __set_long_pointer(__p);
                    __set_long_cap(__str.__get_long_cap());
                    __set_long_size(__str.size());
                }
            }
        }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void __copy_assign_alloc(const basic_string&, false_type) noexcept
        {}


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void __move_assign(basic_string& __str, false_type)
        noexcept(__alloc_traits::is_always_equal::value);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void __move_assign(basic_string& __str, true_type)

        noexcept;





    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void
    __move_assign_alloc(basic_string& __str)
        noexcept(!__alloc_traits::propagate_on_container_move_assignment::value || is_nothrow_move_assignable<allocator_type>::value)


    {__move_assign_alloc(__str, integral_constant<bool,
                      __alloc_traits::propagate_on_container_move_assignment::value>());}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void __move_assign_alloc(basic_string& __c, true_type)
        noexcept(is_nothrow_move_assignable<allocator_type>::value)
        {
            __alloc() = std::__1::move(__c.__alloc());
        }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void __move_assign_alloc(basic_string&, false_type)
        noexcept
        {}

    basic_string& __assign_external(const value_type* __s);
    basic_string& __assign_external(const value_type* __s, size_type __n);


    inline basic_string& __assign_short(const value_type* __s, size_type __n) {
      pointer __p = __is_long()
                        ? (__set_long_size(__n), __get_long_pointer())
                        : (__set_short_size(__n), __get_short_pointer());
      traits_type::move(std::__1::__to_address(__p), __s, __n);
      traits_type::assign(__p[__n], value_type());
      return *this;
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) void __invalidate_all_iterators();
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) void __invalidate_iterators_past(size_type);

    template<class _Tp>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    bool __addr_in_range(_Tp&& __t) const {
        const volatile void *__p = std::__1::addressof(__t);
        return data() <= __p && __p <= data() + size();
    }

    [[noreturn]] __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void __throw_length_error() const {

        __basic_string_common<true>::__throw_length_error();



    }

    [[noreturn]] __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void __throw_out_of_range() const {

        __basic_string_common<true>::__throw_out_of_range();



    }

    friend basic_string operator+<>(const basic_string&, const basic_string&);
    friend basic_string operator+<>(const value_type*, const basic_string&);
    friend basic_string operator+<>(value_type, const basic_string&);
    friend basic_string operator+<>(const basic_string&, const value_type*);
    friend basic_string operator+<>(const basic_string&, value_type);
};
# 1754 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/string" 3
    extern template __attribute__ ((__visibility__("default"))) basic_string<char>& basic_string<char>::replace(size_type, size_type, value_type const*, size_type); extern template __attribute__ ((__visibility__("default"))) basic_string<char>::size_type basic_string<char>::rfind(value_type const*, size_type, size_type) const; extern template __attribute__ ((__visibility__("default"))) void basic_string<char>::__init(value_type const*, size_type, size_type); extern template __attribute__ ((__visibility__("default"))) basic_string<char>::basic_string(basic_string const&); extern template __attribute__ ((__visibility__("default"))) basic_string<char>& basic_string<char>::replace(size_type, size_type, value_type const*); extern template __attribute__ ((__visibility__("default"))) basic_string<char>::basic_string(basic_string const&, allocator<char> const&); extern template __attribute__ ((__visibility__("default"))) basic_string<char>::size_type basic_string<char>::find_last_not_of(value_type const*, size_type, size_type) const; extern template __attribute__ ((__visibility__("default"))) basic_string<char>::~basic_string(); extern template __attribute__ ((__visibility__("default"))) basic_string<char>::size_type basic_string<char>::find_first_not_of(value_type const*, size_type, size_type) const; extern template __attribute__ ((__visibility__("default"))) basic_string<char>& basic_string<char>::insert(size_type, size_type, value_type); extern template __attribute__ ((__visibility__("default"))) basic_string<char>& basic_string<char>::operator=(value_type); extern template __attribute__ ((__visibility__("default"))) void basic_string<char>::__init(value_type const*, size_type); extern template __attribute__ ((__visibility__("default"))) const char& basic_string<char>::at(size_type) const; extern template __attribute__ ((__visibility__("default"))) basic_string<char>& basic_string<char>::insert(size_type, value_type const*, size_type); extern template __attribute__ ((__visibility__("default"))) basic_string<char>::size_type basic_string<char>::find_first_of(value_type const*, size_type, size_type) const; extern template __attribute__ ((__visibility__("default"))) basic_string<char>& basic_string<char>::replace(size_type, size_type, size_type, value_type); extern template __attribute__ ((__visibility__("default"))) basic_string<char>& basic_string<char>::assign(value_type const*, size_type); extern template __attribute__ ((__visibility__("default"))) void basic_string<char>::reserve(size_type); extern template __attribute__ ((__visibility__("default"))) basic_string<char>& basic_string<char>::append(value_type const*, size_type); extern template __attribute__ ((__visibility__("default"))) basic_string<char>& basic_string<char>::assign(basic_string const&, size_type, size_type); extern template __attribute__ ((__visibility__("default"))) basic_string<char>::size_type basic_string<char>::copy(value_type*, size_type, size_type) const; extern template __attribute__ ((__visibility__("default"))) basic_string<char>::basic_string(basic_string const&, size_type, size_type, allocator<char> const&); extern template __attribute__ ((__visibility__("default"))) basic_string<char>::size_type basic_string<char>::find(value_type, size_type) const; extern template __attribute__ ((__visibility__("default"))) void basic_string<char>::__init(size_type, value_type); extern template __attribute__ ((__visibility__("default"))) basic_string<char>& basic_string<char>::insert(size_type, value_type const*); extern template __attribute__ ((__visibility__("default"))) basic_string<char>::size_type basic_string<char>::find_last_of(value_type const*, size_type, size_type) const; extern template __attribute__ ((__visibility__("default"))) void basic_string<char>::__grow_by(size_type, size_type, size_type, size_type, size_type, size_type); extern template __attribute__ ((__visibility__("default"))) void basic_string<char>::__grow_by_and_replace(size_type, size_type, size_type, size_type, size_type, size_type, value_type const*); extern template __attribute__ ((__visibility__("default"))) void basic_string<char>::push_back(value_type); extern template __attribute__ ((__visibility__("default"))) basic_string<char>& basic_string<char>::append(size_type, value_type); extern template __attribute__ ((__visibility__("default"))) basic_string<char>::size_type basic_string<char>::rfind(value_type, size_type) const; extern template __attribute__ ((__visibility__("default"))) const basic_string<char>::size_type basic_string<char>::npos; extern template __attribute__ ((__visibility__("default"))) basic_string<char>& basic_string<char>::assign(size_type, value_type); extern template __attribute__ ((__visibility__("default"))) basic_string<char>& basic_string<char>::erase(size_type, size_type); extern template __attribute__ ((__visibility__("default"))) basic_string<char>& basic_string<char>::append(basic_string const&, size_type, size_type); extern template __attribute__ ((__visibility__("default"))) int basic_string<char>::compare(value_type const*) const; extern template __attribute__ ((__visibility__("default"))) int basic_string<char>::compare(size_type, size_type, value_type const*) const; extern template __attribute__ ((__visibility__("default"))) char& basic_string<char>::at(size_type); extern template __attribute__ ((__visibility__("default"))) basic_string<char>& basic_string<char>::assign(value_type const*); extern template __attribute__ ((__visibility__("default"))) basic_string<char>::size_type basic_string<char>::find(value_type const*, size_type, size_type) const; extern template __attribute__ ((__visibility__("default"))) int basic_string<char>::compare(size_type, size_type, basic_string const&, size_type, size_type) const; extern template __attribute__ ((__visibility__("default"))) int basic_string<char>::compare(size_type, size_type, value_type const*, size_type) const; extern template __attribute__ ((__visibility__("default"))) basic_string<char>& basic_string<char>::operator=(basic_string const&); extern template __attribute__ ((__visibility__("default"))) basic_string<char>& basic_string<char>::append(value_type const*); extern template __attribute__ ((__visibility__("default"))) basic_string<char>& basic_string<char>::replace(size_type, size_type, basic_string const&, size_type, size_type); extern template __attribute__ ((__visibility__("default"))) basic_string<char>::iterator basic_string<char>::insert(basic_string::const_iterator, value_type); extern template __attribute__ ((__visibility__("default"))) void basic_string<char>::resize(size_type, value_type); extern template __attribute__ ((__visibility__("default"))) basic_string<char>& basic_string<char>::insert(size_type, basic_string const&, size_type, size_type);

        extern template __attribute__ ((__visibility__("default"))) basic_string<wchar_t>& basic_string<wchar_t>::replace(size_type, size_type, value_type const*, size_type); extern template __attribute__ ((__visibility__("default"))) basic_string<wchar_t>::size_type basic_string<wchar_t>::rfind(value_type const*, size_type, size_type) const; extern template __attribute__ ((__visibility__("default"))) void basic_string<wchar_t>::__init(value_type const*, size_type, size_type); extern template __attribute__ ((__visibility__("default"))) basic_string<wchar_t>::basic_string(basic_string const&); extern template __attribute__ ((__visibility__("default"))) basic_string<wchar_t>& basic_string<wchar_t>::replace(size_type, size_type, value_type const*); extern template __attribute__ ((__visibility__("default"))) basic_string<wchar_t>::basic_string(basic_string const&, allocator<wchar_t> const&); extern template __attribute__ ((__visibility__("default"))) basic_string<wchar_t>::size_type basic_string<wchar_t>::find_last_not_of(value_type const*, size_type, size_type) const; extern template __attribute__ ((__visibility__("default"))) basic_string<wchar_t>::~basic_string(); extern template __attribute__ ((__visibility__("default"))) basic_string<wchar_t>::size_type basic_string<wchar_t>::find_first_not_of(value_type const*, size_type, size_type) const; extern template __attribute__ ((__visibility__("default"))) basic_string<wchar_t>& basic_string<wchar_t>::insert(size_type, size_type, value_type); extern template __attribute__ ((__visibility__("default"))) basic_string<wchar_t>& basic_string<wchar_t>::operator=(value_type); extern template __attribute__ ((__visibility__("default"))) void basic_string<wchar_t>::__init(value_type const*, size_type); extern template __attribute__ ((__visibility__("default"))) const wchar_t& basic_string<wchar_t>::at(size_type) const; extern template __attribute__ ((__visibility__("default"))) basic_string<wchar_t>& basic_string<wchar_t>::insert(size_type, value_type const*, size_type); extern template __attribute__ ((__visibility__("default"))) basic_string<wchar_t>::size_type basic_string<wchar_t>::find_first_of(value_type const*, size_type, size_type) const; extern template __attribute__ ((__visibility__("default"))) basic_string<wchar_t>& basic_string<wchar_t>::replace(size_type, size_type, size_type, value_type); extern template __attribute__ ((__visibility__("default"))) basic_string<wchar_t>& basic_string<wchar_t>::assign(value_type const*, size_type); extern template __attribute__ ((__visibility__("default"))) void basic_string<wchar_t>::reserve(size_type); extern template __attribute__ ((__visibility__("default"))) basic_string<wchar_t>& basic_string<wchar_t>::append(value_type const*, size_type); extern template __attribute__ ((__visibility__("default"))) basic_string<wchar_t>& basic_string<wchar_t>::assign(basic_string const&, size_type, size_type); extern template __attribute__ ((__visibility__("default"))) basic_string<wchar_t>::size_type basic_string<wchar_t>::copy(value_type*, size_type, size_type) const; extern template __attribute__ ((__visibility__("default"))) basic_string<wchar_t>::basic_string(basic_string const&, size_type, size_type, allocator<wchar_t> const&); extern template __attribute__ ((__visibility__("default"))) basic_string<wchar_t>::size_type basic_string<wchar_t>::find(value_type, size_type) const; extern template __attribute__ ((__visibility__("default"))) void basic_string<wchar_t>::__init(size_type, value_type); extern template __attribute__ ((__visibility__("default"))) basic_string<wchar_t>& basic_string<wchar_t>::insert(size_type, value_type const*); extern template __attribute__ ((__visibility__("default"))) basic_string<wchar_t>::size_type basic_string<wchar_t>::find_last_of(value_type const*, size_type, size_type) const; extern template __attribute__ ((__visibility__("default"))) void basic_string<wchar_t>::__grow_by(size_type, size_type, size_type, size_type, size_type, size_type); extern template __attribute__ ((__visibility__("default"))) void basic_string<wchar_t>::__grow_by_and_replace(size_type, size_type, size_type, size_type, size_type, size_type, value_type const*); extern template __attribute__ ((__visibility__("default"))) void basic_string<wchar_t>::push_back(value_type); extern template __attribute__ ((__visibility__("default"))) basic_string<wchar_t>& basic_string<wchar_t>::append(size_type, value_type); extern template __attribute__ ((__visibility__("default"))) basic_string<wchar_t>::size_type basic_string<wchar_t>::rfind(value_type, size_type) const; extern template __attribute__ ((__visibility__("default"))) const basic_string<wchar_t>::size_type basic_string<wchar_t>::npos; extern template __attribute__ ((__visibility__("default"))) basic_string<wchar_t>& basic_string<wchar_t>::assign(size_type, value_type); extern template __attribute__ ((__visibility__("default"))) basic_string<wchar_t>& basic_string<wchar_t>::erase(size_type, size_type); extern template __attribute__ ((__visibility__("default"))) basic_string<wchar_t>& basic_string<wchar_t>::append(basic_string const&, size_type, size_type); extern template __attribute__ ((__visibility__("default"))) int basic_string<wchar_t>::compare(value_type const*) const; extern template __attribute__ ((__visibility__("default"))) int basic_string<wchar_t>::compare(size_type, size_type, value_type const*) const; extern template __attribute__ ((__visibility__("default"))) wchar_t& basic_string<wchar_t>::at(size_type); extern template __attribute__ ((__visibility__("default"))) basic_string<wchar_t>& basic_string<wchar_t>::assign(value_type const*); extern template __attribute__ ((__visibility__("default"))) basic_string<wchar_t>::size_type basic_string<wchar_t>::find(value_type const*, size_type, size_type) const; extern template __attribute__ ((__visibility__("default"))) int basic_string<wchar_t>::compare(size_type, size_type, basic_string const&, size_type, size_type) const; extern template __attribute__ ((__visibility__("default"))) int basic_string<wchar_t>::compare(size_type, size_type, value_type const*, size_type) const; extern template __attribute__ ((__visibility__("default"))) basic_string<wchar_t>& basic_string<wchar_t>::operator=(basic_string const&); extern template __attribute__ ((__visibility__("default"))) basic_string<wchar_t>& basic_string<wchar_t>::append(value_type const*); extern template __attribute__ ((__visibility__("default"))) basic_string<wchar_t>& basic_string<wchar_t>::replace(size_type, size_type, basic_string const&, size_type, size_type); extern template __attribute__ ((__visibility__("default"))) basic_string<wchar_t>::iterator basic_string<wchar_t>::insert(basic_string::const_iterator, value_type); extern template __attribute__ ((__visibility__("default"))) void basic_string<wchar_t>::resize(size_type, value_type); extern template __attribute__ ((__visibility__("default"))) basic_string<wchar_t>& basic_string<wchar_t>::insert(size_type, basic_string const&, size_type, size_type);





template<class _InputIterator,
         class _CharT = __iter_value_type<_InputIterator>,
         class _Allocator = allocator<_CharT>,
         class = _EnableIf<__is_cpp17_input_iterator<_InputIterator>::value>,
         class = _EnableIf<__is_allocator<_Allocator>::value>
         >
basic_string(_InputIterator, _InputIterator, _Allocator = _Allocator())
  -> basic_string<_CharT, char_traits<_CharT>, _Allocator>;

template<class _CharT,
         class _Traits,
         class _Allocator = allocator<_CharT>,
         class = _EnableIf<__is_allocator<_Allocator>::value>
         >
explicit basic_string(basic_string_view<_CharT, _Traits>, const _Allocator& = _Allocator())
  -> basic_string<_CharT, _Traits, _Allocator>;

template<class _CharT,
         class _Traits,
         class _Allocator = allocator<_CharT>,
         class = _EnableIf<__is_allocator<_Allocator>::value>,
         class _Sz = typename allocator_traits<_Allocator>::size_type
         >
basic_string(basic_string_view<_CharT, _Traits>, _Sz, _Sz, const _Allocator& = _Allocator())
  -> basic_string<_CharT, _Traits, _Allocator>;


template <class _CharT, class _Traits, class _Allocator>
inline
void
basic_string<_CharT, _Traits, _Allocator>::__invalidate_all_iterators()
{



}

template <class _CharT, class _Traits, class _Allocator>
inline
void
basic_string<_CharT, _Traits, _Allocator>::__invalidate_iterators_past(size_type __pos)
{
# 1823 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/string" 3
    (void)__pos;

}

template <class _CharT, class _Traits, class _Allocator>
inline
basic_string<_CharT, _Traits, _Allocator>::basic_string()
    noexcept(is_nothrow_default_constructible<allocator_type>::value)
     : __r_(__default_init_tag(), __default_init_tag())
{



    __zero();
}

template <class _CharT, class _Traits, class _Allocator>
inline
basic_string<_CharT, _Traits, _Allocator>::basic_string(const allocator_type& __a)



        noexcept

: __r_(__default_init_tag(), __a)
{



    __zero();
}

template <class _CharT, class _Traits, class _Allocator>
void basic_string<_CharT, _Traits, _Allocator>::__init(const value_type* __s,
                                                       size_type __sz,
                                                       size_type __reserve)
{
    if (__reserve > max_size())
        this->__throw_length_error();
    pointer __p;
    if (__reserve < __min_cap)
    {
        __set_short_size(__sz);
        __p = __get_short_pointer();
    }
    else
    {
        size_type __cap = __recommend(__reserve);
        __p = __alloc_traits::allocate(__alloc(), __cap+1);
        __set_long_pointer(__p);
        __set_long_cap(__cap+1);
        __set_long_size(__sz);
    }
    traits_type::copy(std::__1::__to_address(__p), __s, __sz);
    traits_type::assign(__p[__sz], value_type());
}

template <class _CharT, class _Traits, class _Allocator>
void
basic_string<_CharT, _Traits, _Allocator>::__init(const value_type* __s, size_type __sz)
{
    if (__sz > max_size())
        this->__throw_length_error();
    pointer __p;
    if (__sz < __min_cap)
    {
        __set_short_size(__sz);
        __p = __get_short_pointer();
    }
    else
    {
        size_type __cap = __recommend(__sz);
        __p = __alloc_traits::allocate(__alloc(), __cap+1);
        __set_long_pointer(__p);
        __set_long_cap(__cap+1);
        __set_long_size(__sz);
    }
    traits_type::copy(std::__1::__to_address(__p), __s, __sz);
    traits_type::assign(__p[__sz], value_type());
}

template <class _CharT, class _Traits, class _Allocator>
template <class>
basic_string<_CharT, _Traits, _Allocator>::basic_string(const _CharT* __s, const _Allocator& __a)
    : __r_(__default_init_tag(), __a)
{
    ((void)0);
    __init(__s, traits_type::length(__s));



}

template <class _CharT, class _Traits, class _Allocator>
inline
basic_string<_CharT, _Traits, _Allocator>::basic_string(const _CharT* __s, size_type __n)
     : __r_(__default_init_tag(), __default_init_tag())
{
    ((void)0);
    __init(__s, __n);



}

template <class _CharT, class _Traits, class _Allocator>
inline
basic_string<_CharT, _Traits, _Allocator>::basic_string(const _CharT* __s, size_type __n, const _Allocator& __a)
    : __r_(__default_init_tag(), __a)
{
    ((void)0);
    __init(__s, __n);



}

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>::basic_string(const basic_string& __str)
    : __r_(__default_init_tag(), __alloc_traits::select_on_container_copy_construction(__str.__alloc()))
{
    if (!__str.__is_long())
        __r_.first().__r = __str.__r_.first().__r;
    else
        __init_copy_ctor_external(std::__1::__to_address(__str.__get_long_pointer()),
                                  __str.__get_long_size());




}

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>::basic_string(
    const basic_string& __str, const allocator_type& __a)
    : __r_(__default_init_tag(), __a)
{
    if (!__str.__is_long())
        __r_.first().__r = __str.__r_.first().__r;
    else
        __init_copy_ctor_external(std::__1::__to_address(__str.__get_long_pointer()),
                                  __str.__get_long_size());



}

template <class _CharT, class _Traits, class _Allocator>
void basic_string<_CharT, _Traits, _Allocator>::__init_copy_ctor_external(
    const value_type* __s, size_type __sz) {
  pointer __p;
  if (__sz < __min_cap) {
    __p = __get_short_pointer();
    __set_short_size(__sz);
  } else {
    if (__sz > max_size())
      this->__throw_length_error();
    size_t __cap = __recommend(__sz);
    __p = __alloc_traits::allocate(__alloc(), __cap + 1);
    __set_long_pointer(__p);
    __set_long_cap(__cap + 1);
    __set_long_size(__sz);
  }
  traits_type::copy(std::__1::__to_address(__p), __s, __sz + 1);
}



template <class _CharT, class _Traits, class _Allocator>
inline
basic_string<_CharT, _Traits, _Allocator>::basic_string(basic_string&& __str)



        noexcept

    : __r_(std::__1::move(__str.__r_))
{
    __str.__zero();





}

template <class _CharT, class _Traits, class _Allocator>
inline
basic_string<_CharT, _Traits, _Allocator>::basic_string(basic_string&& __str, const allocator_type& __a)
    : __r_(__default_init_tag(), __a)
{
    if (__str.__is_long() && __a != __str.__alloc())
        __init(std::__1::__to_address(__str.__get_long_pointer()), __str.__get_long_size());
    else
    {
        __r_.first().__r = __str.__r_.first().__r;
        __str.__zero();
    }





}



template <class _CharT, class _Traits, class _Allocator>
void
basic_string<_CharT, _Traits, _Allocator>::__init(size_type __n, value_type __c)
{
    if (__n > max_size())
        this->__throw_length_error();
    pointer __p;
    if (__n < __min_cap)
    {
        __set_short_size(__n);
        __p = __get_short_pointer();
    }
    else
    {
        size_type __cap = __recommend(__n);
        __p = __alloc_traits::allocate(__alloc(), __cap+1);
        __set_long_pointer(__p);
        __set_long_cap(__cap+1);
        __set_long_size(__n);
    }
    traits_type::assign(std::__1::__to_address(__p), __n, __c);
    traits_type::assign(__p[__n], value_type());
}

template <class _CharT, class _Traits, class _Allocator>
inline
basic_string<_CharT, _Traits, _Allocator>::basic_string(size_type __n, _CharT __c)
     : __r_(__default_init_tag(), __default_init_tag())
{
    __init(__n, __c);



}

template <class _CharT, class _Traits, class _Allocator>
template <class>
basic_string<_CharT, _Traits, _Allocator>::basic_string(size_type __n, _CharT __c, const _Allocator& __a)
    : __r_(__default_init_tag(), __a)
{
    __init(__n, __c);



}

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>::basic_string(const basic_string& __str,
                                                        size_type __pos, size_type __n,
                                                        const _Allocator& __a)
    : __r_(__default_init_tag(), __a)
{
    size_type __str_sz = __str.size();
    if (__pos > __str_sz)
        this->__throw_out_of_range();
    __init(__str.data() + __pos, std::__1::min(__n, __str_sz - __pos));



}

template <class _CharT, class _Traits, class _Allocator>
inline
basic_string<_CharT, _Traits, _Allocator>::basic_string(const basic_string& __str, size_type __pos,
                                                        const _Allocator& __a)
    : __r_(__default_init_tag(), __a)
{
    size_type __str_sz = __str.size();
    if (__pos > __str_sz)
        this->__throw_out_of_range();
    __init(__str.data() + __pos, __str_sz - __pos);



}

template <class _CharT, class _Traits, class _Allocator>
template <class _Tp, class>
basic_string<_CharT, _Traits, _Allocator>::basic_string(
             const _Tp& __t, size_type __pos, size_type __n, const allocator_type& __a)
    : __r_(__default_init_tag(), __a)
{
    __self_view __sv0 = __t;
    __self_view __sv = __sv0.substr(__pos, __n);
    __init(__sv.data(), __sv.size());



}

template <class _CharT, class _Traits, class _Allocator>
template <class _Tp, class>
basic_string<_CharT, _Traits, _Allocator>::basic_string(const _Tp & __t)
     : __r_(__default_init_tag(), __default_init_tag())
{
    __self_view __sv = __t;
    __init(__sv.data(), __sv.size());



}

template <class _CharT, class _Traits, class _Allocator>
template <class _Tp, class>
basic_string<_CharT, _Traits, _Allocator>::basic_string(const _Tp & __t, const _Allocator& __a)
    : __r_(__default_init_tag(), __a)
{
    __self_view __sv = __t;
    __init(__sv.data(), __sv.size());



}

template <class _CharT, class _Traits, class _Allocator>
template <class _InputIterator>
_EnableIf
<
    __is_exactly_cpp17_input_iterator<_InputIterator>::value
>
basic_string<_CharT, _Traits, _Allocator>::__init(_InputIterator __first, _InputIterator __last)
{
    __zero();

    try
    {

    for (; __first != __last; ++__first)
        push_back(*__first);

    }
    catch (...)
    {
        if (__is_long())
            __alloc_traits::deallocate(__alloc(), __get_long_pointer(), __get_long_cap());
        throw;
    }

}

template <class _CharT, class _Traits, class _Allocator>
template <class _ForwardIterator>
_EnableIf
<
    __is_cpp17_forward_iterator<_ForwardIterator>::value
>
basic_string<_CharT, _Traits, _Allocator>::__init(_ForwardIterator __first, _ForwardIterator __last)
{
    size_type __sz = static_cast<size_type>(std::__1::distance(__first, __last));
    if (__sz > max_size())
        this->__throw_length_error();
    pointer __p;
    if (__sz < __min_cap)
    {
        __set_short_size(__sz);
        __p = __get_short_pointer();
    }
    else
    {
        size_type __cap = __recommend(__sz);
        __p = __alloc_traits::allocate(__alloc(), __cap+1);
        __set_long_pointer(__p);
        __set_long_cap(__cap+1);
        __set_long_size(__sz);
    }


    try
    {

    for (; __first != __last; ++__first, (void) ++__p)
        traits_type::assign(*__p, *__first);
    traits_type::assign(*__p, value_type());

    }
    catch (...)
    {
        if (__is_long())
            __alloc_traits::deallocate(__alloc(), __get_long_pointer(), __get_long_cap());
        throw;
    }

}

template <class _CharT, class _Traits, class _Allocator>
template<class _InputIterator, class>
inline
basic_string<_CharT, _Traits, _Allocator>::basic_string(_InputIterator __first, _InputIterator __last)
     : __r_(__default_init_tag(), __default_init_tag())
{
    __init(__first, __last);



}

template <class _CharT, class _Traits, class _Allocator>
template<class _InputIterator, class>
inline
basic_string<_CharT, _Traits, _Allocator>::basic_string(_InputIterator __first, _InputIterator __last,
                                                        const allocator_type& __a)
    : __r_(__default_init_tag(), __a)
{
    __init(__first, __last);



}



template <class _CharT, class _Traits, class _Allocator>
inline
basic_string<_CharT, _Traits, _Allocator>::basic_string(
    initializer_list<_CharT> __il)
     : __r_(__default_init_tag(), __default_init_tag())
{
    __init(__il.begin(), __il.end());



}

template <class _CharT, class _Traits, class _Allocator>
inline

basic_string<_CharT, _Traits, _Allocator>::basic_string(
    initializer_list<_CharT> __il, const _Allocator& __a)
    : __r_(__default_init_tag(), __a)
{
    __init(__il.begin(), __il.end());



}



template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>::~basic_string()
{



    if (__is_long())
        __alloc_traits::deallocate(__alloc(), __get_long_pointer(), __get_long_cap());
}

template <class _CharT, class _Traits, class _Allocator>
void
basic_string<_CharT, _Traits, _Allocator>::__grow_by_and_replace
    (size_type __old_cap, size_type __delta_cap, size_type __old_sz,
     size_type __n_copy, size_type __n_del, size_type __n_add, const value_type* __p_new_stuff)
{
    size_type __ms = max_size();
    if (__delta_cap > __ms - __old_cap - 1)
        this->__throw_length_error();
    pointer __old_p = __get_pointer();
    size_type __cap = __old_cap < __ms / 2 - __alignment ?
                          __recommend(std::__1::max(__old_cap + __delta_cap, 2 * __old_cap)) :
                          __ms - 1;
    pointer __p = __alloc_traits::allocate(__alloc(), __cap+1);
    __invalidate_all_iterators();
    if (__n_copy != 0)
        traits_type::copy(std::__1::__to_address(__p),
                          std::__1::__to_address(__old_p), __n_copy);
    if (__n_add != 0)
        traits_type::copy(std::__1::__to_address(__p) + __n_copy, __p_new_stuff, __n_add);
    size_type __sec_cp_sz = __old_sz - __n_del - __n_copy;
    if (__sec_cp_sz != 0)
        traits_type::copy(std::__1::__to_address(__p) + __n_copy + __n_add,
                          std::__1::__to_address(__old_p) + __n_copy + __n_del, __sec_cp_sz);
    if (__old_cap+1 != __min_cap)
        __alloc_traits::deallocate(__alloc(), __old_p, __old_cap+1);
    __set_long_pointer(__p);
    __set_long_cap(__cap+1);
    __old_sz = __n_copy + __n_add + __sec_cp_sz;
    __set_long_size(__old_sz);
    traits_type::assign(__p[__old_sz], value_type());
}

template <class _CharT, class _Traits, class _Allocator>
void
basic_string<_CharT, _Traits, _Allocator>::__grow_by(size_type __old_cap, size_type __delta_cap, size_type __old_sz,
                                                     size_type __n_copy, size_type __n_del, size_type __n_add)
{
    size_type __ms = max_size();
    if (__delta_cap > __ms - __old_cap)
        this->__throw_length_error();
    pointer __old_p = __get_pointer();
    size_type __cap = __old_cap < __ms / 2 - __alignment ?
                          __recommend(std::__1::max(__old_cap + __delta_cap, 2 * __old_cap)) :
                          __ms - 1;
    pointer __p = __alloc_traits::allocate(__alloc(), __cap+1);
    __invalidate_all_iterators();
    if (__n_copy != 0)
        traits_type::copy(std::__1::__to_address(__p),
                          std::__1::__to_address(__old_p), __n_copy);
    size_type __sec_cp_sz = __old_sz - __n_del - __n_copy;
    if (__sec_cp_sz != 0)
        traits_type::copy(std::__1::__to_address(__p) + __n_copy + __n_add,
                          std::__1::__to_address(__old_p) + __n_copy + __n_del,
                          __sec_cp_sz);
    if (__old_cap+1 != __min_cap)
        __alloc_traits::deallocate(__alloc(), __old_p, __old_cap+1);
    __set_long_pointer(__p);
    __set_long_cap(__cap+1);
}



template <class _CharT, class _Traits, class _Allocator>
template <bool __is_short>
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::__assign_no_alias(
    const value_type* __s, size_type __n) {
  size_type __cap = __is_short ? __min_cap : __get_long_cap();
  if (__n < __cap) {
    pointer __p = __is_short ? __get_short_pointer() : __get_long_pointer();
    __is_short ? __set_short_size(__n) : __set_long_size(__n);
    traits_type::copy(std::__1::__to_address(__p), __s, __n);
    traits_type::assign(__p[__n], value_type());
    __invalidate_iterators_past(__n);
  } else {
    size_type __sz = __is_short ? __get_short_size() : __get_long_size();
    __grow_by_and_replace(__cap - 1, __n - __cap + 1, __sz, 0, __sz, __n, __s);
  }
  return *this;
}

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::__assign_external(
    const value_type* __s, size_type __n) {
  size_type __cap = capacity();
  if (__cap >= __n) {
    value_type* __p = std::__1::__to_address(__get_pointer());
    traits_type::move(__p, __s, __n);
    traits_type::assign(__p[__n], value_type());
    __set_size(__n);
    __invalidate_iterators_past(__n);
  } else {
    size_type __sz = size();
    __grow_by_and_replace(__cap, __n - __cap, __sz, 0, __sz, __n, __s);
  }
  return *this;
}

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::assign(const value_type* __s, size_type __n)
{
    ((void)0);
    return (__builtin_constant_p(__n) && __n < __min_cap)
               ? __assign_short(__s, __n)
               : __assign_external(__s, __n);
}

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::assign(size_type __n, value_type __c)
{
    size_type __cap = capacity();
    if (__cap < __n)
    {
        size_type __sz = size();
        __grow_by(__cap, __n - __cap, __sz, 0, __sz);
    }
    value_type* __p = std::__1::__to_address(__get_pointer());
    traits_type::assign(__p, __n, __c);
    traits_type::assign(__p[__n], value_type());
    __set_size(__n);
    __invalidate_iterators_past(__n);
    return *this;
}

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::operator=(value_type __c)
{
    pointer __p;
    if (__is_long())
    {
        __p = __get_long_pointer();
        __set_long_size(1);
    }
    else
    {
        __p = __get_short_pointer();
        __set_short_size(1);
    }
    traits_type::assign(*__p, __c);
    traits_type::assign(*++__p, value_type());
    __invalidate_iterators_past(1);
    return *this;
}

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::operator=(const basic_string& __str)
{
  if (this != &__str) {
    __copy_assign_alloc(__str);
    if (!__is_long()) {
      if (!__str.__is_long()) {
        __r_.first().__r = __str.__r_.first().__r;
      } else {
        return __assign_no_alias<true>(__str.data(), __str.size());
      }
    } else {
      return __assign_no_alias<false>(__str.data(), __str.size());
    }
  }
  return *this;
}



template <class _CharT, class _Traits, class _Allocator>
inline
void
basic_string<_CharT, _Traits, _Allocator>::__move_assign(basic_string& __str, false_type)
    noexcept(__alloc_traits::is_always_equal::value)
{
    if (__alloc() != __str.__alloc())
        assign(__str);
    else
        __move_assign(__str, true_type());
}

template <class _CharT, class _Traits, class _Allocator>
inline
void
basic_string<_CharT, _Traits, _Allocator>::__move_assign(basic_string& __str, true_type)

    noexcept



{
  if (__is_long()) {
    __alloc_traits::deallocate(__alloc(), __get_long_pointer(),
                               __get_long_cap());






  }
  __move_assign_alloc(__str);
  __r_.first() = __str.__r_.first();
  __str.__set_short_size(0);
  traits_type::assign(__str.__get_short_pointer()[0], value_type());
}

template <class _CharT, class _Traits, class _Allocator>
inline
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::operator=(basic_string&& __str)
    noexcept((__noexcept_move_assign_container<_Allocator, __alloc_traits>::value))
{
    __move_assign(__str, integral_constant<bool,
          __alloc_traits::propagate_on_container_move_assignment::value>());
    return *this;
}



template <class _CharT, class _Traits, class _Allocator>
template<class _InputIterator>
_EnableIf
<
     __is_exactly_cpp17_input_iterator<_InputIterator>::value,
    basic_string<_CharT, _Traits, _Allocator>&
>
basic_string<_CharT, _Traits, _Allocator>::assign(_InputIterator __first, _InputIterator __last)
{
    const basic_string __temp(__first, __last, __alloc());
    assign(__temp.data(), __temp.size());
    return *this;
}

template <class _CharT, class _Traits, class _Allocator>
template<class _ForwardIterator>
_EnableIf
<
    __is_cpp17_forward_iterator<_ForwardIterator>::value,
    basic_string<_CharT, _Traits, _Allocator>&
>
basic_string<_CharT, _Traits, _Allocator>::assign(_ForwardIterator __first, _ForwardIterator __last)
{
    size_type __cap = capacity();
    size_type __n = __string_is_trivial_iterator<_ForwardIterator>::value ?
        static_cast<size_type>(std::__1::distance(__first, __last)) : 0;

    if (__string_is_trivial_iterator<_ForwardIterator>::value &&
        (__cap >= __n || !__addr_in_range(*__first)))
    {
        if (__cap < __n)
        {
            size_type __sz = size();
            __grow_by(__cap, __n - __cap, __sz, 0, __sz);
        }
        pointer __p = __get_pointer();
        for (; __first != __last; ++__first, ++__p)
            traits_type::assign(*__p, *__first);
        traits_type::assign(*__p, value_type());
        __set_size(__n);
        __invalidate_iterators_past(__n);
    }
    else
    {
        const basic_string __temp(__first, __last, __alloc());
        assign(__temp.data(), __temp.size());
    }
    return *this;
}

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::assign(const basic_string& __str, size_type __pos, size_type __n)
{
    size_type __sz = __str.size();
    if (__pos > __sz)
        this->__throw_out_of_range();
    return assign(__str.data() + __pos, std::__1::min(__n, __sz - __pos));
}

template <class _CharT, class _Traits, class _Allocator>
template <class _Tp>
_EnableIf
<
    __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value
    && !__is_same_uncvref<_Tp, basic_string<_CharT, _Traits, _Allocator> >::value,
    basic_string<_CharT, _Traits, _Allocator>&
>
basic_string<_CharT, _Traits, _Allocator>::assign(const _Tp & __t, size_type __pos, size_type __n)
{
    __self_view __sv = __t;
    size_type __sz = __sv.size();
    if (__pos > __sz)
        this->__throw_out_of_range();
    return assign(__sv.data() + __pos, std::__1::min(__n, __sz - __pos));
}


template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::__assign_external(const value_type* __s) {
  return __assign_external(__s, traits_type::length(__s));
}

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::assign(const value_type* __s)
{
    ((void)0);
    return __builtin_constant_p(*__s)
               ? (traits_type::length(__s) < __min_cap
                      ? __assign_short(__s, traits_type::length(__s))
                      : __assign_external(__s, traits_type::length(__s)))
               : __assign_external(__s);
}


template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::append(const value_type* __s, size_type __n)
{
    ((void)0);
    size_type __cap = capacity();
    size_type __sz = size();
    if (__cap - __sz >= __n)
    {
        if (__n)
        {
            value_type* __p = std::__1::__to_address(__get_pointer());
            traits_type::copy(__p + __sz, __s, __n);
            __sz += __n;
            __set_size(__sz);
            traits_type::assign(__p[__sz], value_type());
        }
    }
    else
        __grow_by_and_replace(__cap, __sz + __n - __cap, __sz, __sz, 0, __n, __s);
    return *this;
}

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::append(size_type __n, value_type __c)
{
    if (__n)
    {
        size_type __cap = capacity();
        size_type __sz = size();
        if (__cap - __sz < __n)
            __grow_by(__cap, __sz + __n - __cap, __sz, __sz, 0);
        pointer __p = __get_pointer();
        traits_type::assign(std::__1::__to_address(__p) + __sz, __n, __c);
        __sz += __n;
        __set_size(__sz);
        traits_type::assign(__p[__sz], value_type());
    }
    return *this;
}

template <class _CharT, class _Traits, class _Allocator>
inline void
basic_string<_CharT, _Traits, _Allocator>::__append_default_init(size_type __n)
{
    if (__n)
    {
        size_type __cap = capacity();
        size_type __sz = size();
        if (__cap - __sz < __n)
            __grow_by(__cap, __sz + __n - __cap, __sz, __sz, 0);
        pointer __p = __get_pointer();
        __sz += __n;
        __set_size(__sz);
        traits_type::assign(__p[__sz], value_type());
    }
}

template <class _CharT, class _Traits, class _Allocator>
void
basic_string<_CharT, _Traits, _Allocator>::push_back(value_type __c)
{
    bool __is_short = !__is_long();
    size_type __cap;
    size_type __sz;
    if (__is_short)
    {
        __cap = __min_cap - 1;
        __sz = __get_short_size();
    }
    else
    {
        __cap = __get_long_cap() - 1;
        __sz = __get_long_size();
    }
    if (__sz == __cap)
    {
        __grow_by(__cap, 1, __sz, __sz, 0);
        __is_short = !__is_long();
    }
    pointer __p;
    if (__is_short)
    {
        __p = __get_short_pointer() + __sz;
        __set_short_size(__sz+1);
    }
    else
    {
        __p = __get_long_pointer() + __sz;
        __set_long_size(__sz+1);
    }
    traits_type::assign(*__p, __c);
    traits_type::assign(*++__p, value_type());
}

template <class _CharT, class _Traits, class _Allocator>
template<class _ForwardIterator>
_EnableIf
<
    __is_cpp17_forward_iterator<_ForwardIterator>::value,
    basic_string<_CharT, _Traits, _Allocator>&
>
basic_string<_CharT, _Traits, _Allocator>::append(
    _ForwardIterator __first, _ForwardIterator __last)
{
    size_type __sz = size();
    size_type __cap = capacity();
    size_type __n = static_cast<size_type>(std::__1::distance(__first, __last));
    if (__n)
    {
        if (__string_is_trivial_iterator<_ForwardIterator>::value &&
            !__addr_in_range(*__first))
        {
            if (__cap - __sz < __n)
                __grow_by(__cap, __sz + __n - __cap, __sz, __sz, 0);
            pointer __p = __get_pointer() + __sz;
            for (; __first != __last; ++__p, ++__first)
                traits_type::assign(*__p, *__first);
            traits_type::assign(*__p, value_type());
            __set_size(__sz + __n);
        }
        else
        {
            const basic_string __temp(__first, __last, __alloc());
            append(__temp.data(), __temp.size());
        }
    }
    return *this;
}

template <class _CharT, class _Traits, class _Allocator>
inline
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::append(const basic_string& __str)
{
    return append(__str.data(), __str.size());
}

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::append(const basic_string& __str, size_type __pos, size_type __n)
{
    size_type __sz = __str.size();
    if (__pos > __sz)
        this->__throw_out_of_range();
    return append(__str.data() + __pos, std::__1::min(__n, __sz - __pos));
}

template <class _CharT, class _Traits, class _Allocator>
template <class _Tp>
    _EnableIf
    <
        __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value && !__is_same_uncvref<_Tp, basic_string<_CharT, _Traits, _Allocator> >::value,
        basic_string<_CharT, _Traits, _Allocator>&
    >
basic_string<_CharT, _Traits, _Allocator>::append(const _Tp & __t, size_type __pos, size_type __n)
{
    __self_view __sv = __t;
    size_type __sz = __sv.size();
    if (__pos > __sz)
        this->__throw_out_of_range();
    return append(__sv.data() + __pos, std::__1::min(__n, __sz - __pos));
}

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::append(const value_type* __s)
{
    ((void)0);
    return append(__s, traits_type::length(__s));
}



template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::insert(size_type __pos, const value_type* __s, size_type __n)
{
    ((void)0);
    size_type __sz = size();
    if (__pos > __sz)
        this->__throw_out_of_range();
    size_type __cap = capacity();
    if (__cap - __sz >= __n)
    {
        if (__n)
        {
            value_type* __p = std::__1::__to_address(__get_pointer());
            size_type __n_move = __sz - __pos;
            if (__n_move != 0)
            {
                if (__p + __pos <= __s && __s < __p + __sz)
                    __s += __n;
                traits_type::move(__p + __pos + __n, __p + __pos, __n_move);
            }
            traits_type::move(__p + __pos, __s, __n);
            __sz += __n;
            __set_size(__sz);
            traits_type::assign(__p[__sz], value_type());
        }
    }
    else
        __grow_by_and_replace(__cap, __sz + __n - __cap, __sz, __pos, 0, __n, __s);
    return *this;
}

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::insert(size_type __pos, size_type __n, value_type __c)
{
    size_type __sz = size();
    if (__pos > __sz)
        this->__throw_out_of_range();
    if (__n)
    {
        size_type __cap = capacity();
        value_type* __p;
        if (__cap - __sz >= __n)
        {
            __p = std::__1::__to_address(__get_pointer());
            size_type __n_move = __sz - __pos;
            if (__n_move != 0)
                traits_type::move(__p + __pos + __n, __p + __pos, __n_move);
        }
        else
        {
            __grow_by(__cap, __sz + __n - __cap, __sz, __pos, 0, __n);
            __p = std::__1::__to_address(__get_long_pointer());
        }
        traits_type::assign(__p + __pos, __n, __c);
        __sz += __n;
        __set_size(__sz);
        traits_type::assign(__p[__sz], value_type());
    }
    return *this;
}

template <class _CharT, class _Traits, class _Allocator>
template<class _InputIterator>
_EnableIf
<
   __is_exactly_cpp17_input_iterator<_InputIterator>::value,
   typename basic_string<_CharT, _Traits, _Allocator>::iterator
>
basic_string<_CharT, _Traits, _Allocator>::insert(const_iterator __pos, _InputIterator __first, _InputIterator __last)
{





    const basic_string __temp(__first, __last, __alloc());
    return insert(__pos, __temp.data(), __temp.data() + __temp.size());
}

template <class _CharT, class _Traits, class _Allocator>
template<class _ForwardIterator>
_EnableIf
<
    __is_cpp17_forward_iterator<_ForwardIterator>::value,
    typename basic_string<_CharT, _Traits, _Allocator>::iterator
>
basic_string<_CharT, _Traits, _Allocator>::insert(const_iterator __pos, _ForwardIterator __first, _ForwardIterator __last)
{





    size_type __ip = static_cast<size_type>(__pos - begin());
    size_type __n = static_cast<size_type>(std::__1::distance(__first, __last));
    if (__n)
    {
        if (__string_is_trivial_iterator<_ForwardIterator>::value &&
            !__addr_in_range(*__first))
        {
            size_type __sz = size();
            size_type __cap = capacity();
            value_type* __p;
            if (__cap - __sz >= __n)
            {
                __p = std::__1::__to_address(__get_pointer());
                size_type __n_move = __sz - __ip;
                if (__n_move != 0)
                    traits_type::move(__p + __ip + __n, __p + __ip, __n_move);
            }
            else
            {
                __grow_by(__cap, __sz + __n - __cap, __sz, __ip, 0, __n);
                __p = std::__1::__to_address(__get_long_pointer());
            }
            __sz += __n;
            __set_size(__sz);
            traits_type::assign(__p[__sz], value_type());
            for (__p += __ip; __first != __last; ++__p, ++__first)
                traits_type::assign(*__p, *__first);
        }
        else
        {
            const basic_string __temp(__first, __last, __alloc());
            return insert(__pos, __temp.data(), __temp.data() + __temp.size());
        }
    }
    return begin() + __ip;
}

template <class _CharT, class _Traits, class _Allocator>
inline
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::insert(size_type __pos1, const basic_string& __str)
{
    return insert(__pos1, __str.data(), __str.size());
}

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::insert(size_type __pos1, const basic_string& __str,
                                                  size_type __pos2, size_type __n)
{
    size_type __str_sz = __str.size();
    if (__pos2 > __str_sz)
        this->__throw_out_of_range();
    return insert(__pos1, __str.data() + __pos2, std::__1::min(__n, __str_sz - __pos2));
}

template <class _CharT, class _Traits, class _Allocator>
template <class _Tp>
_EnableIf
<
    __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value && !__is_same_uncvref<_Tp, basic_string<_CharT, _Traits, _Allocator> >::value,
    basic_string<_CharT, _Traits, _Allocator>&
>
basic_string<_CharT, _Traits, _Allocator>::insert(size_type __pos1, const _Tp& __t,
                                                  size_type __pos2, size_type __n)
{
    __self_view __sv = __t;
    size_type __str_sz = __sv.size();
    if (__pos2 > __str_sz)
        this->__throw_out_of_range();
    return insert(__pos1, __sv.data() + __pos2, std::__1::min(__n, __str_sz - __pos2));
}

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::insert(size_type __pos, const value_type* __s)
{
    ((void)0);
    return insert(__pos, __s, traits_type::length(__s));
}

template <class _CharT, class _Traits, class _Allocator>
typename basic_string<_CharT, _Traits, _Allocator>::iterator
basic_string<_CharT, _Traits, _Allocator>::insert(const_iterator __pos, value_type __c)
{
    size_type __ip = static_cast<size_type>(__pos - begin());
    size_type __sz = size();
    size_type __cap = capacity();
    value_type* __p;
    if (__cap == __sz)
    {
        __grow_by(__cap, 1, __sz, __ip, 0, 1);
        __p = std::__1::__to_address(__get_long_pointer());
    }
    else
    {
        __p = std::__1::__to_address(__get_pointer());
        size_type __n_move = __sz - __ip;
        if (__n_move != 0)
            traits_type::move(__p + __ip + 1, __p + __ip, __n_move);
    }
    traits_type::assign(__p[__ip], __c);
    traits_type::assign(__p[++__sz], value_type());
    __set_size(__sz);
    return begin() + static_cast<difference_type>(__ip);
}

template <class _CharT, class _Traits, class _Allocator>
inline
typename basic_string<_CharT, _Traits, _Allocator>::iterator
basic_string<_CharT, _Traits, _Allocator>::insert(const_iterator __pos, size_type __n, value_type __c)
{





    difference_type __p = __pos - begin();
    insert(static_cast<size_type>(__p), __n, __c);
    return begin() + __p;
}



template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::replace(size_type __pos, size_type __n1, const value_type* __s, size_type __n2)
    __attribute__((__no_sanitize__("unsigned-integer-overflow")))
{
    ((void)0);
    size_type __sz = size();
    if (__pos > __sz)
        this->__throw_out_of_range();
    __n1 = std::__1::min(__n1, __sz - __pos);
    size_type __cap = capacity();
    if (__cap - __sz + __n1 >= __n2)
    {
        value_type* __p = std::__1::__to_address(__get_pointer());
        if (__n1 != __n2)
        {
            size_type __n_move = __sz - __pos - __n1;
            if (__n_move != 0)
            {
                if (__n1 > __n2)
                {
                    traits_type::move(__p + __pos, __s, __n2);
                    traits_type::move(__p + __pos + __n2, __p + __pos + __n1, __n_move);
                    goto __finish;
                }
                if (__p + __pos < __s && __s < __p + __sz)
                {
                    if (__p + __pos + __n1 <= __s)
                        __s += __n2 - __n1;
                    else
                    {
                        traits_type::move(__p + __pos, __s, __n1);
                        __pos += __n1;
                        __s += __n2;
                        __n2 -= __n1;
                        __n1 = 0;
                    }
                }
                traits_type::move(__p + __pos + __n2, __p + __pos + __n1, __n_move);
            }
        }
        traits_type::move(__p + __pos, __s, __n2);
__finish:


        __sz += __n2 - __n1;
        __set_size(__sz);
        __invalidate_iterators_past(__sz);
        traits_type::assign(__p[__sz], value_type());
    }
    else
        __grow_by_and_replace(__cap, __sz - __n1 + __n2 - __cap, __sz, __pos, __n1, __n2, __s);
    return *this;
}

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::replace(size_type __pos, size_type __n1, size_type __n2, value_type __c)
    __attribute__((__no_sanitize__("unsigned-integer-overflow")))
{
    size_type __sz = size();
    if (__pos > __sz)
        this->__throw_out_of_range();
    __n1 = std::__1::min(__n1, __sz - __pos);
    size_type __cap = capacity();
    value_type* __p;
    if (__cap - __sz + __n1 >= __n2)
    {
        __p = std::__1::__to_address(__get_pointer());
        if (__n1 != __n2)
        {
            size_type __n_move = __sz - __pos - __n1;
            if (__n_move != 0)
                traits_type::move(__p + __pos + __n2, __p + __pos + __n1, __n_move);
        }
    }
    else
    {
        __grow_by(__cap, __sz - __n1 + __n2 - __cap, __sz, __pos, __n1, __n2);
        __p = std::__1::__to_address(__get_long_pointer());
    }
    traits_type::assign(__p + __pos, __n2, __c);
    __sz += __n2 - __n1;
    __set_size(__sz);
    __invalidate_iterators_past(__sz);
    traits_type::assign(__p[__sz], value_type());
    return *this;
}

template <class _CharT, class _Traits, class _Allocator>
template<class _InputIterator>
_EnableIf
<
    __is_cpp17_input_iterator<_InputIterator>::value,
    basic_string<_CharT, _Traits, _Allocator>&
>
basic_string<_CharT, _Traits, _Allocator>::replace(const_iterator __i1, const_iterator __i2,
                                                   _InputIterator __j1, _InputIterator __j2)
{
    const basic_string __temp(__j1, __j2, __alloc());
    return this->replace(__i1, __i2, __temp);
}

template <class _CharT, class _Traits, class _Allocator>
inline
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::replace(size_type __pos1, size_type __n1, const basic_string& __str)
{
    return replace(__pos1, __n1, __str.data(), __str.size());
}

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::replace(size_type __pos1, size_type __n1, const basic_string& __str,
                                                   size_type __pos2, size_type __n2)
{
    size_type __str_sz = __str.size();
    if (__pos2 > __str_sz)
        this->__throw_out_of_range();
    return replace(__pos1, __n1, __str.data() + __pos2, std::__1::min(__n2, __str_sz - __pos2));
}

template <class _CharT, class _Traits, class _Allocator>
template <class _Tp>
_EnableIf
<
    __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value && !__is_same_uncvref<_Tp, basic_string<_CharT, _Traits, _Allocator> >::value,
    basic_string<_CharT, _Traits, _Allocator>&
>
basic_string<_CharT, _Traits, _Allocator>::replace(size_type __pos1, size_type __n1, const _Tp& __t,
                                                   size_type __pos2, size_type __n2)
{
    __self_view __sv = __t;
    size_type __str_sz = __sv.size();
    if (__pos2 > __str_sz)
        this->__throw_out_of_range();
    return replace(__pos1, __n1, __sv.data() + __pos2, std::__1::min(__n2, __str_sz - __pos2));
}

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::replace(size_type __pos, size_type __n1, const value_type* __s)
{
    ((void)0);
    return replace(__pos, __n1, __s, traits_type::length(__s));
}

template <class _CharT, class _Traits, class _Allocator>
inline
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::replace(const_iterator __i1, const_iterator __i2, const basic_string& __str)
{
    return replace(static_cast<size_type>(__i1 - begin()), static_cast<size_type>(__i2 - __i1),
                   __str.data(), __str.size());
}

template <class _CharT, class _Traits, class _Allocator>
inline
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::replace(const_iterator __i1, const_iterator __i2, const value_type* __s, size_type __n)
{
    return replace(static_cast<size_type>(__i1 - begin()), static_cast<size_type>(__i2 - __i1), __s, __n);
}

template <class _CharT, class _Traits, class _Allocator>
inline
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::replace(const_iterator __i1, const_iterator __i2, const value_type* __s)
{
    return replace(static_cast<size_type>(__i1 - begin()), static_cast<size_type>(__i2 - __i1), __s);
}

template <class _CharT, class _Traits, class _Allocator>
inline
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::replace(const_iterator __i1, const_iterator __i2, size_type __n, value_type __c)
{
    return replace(static_cast<size_type>(__i1 - begin()), static_cast<size_type>(__i2 - __i1), __n, __c);
}





template <class _CharT, class _Traits, class _Allocator>
void
basic_string<_CharT, _Traits, _Allocator>::__erase_external_with_move(
    size_type __pos, size_type __n)
{
    if (__n)
    {
        size_type __sz = size();
        value_type* __p = std::__1::__to_address(__get_pointer());
        __n = std::__1::min(__n, __sz - __pos);
        size_type __n_move = __sz - __pos - __n;
        if (__n_move != 0)
            traits_type::move(__p + __pos, __p + __pos + __n, __n_move);
        __sz -= __n;
        __set_size(__sz);
        __invalidate_iterators_past(__sz);
        traits_type::assign(__p[__sz], value_type());
    }
}

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::erase(size_type __pos,
                                                 size_type __n) {
  if (__pos > size()) this->__throw_out_of_range();
  if (__n == npos) {
    __erase_to_end(__pos);
  } else {
    __erase_external_with_move(__pos, __n);
  }
  return *this;
}

template <class _CharT, class _Traits, class _Allocator>
inline
typename basic_string<_CharT, _Traits, _Allocator>::iterator
basic_string<_CharT, _Traits, _Allocator>::erase(const_iterator __pos)
{





    ((void)0);

    iterator __b = begin();
    size_type __r = static_cast<size_type>(__pos - __b);
    erase(__r, 1);
    return __b + static_cast<difference_type>(__r);
}

template <class _CharT, class _Traits, class _Allocator>
inline
typename basic_string<_CharT, _Traits, _Allocator>::iterator
basic_string<_CharT, _Traits, _Allocator>::erase(const_iterator __first, const_iterator __last)
{





    ((void)0);
    iterator __b = begin();
    size_type __r = static_cast<size_type>(__first - __b);
    erase(__r, static_cast<size_type>(__last - __first));
    return __b + static_cast<difference_type>(__r);
}

template <class _CharT, class _Traits, class _Allocator>
inline
void
basic_string<_CharT, _Traits, _Allocator>::pop_back()
{
    ((void)0);
    size_type __sz;
    if (__is_long())
    {
        __sz = __get_long_size() - 1;
        __set_long_size(__sz);
        traits_type::assign(*(__get_long_pointer() + __sz), value_type());
    }
    else
    {
        __sz = __get_short_size() - 1;
        __set_short_size(__sz);
        traits_type::assign(*(__get_short_pointer() + __sz), value_type());
    }
    __invalidate_iterators_past(__sz);
}

template <class _CharT, class _Traits, class _Allocator>
inline
void
basic_string<_CharT, _Traits, _Allocator>::clear() noexcept
{
    __invalidate_all_iterators();
    if (__is_long())
    {
        traits_type::assign(*__get_long_pointer(), value_type());
        __set_long_size(0);
    }
    else
    {
        traits_type::assign(*__get_short_pointer(), value_type());
        __set_short_size(0);
    }
}

template <class _CharT, class _Traits, class _Allocator>
inline
void
basic_string<_CharT, _Traits, _Allocator>::__erase_to_end(size_type __pos)
{
    if (__is_long())
    {
        traits_type::assign(*(__get_long_pointer() + __pos), value_type());
        __set_long_size(__pos);
    }
    else
    {
        traits_type::assign(*(__get_short_pointer() + __pos), value_type());
        __set_short_size(__pos);
    }
    __invalidate_iterators_past(__pos);
}

template <class _CharT, class _Traits, class _Allocator>
void
basic_string<_CharT, _Traits, _Allocator>::resize(size_type __n, value_type __c)
{
    size_type __sz = size();
    if (__n > __sz)
        append(__n - __sz, __c);
    else
        __erase_to_end(__n);
}

template <class _CharT, class _Traits, class _Allocator>
inline void
basic_string<_CharT, _Traits, _Allocator>::__resize_default_init(size_type __n)
{
    size_type __sz = size();
    if (__n > __sz) {
       __append_default_init(__n - __sz);
    } else
        __erase_to_end(__n);
}

template <class _CharT, class _Traits, class _Allocator>
inline
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::max_size() const noexcept
{
    size_type __m = __alloc_traits::max_size(__alloc());



    return __m - __alignment;

}

template <class _CharT, class _Traits, class _Allocator>
void
basic_string<_CharT, _Traits, _Allocator>::reserve(size_type __requested_capacity)
{
    if (__requested_capacity > max_size())
        this->__throw_length_error();






    size_type __target_capacity = std::__1::max(__requested_capacity, size());
    __target_capacity = __recommend(__target_capacity);
    if (__target_capacity == capacity()) return;

    __shrink_or_extend(__target_capacity);
}

template <class _CharT, class _Traits, class _Allocator>
inline
void
basic_string<_CharT, _Traits, _Allocator>::shrink_to_fit() noexcept
{
    size_type __target_capacity = __recommend(size());
    if (__target_capacity == capacity()) return;

    __shrink_or_extend(__target_capacity);
}

template <class _CharT, class _Traits, class _Allocator>
inline
void
basic_string<_CharT, _Traits, _Allocator>::__shrink_or_extend(size_type __target_capacity)
{
    size_type __cap = capacity();
    size_type __sz = size();

    pointer __new_data, __p;
    bool __was_long, __now_long;
    if (__target_capacity == __min_cap - 1)
    {
        __was_long = true;
        __now_long = false;
        __new_data = __get_short_pointer();
        __p = __get_long_pointer();
    }
    else
    {
        if (__target_capacity > __cap)
            __new_data = __alloc_traits::allocate(__alloc(), __target_capacity+1);
        else
        {

            try
            {

                __new_data = __alloc_traits::allocate(__alloc(), __target_capacity+1);

            }
            catch (...)
            {
                return;
            }




        }
        __now_long = true;
        __was_long = __is_long();
        __p = __get_pointer();
    }
    traits_type::copy(std::__1::__to_address(__new_data),
                        std::__1::__to_address(__p), size()+1);
    if (__was_long)
        __alloc_traits::deallocate(__alloc(), __p, __cap+1);
    if (__now_long)
    {
        __set_long_cap(__target_capacity+1);
        __set_long_size(__sz);
        __set_long_pointer(__new_data);
    }
    else
        __set_short_size(__sz);
    __invalidate_all_iterators();
}

template <class _CharT, class _Traits, class _Allocator>
inline
typename basic_string<_CharT, _Traits, _Allocator>::const_reference
basic_string<_CharT, _Traits, _Allocator>::operator[](size_type __pos) const noexcept
{
    ((void)0);
    return *(data() + __pos);
}

template <class _CharT, class _Traits, class _Allocator>
inline
typename basic_string<_CharT, _Traits, _Allocator>::reference
basic_string<_CharT, _Traits, _Allocator>::operator[](size_type __pos) noexcept
{
    ((void)0);
    return *(__get_pointer() + __pos);
}

template <class _CharT, class _Traits, class _Allocator>
typename basic_string<_CharT, _Traits, _Allocator>::const_reference
basic_string<_CharT, _Traits, _Allocator>::at(size_type __n) const
{
    if (__n >= size())
        this->__throw_out_of_range();
    return (*this)[__n];
}

template <class _CharT, class _Traits, class _Allocator>
typename basic_string<_CharT, _Traits, _Allocator>::reference
basic_string<_CharT, _Traits, _Allocator>::at(size_type __n)
{
    if (__n >= size())
        this->__throw_out_of_range();
    return (*this)[__n];
}

template <class _CharT, class _Traits, class _Allocator>
inline
typename basic_string<_CharT, _Traits, _Allocator>::reference
basic_string<_CharT, _Traits, _Allocator>::front() noexcept
{
    ((void)0);
    return *__get_pointer();
}

template <class _CharT, class _Traits, class _Allocator>
inline
typename basic_string<_CharT, _Traits, _Allocator>::const_reference
basic_string<_CharT, _Traits, _Allocator>::front() const noexcept
{
    ((void)0);
    return *data();
}

template <class _CharT, class _Traits, class _Allocator>
inline
typename basic_string<_CharT, _Traits, _Allocator>::reference
basic_string<_CharT, _Traits, _Allocator>::back() noexcept
{
    ((void)0);
    return *(__get_pointer() + size() - 1);
}

template <class _CharT, class _Traits, class _Allocator>
inline
typename basic_string<_CharT, _Traits, _Allocator>::const_reference
basic_string<_CharT, _Traits, _Allocator>::back() const noexcept
{
    ((void)0);
    return *(data() + size() - 1);
}

template <class _CharT, class _Traits, class _Allocator>
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::copy(value_type* __s, size_type __n, size_type __pos) const
{
    size_type __sz = size();
    if (__pos > __sz)
        this->__throw_out_of_range();
    size_type __rlen = std::__1::min(__n, __sz - __pos);
    traits_type::copy(__s, data() + __pos, __rlen);
    return __rlen;
}

template <class _CharT, class _Traits, class _Allocator>
inline
basic_string<_CharT, _Traits, _Allocator>
basic_string<_CharT, _Traits, _Allocator>::substr(size_type __pos, size_type __n) const
{
    return basic_string(*this, __pos, __n, __alloc());
}

template <class _CharT, class _Traits, class _Allocator>
inline
void
basic_string<_CharT, _Traits, _Allocator>::swap(basic_string& __str)

        noexcept




{







    ((void)0);



    std::__1::swap(__r_.first(), __str.__r_.first());
    std::__1::__swap_allocator(__alloc(), __str.__alloc());
}



template <class _Traits>
struct __attribute__ ((__visibility__("hidden"))) __traits_eq
{
    typedef typename _Traits::char_type char_type;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    bool operator()(const char_type& __x, const char_type& __y) noexcept
        {return _Traits::eq(__x, __y);}
};

template<class _CharT, class _Traits, class _Allocator>
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find(const value_type* __s,
                                                size_type __pos,
                                                size_type __n) const noexcept
{
    ((void)0);
    return __str_find<value_type, size_type, traits_type, npos>
        (data(), size(), __s, __pos, __n);
}

template<class _CharT, class _Traits, class _Allocator>
inline
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find(const basic_string& __str,
                                                size_type __pos) const noexcept
{
    return __str_find<value_type, size_type, traits_type, npos>
        (data(), size(), __str.data(), __pos, __str.size());
}

template<class _CharT, class _Traits, class _Allocator>
template <class _Tp>
_EnableIf
<
    __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,
    typename basic_string<_CharT, _Traits, _Allocator>::size_type
>
basic_string<_CharT, _Traits, _Allocator>::find(const _Tp &__t,
                                                size_type __pos) const noexcept
{
    __self_view __sv = __t;
    return __str_find<value_type, size_type, traits_type, npos>
        (data(), size(), __sv.data(), __pos, __sv.size());
}

template<class _CharT, class _Traits, class _Allocator>
inline
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find(const value_type* __s,
                                                size_type __pos) const noexcept
{
    ((void)0);
    return __str_find<value_type, size_type, traits_type, npos>
        (data(), size(), __s, __pos, traits_type::length(__s));
}

template<class _CharT, class _Traits, class _Allocator>
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find(value_type __c,
                                                size_type __pos) const noexcept
{
    return __str_find<value_type, size_type, traits_type, npos>
        (data(), size(), __c, __pos);
}



template<class _CharT, class _Traits, class _Allocator>
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::rfind(const value_type* __s,
                                                 size_type __pos,
                                                 size_type __n) const noexcept
{
    ((void)0);
    return __str_rfind<value_type, size_type, traits_type, npos>
        (data(), size(), __s, __pos, __n);
}

template<class _CharT, class _Traits, class _Allocator>
inline
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::rfind(const basic_string& __str,
                                                 size_type __pos) const noexcept
{
    return __str_rfind<value_type, size_type, traits_type, npos>
        (data(), size(), __str.data(), __pos, __str.size());
}

template<class _CharT, class _Traits, class _Allocator>
template <class _Tp>
_EnableIf
<
    __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,
    typename basic_string<_CharT, _Traits, _Allocator>::size_type
>
basic_string<_CharT, _Traits, _Allocator>::rfind(const _Tp& __t,
                                                size_type __pos) const noexcept
{
    __self_view __sv = __t;
    return __str_rfind<value_type, size_type, traits_type, npos>
        (data(), size(), __sv.data(), __pos, __sv.size());
}

template<class _CharT, class _Traits, class _Allocator>
inline
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::rfind(const value_type* __s,
                                                 size_type __pos) const noexcept
{
    ((void)0);
    return __str_rfind<value_type, size_type, traits_type, npos>
        (data(), size(), __s, __pos, traits_type::length(__s));
}

template<class _CharT, class _Traits, class _Allocator>
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::rfind(value_type __c,
                                                 size_type __pos) const noexcept
{
    return __str_rfind<value_type, size_type, traits_type, npos>
        (data(), size(), __c, __pos);
}



template<class _CharT, class _Traits, class _Allocator>
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_first_of(const value_type* __s,
                                                         size_type __pos,
                                                         size_type __n) const noexcept
{
    ((void)0);
    return __str_find_first_of<value_type, size_type, traits_type, npos>
        (data(), size(), __s, __pos, __n);
}

template<class _CharT, class _Traits, class _Allocator>
inline
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_first_of(const basic_string& __str,
                                                         size_type __pos) const noexcept
{
    return __str_find_first_of<value_type, size_type, traits_type, npos>
        (data(), size(), __str.data(), __pos, __str.size());
}

template<class _CharT, class _Traits, class _Allocator>
template <class _Tp>
_EnableIf
<
    __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,
    typename basic_string<_CharT, _Traits, _Allocator>::size_type
>
basic_string<_CharT, _Traits, _Allocator>::find_first_of(const _Tp& __t,
                                                size_type __pos) const noexcept
{
    __self_view __sv = __t;
    return __str_find_first_of<value_type, size_type, traits_type, npos>
        (data(), size(), __sv.data(), __pos, __sv.size());
}

template<class _CharT, class _Traits, class _Allocator>
inline
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_first_of(const value_type* __s,
                                                         size_type __pos) const noexcept
{
    ((void)0);
    return __str_find_first_of<value_type, size_type, traits_type, npos>
        (data(), size(), __s, __pos, traits_type::length(__s));
}

template<class _CharT, class _Traits, class _Allocator>
inline
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_first_of(value_type __c,
                                                         size_type __pos) const noexcept
{
    return find(__c, __pos);
}



template<class _CharT, class _Traits, class _Allocator>
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_last_of(const value_type* __s,
                                                        size_type __pos,
                                                        size_type __n) const noexcept
{
    ((void)0);
    return __str_find_last_of<value_type, size_type, traits_type, npos>
        (data(), size(), __s, __pos, __n);
}

template<class _CharT, class _Traits, class _Allocator>
inline
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_last_of(const basic_string& __str,
                                                        size_type __pos) const noexcept
{
    return __str_find_last_of<value_type, size_type, traits_type, npos>
        (data(), size(), __str.data(), __pos, __str.size());
}

template<class _CharT, class _Traits, class _Allocator>
template <class _Tp>
_EnableIf
<
    __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,
    typename basic_string<_CharT, _Traits, _Allocator>::size_type
>
basic_string<_CharT, _Traits, _Allocator>::find_last_of(const _Tp& __t,
                                                size_type __pos) const noexcept
{
    __self_view __sv = __t;
    return __str_find_last_of<value_type, size_type, traits_type, npos>
        (data(), size(), __sv.data(), __pos, __sv.size());
}

template<class _CharT, class _Traits, class _Allocator>
inline
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_last_of(const value_type* __s,
                                                        size_type __pos) const noexcept
{
    ((void)0);
    return __str_find_last_of<value_type, size_type, traits_type, npos>
        (data(), size(), __s, __pos, traits_type::length(__s));
}

template<class _CharT, class _Traits, class _Allocator>
inline
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_last_of(value_type __c,
                                                        size_type __pos) const noexcept
{
    return rfind(__c, __pos);
}



template<class _CharT, class _Traits, class _Allocator>
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_first_not_of(const value_type* __s,
                                                             size_type __pos,
                                                             size_type __n) const noexcept
{
    ((void)0);
    return __str_find_first_not_of<value_type, size_type, traits_type, npos>
        (data(), size(), __s, __pos, __n);
}

template<class _CharT, class _Traits, class _Allocator>
inline
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_first_not_of(const basic_string& __str,
                                                             size_type __pos) const noexcept
{
    return __str_find_first_not_of<value_type, size_type, traits_type, npos>
        (data(), size(), __str.data(), __pos, __str.size());
}

template<class _CharT, class _Traits, class _Allocator>
template <class _Tp>
_EnableIf
<
    __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,
    typename basic_string<_CharT, _Traits, _Allocator>::size_type
>
basic_string<_CharT, _Traits, _Allocator>::find_first_not_of(const _Tp& __t,
                                                size_type __pos) const noexcept
{
    __self_view __sv = __t;
    return __str_find_first_not_of<value_type, size_type, traits_type, npos>
        (data(), size(), __sv.data(), __pos, __sv.size());
}

template<class _CharT, class _Traits, class _Allocator>
inline
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_first_not_of(const value_type* __s,
                                                             size_type __pos) const noexcept
{
    ((void)0);
    return __str_find_first_not_of<value_type, size_type, traits_type, npos>
        (data(), size(), __s, __pos, traits_type::length(__s));
}

template<class _CharT, class _Traits, class _Allocator>
inline
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_first_not_of(value_type __c,
                                                             size_type __pos) const noexcept
{
    return __str_find_first_not_of<value_type, size_type, traits_type, npos>
        (data(), size(), __c, __pos);
}



template<class _CharT, class _Traits, class _Allocator>
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_last_not_of(const value_type* __s,
                                                            size_type __pos,
                                                            size_type __n) const noexcept
{
    ((void)0);
    return __str_find_last_not_of<value_type, size_type, traits_type, npos>
        (data(), size(), __s, __pos, __n);
}

template<class _CharT, class _Traits, class _Allocator>
inline
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_last_not_of(const basic_string& __str,
                                                            size_type __pos) const noexcept
{
    return __str_find_last_not_of<value_type, size_type, traits_type, npos>
        (data(), size(), __str.data(), __pos, __str.size());
}

template<class _CharT, class _Traits, class _Allocator>
template <class _Tp>
_EnableIf
<
    __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,
    typename basic_string<_CharT, _Traits, _Allocator>::size_type
>
basic_string<_CharT, _Traits, _Allocator>::find_last_not_of(const _Tp& __t,
                                                size_type __pos) const noexcept
{
    __self_view __sv = __t;
    return __str_find_last_not_of<value_type, size_type, traits_type, npos>
        (data(), size(), __sv.data(), __pos, __sv.size());
}

template<class _CharT, class _Traits, class _Allocator>
inline
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_last_not_of(const value_type* __s,
                                                            size_type __pos) const noexcept
{
    ((void)0);
    return __str_find_last_not_of<value_type, size_type, traits_type, npos>
        (data(), size(), __s, __pos, traits_type::length(__s));
}

template<class _CharT, class _Traits, class _Allocator>
inline
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_last_not_of(value_type __c,
                                                            size_type __pos) const noexcept
{
    return __str_find_last_not_of<value_type, size_type, traits_type, npos>
        (data(), size(), __c, __pos);
}



template <class _CharT, class _Traits, class _Allocator>
template <class _Tp>
_EnableIf
<
    __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,
    int
>
basic_string<_CharT, _Traits, _Allocator>::compare(const _Tp& __t) const noexcept
{
    __self_view __sv = __t;
    size_t __lhs_sz = size();
    size_t __rhs_sz = __sv.size();
    int __result = traits_type::compare(data(), __sv.data(),
                                        std::__1::min(__lhs_sz, __rhs_sz));
    if (__result != 0)
        return __result;
    if (__lhs_sz < __rhs_sz)
        return -1;
    if (__lhs_sz > __rhs_sz)
        return 1;
    return 0;
}

template <class _CharT, class _Traits, class _Allocator>
inline
int
basic_string<_CharT, _Traits, _Allocator>::compare(const basic_string& __str) const noexcept
{
    return compare(__self_view(__str));
}

template <class _CharT, class _Traits, class _Allocator>
int
basic_string<_CharT, _Traits, _Allocator>::compare(size_type __pos1,
                                                   size_type __n1,
                                                   const value_type* __s,
                                                   size_type __n2) const
{
    ((void)0);
    size_type __sz = size();
    if (__pos1 > __sz || __n2 == npos)
        this->__throw_out_of_range();
    size_type __rlen = std::__1::min(__n1, __sz - __pos1);
    int __r = traits_type::compare(data() + __pos1, __s, std::__1::min(__rlen, __n2));
    if (__r == 0)
    {
        if (__rlen < __n2)
            __r = -1;
        else if (__rlen > __n2)
            __r = 1;
    }
    return __r;
}

template <class _CharT, class _Traits, class _Allocator>
template <class _Tp>
_EnableIf
<
    __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,
    int
>
basic_string<_CharT, _Traits, _Allocator>::compare(size_type __pos1,
                                                   size_type __n1,
                                                   const _Tp& __t) const
{
    __self_view __sv = __t;
    return compare(__pos1, __n1, __sv.data(), __sv.size());
}

template <class _CharT, class _Traits, class _Allocator>
inline
int
basic_string<_CharT, _Traits, _Allocator>::compare(size_type __pos1,
                                                   size_type __n1,
                                                   const basic_string& __str) const
{
    return compare(__pos1, __n1, __str.data(), __str.size());
}

template <class _CharT, class _Traits, class _Allocator>
template <class _Tp>
_EnableIf
<
    __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value
    && !__is_same_uncvref<_Tp, basic_string<_CharT, _Traits, _Allocator> >::value,
    int
>
basic_string<_CharT, _Traits, _Allocator>::compare(size_type __pos1,
                                                   size_type __n1,
                                                   const _Tp& __t,
                                                   size_type __pos2,
                                                   size_type __n2) const
{
    __self_view __sv = __t;
    return __self_view(*this).substr(__pos1, __n1).compare(__sv.substr(__pos2, __n2));
}

template <class _CharT, class _Traits, class _Allocator>
int
basic_string<_CharT, _Traits, _Allocator>::compare(size_type __pos1,
                                                   size_type __n1,
                                                   const basic_string& __str,
                                                   size_type __pos2,
                                                   size_type __n2) const
{
        return compare(__pos1, __n1, __self_view(__str), __pos2, __n2);
}

template <class _CharT, class _Traits, class _Allocator>
int
basic_string<_CharT, _Traits, _Allocator>::compare(const value_type* __s) const noexcept
{
    ((void)0);
    return compare(0, npos, __s, traits_type::length(__s));
}

template <class _CharT, class _Traits, class _Allocator>
int
basic_string<_CharT, _Traits, _Allocator>::compare(size_type __pos1,
                                                   size_type __n1,
                                                   const value_type* __s) const
{
    ((void)0);
    return compare(__pos1, __n1, __s, traits_type::length(__s));
}



template<class _CharT, class _Traits, class _Allocator>
inline
bool
basic_string<_CharT, _Traits, _Allocator>::__invariants() const
{
    if (size() > capacity())
        return false;
    if (capacity() < __min_cap - 1)
        return false;
    if (data() == nullptr)
        return false;
    if (data()[size()] != value_type())
        return false;
    return true;
}



template<class _CharT, class _Traits, class _Allocator>
inline
void
basic_string<_CharT, _Traits, _Allocator>::__clear_and_shrink() noexcept
{
    clear();
    if(__is_long())
    {
        __alloc_traits::deallocate(__alloc(), __get_long_pointer(), capacity() + 1);
        __set_long_cap(0);
        __set_short_size(0);
        traits_type::assign(*__get_short_pointer(), value_type());
    }
}



template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator==(const basic_string<_CharT, _Traits, _Allocator>& __lhs,
           const basic_string<_CharT, _Traits, _Allocator>& __rhs) noexcept
{
    size_t __lhs_sz = __lhs.size();
    return __lhs_sz == __rhs.size() && _Traits::compare(__lhs.data(),
                                                        __rhs.data(),
                                                        __lhs_sz) == 0;
}

template<class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator==(const basic_string<char, char_traits<char>, _Allocator>& __lhs,
           const basic_string<char, char_traits<char>, _Allocator>& __rhs) noexcept
{
    size_t __lhs_sz = __lhs.size();
    if (__lhs_sz != __rhs.size())
        return false;
    const char* __lp = __lhs.data();
    const char* __rp = __rhs.data();
    if (__lhs.__is_long())
        return char_traits<char>::compare(__lp, __rp, __lhs_sz) == 0;
    for (; __lhs_sz != 0; --__lhs_sz, ++__lp, ++__rp)
        if (*__lp != *__rp)
            return false;
    return true;
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator==(const _CharT* __lhs,
           const basic_string<_CharT, _Traits, _Allocator>& __rhs) noexcept
{
    typedef basic_string<_CharT, _Traits, _Allocator> _String;
    ((void)0);
    size_t __lhs_len = _Traits::length(__lhs);
    if (__lhs_len != __rhs.size()) return false;
    return __rhs.compare(0, _String::npos, __lhs, __lhs_len) == 0;
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator==(const basic_string<_CharT,_Traits,_Allocator>& __lhs,
           const _CharT* __rhs) noexcept
{
    typedef basic_string<_CharT, _Traits, _Allocator> _String;
    ((void)0);
    size_t __rhs_len = _Traits::length(__rhs);
    if (__rhs_len != __lhs.size()) return false;
    return __lhs.compare(0, _String::npos, __rhs, __rhs_len) == 0;
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator!=(const basic_string<_CharT,_Traits,_Allocator>& __lhs,
           const basic_string<_CharT, _Traits, _Allocator>& __rhs) noexcept
{
    return !(__lhs == __rhs);
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator!=(const _CharT* __lhs,
           const basic_string<_CharT, _Traits, _Allocator>& __rhs) noexcept
{
    return !(__lhs == __rhs);
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator!=(const basic_string<_CharT, _Traits, _Allocator>& __lhs,
           const _CharT* __rhs) noexcept
{
    return !(__lhs == __rhs);
}



template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator< (const basic_string<_CharT, _Traits, _Allocator>& __lhs,
           const basic_string<_CharT, _Traits, _Allocator>& __rhs) noexcept
{
    return __lhs.compare(__rhs) < 0;
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator< (const basic_string<_CharT, _Traits, _Allocator>& __lhs,
           const _CharT* __rhs) noexcept
{
    return __lhs.compare(__rhs) < 0;
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator< (const _CharT* __lhs,
           const basic_string<_CharT, _Traits, _Allocator>& __rhs) noexcept
{
    return __rhs.compare(__lhs) > 0;
}



template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator> (const basic_string<_CharT, _Traits, _Allocator>& __lhs,
           const basic_string<_CharT, _Traits, _Allocator>& __rhs) noexcept
{
    return __rhs < __lhs;
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator> (const basic_string<_CharT, _Traits, _Allocator>& __lhs,
           const _CharT* __rhs) noexcept
{
    return __rhs < __lhs;
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator> (const _CharT* __lhs,
           const basic_string<_CharT, _Traits, _Allocator>& __rhs) noexcept
{
    return __rhs < __lhs;
}



template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator<=(const basic_string<_CharT, _Traits, _Allocator>& __lhs,
           const basic_string<_CharT, _Traits, _Allocator>& __rhs) noexcept
{
    return !(__rhs < __lhs);
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator<=(const basic_string<_CharT, _Traits, _Allocator>& __lhs,
           const _CharT* __rhs) noexcept
{
    return !(__rhs < __lhs);
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator<=(const _CharT* __lhs,
           const basic_string<_CharT, _Traits, _Allocator>& __rhs) noexcept
{
    return !(__rhs < __lhs);
}



template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator>=(const basic_string<_CharT, _Traits, _Allocator>& __lhs,
           const basic_string<_CharT, _Traits, _Allocator>& __rhs) noexcept
{
    return !(__lhs < __rhs);
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator>=(const basic_string<_CharT, _Traits, _Allocator>& __lhs,
           const _CharT* __rhs) noexcept
{
    return !(__lhs < __rhs);
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator>=(const _CharT* __lhs,
           const basic_string<_CharT, _Traits, _Allocator>& __rhs) noexcept
{
    return !(__lhs < __rhs);
}



template<class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>
operator+(const basic_string<_CharT, _Traits, _Allocator>& __lhs,
          const basic_string<_CharT, _Traits, _Allocator>& __rhs)
{
    basic_string<_CharT, _Traits, _Allocator> __r(__lhs.get_allocator());
    typename basic_string<_CharT, _Traits, _Allocator>::size_type __lhs_sz = __lhs.size();
    typename basic_string<_CharT, _Traits, _Allocator>::size_type __rhs_sz = __rhs.size();
    __r.__init(__lhs.data(), __lhs_sz, __lhs_sz + __rhs_sz);
    __r.append(__rhs.data(), __rhs_sz);
    return __r;
}

template<class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>
operator+(const _CharT* __lhs , const basic_string<_CharT,_Traits,_Allocator>& __rhs)
{
    basic_string<_CharT, _Traits, _Allocator> __r(__rhs.get_allocator());
    typename basic_string<_CharT, _Traits, _Allocator>::size_type __lhs_sz = _Traits::length(__lhs);
    typename basic_string<_CharT, _Traits, _Allocator>::size_type __rhs_sz = __rhs.size();
    __r.__init(__lhs, __lhs_sz, __lhs_sz + __rhs_sz);
    __r.append(__rhs.data(), __rhs_sz);
    return __r;
}

template<class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>
operator+(_CharT __lhs, const basic_string<_CharT,_Traits,_Allocator>& __rhs)
{
    basic_string<_CharT, _Traits, _Allocator> __r(__rhs.get_allocator());
    typename basic_string<_CharT, _Traits, _Allocator>::size_type __rhs_sz = __rhs.size();
    __r.__init(&__lhs, 1, 1 + __rhs_sz);
    __r.append(__rhs.data(), __rhs_sz);
    return __r;
}

template<class _CharT, class _Traits, class _Allocator>
inline
basic_string<_CharT, _Traits, _Allocator>
operator+(const basic_string<_CharT, _Traits, _Allocator>& __lhs, const _CharT* __rhs)
{
    basic_string<_CharT, _Traits, _Allocator> __r(__lhs.get_allocator());
    typename basic_string<_CharT, _Traits, _Allocator>::size_type __lhs_sz = __lhs.size();
    typename basic_string<_CharT, _Traits, _Allocator>::size_type __rhs_sz = _Traits::length(__rhs);
    __r.__init(__lhs.data(), __lhs_sz, __lhs_sz + __rhs_sz);
    __r.append(__rhs, __rhs_sz);
    return __r;
}

template<class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>
operator+(const basic_string<_CharT, _Traits, _Allocator>& __lhs, _CharT __rhs)
{
    basic_string<_CharT, _Traits, _Allocator> __r(__lhs.get_allocator());
    typename basic_string<_CharT, _Traits, _Allocator>::size_type __lhs_sz = __lhs.size();
    __r.__init(__lhs.data(), __lhs_sz, __lhs_sz + 1);
    __r.push_back(__rhs);
    return __r;
}



template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
basic_string<_CharT, _Traits, _Allocator>
operator+(basic_string<_CharT, _Traits, _Allocator>&& __lhs, const basic_string<_CharT, _Traits, _Allocator>& __rhs)
{
    return std::__1::move(__lhs.append(__rhs));
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
basic_string<_CharT, _Traits, _Allocator>
operator+(const basic_string<_CharT, _Traits, _Allocator>& __lhs, basic_string<_CharT, _Traits, _Allocator>&& __rhs)
{
    return std::__1::move(__rhs.insert(0, __lhs));
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
basic_string<_CharT, _Traits, _Allocator>
operator+(basic_string<_CharT, _Traits, _Allocator>&& __lhs, basic_string<_CharT, _Traits, _Allocator>&& __rhs)
{
    return std::__1::move(__lhs.append(__rhs));
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
basic_string<_CharT, _Traits, _Allocator>
operator+(const _CharT* __lhs , basic_string<_CharT,_Traits,_Allocator>&& __rhs)
{
    return std::__1::move(__rhs.insert(0, __lhs));
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
basic_string<_CharT, _Traits, _Allocator>
operator+(_CharT __lhs, basic_string<_CharT,_Traits,_Allocator>&& __rhs)
{
    __rhs.insert(__rhs.begin(), __lhs);
    return std::__1::move(__rhs);
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
basic_string<_CharT, _Traits, _Allocator>
operator+(basic_string<_CharT, _Traits, _Allocator>&& __lhs, const _CharT* __rhs)
{
    return std::__1::move(__lhs.append(__rhs));
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
basic_string<_CharT, _Traits, _Allocator>
operator+(basic_string<_CharT, _Traits, _Allocator>&& __lhs, _CharT __rhs)
{
    __lhs.push_back(__rhs);
    return std::__1::move(__lhs);
}





template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void
swap(basic_string<_CharT, _Traits, _Allocator>& __lhs,
     basic_string<_CharT, _Traits, _Allocator>& __rhs)
     noexcept(noexcept(__lhs.swap(__rhs)))
{
    __lhs.swap(__rhs);
}

__attribute__ ((__visibility__("default"))) int stoi (const string& __str, size_t* __idx = nullptr, int __base = 10);
__attribute__ ((__visibility__("default"))) long stol (const string& __str, size_t* __idx = nullptr, int __base = 10);
__attribute__ ((__visibility__("default"))) unsigned long stoul (const string& __str, size_t* __idx = nullptr, int __base = 10);
__attribute__ ((__visibility__("default"))) long long stoll (const string& __str, size_t* __idx = nullptr, int __base = 10);
__attribute__ ((__visibility__("default"))) unsigned long long stoull(const string& __str, size_t* __idx = nullptr, int __base = 10);

__attribute__ ((__visibility__("default"))) float stof (const string& __str, size_t* __idx = nullptr);
__attribute__ ((__visibility__("default"))) double stod (const string& __str, size_t* __idx = nullptr);
__attribute__ ((__visibility__("default"))) long double stold(const string& __str, size_t* __idx = nullptr);

__attribute__ ((__visibility__("default"))) string to_string(int __val);
__attribute__ ((__visibility__("default"))) string to_string(unsigned __val);
__attribute__ ((__visibility__("default"))) string to_string(long __val);
__attribute__ ((__visibility__("default"))) string to_string(unsigned long __val);
__attribute__ ((__visibility__("default"))) string to_string(long long __val);
__attribute__ ((__visibility__("default"))) string to_string(unsigned long long __val);
__attribute__ ((__visibility__("default"))) string to_string(float __val);
__attribute__ ((__visibility__("default"))) string to_string(double __val);
__attribute__ ((__visibility__("default"))) string to_string(long double __val);


__attribute__ ((__visibility__("default"))) int stoi (const wstring& __str, size_t* __idx = nullptr, int __base = 10);
__attribute__ ((__visibility__("default"))) long stol (const wstring& __str, size_t* __idx = nullptr, int __base = 10);
__attribute__ ((__visibility__("default"))) unsigned long stoul (const wstring& __str, size_t* __idx = nullptr, int __base = 10);
__attribute__ ((__visibility__("default"))) long long stoll (const wstring& __str, size_t* __idx = nullptr, int __base = 10);
__attribute__ ((__visibility__("default"))) unsigned long long stoull(const wstring& __str, size_t* __idx = nullptr, int __base = 10);

__attribute__ ((__visibility__("default"))) float stof (const wstring& __str, size_t* __idx = nullptr);
__attribute__ ((__visibility__("default"))) double stod (const wstring& __str, size_t* __idx = nullptr);
__attribute__ ((__visibility__("default"))) long double stold(const wstring& __str, size_t* __idx = nullptr);

__attribute__ ((__visibility__("default"))) wstring to_wstring(int __val);
__attribute__ ((__visibility__("default"))) wstring to_wstring(unsigned __val);
__attribute__ ((__visibility__("default"))) wstring to_wstring(long __val);
__attribute__ ((__visibility__("default"))) wstring to_wstring(unsigned long __val);
__attribute__ ((__visibility__("default"))) wstring to_wstring(long long __val);
__attribute__ ((__visibility__("default"))) wstring to_wstring(unsigned long long __val);
__attribute__ ((__visibility__("default"))) wstring to_wstring(float __val);
__attribute__ ((__visibility__("default"))) wstring to_wstring(double __val);
__attribute__ ((__visibility__("default"))) wstring to_wstring(long double __val);


template<class _CharT, class _Traits, class _Allocator>
__attribute__ ((__visibility__("default")))
const typename basic_string<_CharT, _Traits, _Allocator>::size_type
               basic_string<_CharT, _Traits, _Allocator>::npos;

template <class _CharT, class _Allocator>
struct __attribute__ ((__type_visibility__("default")))
    hash<basic_string<_CharT, char_traits<_CharT>, _Allocator> >
    : public unary_function<
          basic_string<_CharT, char_traits<_CharT>, _Allocator>, size_t>
{
    size_t
    operator()(const basic_string<_CharT, char_traits<_CharT>, _Allocator>& __val) const noexcept
    { return __do_string_hash(__val.data(), __val.data() + __val.size()); }
};


template<class _CharT, class _Traits, class _Allocator>
basic_ostream<_CharT, _Traits>&
operator<<(basic_ostream<_CharT, _Traits>& __os,
           const basic_string<_CharT, _Traits, _Allocator>& __str);

template<class _CharT, class _Traits, class _Allocator>
basic_istream<_CharT, _Traits>&
operator>>(basic_istream<_CharT, _Traits>& __is,
           basic_string<_CharT, _Traits, _Allocator>& __str);

template<class _CharT, class _Traits, class _Allocator>
basic_istream<_CharT, _Traits>&
getline(basic_istream<_CharT, _Traits>& __is,
        basic_string<_CharT, _Traits, _Allocator>& __str, _CharT __dlm);

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
basic_istream<_CharT, _Traits>&
getline(basic_istream<_CharT, _Traits>& __is,
        basic_string<_CharT, _Traits, _Allocator>& __str);

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
basic_istream<_CharT, _Traits>&
getline(basic_istream<_CharT, _Traits>&& __is,
        basic_string<_CharT, _Traits, _Allocator>& __str, _CharT __dlm);

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
basic_istream<_CharT, _Traits>&
getline(basic_istream<_CharT, _Traits>&& __is,
        basic_string<_CharT, _Traits, _Allocator>& __str);
# 4553 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/string" 3
inline namespace literals
{
  inline namespace string_literals
  {
    inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    basic_string<char> operator "" s( const char *__str, size_t __len )
    {
        return basic_string<char> (__str, __len);
    }


    inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    basic_string<wchar_t> operator "" s( const wchar_t *__str, size_t __len )
    {
        return basic_string<wchar_t> (__str, __len);
    }
# 4579 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/string" 3
    inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    basic_string<char16_t> operator "" s( const char16_t *__str, size_t __len )
    {
        return basic_string<char16_t> (__str, __len);
    }

    inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    basic_string<char32_t> operator "" s( const char32_t *__str, size_t __len )
    {
        return basic_string<char32_t> (__str, __len);
    }
  }
}


} }
# 123 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/bitset" 2 3
# 126 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/bitset" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 130 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/bitset" 2 3


namespace std { inline namespace __1 {

template <size_t _N_words, size_t _Size>
class __bitset;

template <size_t _N_words, size_t _Size>
struct __has_storage_type<__bitset<_N_words, _Size> >
{
    static const bool value = true;
};

template <size_t _N_words, size_t _Size>
class __bitset
{
public:
    typedef ptrdiff_t difference_type;
    typedef size_t size_type;
    typedef size_type __storage_type;
protected:
    typedef __bitset __self;
    typedef __storage_type* __storage_pointer;
    typedef const __storage_type* __const_storage_pointer;
    static const unsigned __bits_per_word = static_cast<unsigned>(sizeof(__storage_type) * 8);

    friend class __bit_reference<__bitset>;
    friend class __bit_const_reference<__bitset>;
    friend class __bit_iterator<__bitset, false>;
    friend class __bit_iterator<__bitset, true>;
    friend struct __bit_array<__bitset>;

    __storage_type __first_[_N_words];

    typedef __bit_reference<__bitset> reference;
    typedef __bit_const_reference<__bitset> const_reference;
    typedef __bit_iterator<__bitset, false> iterator;
    typedef __bit_iterator<__bitset, true> const_iterator;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    constexpr __bitset() noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit constexpr __bitset(unsigned long long __v) noexcept;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) reference __make_ref(size_t __pos) noexcept
        {return reference(__first_ + __pos / __bits_per_word, __storage_type(1) << __pos % __bits_per_word);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr const_reference __make_ref(size_t __pos) const noexcept
        {return const_reference(__first_ + __pos / __bits_per_word, __storage_type(1) << __pos % __bits_per_word);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) iterator __make_iter(size_t __pos) noexcept
        {return iterator(__first_ + __pos / __bits_per_word, __pos % __bits_per_word);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) const_iterator __make_iter(size_t __pos) const noexcept
        {return const_iterator(__first_ + __pos / __bits_per_word, __pos % __bits_per_word);}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void operator&=(const __bitset& __v) noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void operator|=(const __bitset& __v) noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void operator^=(const __bitset& __v) noexcept;

    void flip() noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) unsigned long to_ulong() const
        {return to_ulong(integral_constant<bool, _Size < sizeof(unsigned long) * 8>());}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) unsigned long long to_ullong() const
        {return to_ullong(integral_constant<bool, _Size < sizeof(unsigned long long) * 8>());}

    bool all() const noexcept;
    bool any() const noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_t __hash_code() const noexcept;
private:





    unsigned long to_ulong(false_type) const;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    unsigned long to_ulong(true_type) const;
    unsigned long long to_ullong(false_type) const;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    unsigned long long to_ullong(true_type) const;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    unsigned long long to_ullong(true_type, false_type) const;
    unsigned long long to_ullong(true_type, true_type) const;
};

template <size_t _N_words, size_t _Size>
inline
constexpr
__bitset<_N_words, _Size>::__bitset() noexcept

    : __first_{0}

{



}
# 263 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/bitset" 3
template <size_t _N_words, size_t _Size>
inline
constexpr
__bitset<_N_words, _Size>::__bitset(unsigned long long __v) noexcept


    : __first_{__v}
# 278 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/bitset" 3
{



}

template <size_t _N_words, size_t _Size>
inline
void
__bitset<_N_words, _Size>::operator&=(const __bitset& __v) noexcept
{
    for (size_type __i = 0; __i < _N_words; ++__i)
        __first_[__i] &= __v.__first_[__i];
}

template <size_t _N_words, size_t _Size>
inline
void
__bitset<_N_words, _Size>::operator|=(const __bitset& __v) noexcept
{
    for (size_type __i = 0; __i < _N_words; ++__i)
        __first_[__i] |= __v.__first_[__i];
}

template <size_t _N_words, size_t _Size>
inline
void
__bitset<_N_words, _Size>::operator^=(const __bitset& __v) noexcept
{
    for (size_type __i = 0; __i < _N_words; ++__i)
        __first_[__i] ^= __v.__first_[__i];
}

template <size_t _N_words, size_t _Size>
void
__bitset<_N_words, _Size>::flip() noexcept
{

    size_type __n = _Size;
    __storage_pointer __p = __first_;
    for (; __n >= __bits_per_word; ++__p, __n -= __bits_per_word)
        *__p = ~*__p;

    if (__n > 0)
    {
        __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
        __storage_type __b = *__p & __m;
        *__p &= ~__m;
        *__p |= ~__b & __m;
    }
}

template <size_t _N_words, size_t _Size>
unsigned long
__bitset<_N_words, _Size>::to_ulong(false_type) const
{
    const_iterator __e = __make_iter(_Size);
    const_iterator __i = std::__1::find(__make_iter(sizeof(unsigned long) * 8), __e, true);
    if (__i != __e)
        __throw_overflow_error("bitset to_ulong overflow error");

    return __first_[0];
}

template <size_t _N_words, size_t _Size>
inline
unsigned long
__bitset<_N_words, _Size>::to_ulong(true_type) const
{
    return __first_[0];
}

template <size_t _N_words, size_t _Size>
unsigned long long
__bitset<_N_words, _Size>::to_ullong(false_type) const
{
    const_iterator __e = __make_iter(_Size);
    const_iterator __i = std::__1::find(__make_iter(sizeof(unsigned long long) * 8), __e, true);
    if (__i != __e)
        __throw_overflow_error("bitset to_ullong overflow error");

    return to_ullong(true_type());
}

template <size_t _N_words, size_t _Size>
inline
unsigned long long
__bitset<_N_words, _Size>::to_ullong(true_type) const
{
    return to_ullong(true_type(), integral_constant<bool, sizeof(__storage_type) < sizeof(unsigned long long)>());
}

template <size_t _N_words, size_t _Size>
inline
unsigned long long
__bitset<_N_words, _Size>::to_ullong(true_type, false_type) const
{
    return __first_[0];
}

template <size_t _N_words, size_t _Size>
unsigned long long
__bitset<_N_words, _Size>::to_ullong(true_type, true_type) const
{
    unsigned long long __r = __first_[0];
    for (size_t __i = 1; __i < sizeof(unsigned long long) / sizeof(__storage_type); ++__i)
        __r |= static_cast<unsigned long long>(__first_[__i]) << (sizeof(__storage_type) * 8);
    return __r;
}

template <size_t _N_words, size_t _Size>
bool
__bitset<_N_words, _Size>::all() const noexcept
{

    size_type __n = _Size;
    __const_storage_pointer __p = __first_;
    for (; __n >= __bits_per_word; ++__p, __n -= __bits_per_word)
        if (~*__p)
            return false;

    if (__n > 0)
    {
        __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
        if (~*__p & __m)
            return false;
    }
    return true;
}

template <size_t _N_words, size_t _Size>
bool
__bitset<_N_words, _Size>::any() const noexcept
{

    size_type __n = _Size;
    __const_storage_pointer __p = __first_;
    for (; __n >= __bits_per_word; ++__p, __n -= __bits_per_word)
        if (*__p)
            return true;

    if (__n > 0)
    {
        __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
        if (*__p & __m)
            return true;
    }
    return false;
}

template <size_t _N_words, size_t _Size>
inline
size_t
__bitset<_N_words, _Size>::__hash_code() const noexcept
{
    size_t __h = 0;
    for (size_type __i = 0; __i < _N_words; ++__i)
        __h ^= __first_[__i];
    return __h;
}

template <size_t _Size>
class __bitset<1, _Size>
{
public:
    typedef ptrdiff_t difference_type;
    typedef size_t size_type;
    typedef size_type __storage_type;
protected:
    typedef __bitset __self;
    typedef __storage_type* __storage_pointer;
    typedef const __storage_type* __const_storage_pointer;
    static const unsigned __bits_per_word = static_cast<unsigned>(sizeof(__storage_type) * 8);

    friend class __bit_reference<__bitset>;
    friend class __bit_const_reference<__bitset>;
    friend class __bit_iterator<__bitset, false>;
    friend class __bit_iterator<__bitset, true>;
    friend struct __bit_array<__bitset>;

    __storage_type __first_;

    typedef __bit_reference<__bitset> reference;
    typedef __bit_const_reference<__bitset> const_reference;
    typedef __bit_iterator<__bitset, false> iterator;
    typedef __bit_iterator<__bitset, true> const_iterator;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    constexpr __bitset() noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit constexpr __bitset(unsigned long long __v) noexcept;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) reference __make_ref(size_t __pos) noexcept
        {return reference(&__first_, __storage_type(1) << __pos);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr const_reference __make_ref(size_t __pos) const noexcept
        {return const_reference(&__first_, __storage_type(1) << __pos);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) iterator __make_iter(size_t __pos) noexcept
        {return iterator(&__first_ + __pos / __bits_per_word, __pos % __bits_per_word);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) const_iterator __make_iter(size_t __pos) const noexcept
        {return const_iterator(&__first_ + __pos / __bits_per_word, __pos % __bits_per_word);}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void operator&=(const __bitset& __v) noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void operator|=(const __bitset& __v) noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void operator^=(const __bitset& __v) noexcept;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void flip() noexcept;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    unsigned long to_ulong() const;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    unsigned long long to_ullong() const;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    bool all() const noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    bool any() const noexcept;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_t __hash_code() const noexcept;
};

template <size_t _Size>
inline
constexpr
__bitset<1, _Size>::__bitset() noexcept
    : __first_(0)
{
}

template <size_t _Size>
inline
constexpr
__bitset<1, _Size>::__bitset(unsigned long long __v) noexcept
    : __first_(
        _Size == __bits_per_word ? static_cast<__storage_type>(__v)
                                 : static_cast<__storage_type>(__v) & ((__storage_type(1) << _Size) - 1)
    )
{
}

template <size_t _Size>
inline
void
__bitset<1, _Size>::operator&=(const __bitset& __v) noexcept
{
    __first_ &= __v.__first_;
}

template <size_t _Size>
inline
void
__bitset<1, _Size>::operator|=(const __bitset& __v) noexcept
{
    __first_ |= __v.__first_;
}

template <size_t _Size>
inline
void
__bitset<1, _Size>::operator^=(const __bitset& __v) noexcept
{
    __first_ ^= __v.__first_;
}

template <size_t _Size>
inline
void
__bitset<1, _Size>::flip() noexcept
{
    __storage_type __m = ~__storage_type(0) >> (__bits_per_word - _Size);
    __first_ = ~__first_;
    __first_ &= __m;
}

template <size_t _Size>
inline
unsigned long
__bitset<1, _Size>::to_ulong() const
{
    return __first_;
}

template <size_t _Size>
inline
unsigned long long
__bitset<1, _Size>::to_ullong() const
{
    return __first_;
}

template <size_t _Size>
inline
bool
__bitset<1, _Size>::all() const noexcept
{
    __storage_type __m = ~__storage_type(0) >> (__bits_per_word - _Size);
    return !(~__first_ & __m);
}

template <size_t _Size>
inline
bool
__bitset<1, _Size>::any() const noexcept
{
    __storage_type __m = ~__storage_type(0) >> (__bits_per_word - _Size);
    return __first_ & __m;
}

template <size_t _Size>
inline
size_t
__bitset<1, _Size>::__hash_code() const noexcept
{
    return __first_;
}

template <>
class __bitset<0, 0>
{
public:
    typedef ptrdiff_t difference_type;
    typedef size_t size_type;
    typedef size_type __storage_type;
protected:
    typedef __bitset __self;
    typedef __storage_type* __storage_pointer;
    typedef const __storage_type* __const_storage_pointer;
    static const unsigned __bits_per_word = static_cast<unsigned>(sizeof(__storage_type) * 8);

    friend class __bit_reference<__bitset>;
    friend class __bit_const_reference<__bitset>;
    friend class __bit_iterator<__bitset, false>;
    friend class __bit_iterator<__bitset, true>;
    friend struct __bit_array<__bitset>;

    typedef __bit_reference<__bitset> reference;
    typedef __bit_const_reference<__bitset> const_reference;
    typedef __bit_iterator<__bitset, false> iterator;
    typedef __bit_iterator<__bitset, true> const_iterator;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    constexpr __bitset() noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit constexpr __bitset(unsigned long long) noexcept;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) reference __make_ref(size_t) noexcept
        {return reference(nullptr, 1);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr const_reference __make_ref(size_t) const noexcept
        {return const_reference(nullptr, 1);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) iterator __make_iter(size_t) noexcept
        {return iterator(nullptr, 0);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) const_iterator __make_iter(size_t) const noexcept
        {return const_iterator(nullptr, 0);}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) void operator&=(const __bitset&) noexcept {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) void operator|=(const __bitset&) noexcept {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) void operator^=(const __bitset&) noexcept {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) void flip() noexcept {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) unsigned long to_ulong() const {return 0;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) unsigned long long to_ullong() const {return 0;}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) bool all() const noexcept {return true;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) bool any() const noexcept {return false;}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) size_t __hash_code() const noexcept {return 0;}
};

inline
constexpr
__bitset<0, 0>::__bitset() noexcept
{
}

inline
constexpr
__bitset<0, 0>::__bitset(unsigned long long) noexcept
{
}

template <size_t _Size> class __attribute__ ((__type_visibility__("default"))) bitset;
template <size_t _Size> struct hash<bitset<_Size> >;

template <size_t _Size>
class __attribute__ ((__type_visibility__("default"))) bitset
    : private __bitset<_Size == 0 ? 0 : (_Size - 1) / (sizeof(size_t) * 8) + 1, _Size>
{
public:
    static const unsigned __n_words = _Size == 0 ? 0 : (_Size - 1) / (sizeof(size_t) * 8) + 1;
    typedef __bitset<__n_words, _Size> base;

public:
    typedef typename base::reference reference;
    typedef typename base::const_reference const_reference;


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr bitset() noexcept {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
        bitset(unsigned long long __v) noexcept : base(__v) {}
    template<class _CharT, class = _EnableIf<_IsCharLikeType<_CharT>::value> >
        explicit bitset(const _CharT* __str,
                        typename basic_string<_CharT>::size_type __n = basic_string<_CharT>::npos,
                        _CharT __zero = _CharT('0'), _CharT __one = _CharT('1'));
    template<class _CharT, class _Traits, class _Allocator>
        explicit bitset(const basic_string<_CharT,_Traits,_Allocator>& __str,
                        typename basic_string<_CharT,_Traits,_Allocator>::size_type __pos = 0,
                        typename basic_string<_CharT,_Traits,_Allocator>::size_type __n =
                                (basic_string<_CharT,_Traits,_Allocator>::npos),
                        _CharT __zero = _CharT('0'), _CharT __one = _CharT('1'));


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    bitset& operator&=(const bitset& __rhs) noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    bitset& operator|=(const bitset& __rhs) noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    bitset& operator^=(const bitset& __rhs) noexcept;
    bitset& operator<<=(size_t __pos) noexcept;
    bitset& operator>>=(size_t __pos) noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    bitset& set() noexcept;
    bitset& set(size_t __pos, bool __val = true);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    bitset& reset() noexcept;
    bitset& reset(size_t __pos);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    bitset operator~() const noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    bitset& flip() noexcept;
    bitset& flip(size_t __pos);


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
                              const_reference operator[](size_t __p) const {return base::__make_ref(__p);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) reference operator[](size_t __p) {return base::__make_ref(__p);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    unsigned long to_ulong() const;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    unsigned long long to_ullong() const;
    template <class _CharT, class _Traits, class _Allocator>
        basic_string<_CharT, _Traits, _Allocator> to_string(_CharT __zero = _CharT('0'),
                                                            _CharT __one = _CharT('1')) const;
    template <class _CharT, class _Traits>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        basic_string<_CharT, _Traits, allocator<_CharT> > to_string(_CharT __zero = _CharT('0'),
                                                                    _CharT __one = _CharT('1')) const;
    template <class _CharT>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        basic_string<_CharT, char_traits<_CharT>, allocator<_CharT> > to_string(_CharT __zero = _CharT('0'),
                                                                                _CharT __one = _CharT('1')) const;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    basic_string<char, char_traits<char>, allocator<char> > to_string(char __zero = '0',
                                                                      char __one = '1') const;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_t count() const noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr size_t size() const noexcept {return _Size;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    bool operator==(const bitset& __rhs) const noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    bool operator!=(const bitset& __rhs) const noexcept;
    bool test(size_t __pos) const;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    bool all() const noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    bool any() const noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) bool none() const noexcept {return !any();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    bitset operator<<(size_t __pos) const noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    bitset operator>>(size_t __pos) const noexcept;

private:

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_t __hash_code() const noexcept {return base::__hash_code();}

    friend struct hash<bitset>;
};

template <size_t _Size>
template<class _CharT, class>
bitset<_Size>::bitset(const _CharT* __str,
                      typename basic_string<_CharT>::size_type __n,
                      _CharT __zero, _CharT __one)
{
    size_t __rlen = std::__1::min(__n, char_traits<_CharT>::length(__str));
    for (size_t __i = 0; __i < __rlen; ++__i)
        if (__str[__i] != __zero && __str[__i] != __one)
            __throw_invalid_argument("bitset string ctor has invalid argument");

    size_t _Mp = std::__1::min(__rlen, _Size);
    size_t __i = 0;
    for (; __i < _Mp; ++__i)
    {
        _CharT __c = __str[_Mp - 1 - __i];
        (*this)[__i] = (__c == __one);
    }
    std::__1::fill(base::__make_iter(__i), base::__make_iter(_Size), false);
}

template <size_t _Size>
template<class _CharT, class _Traits, class _Allocator>
bitset<_Size>::bitset(const basic_string<_CharT,_Traits,_Allocator>& __str,
       typename basic_string<_CharT,_Traits,_Allocator>::size_type __pos,
       typename basic_string<_CharT,_Traits,_Allocator>::size_type __n,
       _CharT __zero, _CharT __one)
{
    if (__pos > __str.size())
        __throw_out_of_range("bitset string pos out of range");

    size_t __rlen = std::__1::min(__n, __str.size() - __pos);
    for (size_t __i = __pos; __i < __pos + __rlen; ++__i)
        if (!_Traits::eq(__str[__i], __zero) && !_Traits::eq(__str[__i], __one))
            __throw_invalid_argument("bitset string ctor has invalid argument");

    size_t _Mp = std::__1::min(__rlen, _Size);
    size_t __i = 0;
    for (; __i < _Mp; ++__i)
    {
        _CharT __c = __str[__pos + _Mp - 1 - __i];
        (*this)[__i] = _Traits::eq(__c, __one);
    }
    std::__1::fill(base::__make_iter(__i), base::__make_iter(_Size), false);
}

template <size_t _Size>
inline
bitset<_Size>&
bitset<_Size>::operator&=(const bitset& __rhs) noexcept
{
    base::operator&=(__rhs);
    return *this;
}

template <size_t _Size>
inline
bitset<_Size>&
bitset<_Size>::operator|=(const bitset& __rhs) noexcept
{
    base::operator|=(__rhs);
    return *this;
}

template <size_t _Size>
inline
bitset<_Size>&
bitset<_Size>::operator^=(const bitset& __rhs) noexcept
{
    base::operator^=(__rhs);
    return *this;
}

template <size_t _Size>
bitset<_Size>&
bitset<_Size>::operator<<=(size_t __pos) noexcept
{
    __pos = std::__1::min(__pos, _Size);
    std::__1::copy_backward(base::__make_iter(0), base::__make_iter(_Size - __pos), base::__make_iter(_Size));
    std::__1::fill_n(base::__make_iter(0), __pos, false);
    return *this;
}

template <size_t _Size>
bitset<_Size>&
bitset<_Size>::operator>>=(size_t __pos) noexcept
{
    __pos = std::__1::min(__pos, _Size);
    std::__1::copy(base::__make_iter(__pos), base::__make_iter(_Size), base::__make_iter(0));
    std::__1::fill_n(base::__make_iter(_Size - __pos), __pos, false);
    return *this;
}

template <size_t _Size>
inline
bitset<_Size>&
bitset<_Size>::set() noexcept
{
    std::__1::fill_n(base::__make_iter(0), _Size, true);
    return *this;
}

template <size_t _Size>
bitset<_Size>&
bitset<_Size>::set(size_t __pos, bool __val)
{
    if (__pos >= _Size)
        __throw_out_of_range("bitset set argument out of range");

    (*this)[__pos] = __val;
    return *this;
}

template <size_t _Size>
inline
bitset<_Size>&
bitset<_Size>::reset() noexcept
{
    std::__1::fill_n(base::__make_iter(0), _Size, false);
    return *this;
}

template <size_t _Size>
bitset<_Size>&
bitset<_Size>::reset(size_t __pos)
{
    if (__pos >= _Size)
        __throw_out_of_range("bitset reset argument out of range");

    (*this)[__pos] = false;
    return *this;
}

template <size_t _Size>
inline
bitset<_Size>
bitset<_Size>::operator~() const noexcept
{
    bitset __x(*this);
    __x.flip();
    return __x;
}

template <size_t _Size>
inline
bitset<_Size>&
bitset<_Size>::flip() noexcept
{
    base::flip();
    return *this;
}

template <size_t _Size>
bitset<_Size>&
bitset<_Size>::flip(size_t __pos)
{
    if (__pos >= _Size)
        __throw_out_of_range("bitset flip argument out of range");

    reference r = base::__make_ref(__pos);
    r = ~r;
    return *this;
}

template <size_t _Size>
inline
unsigned long
bitset<_Size>::to_ulong() const
{
    return base::to_ulong();
}

template <size_t _Size>
inline
unsigned long long
bitset<_Size>::to_ullong() const
{
    return base::to_ullong();
}

template <size_t _Size>
template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>
bitset<_Size>::to_string(_CharT __zero, _CharT __one) const
{
    basic_string<_CharT, _Traits, _Allocator> __r(_Size, __zero);
    for (size_t __i = 0; __i < _Size; ++__i)
    {
        if ((*this)[__i])
            __r[_Size - 1 - __i] = __one;
    }
    return __r;
}

template <size_t _Size>
template <class _CharT, class _Traits>
inline
basic_string<_CharT, _Traits, allocator<_CharT> >
bitset<_Size>::to_string(_CharT __zero, _CharT __one) const
{
    return to_string<_CharT, _Traits, allocator<_CharT> >(__zero, __one);
}

template <size_t _Size>
template <class _CharT>
inline
basic_string<_CharT, char_traits<_CharT>, allocator<_CharT> >
bitset<_Size>::to_string(_CharT __zero, _CharT __one) const
{
    return to_string<_CharT, char_traits<_CharT>, allocator<_CharT> >(__zero, __one);
}

template <size_t _Size>
inline
basic_string<char, char_traits<char>, allocator<char> >
bitset<_Size>::to_string(char __zero, char __one) const
{
    return to_string<char, char_traits<char>, allocator<char> >(__zero, __one);
}

template <size_t _Size>
inline
size_t
bitset<_Size>::count() const noexcept
{
    return static_cast<size_t>(std::__1::__count_bool_true(base::__make_iter(0), _Size));
}

template <size_t _Size>
inline
bool
bitset<_Size>::operator==(const bitset& __rhs) const noexcept
{
    return std::__1::equal(base::__make_iter(0), base::__make_iter(_Size), __rhs.__make_iter(0));
}

template <size_t _Size>
inline
bool
bitset<_Size>::operator!=(const bitset& __rhs) const noexcept
{
    return !(*this == __rhs);
}

template <size_t _Size>
bool
bitset<_Size>::test(size_t __pos) const
{
    if (__pos >= _Size)
        __throw_out_of_range("bitset test argument out of range");

    return (*this)[__pos];
}

template <size_t _Size>
inline
bool
bitset<_Size>::all() const noexcept
{
    return base::all();
}

template <size_t _Size>
inline
bool
bitset<_Size>::any() const noexcept
{
    return base::any();
}

template <size_t _Size>
inline
bitset<_Size>
bitset<_Size>::operator<<(size_t __pos) const noexcept
{
    bitset __r = *this;
    __r <<= __pos;
    return __r;
}

template <size_t _Size>
inline
bitset<_Size>
bitset<_Size>::operator>>(size_t __pos) const noexcept
{
    bitset __r = *this;
    __r >>= __pos;
    return __r;
}

template <size_t _Size>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bitset<_Size>
operator&(const bitset<_Size>& __x, const bitset<_Size>& __y) noexcept
{
    bitset<_Size> __r = __x;
    __r &= __y;
    return __r;
}

template <size_t _Size>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bitset<_Size>
operator|(const bitset<_Size>& __x, const bitset<_Size>& __y) noexcept
{
    bitset<_Size> __r = __x;
    __r |= __y;
    return __r;
}

template <size_t _Size>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bitset<_Size>
operator^(const bitset<_Size>& __x, const bitset<_Size>& __y) noexcept
{
    bitset<_Size> __r = __x;
    __r ^= __y;
    return __r;
}

template <size_t _Size>
struct __attribute__ ((__type_visibility__("default"))) hash<bitset<_Size> >
    : public unary_function<bitset<_Size>, size_t>
{
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_t operator()(const bitset<_Size>& __bs) const noexcept
        {return __bs.__hash_code();}
};

template <class _CharT, class _Traits, size_t _Size>
basic_istream<_CharT, _Traits>&
operator>>(basic_istream<_CharT, _Traits>& __is, bitset<_Size>& __x);

template <class _CharT, class _Traits, size_t _Size>
basic_ostream<_CharT, _Traits>&
operator<<(basic_ostream<_CharT, _Traits>& __os, const bitset<_Size>& __x);

} }
# 138 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/ostream" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/ios" 1 3
# 214 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/ios" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__locale" 1 3
# 16 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__locale" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/memory" 1 3
# 974 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/memory" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 1 3
# 20 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/assert.h" 1 3 4
# 44 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/assert.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/stdlib.h" 1 3 4
# 45 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/assert.h" 2 3 4
# 81 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/assert.h" 3 4
extern "C" {
void __assert_rtn(const char *, const char *, int, const char *) __attribute__((__noreturn__)) __attribute__((__cold__)) __attribute__((__disable_tail_calls__));



}
# 21 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 2 3
# 24 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 3
# 975 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/memory" 2 3
# 17 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__locale" 2 3

# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/mutex" 1 3
# 190 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/mutex" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__mutex_base" 1 3
# 16 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__mutex_base" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/system_error" 1 3
# 146 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/system_error" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__errc" 1 3
# 108 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__errc" 3


namespace std { inline namespace __1 {





enum class __attribute__ ((__type_visibility__("default"))) errc
{
    address_family_not_supported = 47,
    address_in_use = 48,
    address_not_available = 49,
    already_connected = 56,
    argument_list_too_long = 7,
    argument_out_of_domain = 33,
    bad_address = 14,
    bad_file_descriptor = 9,
    bad_message = 94,
    broken_pipe = 32,
    connection_aborted = 53,
    connection_already_in_progress = 37,
    connection_refused = 61,
    connection_reset = 54,
    cross_device_link = 18,
    destination_address_required = 39,
    device_or_resource_busy = 16,
    directory_not_empty = 66,
    executable_format_error = 8,
    file_exists = 17,
    file_too_large = 27,
    filename_too_long = 63,
    function_not_supported = 78,
    host_unreachable = 65,
    identifier_removed = 90,
    illegal_byte_sequence = 92,
    inappropriate_io_control_operation = 25,
    interrupted = 4,
    invalid_argument = 22,
    invalid_seek = 29,
    io_error = 5,
    is_a_directory = 21,
    message_size = 40,
    network_down = 50,
    network_reset = 52,
    network_unreachable = 51,
    no_buffer_space = 55,
    no_child_process = 10,
    no_link = 97,
    no_lock_available = 77,

    no_message_available = 96,



    no_message = 91,
    no_protocol_option = 42,
    no_space_on_device = 28,

    no_stream_resources = 98,



    no_such_device_or_address = 6,
    no_such_device = 19,
    no_such_file_or_directory = 2,
    no_such_process = 3,
    not_a_directory = 20,
    not_a_socket = 38,

    not_a_stream = 99,



    not_connected = 57,
    not_enough_memory = 12,
    not_supported = 45,
    operation_canceled = 89,
    operation_in_progress = 36,
    operation_not_permitted = 1,
    operation_not_supported = 102,
    operation_would_block = 35,
    owner_dead = 105,
    permission_denied = 13,
    protocol_error = 100,
    protocol_not_supported = 43,
    read_only_file_system = 30,
    resource_deadlock_would_occur = 11,
    resource_unavailable_try_again = 35,
    result_out_of_range = 34,
    state_not_recoverable = 104,

    stream_timeout = 101,



    text_file_busy = 26,
    timed_out = 60,
    too_many_files_open_in_system = 23,
    too_many_files_open = 24,
    too_many_links = 31,
    too_many_symbolic_link_levels = 62,
    value_too_large = 84,
    wrong_protocol_type = 41
};


} }
# 147 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/system_error" 2 3





# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 1 3
# 153 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/system_error" 2 3
# 156 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/system_error" 3


namespace std { inline namespace __1 {



template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) is_error_code_enum
    : public false_type {};


template <class _Tp>
inline constexpr size_t is_error_code_enum_v = is_error_code_enum<_Tp>::value;




template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) is_error_condition_enum
    : public false_type {};


template <class _Tp>
inline constexpr size_t is_error_condition_enum_v = is_error_condition_enum<_Tp>::value;


template <>
struct __attribute__ ((__type_visibility__("default"))) is_error_condition_enum<errc>
    : true_type { };







class __attribute__ ((__visibility__("default"))) error_condition;
class __attribute__ ((__visibility__("default"))) error_code;



class __attribute__ ((__visibility__("hidden"))) __do_message;

class __attribute__ ((__visibility__("default"))) error_category
{
public:
    virtual ~error_category() noexcept;





    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    constexpr error_category() noexcept = default;

private:
    error_category(const error_category&);
    error_category& operator=(const error_category&);

public:
    virtual const char* name() const noexcept = 0;
    virtual error_condition default_error_condition(int __ev) const noexcept;
    virtual bool equivalent(int __code, const error_condition& __condition) const noexcept;
    virtual bool equivalent(const error_code& __code, int __condition) const noexcept;
    virtual string message(int __ev) const = 0;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    bool operator==(const error_category& __rhs) const noexcept {return this == &__rhs;}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    bool operator!=(const error_category& __rhs) const noexcept {return !(*this == __rhs);}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    bool operator< (const error_category& __rhs) const noexcept {return this < &__rhs;}

    friend class __attribute__ ((__visibility__("hidden"))) __do_message;
};

class __attribute__ ((__visibility__("hidden"))) __do_message
    : public error_category
{
public:
    virtual string message(int ev) const;
};

__attribute__ ((__visibility__("default"))) const error_category& generic_category() noexcept;
__attribute__ ((__visibility__("default"))) const error_category& system_category() noexcept;

class __attribute__ ((__visibility__("default"))) error_condition
{
    int __val_;
    const error_category* __cat_;
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    error_condition() noexcept : __val_(0), __cat_(&generic_category()) {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    error_condition(int __val, const error_category& __cat) noexcept
        : __val_(__val), __cat_(&__cat) {}

    template <class _Ep>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        error_condition(_Ep __e,
              typename enable_if<is_error_condition_enum<_Ep>::value>::type* = nullptr
                                                                     ) noexcept
            {*this = make_error_condition(__e);}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void assign(int __val, const error_category& __cat) noexcept
    {
        __val_ = __val;
        __cat_ = &__cat;
    }

    template <class _Ep>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        typename enable_if
        <
            is_error_condition_enum<_Ep>::value,
            error_condition&
        >::type
        operator=(_Ep __e) noexcept
            {*this = make_error_condition(__e); return *this;}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void clear() noexcept
    {
        __val_ = 0;
        __cat_ = &generic_category();
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    int value() const noexcept {return __val_;}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const error_category& category() const noexcept {return *__cat_;}
    string message() const;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit operator bool() const noexcept {return __val_ != 0;}
};

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
error_condition
make_error_condition(errc __e) noexcept
{
    return error_condition(static_cast<int>(__e), generic_category());
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator<(const error_condition& __x, const error_condition& __y) noexcept
{
    return __x.category() < __y.category()
        || (__x.category() == __y.category() && __x.value() < __y.value());
}



class __attribute__ ((__visibility__("default"))) error_code
{
    int __val_;
    const error_category* __cat_;
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    error_code() noexcept : __val_(0), __cat_(&system_category()) {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    error_code(int __val, const error_category& __cat) noexcept
        : __val_(__val), __cat_(&__cat) {}

    template <class _Ep>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        error_code(_Ep __e,
                   typename enable_if<is_error_code_enum<_Ep>::value>::type* = nullptr
                                                                     ) noexcept
            {*this = make_error_code(__e);}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void assign(int __val, const error_category& __cat) noexcept
    {
        __val_ = __val;
        __cat_ = &__cat;
    }

    template <class _Ep>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        typename enable_if
        <
            is_error_code_enum<_Ep>::value,
            error_code&
        >::type
        operator=(_Ep __e) noexcept
            {*this = make_error_code(__e); return *this;}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void clear() noexcept
    {
        __val_ = 0;
        __cat_ = &system_category();
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    int value() const noexcept {return __val_;}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const error_category& category() const noexcept {return *__cat_;}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    error_condition default_error_condition() const noexcept
        {return __cat_->default_error_condition(__val_);}

    string message() const;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit operator bool() const noexcept {return __val_ != 0;}
};

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
error_code
make_error_code(errc __e) noexcept
{
    return error_code(static_cast<int>(__e), generic_category());
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator<(const error_code& __x, const error_code& __y) noexcept
{
    return __x.category() < __y.category()
        || (__x.category() == __y.category() && __x.value() < __y.value());
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator==(const error_code& __x, const error_code& __y) noexcept
{
    return __x.category() == __y.category() && __x.value() == __y.value();
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator==(const error_code& __x, const error_condition& __y) noexcept
{
    return __x.category().equivalent(__x.value(), __y)
        || __y.category().equivalent(__x, __y.value());
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator==(const error_condition& __x, const error_code& __y) noexcept
{
    return __y == __x;
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator==(const error_condition& __x, const error_condition& __y) noexcept
{
    return __x.category() == __y.category() && __x.value() == __y.value();
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator!=(const error_code& __x, const error_code& __y) noexcept
{return !(__x == __y);}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator!=(const error_code& __x, const error_condition& __y) noexcept
{return !(__x == __y);}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator!=(const error_condition& __x, const error_code& __y) noexcept
{return !(__x == __y);}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator!=(const error_condition& __x, const error_condition& __y) noexcept
{return !(__x == __y);}

template <>
struct __attribute__ ((__type_visibility__("default"))) hash<error_code>
    : public unary_function<error_code, size_t>
{
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_t operator()(const error_code& __ec) const noexcept
    {
        return static_cast<size_t>(__ec.value());
    }
};

template <>
struct __attribute__ ((__type_visibility__("default"))) hash<error_condition>
    : public unary_function<error_condition, size_t>
{
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_t operator()(const error_condition& __ec) const noexcept
    {
        return static_cast<size_t>(__ec.value());
    }
};



class __attribute__ ((__visibility__("default"))) system_error
    : public runtime_error
{
    error_code __ec_;
public:
    system_error(error_code __ec, const string& __what_arg);
    system_error(error_code __ec, const char* __what_arg);
    system_error(error_code __ec);
    system_error(int __ev, const error_category& __ecat, const string& __what_arg);
    system_error(int __ev, const error_category& __ecat, const char* __what_arg);
    system_error(int __ev, const error_category& __ecat);
    system_error(const system_error&) noexcept = default;
    ~system_error() noexcept;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const error_code& code() const noexcept {return __ec_;}

private:
    static string __init(const error_code&, string);
};

[[noreturn]] __attribute__ ((__visibility__("default")))
void __throw_system_error(int ev, const char* what_arg);

} }
# 17 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__mutex_base" 2 3
# 21 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__mutex_base" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 25 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__mutex_base" 2 3


namespace std { inline namespace __1 {



class __attribute__ ((__visibility__("default"))) mutex
{
    __libcpp_mutex_t __m_ = {0x32AAABA7, {0}};

public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    constexpr mutex() = default;

    mutex(const mutex&) = delete;
    mutex& operator=(const mutex&) = delete;




    ~mutex() noexcept;


    void lock() ;
    bool try_lock() noexcept ;
    void unlock() noexcept ;

    typedef __libcpp_mutex_t* native_handle_type;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) native_handle_type native_handle() {return &__m_;}
};

static_assert(is_nothrow_default_constructible<mutex>::value,
              "the default constructor for std::mutex must be nothrow");

struct __attribute__ ((__visibility__("default"))) defer_lock_t { explicit defer_lock_t() = default; };
struct __attribute__ ((__visibility__("default"))) try_to_lock_t { explicit try_to_lock_t() = default; };
struct __attribute__ ((__visibility__("default"))) adopt_lock_t { explicit adopt_lock_t() = default; };
# 71 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__mutex_base" 3
                         constexpr defer_lock_t defer_lock = defer_lock_t();
                         constexpr try_to_lock_t try_to_lock = try_to_lock_t();
                         constexpr adopt_lock_t adopt_lock = adopt_lock_t();



template <class _Mutex>
class __attribute__ ((__type_visibility__("default")))
lock_guard
{
public:
    typedef _Mutex mutex_type;

private:
    mutex_type& __m_;
public:

                          __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit lock_guard(mutex_type& __m)
        : __m_(__m) {__m_.lock();}

                          __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    lock_guard(mutex_type& __m, adopt_lock_t)
        : __m_(__m) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    ~lock_guard() {__m_.unlock();}

private:
    lock_guard(lock_guard const&) = delete;
    lock_guard& operator=(lock_guard const&) = delete;
};

template <class _Mutex>
class __attribute__ ((__type_visibility__("default"))) unique_lock
{
public:
    typedef _Mutex mutex_type;

private:
    mutex_type* __m_;
    bool __owns_;

public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    unique_lock() noexcept : __m_(nullptr), __owns_(false) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit unique_lock(mutex_type& __m)
        : __m_(std::__1::addressof(__m)), __owns_(true) {__m_->lock();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    unique_lock(mutex_type& __m, defer_lock_t) noexcept
        : __m_(std::__1::addressof(__m)), __owns_(false) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    unique_lock(mutex_type& __m, try_to_lock_t)
        : __m_(std::__1::addressof(__m)), __owns_(__m.try_lock()) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    unique_lock(mutex_type& __m, adopt_lock_t)
        : __m_(std::__1::addressof(__m)), __owns_(true) {}
    template <class _Clock, class _Duration>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        unique_lock(mutex_type& __m, const chrono::time_point<_Clock, _Duration>& __t)
            : __m_(std::__1::addressof(__m)), __owns_(__m.try_lock_until(__t)) {}
    template <class _Rep, class _Period>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        unique_lock(mutex_type& __m, const chrono::duration<_Rep, _Period>& __d)
            : __m_(std::__1::addressof(__m)), __owns_(__m.try_lock_for(__d)) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    ~unique_lock()
    {
        if (__owns_)
            __m_->unlock();
    }

private:
    unique_lock(unique_lock const&);
    unique_lock& operator=(unique_lock const&);

public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    unique_lock(unique_lock&& __u) noexcept
        : __m_(__u.__m_), __owns_(__u.__owns_)
        {__u.__m_ = nullptr; __u.__owns_ = false;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    unique_lock& operator=(unique_lock&& __u) noexcept
        {
            if (__owns_)
                __m_->unlock();
            __m_ = __u.__m_;
            __owns_ = __u.__owns_;
            __u.__m_ = nullptr;
            __u.__owns_ = false;
            return *this;
        }

    void lock();
    bool try_lock();

    template <class _Rep, class _Period>
        bool try_lock_for(const chrono::duration<_Rep, _Period>& __d);
    template <class _Clock, class _Duration>
        bool try_lock_until(const chrono::time_point<_Clock, _Duration>& __t);

    void unlock();

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void swap(unique_lock& __u) noexcept
    {
        std::__1::swap(__m_, __u.__m_);
        std::__1::swap(__owns_, __u.__owns_);
    }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    mutex_type* release() noexcept
    {
        mutex_type* __m = __m_;
        __m_ = nullptr;
        __owns_ = false;
        return __m;
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    bool owns_lock() const noexcept {return __owns_;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit operator bool() const noexcept {return __owns_;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    mutex_type* mutex() const noexcept {return __m_;}
};

template <class _Mutex>
void
unique_lock<_Mutex>::lock()
{
    if (__m_ == nullptr)
        __throw_system_error(1, "unique_lock::lock: references null mutex");
    if (__owns_)
        __throw_system_error(11, "unique_lock::lock: already locked");
    __m_->lock();
    __owns_ = true;
}

template <class _Mutex>
bool
unique_lock<_Mutex>::try_lock()
{
    if (__m_ == nullptr)
        __throw_system_error(1, "unique_lock::try_lock: references null mutex");
    if (__owns_)
        __throw_system_error(11, "unique_lock::try_lock: already locked");
    __owns_ = __m_->try_lock();
    return __owns_;
}

template <class _Mutex>
template <class _Rep, class _Period>
bool
unique_lock<_Mutex>::try_lock_for(const chrono::duration<_Rep, _Period>& __d)
{
    if (__m_ == nullptr)
        __throw_system_error(1, "unique_lock::try_lock_for: references null mutex");
    if (__owns_)
        __throw_system_error(11, "unique_lock::try_lock_for: already locked");
    __owns_ = __m_->try_lock_for(__d);
    return __owns_;
}

template <class _Mutex>
template <class _Clock, class _Duration>
bool
unique_lock<_Mutex>::try_lock_until(const chrono::time_point<_Clock, _Duration>& __t)
{
    if (__m_ == nullptr)
        __throw_system_error(1, "unique_lock::try_lock_until: references null mutex");
    if (__owns_)
        __throw_system_error(11, "unique_lock::try_lock_until: already locked");
    __owns_ = __m_->try_lock_until(__t);
    return __owns_;
}

template <class _Mutex>
void
unique_lock<_Mutex>::unlock()
{
    if (!__owns_)
        __throw_system_error(1, "unique_lock::unlock: not locked");
    __m_->unlock();
    __owns_ = false;
}

template <class _Mutex>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void
swap(unique_lock<_Mutex>& __x, unique_lock<_Mutex>& __y) noexcept
    {__x.swap(__y);}


enum class __attribute__ ((__type_visibility__("default"))) cv_status
{
    no_timeout,
    timeout
};


class __attribute__ ((__visibility__("default"))) condition_variable
{
    __libcpp_condvar_t __cv_ = {0x3CB0B1BB, {0}};
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    constexpr condition_variable() noexcept = default;




    ~condition_variable();


    condition_variable(const condition_variable&) = delete;
    condition_variable& operator=(const condition_variable&) = delete;

    void notify_one() noexcept;
    void notify_all() noexcept;

    void wait(unique_lock<mutex>& __lk) noexcept;
    template <class _Predicate>
        inline __attribute__ ((__visibility__("hidden")))
        void wait(unique_lock<mutex>& __lk, _Predicate __pred);

    template <class _Clock, class _Duration>
        inline __attribute__ ((__visibility__("hidden")))
        cv_status
        wait_until(unique_lock<mutex>& __lk,
                   const chrono::time_point<_Clock, _Duration>& __t);

    template <class _Clock, class _Duration, class _Predicate>
        inline __attribute__ ((__visibility__("hidden")))
        bool
        wait_until(unique_lock<mutex>& __lk,
                   const chrono::time_point<_Clock, _Duration>& __t,
                   _Predicate __pred);

    template <class _Rep, class _Period>
        inline __attribute__ ((__visibility__("hidden")))
        cv_status
        wait_for(unique_lock<mutex>& __lk,
                 const chrono::duration<_Rep, _Period>& __d);

    template <class _Rep, class _Period, class _Predicate>
        bool
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        wait_for(unique_lock<mutex>& __lk,
                 const chrono::duration<_Rep, _Period>& __d,
                 _Predicate __pred);

    typedef __libcpp_condvar_t* native_handle_type;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) native_handle_type native_handle() {return &__cv_;}

private:
    void __do_timed_wait(unique_lock<mutex>& __lk,
       chrono::time_point<chrono::system_clock, chrono::nanoseconds>) noexcept;




    template <class _Clock>
    void __do_timed_wait(unique_lock<mutex>& __lk,
       chrono::time_point<_Clock, chrono::nanoseconds>) noexcept;
};


template <class _Rep, class _Period>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename enable_if
<
    is_floating_point<_Rep>::value,
    chrono::nanoseconds
>::type
__safe_nanosecond_cast(chrono::duration<_Rep, _Period> __d)
{
    using namespace chrono;
    using __ratio = ratio_divide<_Period, nano>;
    using __ns_rep = nanoseconds::rep;
    _Rep __result_float = __d.count() * __ratio::num / __ratio::den;

    _Rep __result_max = numeric_limits<__ns_rep>::max();
    if (__result_float >= __result_max) {
        return nanoseconds::max();
    }

    _Rep __result_min = numeric_limits<__ns_rep>::min();
    if (__result_float <= __result_min) {
        return nanoseconds::min();
    }

    return nanoseconds(static_cast<__ns_rep>(__result_float));
}

template <class _Rep, class _Period>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename enable_if
<
    !is_floating_point<_Rep>::value,
    chrono::nanoseconds
>::type
__safe_nanosecond_cast(chrono::duration<_Rep, _Period> __d)
{
    using namespace chrono;
    if (__d.count() == 0) {
        return nanoseconds(0);
    }

    using __ratio = ratio_divide<_Period, nano>;
    using __ns_rep = nanoseconds::rep;
    __ns_rep __result_max = numeric_limits<__ns_rep>::max();
    if (__d.count() > 0 && __d.count() > __result_max / __ratio::num) {
        return nanoseconds::max();
    }

    __ns_rep __result_min = numeric_limits<__ns_rep>::min();
    if (__d.count() < 0 && __d.count() < __result_min / __ratio::num) {
        return nanoseconds::min();
    }

    __ns_rep __result = __d.count() * __ratio::num / __ratio::den;
    if (__result == 0) {
        return nanoseconds(1);
    }

    return nanoseconds(__result);
}


template <class _Predicate>
void
condition_variable::wait(unique_lock<mutex>& __lk, _Predicate __pred)
{
    while (!__pred())
        wait(__lk);
}

template <class _Clock, class _Duration>
cv_status
condition_variable::wait_until(unique_lock<mutex>& __lk,
                               const chrono::time_point<_Clock, _Duration>& __t)
{
    using namespace chrono;
    using __clock_tp_ns = time_point<_Clock, nanoseconds>;

    typename _Clock::time_point __now = _Clock::now();
    if (__t <= __now)
        return cv_status::timeout;

    __clock_tp_ns __t_ns = __clock_tp_ns(std::__1::__safe_nanosecond_cast(__t.time_since_epoch()));

    __do_timed_wait(__lk, __t_ns);
    return _Clock::now() < __t ? cv_status::no_timeout : cv_status::timeout;
}

template <class _Clock, class _Duration, class _Predicate>
bool
condition_variable::wait_until(unique_lock<mutex>& __lk,
                   const chrono::time_point<_Clock, _Duration>& __t,
                   _Predicate __pred)
{
    while (!__pred())
    {
        if (wait_until(__lk, __t) == cv_status::timeout)
            return __pred();
    }
    return true;
}

template <class _Rep, class _Period>
cv_status
condition_variable::wait_for(unique_lock<mutex>& __lk,
                             const chrono::duration<_Rep, _Period>& __d)
{
    using namespace chrono;
    if (__d <= __d.zero())
        return cv_status::timeout;
    using __ns_rep = nanoseconds::rep;
    steady_clock::time_point __c_now = steady_clock::now();





    using __clock_tp_ns = time_point<system_clock, nanoseconds>;
    __ns_rep __now_count_ns = std::__1::__safe_nanosecond_cast(system_clock::now().time_since_epoch()).count();


    __ns_rep __d_ns_count = std::__1::__safe_nanosecond_cast(__d).count();

    if (__now_count_ns > numeric_limits<__ns_rep>::max() - __d_ns_count) {
        __do_timed_wait(__lk, __clock_tp_ns::max());
    } else {
        __do_timed_wait(__lk, __clock_tp_ns(nanoseconds(__now_count_ns + __d_ns_count)));
    }

    return steady_clock::now() - __c_now < __d ? cv_status::no_timeout :
                                                 cv_status::timeout;
}

template <class _Rep, class _Period, class _Predicate>
inline
bool
condition_variable::wait_for(unique_lock<mutex>& __lk,
                             const chrono::duration<_Rep, _Period>& __d,
                             _Predicate __pred)
{
    return wait_until(__lk, chrono::steady_clock::now() + __d,
                      std::__1::move(__pred));
}
# 512 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__mutex_base" 3
template <class _Clock>
inline
void
condition_variable::__do_timed_wait(unique_lock<mutex>& __lk,
     chrono::time_point<_Clock, chrono::nanoseconds> __tp) noexcept
{
    wait_for(__lk, __tp - _Clock::now());
}



} }
# 191 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/mutex" 2 3




# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/memory" 1 3
# 974 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/memory" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 1 3
# 20 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/assert.h" 1 3 4
# 44 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/assert.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/stdlib.h" 1 3 4
# 45 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/assert.h" 2 3 4
# 81 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/assert.h" 3 4
extern "C" {
void __assert_rtn(const char *, const char *, int, const char *) __attribute__((__noreturn__)) __attribute__((__cold__)) __attribute__((__disable_tail_calls__));



}
# 21 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 2 3
# 24 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 3
# 975 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/memory" 2 3
# 196 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/mutex" 2 3
# 203 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/mutex" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 207 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/mutex" 2 3


namespace std { inline namespace __1 {



class __attribute__ ((__visibility__("default"))) recursive_mutex
{
    __libcpp_recursive_mutex_t __m_;

public:
     recursive_mutex();
     ~recursive_mutex();

private:
    recursive_mutex(const recursive_mutex&);
    recursive_mutex& operator=(const recursive_mutex&);

public:
    void lock();
    bool try_lock() noexcept;
    void unlock() noexcept;

    typedef __libcpp_recursive_mutex_t* native_handle_type;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    native_handle_type native_handle() {return &__m_;}
};

class __attribute__ ((__visibility__("default"))) timed_mutex
{
    mutex __m_;
    condition_variable __cv_;
    bool __locked_;
public:
     timed_mutex();
     ~timed_mutex();

private:
    timed_mutex(const timed_mutex&);
    timed_mutex& operator=(const timed_mutex&);

public:
    void lock();
    bool try_lock() noexcept;
    template <class _Rep, class _Period>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        bool try_lock_for(const chrono::duration<_Rep, _Period>& __d)
            {return try_lock_until(chrono::steady_clock::now() + __d);}
    template <class _Clock, class _Duration>
        inline __attribute__ ((__visibility__("hidden")))
        bool try_lock_until(const chrono::time_point<_Clock, _Duration>& __t);
    void unlock() noexcept;
};

template <class _Clock, class _Duration>
bool
timed_mutex::try_lock_until(const chrono::time_point<_Clock, _Duration>& __t)
{
    using namespace chrono;
    unique_lock<mutex> __lk(__m_);
    bool no_timeout = _Clock::now() < __t;
    while (no_timeout && __locked_)
        no_timeout = __cv_.wait_until(__lk, __t) == cv_status::no_timeout;
    if (!__locked_)
    {
        __locked_ = true;
        return true;
    }
    return false;
}

class __attribute__ ((__visibility__("default"))) recursive_timed_mutex
{
    mutex __m_;
    condition_variable __cv_;
    size_t __count_;
    __thread_id __id_;
public:
     recursive_timed_mutex();
     ~recursive_timed_mutex();

private:
    recursive_timed_mutex(const recursive_timed_mutex&);
    recursive_timed_mutex& operator=(const recursive_timed_mutex&);

public:
    void lock();
    bool try_lock() noexcept;
    template <class _Rep, class _Period>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        bool try_lock_for(const chrono::duration<_Rep, _Period>& __d)
            {return try_lock_until(chrono::steady_clock::now() + __d);}
    template <class _Clock, class _Duration>
        inline __attribute__ ((__visibility__("hidden")))
        bool try_lock_until(const chrono::time_point<_Clock, _Duration>& __t);
    void unlock() noexcept;
};

template <class _Clock, class _Duration>
bool
recursive_timed_mutex::try_lock_until(const chrono::time_point<_Clock, _Duration>& __t)
{
    using namespace chrono;
    __thread_id __id = this_thread::get_id();
    unique_lock<mutex> lk(__m_);
    if (__id == __id_)
    {
        if (__count_ == numeric_limits<size_t>::max())
            return false;
        ++__count_;
        return true;
    }
    bool no_timeout = _Clock::now() < __t;
    while (no_timeout && __count_ != 0)
        no_timeout = __cv_.wait_until(lk, __t) == cv_status::no_timeout;
    if (__count_ == 0)
    {
        __count_ = 1;
        __id_ = __id;
        return true;
    }
    return false;
}

template <class _L0, class _L1>
int
try_lock(_L0& __l0, _L1& __l1)
{
    unique_lock<_L0> __u0(__l0, try_to_lock);
    if (__u0.owns_lock())
    {
        if (__l1.try_lock())
        {
            __u0.release();
            return -1;
        }
        else
            return 1;
    }
    return 0;
}



template <class _L0, class _L1, class _L2, class... _L3>
int
try_lock(_L0& __l0, _L1& __l1, _L2& __l2, _L3&... __l3)
{
    int __r = 0;
    unique_lock<_L0> __u0(__l0, try_to_lock);
    if (__u0.owns_lock())
    {
        __r = try_lock(__l1, __l2, __l3...);
        if (__r == -1)
            __u0.release();
        else
            ++__r;
    }
    return __r;
}



template <class _L0, class _L1>
void
lock(_L0& __l0, _L1& __l1)
{
    while (true)
    {
        {
            unique_lock<_L0> __u0(__l0);
            if (__l1.try_lock())
            {
                __u0.release();
                break;
            }
        }
        __libcpp_thread_yield();
        {
            unique_lock<_L1> __u1(__l1);
            if (__l0.try_lock())
            {
                __u1.release();
                break;
            }
        }
        __libcpp_thread_yield();
    }
}



template <class _L0, class _L1, class _L2, class ..._L3>
void
__lock_first(int __i, _L0& __l0, _L1& __l1, _L2& __l2, _L3& ...__l3)
{
    while (true)
    {
        switch (__i)
        {
        case 0:
            {
                unique_lock<_L0> __u0(__l0);
                __i = try_lock(__l1, __l2, __l3...);
                if (__i == -1)
                {
                    __u0.release();
                    return;
                }
            }
            ++__i;
            __libcpp_thread_yield();
            break;
        case 1:
            {
                unique_lock<_L1> __u1(__l1);
                __i = try_lock(__l2, __l3..., __l0);
                if (__i == -1)
                {
                    __u1.release();
                    return;
                }
            }
            if (__i == sizeof...(_L3) + 1)
                __i = 0;
            else
                __i += 2;
            __libcpp_thread_yield();
            break;
        default:
            __lock_first(__i - 2, __l2, __l3..., __l0, __l1);
            return;
        }
    }
}

template <class _L0, class _L1, class _L2, class ..._L3>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void
lock(_L0& __l0, _L1& __l1, _L2& __l2, _L3& ...__l3)
{
    __lock_first(0, __l0, __l1, __l2, __l3...);
}

template <class _L0>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void __unlock(_L0& __l0) {
    __l0.unlock();
}

template <class _L0, class _L1>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void __unlock(_L0& __l0, _L1& __l1) {
    __l0.unlock();
    __l1.unlock();
}

template <class _L0, class _L1, class _L2, class ..._L3>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void __unlock(_L0& __l0, _L1& __l1, _L2& __l2, _L3&... __l3) {
    __l0.unlock();
    __l1.unlock();
    std::__1::__unlock(__l2, __l3...);
}




template <class ..._Mutexes>
class __attribute__ ((__type_visibility__("default"))) scoped_lock;

template <>
class __attribute__ ((__type_visibility__("default"))) scoped_lock<> {
public:
    explicit scoped_lock() {}
    ~scoped_lock() = default;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit scoped_lock(adopt_lock_t) {}

    scoped_lock(scoped_lock const&) = delete;
    scoped_lock& operator=(scoped_lock const&) = delete;
};

template <class _Mutex>
class __attribute__ ((__type_visibility__("default"))) scoped_lock<_Mutex> {
public:
    typedef _Mutex mutex_type;
private:
    mutex_type& __m_;
public:
    explicit scoped_lock(mutex_type & __m)
        : __m_(__m) {__m_.lock();}

    ~scoped_lock() {__m_.unlock();}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit scoped_lock(adopt_lock_t, mutex_type& __m)
        : __m_(__m) {}

    scoped_lock(scoped_lock const&) = delete;
    scoped_lock& operator=(scoped_lock const&) = delete;
};

template <class ..._MArgs>
class __attribute__ ((__type_visibility__("default"))) scoped_lock
{
    static_assert(sizeof...(_MArgs) > 1, "At least 2 lock types required");
    typedef tuple<_MArgs&...> _MutexTuple;

public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit scoped_lock(_MArgs&... __margs)
      : __t_(__margs...)
    {
        std::__1::lock(__margs...);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    scoped_lock(adopt_lock_t, _MArgs&... __margs)
        : __t_(__margs...)
    {
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    ~scoped_lock() {
        typedef typename __make_tuple_indices<sizeof...(_MArgs)>::type _Indices;
        __unlock_unpack(_Indices{}, __t_);
    }

    scoped_lock(scoped_lock const&) = delete;
    scoped_lock& operator=(scoped_lock const&) = delete;

private:
    template <size_t ..._Indx>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    static void __unlock_unpack(__tuple_indices<_Indx...>, _MutexTuple& __mt) {
        std::__1::__unlock(std::__1::get<_Indx>(__mt)...);
    }

    _MutexTuple __t_;
};




struct __attribute__ ((__type_visibility__("default"))) once_flag;



template<class _Callable, class... _Args>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void call_once(once_flag&, _Callable&&, _Args&&...);
# 574 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/mutex" 3
struct __attribute__ ((__type_visibility__("default"))) once_flag
{
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    constexpr
        once_flag() noexcept : __state_(0) {}




   typedef unsigned long _State_type;



private:
    once_flag(const once_flag&);
    once_flag& operator=(const once_flag&);

    _State_type __state_;


    template<class _Callable, class... _Args>
    friend
    void call_once(once_flag&, _Callable&&, _Args&&...);
# 606 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/mutex" 3
};



template <class _Fp>
class __call_once_param
{
    _Fp& __f_;
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit __call_once_param(_Fp& __f) : __f_(__f) {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void operator()()
    {
        typedef typename __make_tuple_indices<tuple_size<_Fp>::value, 1>::type _Index;
        __execute(_Index());
    }

private:
    template <size_t ..._Indices>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void __execute(__tuple_indices<_Indices...>)
    {
        std::__1::__invoke(std::__1::get<0>(std::__1::move(__f_)), std::__1::get<_Indices>(std::__1::move(__f_))...);
    }
};
# 653 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/mutex" 3
template <class _Fp>
void __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
__call_once_proxy(void* __vp)
{
    __call_once_param<_Fp>* __p = static_cast<__call_once_param<_Fp>*>(__vp);
    (*__p)();
}

__attribute__ ((__visibility__("default"))) void __call_once(volatile once_flag::_State_type&, void*,
                                  void (*)(void*));



template<class _Callable, class... _Args>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void
call_once(once_flag& __flag, _Callable&& __func, _Args&&... __args)
{
    if (__libcpp_acquire_load(&__flag.__state_) != ~once_flag::_State_type(0))
    {
        typedef tuple<_Callable&&, _Args&&...> _Gp;
        _Gp __f(std::__1::forward<_Callable>(__func), std::__1::forward<_Args>(__args)...);
        __call_once_param<_Gp> __p(__f);
        __call_once(__flag.__state_, &__p, &__call_once_proxy<_Gp>);
    }
}
# 708 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/mutex" 3
} }
# 19 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__locale" 2 3
# 40 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__locale" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/xlocale.h" 1 3 4
# 34 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/xlocale.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/_xlocale.h" 1 3 4
# 29 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/_xlocale.h" 3 4
struct _xlocale;
typedef struct _xlocale * locale_t;

extern "C" {
int ___mb_cur_max(void);
int ___mb_cur_max_l(locale_t);
}
# 35 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/xlocale.h" 2 3 4
# 63 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/xlocale.h" 3 4
extern "C" {
extern const locale_t _c_locale;

locale_t duplocale(locale_t);
int freelocale(locale_t);
struct lconv * localeconv_l(locale_t);
locale_t newlocale(int, const char *, locale_t);
const char * querylocale(int, locale_t);
locale_t uselocale(locale_t);
}


# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/xlocale/_ctype.h" 1 3 4
# 37 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/xlocale/_ctype.h" 3 4
extern "C" {
unsigned long ___runetype_l(__darwin_ct_rune_t, locale_t);
__darwin_ct_rune_t ___tolower_l(__darwin_ct_rune_t, locale_t);
__darwin_ct_rune_t ___toupper_l(__darwin_ct_rune_t, locale_t);
}

extern "C" {
int __maskrune_l(__darwin_ct_rune_t, unsigned long, locale_t);
}

inline int
__istype_l(__darwin_ct_rune_t _c, unsigned long _f, locale_t _l)
{
 return !!(isascii(_c) ? (_DefaultRuneLocale.__runetype[_c] & _f)
  : __maskrune_l(_c, _f, _l));
}

inline __darwin_ct_rune_t
__toupper_l(__darwin_ct_rune_t _c, locale_t _l)
{
 return isascii(_c) ? _DefaultRuneLocale.__mapupper[_c]
  : ___toupper_l(_c, _l);
}

inline __darwin_ct_rune_t
__tolower_l(__darwin_ct_rune_t _c, locale_t _l)
{
 return isascii(_c) ? _DefaultRuneLocale.__maplower[_c]
  : ___tolower_l(_c, _l);
}

inline int
__wcwidth_l(__darwin_ct_rune_t _c, locale_t _l)
{
 unsigned int _x;

 if (_c == 0)
  return (0);
 _x = (unsigned int)__maskrune_l(_c, 0xe0000000L|0x00040000L, _l);
 if ((_x & 0xe0000000L) != 0)
  return ((_x & 0xe0000000L) >> 30);
 return ((_x & 0x00040000L) != 0 ? 1 : -1);
}



inline int
digittoint_l(int c, locale_t l)
{
 return (__maskrune_l(c, 0x0F, l));
}

inline int
isalnum_l(int c, locale_t l)
{
 return (__istype_l(c, 0x00000100L|0x00000400L, l));
}

inline int
isalpha_l(int c, locale_t l)
{
 return (__istype_l(c, 0x00000100L, l));
}

inline int
isblank_l(int c, locale_t l)
{
 return (__istype_l(c, 0x00020000L, l));
}

inline int
iscntrl_l(int c, locale_t l)
{
 return (__istype_l(c, 0x00000200L, l));
}

inline int
isdigit_l(int c, locale_t l)
{
 return (__istype_l(c, 0x00000400L, l));
}

inline int
isgraph_l(int c, locale_t l)
{
 return (__istype_l(c, 0x00000800L, l));
}

inline int
ishexnumber_l(int c, locale_t l)
{
 return (__istype_l(c, 0x00010000L, l));
}

inline int
isideogram_l(int c, locale_t l)
{
 return (__istype_l(c, 0x00080000L, l));
}

inline int
islower_l(int c, locale_t l)
{
 return (__istype_l(c, 0x00001000L, l));
}

inline int
isnumber_l(int c, locale_t l)
{
 return (__istype_l(c, 0x00000400L, l));
}

inline int
isphonogram_l(int c, locale_t l)
{
 return (__istype_l(c, 0x00200000L, l));
}

inline int
isprint_l(int c, locale_t l)
{
 return (__istype_l(c, 0x00040000L, l));
}

inline int
ispunct_l(int c, locale_t l)
{
 return (__istype_l(c, 0x00002000L, l));
}

inline int
isrune_l(int c, locale_t l)
{
 return (__istype_l(c, 0xFFFFFFF0L, l));
}

inline int
isspace_l(int c, locale_t l)
{
 return (__istype_l(c, 0x00004000L, l));
}

inline int
isspecial_l(int c, locale_t l)
{
 return (__istype_l(c, 0x00100000L, l));
}

inline int
isupper_l(int c, locale_t l)
{
 return (__istype_l(c, 0x00008000L, l));
}

inline int
isxdigit_l(int c, locale_t l)
{
 return (__istype_l(c, 0x00010000L, l));
}

inline int
tolower_l(int c, locale_t l)
{
        return (__tolower_l(c, l));
}

inline int
toupper_l(int c, locale_t l)
{
        return (__toupper_l(c, l));
}
# 76 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/xlocale.h" 2 3 4


# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/xlocale/__wctype.h" 1 3 4
# 33 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/xlocale/__wctype.h" 3 4
inline int
iswalnum_l(wint_t _wc, locale_t _l)
{
 return (__istype_l(_wc, 0x00000100L|0x00000400L, _l));
}

inline int
iswalpha_l(wint_t _wc, locale_t _l)
{
 return (__istype_l(_wc, 0x00000100L, _l));
}

inline int
iswcntrl_l(wint_t _wc, locale_t _l)
{
 return (__istype_l(_wc, 0x00000200L, _l));
}

inline int
iswctype_l(wint_t _wc, wctype_t _charclass, locale_t _l)
{
 return (__istype_l(_wc, _charclass, _l));
}

inline int
iswdigit_l(wint_t _wc, locale_t _l)
{
 return (__istype_l(_wc, 0x00000400L, _l));
}

inline int
iswgraph_l(wint_t _wc, locale_t _l)
{
 return (__istype_l(_wc, 0x00000800L, _l));
}

inline int
iswlower_l(wint_t _wc, locale_t _l)
{
 return (__istype_l(_wc, 0x00001000L, _l));
}

inline int
iswprint_l(wint_t _wc, locale_t _l)
{
 return (__istype_l(_wc, 0x00040000L, _l));
}

inline int
iswpunct_l(wint_t _wc, locale_t _l)
{
 return (__istype_l(_wc, 0x00002000L, _l));
}

inline int
iswspace_l(wint_t _wc, locale_t _l)
{
 return (__istype_l(_wc, 0x00004000L, _l));
}

inline int
iswupper_l(wint_t _wc, locale_t _l)
{
 return (__istype_l(_wc, 0x00008000L, _l));
}

inline int
iswxdigit_l(wint_t _wc, locale_t _l)
{
 return (__istype_l(_wc, 0x00010000L, _l));
}

inline wint_t
towlower_l(wint_t _wc, locale_t _l)
{
        return (__tolower_l(_wc, _l));
}

inline wint_t
towupper_l(wint_t _wc, locale_t _l)
{
        return (__toupper_l(_wc, _l));
}
# 138 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/xlocale/__wctype.h" 3 4
extern "C" {
wctype_t
 wctype_l(const char *, locale_t);
}
# 79 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/xlocale.h" 2 3 4
# 93 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/xlocale.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/xlocale/_stdio.h" 1 3 4
# 30 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/xlocale/_stdio.h" 3 4
extern "C" {

int fprintf_l(FILE * , locale_t , const char * , ...)
        __attribute__((__format__ (__printf__, 3, 4)));
int fscanf_l(FILE * , locale_t , const char * , ...)
        __attribute__((__format__ (__scanf__, 3, 4)));
int printf_l(locale_t , const char * , ...)
        __attribute__((__format__ (__printf__, 2, 3)));
int scanf_l(locale_t , const char * , ...)
        __attribute__((__format__ (__scanf__, 2, 3)));
int sprintf_l(char * , locale_t , const char * , ...)
        __attribute__((__format__ (__printf__, 3, 4))) __attribute__((__availability__(swift, unavailable, message="Use snprintf_l instead.")));
int sscanf_l(const char * , locale_t , const char * , ...)
        __attribute__((__format__ (__scanf__, 3, 4)));
int vfprintf_l(FILE * , locale_t , const char * , va_list)
        __attribute__((__format__ (__printf__, 3, 0)));
int vprintf_l(locale_t , const char * , va_list)
        __attribute__((__format__ (__printf__, 2, 0)));
int vsprintf_l(char * , locale_t , const char * , va_list)
        __attribute__((__format__ (__printf__, 3, 0))) __attribute__((__availability__(swift, unavailable, message="Use vsnprintf_l instead.")));


int snprintf_l(char * , size_t, locale_t , const char * , ...)
        __attribute__((__format__ (__printf__, 4, 5)));
int vfscanf_l(FILE * , locale_t , const char * , va_list)
        __attribute__((__format__ (__scanf__, 3, 0)));
int vscanf_l(locale_t , const char * , va_list)
        __attribute__((__format__ (__scanf__, 2, 0)));
int vsnprintf_l(char * , size_t, locale_t , const char * , va_list)
        __attribute__((__format__ (__printf__, 4, 0)));
int vsscanf_l(const char * , locale_t , const char * , va_list)
        __attribute__((__format__ (__scanf__, 3, 0)));



int dprintf_l(int, locale_t , const char * , ...)
        __attribute__((__format__ (__printf__, 3, 4))) __attribute__((availability(macosx,introduced=10.7)));
int vdprintf_l(int, locale_t , const char * , va_list)
        __attribute__((__format__ (__printf__, 3, 0))) __attribute__((availability(macosx,introduced=10.7)));




int asprintf_l(char ** , locale_t , const char * , ...)
        __attribute__((__format__ (__printf__, 3, 4)));
int vasprintf_l(char ** , locale_t , const char * , va_list)
        __attribute__((__format__ (__printf__, 3, 0)));


}
# 94 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/xlocale.h" 2 3 4


# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/xlocale/_stdlib.h" 1 3 4
# 29 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/xlocale/_stdlib.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_wchar_t.h" 1 3 4
# 30 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/xlocale/_stdlib.h" 2 3 4


extern "C" {
double atof_l(const char *, locale_t);
int atoi_l(const char *, locale_t);
long atol_l(const char *, locale_t);

long long
  atoll_l(const char *, locale_t);

int mblen_l(const char *, size_t, locale_t);
size_t mbstowcs_l(wchar_t * , const char * , size_t,
     locale_t);
int mbtowc_l(wchar_t * , const char * , size_t,
     locale_t);
double strtod_l(const char *, char **, locale_t) __asm("_" "strtod_l" );
float strtof_l(const char *, char **, locale_t) __asm("_" "strtof_l" );
long strtol_l(const char *, char **, int, locale_t);
long double
  strtold_l(const char *, char **, locale_t);
long long
  strtoll_l(const char *, char **, int, locale_t);

long long
  strtoq_l(const char *, char **, int, locale_t);

unsigned long
  strtoul_l(const char *, char **, int, locale_t);
unsigned long long
  strtoull_l(const char *, char **, int, locale_t);

unsigned long long
  strtouq_l(const char *, char **, int, locale_t);

size_t wcstombs_l(char * , const wchar_t * , size_t,
     locale_t);
int wctomb_l(char *, wchar_t, locale_t);





}
# 97 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/xlocale.h" 2 3 4


# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/xlocale/_string.h" 1 3 4
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/xlocale/_string.h" 3 4
extern "C" {
int strcoll_l(const char *, const char *, locale_t);
size_t strxfrm_l(char *, const char *, size_t, locale_t);
int strcasecmp_l(const char *, const char *, locale_t);
char *strcasestr_l(const char *, const char *, locale_t);
int strncasecmp_l(const char *, const char *, size_t, locale_t);
}
# 100 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/xlocale.h" 2 3 4


# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/xlocale/_time.h" 1 3 4
# 32 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/xlocale/_time.h" 3 4
extern "C" {
size_t strftime_l(char * , size_t, const char * ,
  const struct tm * , locale_t)
  __asm("_" "strftime_l" ) __attribute__((__format__ (__strftime__, 3, 0)));
char *strptime_l(const char * , const char * ,
  struct tm * , locale_t)
  __asm("_" "strptime_l" ) __attribute__((__format__ (__strftime__, 2, 0)));
}
# 103 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/xlocale.h" 2 3 4


# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/xlocale/_wchar.h" 1 3 4
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/xlocale/_wchar.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/stddef.h" 1 3 4
# 32 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/xlocale/_wchar.h" 2 3 4


extern "C" {
wint_t btowc_l(int, locale_t);
wint_t fgetwc_l(FILE *, locale_t);
wchar_t *fgetws_l(wchar_t * , int, FILE * , locale_t);
wint_t fputwc_l(wchar_t, FILE *, locale_t);
int fputws_l(const wchar_t * , FILE * , locale_t);
int fwprintf_l(FILE * , locale_t, const wchar_t * , ...);
int fwscanf_l(FILE * , locale_t, const wchar_t * , ...);
wint_t getwc_l(FILE *, locale_t);
wint_t getwchar_l(locale_t);
size_t mbrlen_l(const char * , size_t, mbstate_t * ,
     locale_t);
size_t mbrtowc_l(wchar_t * , const char * , size_t,
     mbstate_t * , locale_t);
int mbsinit_l(const mbstate_t *, locale_t);
size_t mbsrtowcs_l(wchar_t * , const char ** , size_t,
     mbstate_t * , locale_t);
wint_t putwc_l(wchar_t, FILE *, locale_t);
wint_t putwchar_l(wchar_t, locale_t);
int swprintf_l(wchar_t * , size_t n, locale_t,
  const wchar_t * , ...);
int swscanf_l(const wchar_t * , locale_t,
  const wchar_t * , ...);
wint_t ungetwc_l(wint_t, FILE *, locale_t);
int vfwprintf_l(FILE * , locale_t, const wchar_t * ,
  __darwin_va_list);
int vswprintf_l(wchar_t * , size_t n, locale_t,
  const wchar_t * , __darwin_va_list);
int vwprintf_l(locale_t, const wchar_t * , __darwin_va_list);
size_t wcrtomb_l(char * , wchar_t, mbstate_t * ,
     locale_t);
int wcscoll_l(const wchar_t *, const wchar_t *, locale_t);
size_t wcsftime_l(wchar_t * , size_t, const wchar_t * ,
  const struct tm * , locale_t)
  __asm("_" "wcsftime_l" );
size_t wcsrtombs_l(char * , const wchar_t ** , size_t,
     mbstate_t * , locale_t);
double wcstod_l(const wchar_t * , wchar_t ** , locale_t);
long wcstol_l(const wchar_t * , wchar_t ** , int,
     locale_t);
unsigned long
 wcstoul_l(const wchar_t * , wchar_t ** , int,
     locale_t);
int wcswidth_l(const wchar_t *, size_t, locale_t);
size_t wcsxfrm_l(wchar_t * , const wchar_t * , size_t,
     locale_t);
int wctob_l(wint_t, locale_t);
int wcwidth_l(wchar_t, locale_t);
int wprintf_l(locale_t, const wchar_t * , ...);
int wscanf_l(locale_t, const wchar_t * , ...);
}
# 93 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/xlocale/_wchar.h" 3 4
extern "C" {
int vfwscanf_l(FILE * , locale_t, const wchar_t * ,
  __darwin_va_list);
int vswscanf_l(const wchar_t * , locale_t,
  const wchar_t * , __darwin_va_list);
int vwscanf_l(locale_t, const wchar_t * , __darwin_va_list);
float wcstof_l(const wchar_t * , wchar_t ** , locale_t);
long double
 wcstold_l(const wchar_t * , wchar_t ** , locale_t);

long long
 wcstoll_l(const wchar_t * , wchar_t ** , int,
     locale_t);
unsigned long long
 wcstoull_l(const wchar_t * , wchar_t ** , int,
     locale_t);

}
# 120 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/xlocale/_wchar.h" 3 4
extern "C" {
size_t mbsnrtowcs_l(wchar_t * , const char ** , size_t,
     size_t, mbstate_t * , locale_t);
int wcscasecmp_l(const wchar_t *, const wchar_t *, locale_t) __attribute__((availability(macosx,introduced=10.7)));
int wcsncasecmp_l(const wchar_t *, const wchar_t *, size_t n, locale_t) __attribute__((availability(macosx,introduced=10.7)));
size_t wcsnrtombs_l(char * , const wchar_t ** , size_t,
     size_t, mbstate_t * , locale_t);
}







extern "C" {
wchar_t *fgetwln_l(FILE * , size_t *, locale_t) __attribute__((availability(macosx,introduced=10.7)));
}
# 106 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/xlocale.h" 2 3 4


# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/xlocale/_wctype.h" 1 3 4
# 34 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/xlocale/_wctype.h" 3 4
inline int
iswblank_l(wint_t _wc, locale_t _l)
{
 return (__istype_l(_wc, 0x00020000L, _l));
}

inline int
iswhexnumber_l(wint_t _wc, locale_t _l)
{
 return (__istype_l(_wc, 0x00010000L, _l));
}

inline int
iswideogram_l(wint_t _wc, locale_t _l)
{
 return (__istype_l(_wc, 0x00080000L, _l));
}

inline int
iswnumber_l(wint_t _wc, locale_t _l)
{
 return (__istype_l(_wc, 0x00000400L, _l));
}

inline int
iswphonogram_l(wint_t _wc, locale_t _l)
{
 return (__istype_l(_wc, 0x00200000L, _l));
}

inline int
iswrune_l(wint_t _wc, locale_t _l)
{
 return (__istype_l(_wc, 0xFFFFFFF0L, _l));
}

inline int
iswspecial_l(wint_t _wc, locale_t _l)
{
 return (__istype_l(_wc, 0x00100000L, _l));
}
# 90 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/xlocale/_wctype.h" 3 4
extern "C" {
wint_t nextwctype_l(wint_t, wctype_t, locale_t);
wint_t towctrans_l(wint_t, wctrans_t, locale_t);
wctrans_t
 wctrans_l(const char *, locale_t);
}
# 109 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/xlocale.h" 2 3 4
# 41 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__locale" 2 3
# 52 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__locale" 3


namespace std { inline namespace __1 {
# 113 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__locale" 3
class __attribute__ ((__visibility__("default"))) locale;

template <class _Facet>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
has_facet(const locale&) noexcept;

template <class _Facet>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
const _Facet&
use_facet(const locale&);

class __attribute__ ((__visibility__("default"))) locale
{
public:

    class __attribute__ ((__visibility__("default"))) facet;
    class __attribute__ ((__visibility__("default"))) id;

    typedef int category;
    __attribute__((availability(macosx,strict,introduced=10.9))) __attribute__((availability(ios,strict,introduced=7.0)))
    static const category
        none = 0,
        collate = (1 << 0),
        ctype = (1 << 1),
        monetary = (1 << 3),
        numeric = (1 << 4),
        time = (1 << 5),
        messages = (1 << 2),
        all = collate | ctype | monetary | numeric | time | messages;


    locale() noexcept;
    locale(const locale&) noexcept;
    explicit locale(const char*);
    explicit locale(const string&);
    locale(const locale&, const char*, category);
    locale(const locale&, const string&, category);
    template <class _Facet>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) locale(const locale&, _Facet*);
    locale(const locale&, const locale&, category);

    ~locale();

    const locale& operator=(const locale&) noexcept;

    template <class _Facet>
      inline __attribute__ ((__visibility__("hidden")))
      locale combine(const locale&) const;


    string name() const;
    bool operator==(const locale&) const;
    bool operator!=(const locale& __y) const {return !(*this == __y);}
    template <class _CharT, class _Traits, class _Allocator>
      inline __attribute__ ((__visibility__("hidden")))
      bool operator()(const basic_string<_CharT, _Traits, _Allocator>&,
                      const basic_string<_CharT, _Traits, _Allocator>&) const;


    static locale global(const locale&);
    static const locale& classic();

private:
    class __imp;
    __imp* __locale_;

    void __install_ctor(const locale&, facet*, long);
    static locale& __global();
    bool has_facet(id&) const;
    const facet* use_facet(id&) const;

    template <class _Facet> friend bool has_facet(const locale&) noexcept;
    template <class _Facet> friend const _Facet& use_facet(const locale&);
};

class __attribute__ ((__visibility__("default"))) locale::facet
    : public __shared_count
{
protected:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit facet(size_t __refs = 0)
        : __shared_count(static_cast<long>(__refs)-1) {}

    virtual ~facet();



private:
    virtual void __on_zero_shared() noexcept;
};

class __attribute__ ((__visibility__("default"))) locale::id
{
    once_flag __flag_;
    int32_t __id_;

    static int32_t __next_id;
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr id() :__id_(0) {}
private:
    void __init();
    void operator=(const id&);
    id(const id&);
public:
    long __get();

    friend class locale;
    friend class locale::__imp;
};

template <class _Facet>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
locale::locale(const locale& __other, _Facet* __f)
{
    __install_ctor(__other, __f, __f ? __f->id.__get() : 0);
}

template <class _Facet>
locale
locale::combine(const locale& __other) const
{
    if (!std::__1::has_facet<_Facet>(__other))
        __throw_runtime_error("locale::combine: locale missing facet");

    return locale(*this, &const_cast<_Facet&>(std::__1::use_facet<_Facet>(__other)));
}

template <class _Facet>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
has_facet(const locale& __l) noexcept
{
    return __l.has_facet(_Facet::id);
}

template <class _Facet>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
const _Facet&
use_facet(const locale& __l)
{
    return static_cast<const _Facet&>(*__l.use_facet(_Facet::id));
}



template <class _CharT>
class __attribute__ ((__type_visibility__("default"))) collate
    : public locale::facet
{
public:
    typedef _CharT char_type;
    typedef basic_string<char_type> string_type;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit collate(size_t __refs = 0)
        : locale::facet(__refs) {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    int compare(const char_type* __lo1, const char_type* __hi1,
                const char_type* __lo2, const char_type* __hi2) const
    {
        return do_compare(__lo1, __hi1, __lo2, __hi2);
    }



    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __attribute__ ((__always_inline__))
    string_type transform(const char_type* __lo, const char_type* __hi) const
    {
        return do_transform(__lo, __hi);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    long hash(const char_type* __lo, const char_type* __hi) const
    {
        return do_hash(__lo, __hi);
    }

    static locale::id id;

protected:
    ~collate();
    virtual int do_compare(const char_type* __lo1, const char_type* __hi1,
                           const char_type* __lo2, const char_type* __hi2) const;
    virtual string_type do_transform(const char_type* __lo, const char_type* __hi) const
        {return string_type(__lo, __hi);}
    virtual long do_hash(const char_type* __lo, const char_type* __hi) const;
};

template <class _CharT> locale::id collate<_CharT>::id;

template <class _CharT>
collate<_CharT>::~collate()
{
}

template <class _CharT>
int
collate<_CharT>::do_compare(const char_type* __lo1, const char_type* __hi1,
                            const char_type* __lo2, const char_type* __hi2) const
{
    for (; __lo2 != __hi2; ++__lo1, ++__lo2)
    {
        if (__lo1 == __hi1 || *__lo1 < *__lo2)
            return -1;
        if (*__lo2 < *__lo1)
            return 1;
    }
    return __lo1 != __hi1;
}

template <class _CharT>
long
collate<_CharT>::do_hash(const char_type* __lo, const char_type* __hi) const
{
    size_t __h = 0;
    const size_t __sr = 8 * sizeof(size_t) - 8;
    const size_t __mask = size_t(0xF) << (__sr + 4);
    for(const char_type* __p = __lo; __p != __hi; ++__p)
    {
        __h = (__h << 4) + static_cast<size_t>(*__p);
        size_t __g = __h & __mask;
        __h ^= __g | (__g >> __sr);
    }
    return static_cast<long>(__h);
}

extern template class __attribute__ ((__visibility__("default"))) collate<char>;

extern template class __attribute__ ((__visibility__("default"))) collate<wchar_t>;




template <class _CharT> class __attribute__ ((__type_visibility__("default"))) collate_byname;

template <>
class __attribute__ ((__visibility__("default"))) collate_byname<char>
    : public collate<char>
{
    locale_t __l;
public:
    typedef char char_type;
    typedef basic_string<char_type> string_type;

    explicit collate_byname(const char* __n, size_t __refs = 0);
    explicit collate_byname(const string& __n, size_t __refs = 0);

protected:
    ~collate_byname();
    virtual int do_compare(const char_type* __lo1, const char_type* __hi1,
                           const char_type* __lo2, const char_type* __hi2) const;
    virtual string_type do_transform(const char_type* __lo, const char_type* __hi) const;
};


template <>
class __attribute__ ((__visibility__("default"))) collate_byname<wchar_t>
    : public collate<wchar_t>
{
    locale_t __l;
public:
    typedef wchar_t char_type;
    typedef basic_string<char_type> string_type;

    explicit collate_byname(const char* __n, size_t __refs = 0);
    explicit collate_byname(const string& __n, size_t __refs = 0);

protected:
    ~collate_byname();

    virtual int do_compare(const char_type* __lo1, const char_type* __hi1,
                           const char_type* __lo2, const char_type* __hi2) const;
    virtual string_type do_transform(const char_type* __lo, const char_type* __hi) const;
};


template <class _CharT, class _Traits, class _Allocator>
bool
locale::operator()(const basic_string<_CharT, _Traits, _Allocator>& __x,
                   const basic_string<_CharT, _Traits, _Allocator>& __y) const
{
    return std::__1::use_facet<std::__1::collate<_CharT> >(*this).compare(
                                       __x.data(), __x.data() + __x.size(),
                                       __y.data(), __y.data() + __y.size()) < 0;
}



class __attribute__ ((__visibility__("default"))) ctype_base
{
public:
# 459 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__locale" 3
    typedef __uint32_t mask;





    static const mask space = 0x00004000L;
    static const mask print = 0x00040000L;
    static const mask cntrl = 0x00000200L;
    static const mask upper = 0x00008000L;
    static const mask lower = 0x00001000L;
    static const mask alpha = 0x00000100L;
    static const mask digit = 0x00000400L;
    static const mask punct = 0x00002000L;
    static const mask xdigit = 0x00010000L;







    static const mask blank = 0x00020000L;
    static const mask __regex_word = 0x80;
# 517 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__locale" 3
    static const mask alnum = alpha | digit;
    static const mask graph = alnum | punct;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) ctype_base() {}
};

template <class _CharT> class __attribute__ ((__type_visibility__("default"))) ctype;


template <>
class __attribute__ ((__visibility__("default"))) ctype<wchar_t>
    : public locale::facet,
      public ctype_base
{
public:
    typedef wchar_t char_type;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit ctype(size_t __refs = 0)
        : locale::facet(__refs) {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    bool is(mask __m, char_type __c) const
    {
        return do_is(__m, __c);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const char_type* is(const char_type* __low, const char_type* __high, mask* __vec) const
    {
        return do_is(__low, __high, __vec);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const char_type* scan_is(mask __m, const char_type* __low, const char_type* __high) const
    {
        return do_scan_is(__m, __low, __high);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const char_type* scan_not(mask __m, const char_type* __low, const char_type* __high) const
    {
        return do_scan_not(__m, __low, __high);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    char_type toupper(char_type __c) const
    {
        return do_toupper(__c);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const char_type* toupper(char_type* __low, const char_type* __high) const
    {
        return do_toupper(__low, __high);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    char_type tolower(char_type __c) const
    {
        return do_tolower(__c);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const char_type* tolower(char_type* __low, const char_type* __high) const
    {
        return do_tolower(__low, __high);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    char_type widen(char __c) const
    {
        return do_widen(__c);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const char* widen(const char* __low, const char* __high, char_type* __to) const
    {
        return do_widen(__low, __high, __to);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    char narrow(char_type __c, char __dfault) const
    {
        return do_narrow(__c, __dfault);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const char_type* narrow(const char_type* __low, const char_type* __high, char __dfault, char* __to) const
    {
        return do_narrow(__low, __high, __dfault, __to);
    }

    static locale::id id;

protected:
    ~ctype();
    virtual bool do_is(mask __m, char_type __c) const;
    virtual const char_type* do_is(const char_type* __low, const char_type* __high, mask* __vec) const;
    virtual const char_type* do_scan_is(mask __m, const char_type* __low, const char_type* __high) const;
    virtual const char_type* do_scan_not(mask __m, const char_type* __low, const char_type* __high) const;
    virtual char_type do_toupper(char_type) const;
    virtual const char_type* do_toupper(char_type* __low, const char_type* __high) const;
    virtual char_type do_tolower(char_type) const;
    virtual const char_type* do_tolower(char_type* __low, const char_type* __high) const;
    virtual char_type do_widen(char) const;
    virtual const char* do_widen(const char* __low, const char* __high, char_type* __dest) const;
    virtual char do_narrow(char_type, char __dfault) const;
    virtual const char_type* do_narrow(const char_type* __low, const char_type* __high, char __dfault, char* __dest) const;
};


template <>
class __attribute__ ((__visibility__("default"))) ctype<char>
    : public locale::facet, public ctype_base
{
    const mask* __tab_;
    bool __del_;
public:
    typedef char char_type;

    explicit ctype(const mask* __tab = nullptr, bool __del = false, size_t __refs = 0);

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    bool is(mask __m, char_type __c) const
    {
        return isascii(__c) ? (__tab_[static_cast<int>(__c)] & __m) !=0 : false;
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const char_type* is(const char_type* __low, const char_type* __high, mask* __vec) const
    {
        for (; __low != __high; ++__low, ++__vec)
            *__vec = isascii(*__low) ? __tab_[static_cast<int>(*__low)] : 0;
        return __low;
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const char_type* scan_is (mask __m, const char_type* __low, const char_type* __high) const
    {
        for (; __low != __high; ++__low)
            if (isascii(*__low) && (__tab_[static_cast<int>(*__low)] & __m))
                break;
        return __low;
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const char_type* scan_not(mask __m, const char_type* __low, const char_type* __high) const
    {
        for (; __low != __high; ++__low)
            if (!(isascii(*__low) && (__tab_[static_cast<int>(*__low)] & __m)))
                break;
        return __low;
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    char_type toupper(char_type __c) const
    {
        return do_toupper(__c);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const char_type* toupper(char_type* __low, const char_type* __high) const
    {
        return do_toupper(__low, __high);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    char_type tolower(char_type __c) const
    {
        return do_tolower(__c);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const char_type* tolower(char_type* __low, const char_type* __high) const
    {
        return do_tolower(__low, __high);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    char_type widen(char __c) const
    {
        return do_widen(__c);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const char* widen(const char* __low, const char* __high, char_type* __to) const
    {
        return do_widen(__low, __high, __to);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    char narrow(char_type __c, char __dfault) const
    {
        return do_narrow(__c, __dfault);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const char* narrow(const char_type* __low, const char_type* __high, char __dfault, char* __to) const
    {
        return do_narrow(__low, __high, __dfault, __to);
    }

    static locale::id id;


    static const size_t table_size = (1 <<8 );



    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) const mask* table() const noexcept {return __tab_;}
    static const mask* classic_table() noexcept;
# 738 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__locale" 3
protected:
    ~ctype();
    virtual char_type do_toupper(char_type __c) const;
    virtual const char_type* do_toupper(char_type* __low, const char_type* __high) const;
    virtual char_type do_tolower(char_type __c) const;
    virtual const char_type* do_tolower(char_type* __low, const char_type* __high) const;
    virtual char_type do_widen(char __c) const;
    virtual const char* do_widen(const char* __low, const char* __high, char_type* __to) const;
    virtual char do_narrow(char_type __c, char __dfault) const;
    virtual const char* do_narrow(const char_type* __low, const char_type* __high, char __dfault, char* __to) const;
};



template <class _CharT> class __attribute__ ((__type_visibility__("default"))) ctype_byname;

template <>
class __attribute__ ((__visibility__("default"))) ctype_byname<char>
    : public ctype<char>
{
    locale_t __l;

public:
    explicit ctype_byname(const char*, size_t = 0);
    explicit ctype_byname(const string&, size_t = 0);

protected:
    ~ctype_byname();
    virtual char_type do_toupper(char_type) const;
    virtual const char_type* do_toupper(char_type* __low, const char_type* __high) const;
    virtual char_type do_tolower(char_type) const;
    virtual const char_type* do_tolower(char_type* __low, const char_type* __high) const;
};


template <>
class __attribute__ ((__visibility__("default"))) ctype_byname<wchar_t>
    : public ctype<wchar_t>
{
    locale_t __l;

public:
    explicit ctype_byname(const char*, size_t = 0);
    explicit ctype_byname(const string&, size_t = 0);

protected:
    ~ctype_byname();
    virtual bool do_is(mask __m, char_type __c) const;
    virtual const char_type* do_is(const char_type* __low, const char_type* __high, mask* __vec) const;
    virtual const char_type* do_scan_is(mask __m, const char_type* __low, const char_type* __high) const;
    virtual const char_type* do_scan_not(mask __m, const char_type* __low, const char_type* __high) const;
    virtual char_type do_toupper(char_type) const;
    virtual const char_type* do_toupper(char_type* __low, const char_type* __high) const;
    virtual char_type do_tolower(char_type) const;
    virtual const char_type* do_tolower(char_type* __low, const char_type* __high) const;
    virtual char_type do_widen(char) const;
    virtual const char* do_widen(const char* __low, const char* __high, char_type* __dest) const;
    virtual char do_narrow(char_type, char __dfault) const;
    virtual const char_type* do_narrow(const char_type* __low, const char_type* __high, char __dfault, char* __dest) const;
};


template <class _CharT>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
isspace(_CharT __c, const locale& __loc)
{
    return use_facet<ctype<_CharT> >(__loc).is(ctype_base::space, __c);
}

template <class _CharT>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
isprint(_CharT __c, const locale& __loc)
{
    return use_facet<ctype<_CharT> >(__loc).is(ctype_base::print, __c);
}

template <class _CharT>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
iscntrl(_CharT __c, const locale& __loc)
{
    return use_facet<ctype<_CharT> >(__loc).is(ctype_base::cntrl, __c);
}

template <class _CharT>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
isupper(_CharT __c, const locale& __loc)
{
    return use_facet<ctype<_CharT> >(__loc).is(ctype_base::upper, __c);
}

template <class _CharT>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
islower(_CharT __c, const locale& __loc)
{
    return use_facet<ctype<_CharT> >(__loc).is(ctype_base::lower, __c);
}

template <class _CharT>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
isalpha(_CharT __c, const locale& __loc)
{
    return use_facet<ctype<_CharT> >(__loc).is(ctype_base::alpha, __c);
}

template <class _CharT>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
isdigit(_CharT __c, const locale& __loc)
{
    return use_facet<ctype<_CharT> >(__loc).is(ctype_base::digit, __c);
}

template <class _CharT>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
ispunct(_CharT __c, const locale& __loc)
{
    return use_facet<ctype<_CharT> >(__loc).is(ctype_base::punct, __c);
}

template <class _CharT>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
isxdigit(_CharT __c, const locale& __loc)
{
    return use_facet<ctype<_CharT> >(__loc).is(ctype_base::xdigit, __c);
}

template <class _CharT>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
isalnum(_CharT __c, const locale& __loc)
{
    return use_facet<ctype<_CharT> >(__loc).is(ctype_base::alnum, __c);
}

template <class _CharT>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
isgraph(_CharT __c, const locale& __loc)
{
    return use_facet<ctype<_CharT> >(__loc).is(ctype_base::graph, __c);
}

template <class _CharT>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
_CharT
toupper(_CharT __c, const locale& __loc)
{
    return use_facet<ctype<_CharT> >(__loc).toupper(__c);
}

template <class _CharT>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
_CharT
tolower(_CharT __c, const locale& __loc)
{
    return use_facet<ctype<_CharT> >(__loc).tolower(__c);
}



class __attribute__ ((__visibility__("default"))) codecvt_base
{
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) codecvt_base() {}
    enum result {ok, partial, error, noconv};
};



template <class _InternT, class _ExternT, class _StateT> class __attribute__ ((__type_visibility__("default"))) codecvt;



template <>
class __attribute__ ((__visibility__("default"))) codecvt<char, char, mbstate_t>
    : public locale::facet,
      public codecvt_base
{
public:
    typedef char intern_type;
    typedef char extern_type;
    typedef mbstate_t state_type;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit codecvt(size_t __refs = 0)
        : locale::facet(__refs) {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    result out(state_type& __st,
               const intern_type* __frm, const intern_type* __frm_end, const intern_type*& __frm_nxt,
               extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const
    {
        return do_out(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    result unshift(state_type& __st,
                   extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const
    {
        return do_unshift(__st, __to, __to_end, __to_nxt);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    result in(state_type& __st,
              const extern_type* __frm, const extern_type* __frm_end, const extern_type*& __frm_nxt,
              intern_type* __to, intern_type* __to_end, intern_type*& __to_nxt) const
    {
        return do_in(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    int encoding() const noexcept
    {
        return do_encoding();
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    bool always_noconv() const noexcept
    {
        return do_always_noconv();
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    int length(state_type& __st, const extern_type* __frm, const extern_type* __end, size_t __mx) const
    {
        return do_length(__st, __frm, __end, __mx);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    int max_length() const noexcept
    {
        return do_max_length();
    }

    static locale::id id;

protected:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit codecvt(const char*, size_t __refs = 0)
        : locale::facet(__refs) {}

    ~codecvt();

    virtual result do_out(state_type& __st,
                          const intern_type* __frm, const intern_type* __frm_end, const intern_type*& __frm_nxt,
                          extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const;
    virtual result do_in(state_type& __st,
                         const extern_type* __frm, const extern_type* __frm_end, const extern_type*& __frm_nxt,
                         intern_type* __to, intern_type* __to_end, intern_type*& __to_nxt) const;
    virtual result do_unshift(state_type& __st,
                              extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const;
    virtual int do_encoding() const noexcept;
    virtual bool do_always_noconv() const noexcept;
    virtual int do_length(state_type& __st, const extern_type* __frm, const extern_type* __end, size_t __mx) const;
    virtual int do_max_length() const noexcept;
};




template <>
class __attribute__ ((__visibility__("default"))) codecvt<wchar_t, char, mbstate_t>
    : public locale::facet,
      public codecvt_base
{
    locale_t __l;
public:
    typedef wchar_t intern_type;
    typedef char extern_type;
    typedef mbstate_t state_type;

    explicit codecvt(size_t __refs = 0);

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    result out(state_type& __st,
               const intern_type* __frm, const intern_type* __frm_end, const intern_type*& __frm_nxt,
               extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const
    {
        return do_out(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    result unshift(state_type& __st,
                   extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const
    {
        return do_unshift(__st, __to, __to_end, __to_nxt);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    result in(state_type& __st,
              const extern_type* __frm, const extern_type* __frm_end, const extern_type*& __frm_nxt,
              intern_type* __to, intern_type* __to_end, intern_type*& __to_nxt) const
    {
        return do_in(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    int encoding() const noexcept
    {
        return do_encoding();
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    bool always_noconv() const noexcept
    {
        return do_always_noconv();
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    int length(state_type& __st, const extern_type* __frm, const extern_type* __end, size_t __mx) const
    {
        return do_length(__st, __frm, __end, __mx);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    int max_length() const noexcept
    {
        return do_max_length();
    }

    static locale::id id;

protected:
    explicit codecvt(const char*, size_t __refs = 0);

    ~codecvt();

    virtual result do_out(state_type& __st,
                          const intern_type* __frm, const intern_type* __frm_end, const intern_type*& __frm_nxt,
                          extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const;
    virtual result do_in(state_type& __st,
                         const extern_type* __frm, const extern_type* __frm_end, const extern_type*& __frm_nxt,
                         intern_type* __to, intern_type* __to_end, intern_type*& __to_nxt) const;
    virtual result do_unshift(state_type& __st,
                              extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const;
    virtual int do_encoding() const noexcept;
    virtual bool do_always_noconv() const noexcept;
    virtual int do_length(state_type&, const extern_type* __frm, const extern_type* __end, size_t __mx) const;
    virtual int do_max_length() const noexcept;
};




template <>
class __attribute__ ((__visibility__("default"))) codecvt<char16_t, char, mbstate_t>
    : public locale::facet,
      public codecvt_base
{
public:
    typedef char16_t intern_type;
    typedef char extern_type;
    typedef mbstate_t state_type;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit codecvt(size_t __refs = 0)
        : locale::facet(__refs) {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    result out(state_type& __st,
               const intern_type* __frm, const intern_type* __frm_end, const intern_type*& __frm_nxt,
               extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const
    {
        return do_out(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    result unshift(state_type& __st,
                   extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const
    {
        return do_unshift(__st, __to, __to_end, __to_nxt);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    result in(state_type& __st,
              const extern_type* __frm, const extern_type* __frm_end, const extern_type*& __frm_nxt,
              intern_type* __to, intern_type* __to_end, intern_type*& __to_nxt) const
    {
        return do_in(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    int encoding() const noexcept
    {
        return do_encoding();
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    bool always_noconv() const noexcept
    {
        return do_always_noconv();
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    int length(state_type& __st, const extern_type* __frm, const extern_type* __end, size_t __mx) const
    {
        return do_length(__st, __frm, __end, __mx);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    int max_length() const noexcept
    {
        return do_max_length();
    }

    static locale::id id;

protected:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit codecvt(const char*, size_t __refs = 0)
        : locale::facet(__refs) {}

    ~codecvt();

    virtual result do_out(state_type& __st,
                          const intern_type* __frm, const intern_type* __frm_end, const intern_type*& __frm_nxt,
                          extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const;
    virtual result do_in(state_type& __st,
                         const extern_type* __frm, const extern_type* __frm_end, const extern_type*& __frm_nxt,
                         intern_type* __to, intern_type* __to_end, intern_type*& __to_nxt) const;
    virtual result do_unshift(state_type& __st,
                              extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const;
    virtual int do_encoding() const noexcept;
    virtual bool do_always_noconv() const noexcept;
    virtual int do_length(state_type&, const extern_type* __frm, const extern_type* __end, size_t __mx) const;
    virtual int do_max_length() const noexcept;
};
# 1266 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__locale" 3
template <>
class __attribute__ ((__visibility__("default"))) codecvt<char32_t, char, mbstate_t>
    : public locale::facet,
      public codecvt_base
{
public:
    typedef char32_t intern_type;
    typedef char extern_type;
    typedef mbstate_t state_type;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit codecvt(size_t __refs = 0)
        : locale::facet(__refs) {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    result out(state_type& __st,
               const intern_type* __frm, const intern_type* __frm_end, const intern_type*& __frm_nxt,
               extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const
    {
        return do_out(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    result unshift(state_type& __st,
                   extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const
    {
        return do_unshift(__st, __to, __to_end, __to_nxt);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    result in(state_type& __st,
              const extern_type* __frm, const extern_type* __frm_end, const extern_type*& __frm_nxt,
              intern_type* __to, intern_type* __to_end, intern_type*& __to_nxt) const
    {
        return do_in(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    int encoding() const noexcept
    {
        return do_encoding();
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    bool always_noconv() const noexcept
    {
        return do_always_noconv();
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    int length(state_type& __st, const extern_type* __frm, const extern_type* __end, size_t __mx) const
    {
        return do_length(__st, __frm, __end, __mx);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    int max_length() const noexcept
    {
        return do_max_length();
    }

    static locale::id id;

protected:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit codecvt(const char*, size_t __refs = 0)
        : locale::facet(__refs) {}

    ~codecvt();

    virtual result do_out(state_type& __st,
                          const intern_type* __frm, const intern_type* __frm_end, const intern_type*& __frm_nxt,
                          extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const;
    virtual result do_in(state_type& __st,
                         const extern_type* __frm, const extern_type* __frm_end, const extern_type*& __frm_nxt,
                         intern_type* __to, intern_type* __to_end, intern_type*& __to_nxt) const;
    virtual result do_unshift(state_type& __st,
                              extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const;
    virtual int do_encoding() const noexcept;
    virtual bool do_always_noconv() const noexcept;
    virtual int do_length(state_type&, const extern_type* __frm, const extern_type* __end, size_t __mx) const;
    virtual int do_max_length() const noexcept;
};
# 1442 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__locale" 3
template <class _InternT, class _ExternT, class _StateT>
class __attribute__ ((__type_visibility__("default"))) codecvt_byname
    : public codecvt<_InternT, _ExternT, _StateT>
{
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit codecvt_byname(const char* __nm, size_t __refs = 0)
        : codecvt<_InternT, _ExternT, _StateT>(__nm, __refs) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit codecvt_byname(const string& __nm, size_t __refs = 0)
        : codecvt<_InternT, _ExternT, _StateT>(__nm.c_str(), __refs) {}
protected:
    ~codecvt_byname();
};

#pragma GCC diagnostic push
# 1457 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__locale" 3
#pragma GCC diagnostic ignored "-Wdeprecated"
# 1457 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__locale" 3
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
template <class _InternT, class _ExternT, class _StateT>
codecvt_byname<_InternT, _ExternT, _StateT>::~codecvt_byname()
{
}
#pragma GCC diagnostic pop

extern template class __attribute__ ((__visibility__("default"))) codecvt_byname<char, char, mbstate_t>;

extern template class __attribute__ ((__visibility__("default"))) codecvt_byname<wchar_t, char, mbstate_t>;

extern template class __attribute__ ((__visibility__("default"))) codecvt_byname<char16_t, char, mbstate_t>;
extern template class __attribute__ ((__visibility__("default"))) codecvt_byname<char32_t, char, mbstate_t>;





template <size_t _Np>
struct __narrow_to_utf8
{
    template <class _OutputIterator, class _CharT>
    _OutputIterator
    operator()(_OutputIterator __s, const _CharT* __wb, const _CharT* __we) const;
};

template <>
struct __narrow_to_utf8<8>
{
    template <class _OutputIterator, class _CharT>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    _OutputIterator
    operator()(_OutputIterator __s, const _CharT* __wb, const _CharT* __we) const
    {
        for (; __wb < __we; ++__wb, ++__s)
            *__s = *__wb;
        return __s;
    }
};

#pragma GCC diagnostic push
# 1497 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__locale" 3
#pragma GCC diagnostic ignored "-Wdeprecated"
# 1497 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__locale" 3
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
template <>
struct __attribute__ ((__visibility__("default"))) __narrow_to_utf8<16>
    : public codecvt<char16_t, char, mbstate_t>
{
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __narrow_to_utf8() : codecvt<char16_t, char, mbstate_t>(1) {}
#pragma GCC diagnostic pop

    ~__narrow_to_utf8();

    template <class _OutputIterator, class _CharT>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    _OutputIterator
    operator()(_OutputIterator __s, const _CharT* __wb, const _CharT* __we) const
    {
        result __r = ok;
        mbstate_t __mb;
        while (__wb < __we && __r != error)
        {
            const int __sz = 32;
            char __buf[__sz];
            char* __bn;
            const char16_t* __wn = (const char16_t*)__wb;
            __r = do_out(__mb, (const char16_t*)__wb, (const char16_t*)__we, __wn,
                         __buf, __buf+__sz, __bn);
            if (__r == codecvt_base::error || __wn == (const char16_t*)__wb)
                __throw_runtime_error("locale not supported");
            for (const char* __p = __buf; __p < __bn; ++__p, ++__s)
                *__s = *__p;
            __wb = (const _CharT*)__wn;
        }
        return __s;
    }
};

#pragma GCC diagnostic push
# 1533 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__locale" 3
#pragma GCC diagnostic ignored "-Wdeprecated"
# 1533 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__locale" 3
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
template <>
struct __attribute__ ((__visibility__("default"))) __narrow_to_utf8<32>
    : public codecvt<char32_t, char, mbstate_t>
{
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __narrow_to_utf8() : codecvt<char32_t, char, mbstate_t>(1) {}
#pragma GCC diagnostic pop

    ~__narrow_to_utf8();

    template <class _OutputIterator, class _CharT>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    _OutputIterator
    operator()(_OutputIterator __s, const _CharT* __wb, const _CharT* __we) const
    {
        result __r = ok;
        mbstate_t __mb;
        while (__wb < __we && __r != error)
        {
            const int __sz = 32;
            char __buf[__sz];
            char* __bn;
            const char32_t* __wn = (const char32_t*)__wb;
            __r = do_out(__mb, (const char32_t*)__wb, (const char32_t*)__we, __wn,
                         __buf, __buf+__sz, __bn);
            if (__r == codecvt_base::error || __wn == (const char32_t*)__wb)
                __throw_runtime_error("locale not supported");
            for (const char* __p = __buf; __p < __bn; ++__p, ++__s)
                *__s = *__p;
            __wb = (const _CharT*)__wn;
        }
        return __s;
    }
};

template <size_t _Np>
struct __widen_from_utf8
{
    template <class _OutputIterator>
    _OutputIterator
    operator()(_OutputIterator __s, const char* __nb, const char* __ne) const;
};

template <>
struct __widen_from_utf8<8>
{
    template <class _OutputIterator>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    _OutputIterator
    operator()(_OutputIterator __s, const char* __nb, const char* __ne) const
    {
        for (; __nb < __ne; ++__nb, ++__s)
            *__s = *__nb;
        return __s;
    }
};

#pragma GCC diagnostic push
# 1591 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__locale" 3
#pragma GCC diagnostic ignored "-Wdeprecated"
# 1591 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__locale" 3
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
template <>
struct __attribute__ ((__visibility__("default"))) __widen_from_utf8<16>
    : public codecvt<char16_t, char, mbstate_t>
{
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __widen_from_utf8() : codecvt<char16_t, char, mbstate_t>(1) {}
#pragma GCC diagnostic pop

    ~__widen_from_utf8();

    template <class _OutputIterator>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    _OutputIterator
    operator()(_OutputIterator __s, const char* __nb, const char* __ne) const
    {
        result __r = ok;
        mbstate_t __mb;
        while (__nb < __ne && __r != error)
        {
            const int __sz = 32;
            char16_t __buf[__sz];
            char16_t* __bn;
            const char* __nn = __nb;
            __r = do_in(__mb, __nb, __ne - __nb > __sz ? __nb+__sz : __ne, __nn,
                        __buf, __buf+__sz, __bn);
            if (__r == codecvt_base::error || __nn == __nb)
                __throw_runtime_error("locale not supported");
            for (const char16_t* __p = __buf; __p < __bn; ++__p, ++__s)
                *__s = *__p;
            __nb = __nn;
        }
        return __s;
    }
};

#pragma GCC diagnostic push
# 1627 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__locale" 3
#pragma GCC diagnostic ignored "-Wdeprecated"
# 1627 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__locale" 3
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
template <>
struct __attribute__ ((__visibility__("default"))) __widen_from_utf8<32>
    : public codecvt<char32_t, char, mbstate_t>
{
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __widen_from_utf8() : codecvt<char32_t, char, mbstate_t>(1) {}
#pragma GCC diagnostic pop

    ~__widen_from_utf8();

    template <class _OutputIterator>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    _OutputIterator
    operator()(_OutputIterator __s, const char* __nb, const char* __ne) const
    {
        result __r = ok;
        mbstate_t __mb;
        while (__nb < __ne && __r != error)
        {
            const int __sz = 32;
            char32_t __buf[__sz];
            char32_t* __bn;
            const char* __nn = __nb;
            __r = do_in(__mb, __nb, __ne - __nb > __sz ? __nb+__sz : __ne, __nn,
                        __buf, __buf+__sz, __bn);
            if (__r == codecvt_base::error || __nn == __nb)
                __throw_runtime_error("locale not supported");
            for (const char32_t* __p = __buf; __p < __bn; ++__p, ++__s)
                *__s = *__p;
            __nb = __nn;
        }
        return __s;
    }
};



template <class _CharT> class __attribute__ ((__type_visibility__("default"))) numpunct;

template <>
class __attribute__ ((__visibility__("default"))) numpunct<char>
    : public locale::facet
{
public:
    typedef char char_type;
    typedef basic_string<char_type> string_type;

    explicit numpunct(size_t __refs = 0);

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) char_type decimal_point() const {return do_decimal_point();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) char_type thousands_sep() const {return do_thousands_sep();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) string grouping() const {return do_grouping();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) string_type truename() const {return do_truename();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) string_type falsename() const {return do_falsename();}

    static locale::id id;

protected:
    ~numpunct();
    virtual char_type do_decimal_point() const;
    virtual char_type do_thousands_sep() const;
    virtual string do_grouping() const;
    virtual string_type do_truename() const;
    virtual string_type do_falsename() const;

    char_type __decimal_point_;
    char_type __thousands_sep_;
    string __grouping_;
};


template <>
class __attribute__ ((__visibility__("default"))) numpunct<wchar_t>
    : public locale::facet
{
public:
    typedef wchar_t char_type;
    typedef basic_string<char_type> string_type;

    explicit numpunct(size_t __refs = 0);

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) char_type decimal_point() const {return do_decimal_point();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) char_type thousands_sep() const {return do_thousands_sep();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) string grouping() const {return do_grouping();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) string_type truename() const {return do_truename();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) string_type falsename() const {return do_falsename();}

    static locale::id id;

protected:
    ~numpunct();
    virtual char_type do_decimal_point() const;
    virtual char_type do_thousands_sep() const;
    virtual string do_grouping() const;
    virtual string_type do_truename() const;
    virtual string_type do_falsename() const;

    char_type __decimal_point_;
    char_type __thousands_sep_;
    string __grouping_;
};




template <class _CharT> class __attribute__ ((__type_visibility__("default"))) numpunct_byname;

template <>
class __attribute__ ((__visibility__("default"))) numpunct_byname<char>
: public numpunct<char>
{
public:
    typedef char char_type;
    typedef basic_string<char_type> string_type;

    explicit numpunct_byname(const char* __nm, size_t __refs = 0);
    explicit numpunct_byname(const string& __nm, size_t __refs = 0);

protected:
    ~numpunct_byname();

private:
    void __init(const char*);
};


template <>
class __attribute__ ((__visibility__("default"))) numpunct_byname<wchar_t>
: public numpunct<wchar_t>
{
public:
    typedef wchar_t char_type;
    typedef basic_string<char_type> string_type;

    explicit numpunct_byname(const char* __nm, size_t __refs = 0);
    explicit numpunct_byname(const string& __nm, size_t __refs = 0);

protected:
    ~numpunct_byname();

private:
    void __init(const char*);
};


} }
# 215 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/ios" 2 3
# 224 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/ios" 3


namespace std { inline namespace __1 {

typedef ptrdiff_t streamsize;

class __attribute__ ((__visibility__("default"))) ios_base
{
public:
    class __attribute__ ((__visibility__("default"))) failure;

    typedef unsigned int fmtflags;
    static const fmtflags boolalpha = 0x0001;
    static const fmtflags dec = 0x0002;
    static const fmtflags fixed = 0x0004;
    static const fmtflags hex = 0x0008;
    static const fmtflags internal = 0x0010;
    static const fmtflags left = 0x0020;
    static const fmtflags oct = 0x0040;
    static const fmtflags right = 0x0080;
    static const fmtflags scientific = 0x0100;
    static const fmtflags showbase = 0x0200;
    static const fmtflags showpoint = 0x0400;
    static const fmtflags showpos = 0x0800;
    static const fmtflags skipws = 0x1000;
    static const fmtflags unitbuf = 0x2000;
    static const fmtflags uppercase = 0x4000;
    static const fmtflags adjustfield = left | right | internal;
    static const fmtflags basefield = dec | oct | hex;
    static const fmtflags floatfield = scientific | fixed;

    typedef unsigned int iostate;
    static const iostate badbit = 0x1;
    static const iostate eofbit = 0x2;
    static const iostate failbit = 0x4;
    static const iostate goodbit = 0x0;

    typedef unsigned int openmode;
    static const openmode app = 0x01;
    static const openmode ate = 0x02;
    static const openmode binary = 0x04;
    static const openmode in = 0x08;
    static const openmode out = 0x10;
    static const openmode trunc = 0x20;

    enum seekdir {beg, cur, end};
# 280 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/ios" 3
    class __attribute__ ((__visibility__("default"))) Init;


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) fmtflags flags() const;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) fmtflags flags(fmtflags __fmtfl);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) fmtflags setf(fmtflags __fmtfl);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) fmtflags setf(fmtflags __fmtfl, fmtflags __mask);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) void unsetf(fmtflags __mask);

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) streamsize precision() const;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) streamsize precision(streamsize __prec);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) streamsize width() const;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) streamsize width(streamsize __wide);


    locale imbue(const locale& __loc);
    locale getloc() const;


    static int xalloc();
    long& iword(int __index);
    void*& pword(int __index);


    virtual ~ios_base();


    enum event { erase_event, imbue_event, copyfmt_event };
    typedef void (*event_callback)(event, ios_base&, int __index);
    void register_callback(event_callback __fn, int __index);

private:
    ios_base(const ios_base&);
    ios_base& operator=(const ios_base&);

public:
    static bool sync_with_stdio(bool __sync = true);

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) iostate rdstate() const;
    void clear(iostate __state = goodbit);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) void setstate(iostate __state);

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) bool good() const;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) bool eof() const;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) bool fail() const;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) bool bad() const;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) iostate exceptions() const;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) void exceptions(iostate __iostate);

    void __set_badbit_and_consider_rethrow();
    void __set_failbit_and_consider_rethrow();

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void __setstate_nothrow(iostate __state)
    {
        if (__rdbuf_)
            __rdstate_ |= __state;
        else
            __rdstate_ |= __state | ios_base::badbit;
    }

protected:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    ios_base() {
               }

    void init(void* __sb);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) void* rdbuf() const {return __rdbuf_;}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void rdbuf(void* __sb)
    {
        __rdbuf_ = __sb;
        clear();
    }

    void __call_callbacks(event);
    void copyfmt(const ios_base&);
    void move(ios_base&);
    void swap(ios_base&) noexcept;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void set_rdbuf(void* __sb)
    {
        __rdbuf_ = __sb;
    }

private:

    fmtflags __fmtflags_;
    streamsize __precision_;
    streamsize __width_;
    iostate __rdstate_;
    iostate __exceptions_;
    void* __rdbuf_;
    void* __loc_;
    event_callback* __fn_;
    int* __index_;
    size_t __event_size_;
    size_t __event_cap_;



    static atomic<int> __xindex_;



    long* __iarray_;
    size_t __iarray_size_;
    size_t __iarray_cap_;
    void** __parray_;
    size_t __parray_size_;
    size_t __parray_cap_;
};


enum class __attribute__ ((__type_visibility__("default"))) io_errc
{
    stream = 1
};


template <>
struct __attribute__ ((__type_visibility__("default"))) is_error_code_enum<io_errc> : public true_type { };






__attribute__ ((__visibility__("default")))
const error_category& iostream_category() noexcept;

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
error_code
make_error_code(io_errc __e) noexcept
{
    return error_code(static_cast<int>(__e), iostream_category());
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
error_condition
make_error_condition(io_errc __e) noexcept
{
    return error_condition(static_cast<int>(__e), iostream_category());
}

class __attribute__ ((__visibility__("default"))) ios_base::failure
    : public system_error
{
public:
    explicit failure(const string& __msg, const error_code& __ec = io_errc::stream);
    explicit failure(const char* __msg, const error_code& __ec = io_errc::stream);
    failure(const failure&) noexcept = default;
    virtual ~failure() noexcept;
};

[[noreturn]] inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void __throw_failure(char const* __msg) {

    throw ios_base::failure(__msg);




}

class __attribute__ ((__visibility__("default"))) ios_base::Init
{
public:
    Init();
    ~Init();
};



inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
ios_base::fmtflags
ios_base::flags() const
{
    return __fmtflags_;
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
ios_base::fmtflags
ios_base::flags(fmtflags __fmtfl)
{
    fmtflags __r = __fmtflags_;
    __fmtflags_ = __fmtfl;
    return __r;
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
ios_base::fmtflags
ios_base::setf(fmtflags __fmtfl)
{
    fmtflags __r = __fmtflags_;
    __fmtflags_ |= __fmtfl;
    return __r;
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void
ios_base::unsetf(fmtflags __mask)
{
    __fmtflags_ &= ~__mask;
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
ios_base::fmtflags
ios_base::setf(fmtflags __fmtfl, fmtflags __mask)
{
    fmtflags __r = __fmtflags_;
    unsetf(__mask);
    __fmtflags_ |= __fmtfl & __mask;
    return __r;
}



inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
streamsize
ios_base::precision() const
{
    return __precision_;
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
streamsize
ios_base::precision(streamsize __prec)
{
    streamsize __r = __precision_;
    __precision_ = __prec;
    return __r;
}



inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
streamsize
ios_base::width() const
{
    return __width_;
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
streamsize
ios_base::width(streamsize __wide)
{
    streamsize __r = __width_;
    __width_ = __wide;
    return __r;
}



inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
ios_base::iostate
ios_base::rdstate() const
{
    return __rdstate_;
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void
ios_base::setstate(iostate __state)
{
    clear(__rdstate_ | __state);
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
ios_base::good() const
{
    return __rdstate_ == 0;
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
ios_base::eof() const
{
    return (__rdstate_ & eofbit) != 0;
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
ios_base::fail() const
{
    return (__rdstate_ & (failbit | badbit)) != 0;
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
ios_base::bad() const
{
    return (__rdstate_ & badbit) != 0;
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
ios_base::iostate
ios_base::exceptions() const
{
    return __exceptions_;
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void
ios_base::exceptions(iostate __iostate)
{
    __exceptions_ = __iostate;
    clear(__rdstate_);
}

template <class _CharT, class _Traits>
class __attribute__ ((__type_visibility__("default"))) basic_ios
    : public ios_base
{
public:

    typedef _CharT char_type;
    typedef _Traits traits_type;

    typedef typename traits_type::int_type int_type;
    typedef typename traits_type::pos_type pos_type;
    typedef typename traits_type::off_type off_type;

    static_assert((is_same<_CharT, typename traits_type::char_type>::value),
                  "traits_type::char_type must be the same type as CharT");







    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit operator bool() const {return !fail();}


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) bool operator!() const {return fail();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) iostate rdstate() const {return ios_base::rdstate();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) void clear(iostate __state = goodbit) {ios_base::clear(__state);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) void setstate(iostate __state) {ios_base::setstate(__state);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) bool good() const {return ios_base::good();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) bool eof() const {return ios_base::eof();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) bool fail() const {return ios_base::fail();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) bool bad() const {return ios_base::bad();}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) iostate exceptions() const {return ios_base::exceptions();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) void exceptions(iostate __iostate) {ios_base::exceptions(__iostate);}


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit basic_ios(basic_streambuf<char_type,traits_type>* __sb);
    virtual ~basic_ios();


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    basic_ostream<char_type, traits_type>* tie() const;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    basic_ostream<char_type, traits_type>* tie(basic_ostream<char_type, traits_type>* __tiestr);

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    basic_streambuf<char_type, traits_type>* rdbuf() const;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    basic_streambuf<char_type, traits_type>* rdbuf(basic_streambuf<char_type, traits_type>* __sb);

    basic_ios& copyfmt(const basic_ios& __rhs);

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    char_type fill() const;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    char_type fill(char_type __ch);

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    locale imbue(const locale& __loc);

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    char narrow(char_type __c, char __dfault) const;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    char_type widen(char __c) const;

protected:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    basic_ios() {
                }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void init(basic_streambuf<char_type, traits_type>* __sb);

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void move(basic_ios& __rhs);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void move(basic_ios&& __rhs) {move(__rhs);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void swap(basic_ios& __rhs) noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void set_rdbuf(basic_streambuf<char_type, traits_type>* __sb);
private:
    basic_ostream<char_type, traits_type>* __tie_;
    mutable int_type __fill_;
};

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
basic_ios<_CharT, _Traits>::basic_ios(basic_streambuf<char_type,traits_type>* __sb)
{
    init(__sb);
}

template <class _CharT, class _Traits>
basic_ios<_CharT, _Traits>::~basic_ios()
{
}

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void
basic_ios<_CharT, _Traits>::init(basic_streambuf<char_type, traits_type>* __sb)
{
    ios_base::init(__sb);
    __tie_ = nullptr;
    __fill_ = traits_type::eof();
}

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
basic_ostream<_CharT, _Traits>*
basic_ios<_CharT, _Traits>::tie() const
{
    return __tie_;
}

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
basic_ostream<_CharT, _Traits>*
basic_ios<_CharT, _Traits>::tie(basic_ostream<char_type, traits_type>* __tiestr)
{
    basic_ostream<char_type, traits_type>* __r = __tie_;
    __tie_ = __tiestr;
    return __r;
}

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
basic_streambuf<_CharT, _Traits>*
basic_ios<_CharT, _Traits>::rdbuf() const
{
    return static_cast<basic_streambuf<char_type, traits_type>*>(ios_base::rdbuf());
}

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
basic_streambuf<_CharT, _Traits>*
basic_ios<_CharT, _Traits>::rdbuf(basic_streambuf<char_type, traits_type>* __sb)
{
    basic_streambuf<char_type, traits_type>* __r = rdbuf();
    ios_base::rdbuf(__sb);
    return __r;
}

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
locale
basic_ios<_CharT, _Traits>::imbue(const locale& __loc)
{
    locale __r = getloc();
    ios_base::imbue(__loc);
    if (rdbuf())
        rdbuf()->pubimbue(__loc);
    return __r;
}

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
char
basic_ios<_CharT, _Traits>::narrow(char_type __c, char __dfault) const
{
    return use_facet<ctype<char_type> >(getloc()).narrow(__c, __dfault);
}

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
_CharT
basic_ios<_CharT, _Traits>::widen(char __c) const
{
    return use_facet<ctype<char_type> >(getloc()).widen(__c);
}

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
_CharT
basic_ios<_CharT, _Traits>::fill() const
{
    if (traits_type::eq_int_type(traits_type::eof(), __fill_))
        __fill_ = widen(' ');
    return __fill_;
}

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
_CharT
basic_ios<_CharT, _Traits>::fill(char_type __ch)
{
    char_type __r = __fill_;
    __fill_ = __ch;
    return __r;
}

template <class _CharT, class _Traits>
basic_ios<_CharT, _Traits>&
basic_ios<_CharT, _Traits>::copyfmt(const basic_ios& __rhs)
{
    if (this != &__rhs)
    {
        __call_callbacks(erase_event);
        ios_base::copyfmt(__rhs);
        __tie_ = __rhs.__tie_;
        __fill_ = __rhs.__fill_;
        __call_callbacks(copyfmt_event);
        exceptions(__rhs.exceptions());
    }
    return *this;
}

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void
basic_ios<_CharT, _Traits>::move(basic_ios& __rhs)
{
    ios_base::move(__rhs);
    __tie_ = __rhs.__tie_;
    __rhs.__tie_ = nullptr;
    __fill_ = __rhs.__fill_;
}

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void
basic_ios<_CharT, _Traits>::swap(basic_ios& __rhs) noexcept
{
    ios_base::swap(__rhs);
    std::__1::swap(__tie_, __rhs.__tie_);
    std::__1::swap(__fill_, __rhs.__fill_);
}

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void
basic_ios<_CharT, _Traits>::set_rdbuf(basic_streambuf<char_type, traits_type>* __sb)
{
    ios_base::set_rdbuf(__sb);
}

inline
ios_base&
boolalpha(ios_base& __str)
{
    __str.setf(ios_base::boolalpha);
    return __str;
}

inline
ios_base&
noboolalpha(ios_base& __str)
{
    __str.unsetf(ios_base::boolalpha);
    return __str;
}

inline
ios_base&
showbase(ios_base& __str)
{
    __str.setf(ios_base::showbase);
    return __str;
}

inline
ios_base&
noshowbase(ios_base& __str)
{
    __str.unsetf(ios_base::showbase);
    return __str;
}

inline
ios_base&
showpoint(ios_base& __str)
{
    __str.setf(ios_base::showpoint);
    return __str;
}

inline
ios_base&
noshowpoint(ios_base& __str)
{
    __str.unsetf(ios_base::showpoint);
    return __str;
}

inline
ios_base&
showpos(ios_base& __str)
{
    __str.setf(ios_base::showpos);
    return __str;
}

inline
ios_base&
noshowpos(ios_base& __str)
{
    __str.unsetf(ios_base::showpos);
    return __str;
}

inline
ios_base&
skipws(ios_base& __str)
{
    __str.setf(ios_base::skipws);
    return __str;
}

inline
ios_base&
noskipws(ios_base& __str)
{
    __str.unsetf(ios_base::skipws);
    return __str;
}

inline
ios_base&
uppercase(ios_base& __str)
{
    __str.setf(ios_base::uppercase);
    return __str;
}

inline
ios_base&
nouppercase(ios_base& __str)
{
    __str.unsetf(ios_base::uppercase);
    return __str;
}

inline
ios_base&
unitbuf(ios_base& __str)
{
    __str.setf(ios_base::unitbuf);
    return __str;
}

inline
ios_base&
nounitbuf(ios_base& __str)
{
    __str.unsetf(ios_base::unitbuf);
    return __str;
}

inline
ios_base&
internal(ios_base& __str)
{
    __str.setf(ios_base::internal, ios_base::adjustfield);
    return __str;
}

inline
ios_base&
left(ios_base& __str)
{
    __str.setf(ios_base::left, ios_base::adjustfield);
    return __str;
}

inline
ios_base&
right(ios_base& __str)
{
    __str.setf(ios_base::right, ios_base::adjustfield);
    return __str;
}

inline
ios_base&
dec(ios_base& __str)
{
    __str.setf(ios_base::dec, ios_base::basefield);
    return __str;
}

inline
ios_base&
hex(ios_base& __str)
{
    __str.setf(ios_base::hex, ios_base::basefield);
    return __str;
}

inline
ios_base&
oct(ios_base& __str)
{
    __str.setf(ios_base::oct, ios_base::basefield);
    return __str;
}

inline
ios_base&
fixed(ios_base& __str)
{
    __str.setf(ios_base::fixed, ios_base::floatfield);
    return __str;
}

inline
ios_base&
scientific(ios_base& __str)
{
    __str.setf(ios_base::scientific, ios_base::floatfield);
    return __str;
}

inline
ios_base&
hexfloat(ios_base& __str)
{
    __str.setf(ios_base::fixed | ios_base::scientific, ios_base::floatfield);
    return __str;
}

inline
ios_base&
defaultfloat(ios_base& __str)
{
    __str.unsetf(ios_base::floatfield);
    return __str;
}

} }
# 139 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/ostream" 2 3

# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/locale" 1 3
# 203 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/locale" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/memory" 1 3
# 974 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/memory" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 1 3
# 20 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/assert.h" 1 3 4
# 44 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/assert.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/stdlib.h" 1 3 4
# 45 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/assert.h" 2 3 4
# 81 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/assert.h" 3 4
extern "C" {
void __assert_rtn(const char *, const char *, int, const char *) __attribute__((__noreturn__)) __attribute__((__cold__)) __attribute__((__disable_tail_calls__));



}
# 21 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 2 3
# 24 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 3
# 975 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/memory" 2 3
# 204 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/locale" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/streambuf" 1 3
# 116 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/streambuf" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 120 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/streambuf" 2 3

namespace std { inline namespace __1 {

template <class _CharT, class _Traits>
class __attribute__ ((__type_visibility__("default"))) basic_streambuf
{
public:

    typedef _CharT char_type;
    typedef _Traits traits_type;
    typedef typename traits_type::int_type int_type;
    typedef typename traits_type::pos_type pos_type;
    typedef typename traits_type::off_type off_type;

    static_assert((is_same<_CharT, typename traits_type::char_type>::value),
                  "traits_type::char_type must be the same type as CharT");

    virtual ~basic_streambuf();


    inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    locale pubimbue(const locale& __loc) {
        imbue(__loc);
        locale __r = __loc_;
        __loc_ = __loc;
        return __r;
    }

    inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    locale getloc() const { return __loc_; }


    inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    basic_streambuf* pubsetbuf(char_type* __s, streamsize __n)
    { return setbuf(__s, __n); }

    inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    pos_type pubseekoff(off_type __off, ios_base::seekdir __way,
                        ios_base::openmode __which = ios_base::in | ios_base::out)
    { return seekoff(__off, __way, __which); }

    inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    pos_type pubseekpos(pos_type __sp,
                        ios_base::openmode __which = ios_base::in | ios_base::out)
    { return seekpos(__sp, __which); }

    inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    int pubsync() { return sync(); }



    inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    streamsize in_avail() {
        if (__ninp_ < __einp_)
            return static_cast<streamsize>(__einp_ - __ninp_);
        return showmanyc();
    }

    inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    int_type snextc() {
        if (sbumpc() == traits_type::eof())
            return traits_type::eof();
        return sgetc();
    }

    inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    int_type sbumpc() {
        if (__ninp_ == __einp_)
            return uflow();
        return traits_type::to_int_type(*__ninp_++);
    }

    inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    int_type sgetc() {
        if (__ninp_ == __einp_)
            return underflow();
        return traits_type::to_int_type(*__ninp_);
    }

    inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    streamsize sgetn(char_type* __s, streamsize __n)
    { return xsgetn(__s, __n); }


    inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    int_type sputbackc(char_type __c) {
        if (__binp_ == __ninp_ || !traits_type::eq(__c, __ninp_[-1]))
            return pbackfail(traits_type::to_int_type(__c));
        return traits_type::to_int_type(*--__ninp_);
    }

    inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    int_type sungetc() {
        if (__binp_ == __ninp_)
          return pbackfail();
        return traits_type::to_int_type(*--__ninp_);
    }


    inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    int_type sputc(char_type __c) {
        if (__nout_ == __eout_)
            return overflow(traits_type::to_int_type(__c));
        *__nout_++ = __c;
        return traits_type::to_int_type(__c);
    }

    inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    streamsize sputn(const char_type* __s, streamsize __n)
    { return xsputn(__s, __n); }

protected:
    basic_streambuf();
    basic_streambuf(const basic_streambuf& __rhs);
    basic_streambuf& operator=(const basic_streambuf& __rhs);
    void swap(basic_streambuf& __rhs);


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) char_type* eback() const {return __binp_;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) char_type* gptr() const {return __ninp_;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) char_type* egptr() const {return __einp_;}

    inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void gbump(int __n) { __ninp_ += __n; }

    inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void setg(char_type* __gbeg, char_type* __gnext, char_type* __gend) {
        __binp_ = __gbeg;
        __ninp_ = __gnext;
        __einp_ = __gend;
    }


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) char_type* pbase() const {return __bout_;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) char_type* pptr() const {return __nout_;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) char_type* epptr() const {return __eout_;}

    inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void pbump(int __n) { __nout_ += __n; }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void __pbump(streamsize __n) { __nout_ += __n; }

    inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void setp(char_type* __pbeg, char_type* __pend) {
        __bout_ = __nout_ = __pbeg;
        __eout_ = __pend;
    }



    virtual void imbue(const locale& __loc);


    virtual basic_streambuf* setbuf(char_type* __s, streamsize __n);
    virtual pos_type seekoff(off_type __off, ios_base::seekdir __way,
                             ios_base::openmode __which = ios_base::in | ios_base::out);
    virtual pos_type seekpos(pos_type __sp,
                             ios_base::openmode __which = ios_base::in | ios_base::out);
    virtual int sync();


    virtual streamsize showmanyc();
    virtual streamsize xsgetn(char_type* __s, streamsize __n);
    virtual int_type underflow();
    virtual int_type uflow();


    virtual int_type pbackfail(int_type __c = traits_type::eof());


    virtual streamsize xsputn(const char_type* __s, streamsize __n);
    virtual int_type overflow(int_type __c = traits_type::eof());

private:
    locale __loc_;
    char_type* __binp_;
    char_type* __ninp_;
    char_type* __einp_;
    char_type* __bout_;
    char_type* __nout_;
    char_type* __eout_;
};

template <class _CharT, class _Traits>
basic_streambuf<_CharT, _Traits>::~basic_streambuf()
{
}

template <class _CharT, class _Traits>
basic_streambuf<_CharT, _Traits>::basic_streambuf()
    : __binp_(nullptr),
      __ninp_(nullptr),
      __einp_(nullptr),
      __bout_(nullptr),
      __nout_(nullptr),
      __eout_(nullptr)
{
}

template <class _CharT, class _Traits>
basic_streambuf<_CharT, _Traits>::basic_streambuf(const basic_streambuf& __sb)
    : __loc_(__sb.__loc_),
      __binp_(__sb.__binp_),
      __ninp_(__sb.__ninp_),
      __einp_(__sb.__einp_),
      __bout_(__sb.__bout_),
      __nout_(__sb.__nout_),
      __eout_(__sb.__eout_)
{
}

template <class _CharT, class _Traits>
basic_streambuf<_CharT, _Traits>&
basic_streambuf<_CharT, _Traits>::operator=(const basic_streambuf& __sb)
{
    __loc_ = __sb.__loc_;
    __binp_ = __sb.__binp_;
    __ninp_ = __sb.__ninp_;
    __einp_ = __sb.__einp_;
    __bout_ = __sb.__bout_;
    __nout_ = __sb.__nout_;
    __eout_ = __sb.__eout_;
    return *this;
}

template <class _CharT, class _Traits>
void
basic_streambuf<_CharT, _Traits>::swap(basic_streambuf& __sb)
{
    std::__1::swap(__loc_, __sb.__loc_);
    std::__1::swap(__binp_, __sb.__binp_);
    std::__1::swap(__ninp_, __sb.__ninp_);
    std::__1::swap(__einp_, __sb.__einp_);
    std::__1::swap(__bout_, __sb.__bout_);
    std::__1::swap(__nout_, __sb.__nout_);
    std::__1::swap(__eout_, __sb.__eout_);
}

template <class _CharT, class _Traits>
void
basic_streambuf<_CharT, _Traits>::imbue(const locale&)
{
}

template <class _CharT, class _Traits>
basic_streambuf<_CharT, _Traits>*
basic_streambuf<_CharT, _Traits>::setbuf(char_type*, streamsize)
{
    return this;
}

template <class _CharT, class _Traits>
typename basic_streambuf<_CharT, _Traits>::pos_type
basic_streambuf<_CharT, _Traits>::seekoff(off_type, ios_base::seekdir,
                                          ios_base::openmode)
{
    return pos_type(off_type(-1));
}

template <class _CharT, class _Traits>
typename basic_streambuf<_CharT, _Traits>::pos_type
basic_streambuf<_CharT, _Traits>::seekpos(pos_type, ios_base::openmode)
{
    return pos_type(off_type(-1));
}

template <class _CharT, class _Traits>
int
basic_streambuf<_CharT, _Traits>::sync()
{
    return 0;
}

template <class _CharT, class _Traits>
streamsize
basic_streambuf<_CharT, _Traits>::showmanyc()
{
    return 0;
}

template <class _CharT, class _Traits>
streamsize
basic_streambuf<_CharT, _Traits>::xsgetn(char_type* __s, streamsize __n)
{
    const int_type __eof = traits_type::eof();
    int_type __c;
    streamsize __i = 0;
    while(__i < __n)
    {
        if (__ninp_ < __einp_)
        {
            const streamsize __len = std::__1::min(static_cast<streamsize>(2147483647),
                                std::__1::min(__einp_ - __ninp_, __n - __i));
            traits_type::copy(__s, __ninp_, __len);
            __s += __len;
            __i += __len;
            this->gbump(__len);
        }
        else if ((__c = uflow()) != __eof)
        {
            *__s = traits_type::to_char_type(__c);
            ++__s;
            ++__i;
        }
        else
            break;
    }
    return __i;
}

template <class _CharT, class _Traits>
typename basic_streambuf<_CharT, _Traits>::int_type
basic_streambuf<_CharT, _Traits>::underflow()
{
    return traits_type::eof();
}

template <class _CharT, class _Traits>
typename basic_streambuf<_CharT, _Traits>::int_type
basic_streambuf<_CharT, _Traits>::uflow()
{
    if (underflow() == traits_type::eof())
        return traits_type::eof();
    return traits_type::to_int_type(*__ninp_++);
}

template <class _CharT, class _Traits>
typename basic_streambuf<_CharT, _Traits>::int_type
basic_streambuf<_CharT, _Traits>::pbackfail(int_type)
{
    return traits_type::eof();
}

template <class _CharT, class _Traits>
streamsize
basic_streambuf<_CharT, _Traits>::xsputn(const char_type* __s, streamsize __n)
{
    streamsize __i = 0;
    int_type __eof = traits_type::eof();
    while( __i < __n)
    {
        if (__nout_ >= __eout_)
        {
            if (overflow(traits_type::to_int_type(*__s)) == __eof)
                break;
            ++__s;
            ++__i;
        }
        else
        {
            streamsize __chunk_size = std::__1::min(__eout_ - __nout_, __n - __i);
            traits_type::copy(__nout_, __s, __chunk_size);
            __nout_ += __chunk_size;
            __s += __chunk_size;
            __i += __chunk_size;
        }
    }
    return __i;
}

template <class _CharT, class _Traits>
typename basic_streambuf<_CharT, _Traits>::int_type
basic_streambuf<_CharT, _Traits>::overflow(int_type)
{
    return traits_type::eof();
}

extern template class __attribute__ ((__visibility__("default"))) basic_streambuf<char>;
extern template class __attribute__ ((__visibility__("default"))) basic_streambuf<wchar_t>;

extern template class __attribute__ ((__visibility__("default"))) basic_ios<char>;
extern template class __attribute__ ((__visibility__("default"))) basic_ios<wchar_t>;

} }
# 205 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/locale" 2 3






# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/nl_types.h" 1 3 4
# 45 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/nl_types.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/types.h" 1 3 4
# 84 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/types.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_u_char.h" 1 3 4
# 30 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_u_char.h" 3 4
typedef unsigned char u_char;
# 85 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/types.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_u_short.h" 1 3 4
# 30 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_u_short.h" 3 4
typedef unsigned short u_short;
# 86 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/types.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_u_int.h" 1 3 4
# 30 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_u_int.h" 3 4
typedef unsigned int u_int;
# 87 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/types.h" 2 3 4

typedef unsigned long u_long;


typedef unsigned short ushort;
typedef unsigned int uint;


typedef u_int64_t u_quad_t;
typedef int64_t quad_t;
typedef quad_t * qaddr_t;

# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_caddr_t.h" 1 3 4
# 30 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_caddr_t.h" 3 4
typedef char * caddr_t;
# 100 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/types.h" 2 3 4

typedef int32_t daddr_t;



typedef u_int32_t fixpt_t;

# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_blkcnt_t.h" 1 3 4
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_blkcnt_t.h" 3 4
typedef __darwin_blkcnt_t blkcnt_t;
# 108 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/types.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_blksize_t.h" 1 3 4
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_blksize_t.h" 3 4
typedef __darwin_blksize_t blksize_t;
# 109 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/types.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_gid_t.h" 1 3 4
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_gid_t.h" 3 4
typedef __darwin_gid_t gid_t;
# 110 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/types.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_in_addr_t.h" 1 3 4
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_in_addr_t.h" 3 4
typedef __uint32_t in_addr_t;
# 111 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/types.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_in_port_t.h" 1 3 4
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_in_port_t.h" 3 4
typedef __uint16_t in_port_t;
# 112 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/types.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_ino_t.h" 1 3 4
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_ino_t.h" 3 4
typedef __darwin_ino_t ino_t;
# 113 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/types.h" 2 3 4


# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_ino64_t.h" 1 3 4
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_ino64_t.h" 3 4
typedef __darwin_ino64_t ino64_t;
# 116 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/types.h" 2 3 4


# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_key_t.h" 1 3 4
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_key_t.h" 3 4
typedef __int32_t key_t;
# 119 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/types.h" 2 3 4

# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_nlink_t.h" 1 3 4
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_nlink_t.h" 3 4
typedef __uint16_t nlink_t;
# 121 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/types.h" 2 3 4




typedef int32_t segsz_t;
typedef int32_t swblk_t;
# 138 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/types.h" 3 4
static inline __int32_t
major(__uint32_t _x)
{
 return (__int32_t)(((__uint32_t)_x >> 24) & 0xff);
}

static inline __int32_t
minor(__uint32_t _x)
{
 return (__int32_t)((_x) & 0xffffff);
}

static inline dev_t
makedev(__uint32_t _major, __uint32_t _minor)
{
 return (dev_t)(((_major) << 24) | (_minor));
}
# 170 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/types.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_useconds_t.h" 1 3 4
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_useconds_t.h" 3 4
typedef __darwin_useconds_t useconds_t;
# 171 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/types.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_suseconds_t.h" 1 3 4
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_suseconds_t.h" 3 4
typedef __darwin_suseconds_t suseconds_t;
# 172 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/types.h" 2 3 4


# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_rsize_t.h" 1 3 4
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_rsize_t.h" 3 4
typedef __darwin_size_t rsize_t;
# 175 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/types.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_errno_t.h" 1 3 4
# 30 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_errno_t.h" 3 4
typedef int errno_t;
# 176 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/types.h" 2 3 4








# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_fd_def.h" 1 3 4
# 49 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_fd_def.h" 3 4
extern "C" {
typedef struct fd_set {
 __int32_t fds_bits[((((1024) % ((sizeof(__int32_t) * 8))) == 0) ? ((1024) / ((sizeof(__int32_t) * 8))) : (((1024) / ((sizeof(__int32_t) * 8))) + 1))];
} fd_set;

int __darwin_check_fd_set_overflow(int, const void *, int) __attribute__((availability(macosx,introduced=11.0))) __attribute__((availability(ios,introduced=14.0))) __attribute__((availability(tvos,introduced=14.0))) __attribute__((availability(watchos,introduced=7.0)));
}

inline __attribute__ ((__always_inline__)) int
__darwin_check_fd_set(int _a, const void *_b)
{

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunguarded-availability-new"

 if ((uintptr_t)&__darwin_check_fd_set_overflow != (uintptr_t) 0) {



  return __darwin_check_fd_set_overflow(_a, _b, 0);

 } else {
  return 1;
 }

#pragma clang diagnostic pop

}


inline __attribute__ ((__always_inline__)) int
__darwin_fd_isset(int _fd, const struct fd_set *_p)
{
 if (__darwin_check_fd_set(_fd, (const void *) _p)) {
  return _p->fds_bits[(unsigned long)_fd / (sizeof(__int32_t) * 8)] & ((__int32_t)(((unsigned long)1) << ((unsigned long)_fd % (sizeof(__int32_t) * 8))));
 }

 return 0;
}

inline __attribute__ ((__always_inline__)) void
__darwin_fd_set(int _fd, struct fd_set *const _p)
{
 if (__darwin_check_fd_set(_fd, (const void *) _p)) {
  (_p->fds_bits[(unsigned long)_fd / (sizeof(__int32_t) * 8)] |= ((__int32_t)(((unsigned long)1) << ((unsigned long)_fd % (sizeof(__int32_t) * 8)))));
 }
}

inline __attribute__ ((__always_inline__)) void
__darwin_fd_clr(int _fd, struct fd_set *const _p)
{
 if (__darwin_check_fd_set(_fd, (const void *) _p)) {
  (_p->fds_bits[(unsigned long)_fd / (sizeof(__int32_t) * 8)] &= ~((__int32_t)(((unsigned long)1) << ((unsigned long)_fd % (sizeof(__int32_t) * 8)))));
 }
}
# 185 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/types.h" 2 3 4




typedef __int32_t fd_mask;







# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_fd_setsize.h" 1 3 4
# 198 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/types.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_fd_set.h" 1 3 4
# 199 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/types.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_fd_clr.h" 1 3 4
# 200 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/types.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_fd_zero.h" 1 3 4
# 201 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/types.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_fd_isset.h" 1 3 4
# 202 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/types.h" 2 3 4


# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_fd_copy.h" 1 3 4
# 205 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/types.h" 2 3 4
# 232 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/types.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_fsblkcnt_t.h" 1 3 4
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_fsblkcnt_t.h" 3 4
typedef __darwin_fsblkcnt_t fsblkcnt_t;
# 233 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/types.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_fsfilcnt_t.h" 1 3 4
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_fsfilcnt_t.h" 3 4
typedef __darwin_fsfilcnt_t fsfilcnt_t;
# 234 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/types.h" 2 3 4
# 46 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/nl_types.h" 2 3 4
# 89 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/nl_types.h" 3 4
typedef struct __nl_cat_d {
 void *__data;
 int __size;
} *nl_catd;

# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/_types/_nl_item.h" 1 3 4
# 32 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/_types/_nl_item.h" 3 4
typedef __darwin_nl_item nl_item;
# 95 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/nl_types.h" 2 3 4

extern "C" {
nl_catd catopen(const char *, int);
char *catgets(nl_catd, int, int, const char *)
 __attribute__((__format_arg__(4)));
int catclose(nl_catd);
}
# 212 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/locale" 2 3




# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__bsd_locale_defaults.h" 1 3
# 19 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__bsd_locale_defaults.h" 3
# 217 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/locale" 2 3
# 223 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/locale" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 227 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/locale" 2 3


namespace std { inline namespace __1 {
# 260 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/locale" 3
template <class _InputIterator, class _ForwardIterator, class _Ctype>
__attribute__ ((__visibility__("hidden")))
_ForwardIterator
__scan_keyword(_InputIterator& __b, _InputIterator __e,
               _ForwardIterator __kb, _ForwardIterator __ke,
               const _Ctype& __ct, ios_base::iostate& __err,
               bool __case_sensitive = true)
{
    typedef typename iterator_traits<_InputIterator>::value_type _CharT;
    size_t __nkw = static_cast<size_t>(std::__1::distance(__kb, __ke));
    const unsigned char __doesnt_match = '\0';
    const unsigned char __might_match = '\1';
    const unsigned char __does_match = '\2';
    unsigned char __statbuf[100];
    unsigned char* __status = __statbuf;
    unique_ptr<unsigned char, void(*)(void*)> __stat_hold(nullptr, free);
    if (__nkw > sizeof(__statbuf))
    {
        __status = (unsigned char*)malloc(__nkw);
        if (__status == nullptr)
            __throw_bad_alloc();
        __stat_hold.reset(__status);
    }
    size_t __n_might_match = __nkw;
    size_t __n_does_match = 0;

    unsigned char* __st = __status;
    for (_ForwardIterator __ky = __kb; __ky != __ke; ++__ky, (void) ++__st)
    {
        if (!__ky->empty())
            *__st = __might_match;
        else
        {
            *__st = __does_match;
            --__n_might_match;
            ++__n_does_match;
        }
    }

    for (size_t __indx = 0; __b != __e && __n_might_match > 0; ++__indx)
    {

        _CharT __c = *__b;
        if (!__case_sensitive)
            __c = __ct.toupper(__c);
        bool __consume = false;






        __st = __status;
        for (_ForwardIterator __ky = __kb; __ky != __ke; ++__ky, (void) ++__st)
        {
            if (*__st == __might_match)
            {
                _CharT __kc = (*__ky)[__indx];
                if (!__case_sensitive)
                    __kc = __ct.toupper(__kc);
                if (__c == __kc)
                {
                    __consume = true;
                    if (__ky->size() == __indx+1)
                    {
                        *__st = __does_match;
                        --__n_might_match;
                        ++__n_does_match;
                    }
                }
                else
                {
                    *__st = __doesnt_match;
                    --__n_might_match;
                }
            }
        }

        if (__consume)
        {
            ++__b;



            if (__n_might_match + __n_does_match > 1)
            {
                __st = __status;
                for (_ForwardIterator __ky = __kb; __ky != __ke; ++__ky, (void) ++__st)
                {
                    if (*__st == __does_match && __ky->size() != __indx+1)
                    {
                        *__st = __doesnt_match;
                        --__n_does_match;
                    }
                }
            }
        }
    }

    if (__b == __e)
        __err |= ios_base::eofbit;

    for (__st = __status; __kb != __ke; ++__kb, (void) ++__st)
        if (*__st == __does_match)
            break;
    if (__kb == __ke)
        __err |= ios_base::failbit;
    return __kb;
}

struct __attribute__ ((__visibility__("default"))) __num_get_base
{
    static const int __num_get_buf_sz = 40;

    static int __get_base(ios_base&);
    static const char __src[33];
};

__attribute__ ((__visibility__("default")))
void __check_grouping(const string& __grouping, unsigned* __g, unsigned* __g_end,
                      ios_base::iostate& __err);

template <class _CharT>
struct __num_get
    : protected __num_get_base
{
    static string __stage2_float_prep(ios_base& __iob, _CharT* __atoms, _CharT& __decimal_point,
                                      _CharT& __thousands_sep);

    static int __stage2_float_loop(_CharT __ct, bool& __in_units, char& __exp,
                                   char* __a, char*& __a_end,
                                   _CharT __decimal_point, _CharT __thousands_sep,
                                   const string& __grouping, unsigned* __g,
                                   unsigned*& __g_end, unsigned& __dc, _CharT* __atoms);

    static string __stage2_int_prep(ios_base& __iob, _CharT* __atoms, _CharT& __thousands_sep);
    static int __stage2_int_loop(_CharT __ct, int __base, char* __a, char*& __a_end,
                  unsigned& __dc, _CharT __thousands_sep, const string& __grouping,
                  unsigned* __g, unsigned*& __g_end, _CharT* __atoms);
# 434 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/locale" 3
};


template <class _CharT>
string
__num_get<_CharT>::__stage2_int_prep(ios_base& __iob, _CharT* __atoms, _CharT& __thousands_sep)
{
    locale __loc = __iob.getloc();
    use_facet<ctype<_CharT> >(__loc).widen(__src, __src + 26, __atoms);
    const numpunct<_CharT>& __np = use_facet<numpunct<_CharT> >(__loc);
    __thousands_sep = __np.thousands_sep();
    return __np.grouping();
}


template <class _CharT>
string
__num_get<_CharT>::__stage2_float_prep(ios_base& __iob, _CharT* __atoms, _CharT& __decimal_point,
                    _CharT& __thousands_sep)
{
    locale __loc = __iob.getloc();
    use_facet<ctype<_CharT> >(__loc).widen(__src, __src + 32, __atoms);
    const numpunct<_CharT>& __np = use_facet<numpunct<_CharT> >(__loc);
    __decimal_point = __np.decimal_point();
    __thousands_sep = __np.thousands_sep();
    return __np.grouping();
}

template <class _CharT>
int

__num_get<_CharT>::__stage2_int_loop(_CharT __ct, int __base, char* __a, char*& __a_end,
                  unsigned& __dc, _CharT __thousands_sep, const string& __grouping,
                  unsigned* __g, unsigned*& __g_end, _CharT* __atoms)






{
    if (__a_end == __a && (__ct == __atoms[24] || __ct == __atoms[25]))
    {
        *__a_end++ = __ct == __atoms[24] ? '+' : '-';
        __dc = 0;
        return 0;
    }
    if (__grouping.size() != 0 && __ct == __thousands_sep)
    {
        if (__g_end-__g < __num_get_buf_sz)
        {
            *__g_end++ = __dc;
            __dc = 0;
        }
        return 0;
    }
    ptrdiff_t __f = find(__atoms, __atoms + 26, __ct) - __atoms;
    if (__f >= 24)
        return -1;
    switch (__base)
    {
    case 8:
    case 10:
        if (__f >= __base)
            return -1;
        break;
    case 16:
        if (__f < 22)
            break;
        if (__a_end != __a && __a_end - __a <= 2 && __a_end[-1] == '0')
        {
            __dc = 0;
            *__a_end++ = __src[__f];
            return 0;
        }
        return -1;
    }
    *__a_end++ = __src[__f];
    ++__dc;
    return 0;
}

template <class _CharT>
int
__num_get<_CharT>::__stage2_float_loop(_CharT __ct, bool& __in_units, char& __exp, char* __a, char*& __a_end,
                    _CharT __decimal_point, _CharT __thousands_sep, const string& __grouping,
                    unsigned* __g, unsigned*& __g_end, unsigned& __dc, _CharT* __atoms)
{
    if (__ct == __decimal_point)
    {
        if (!__in_units)
            return -1;
        __in_units = false;
        *__a_end++ = '.';
        if (__grouping.size() != 0 && __g_end-__g < __num_get_buf_sz)
            *__g_end++ = __dc;
        return 0;
    }
    if (__ct == __thousands_sep && __grouping.size() != 0)
    {
        if (!__in_units)
            return -1;
        if (__g_end-__g < __num_get_buf_sz)
        {
            *__g_end++ = __dc;
            __dc = 0;
        }
        return 0;
    }
    ptrdiff_t __f = find(__atoms, __atoms + 32, __ct) - __atoms;
    if (__f >= 32)
        return -1;
    char __x = __src[__f];
    if (__x == '-' || __x == '+')
    {
        if (__a_end == __a || (__a_end[-1] & 0x5F) == (__exp & 0x7F))
        {
            *__a_end++ = __x;
            return 0;
        }
        return -1;
    }
    if (__x == 'x' || __x == 'X')
        __exp = 'P';
    else if ((__x & 0x5F) == __exp)
    {
        __exp |= (char) 0x80;
        if (__in_units)
        {
            __in_units = false;
            if (__grouping.size() != 0 && __g_end-__g < __num_get_buf_sz)
                *__g_end++ = __dc;
        }
    }
    *__a_end++ = __x;
    if (__f >= 22)
        return 0;
    ++__dc;
    return 0;
}

extern template struct __attribute__ ((__visibility__("default"))) __num_get<char>;

extern template struct __attribute__ ((__visibility__("default"))) __num_get<wchar_t>;


template <class _CharT, class _InputIterator = istreambuf_iterator<_CharT> >
class __attribute__ ((__type_visibility__("default"))) num_get
    : public locale::facet,
      private __num_get<_CharT>
{
public:
    typedef _CharT char_type;
    typedef _InputIterator iter_type;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit num_get(size_t __refs = 0)
        : locale::facet(__refs) {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,
                  ios_base::iostate& __err, bool& __v) const
    {
        return do_get(__b, __e, __iob, __err, __v);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,
                  ios_base::iostate& __err, long& __v) const
    {
        return do_get(__b, __e, __iob, __err, __v);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,
                  ios_base::iostate& __err, long long& __v) const
    {
        return do_get(__b, __e, __iob, __err, __v);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,
                  ios_base::iostate& __err, unsigned short& __v) const
    {
        return do_get(__b, __e, __iob, __err, __v);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,
                  ios_base::iostate& __err, unsigned int& __v) const
    {
        return do_get(__b, __e, __iob, __err, __v);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,
                  ios_base::iostate& __err, unsigned long& __v) const
    {
        return do_get(__b, __e, __iob, __err, __v);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,
                  ios_base::iostate& __err, unsigned long long& __v) const
    {
        return do_get(__b, __e, __iob, __err, __v);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,
                  ios_base::iostate& __err, float& __v) const
    {
        return do_get(__b, __e, __iob, __err, __v);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,
                  ios_base::iostate& __err, double& __v) const
    {
        return do_get(__b, __e, __iob, __err, __v);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,
                  ios_base::iostate& __err, long double& __v) const
    {
        return do_get(__b, __e, __iob, __err, __v);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,
                  ios_base::iostate& __err, void*& __v) const
    {
        return do_get(__b, __e, __iob, __err, __v);
    }

    static locale::id id;

protected:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    ~num_get() {}

    template <class _Fp>
    inline __attribute__ ((__visibility__("hidden")))
    iter_type __do_get_floating_point
                            (iter_type __b, iter_type __e, ios_base& __iob,
                             ios_base::iostate& __err, _Fp& __v) const;

    template <class _Signed>
    inline __attribute__ ((__visibility__("hidden")))
    iter_type __do_get_signed
                            (iter_type __b, iter_type __e, ios_base& __iob,
                             ios_base::iostate& __err, _Signed& __v) const;

    template <class _Unsigned>
    inline __attribute__ ((__visibility__("hidden")))
    iter_type __do_get_unsigned
                            (iter_type __b, iter_type __e, ios_base& __iob,
                             ios_base::iostate& __err, _Unsigned& __v) const;


    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,
                             ios_base::iostate& __err, bool& __v) const;

    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,
                             ios_base::iostate& __err, long& __v) const
    { return this->__do_get_signed ( __b, __e, __iob, __err, __v ); }

    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,
                             ios_base::iostate& __err, long long& __v) const
    { return this->__do_get_signed ( __b, __e, __iob, __err, __v ); }

    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,
                             ios_base::iostate& __err, unsigned short& __v) const
    { return this->__do_get_unsigned ( __b, __e, __iob, __err, __v ); }

    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,
                             ios_base::iostate& __err, unsigned int& __v) const
    { return this->__do_get_unsigned ( __b, __e, __iob, __err, __v ); }

    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,
                             ios_base::iostate& __err, unsigned long& __v) const
    { return this->__do_get_unsigned ( __b, __e, __iob, __err, __v ); }

    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,
                             ios_base::iostate& __err, unsigned long long& __v) const
    { return this->__do_get_unsigned ( __b, __e, __iob, __err, __v ); }

    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,
                             ios_base::iostate& __err, float& __v) const
    { return this->__do_get_floating_point ( __b, __e, __iob, __err, __v ); }

    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,
                             ios_base::iostate& __err, double& __v) const
    { return this->__do_get_floating_point ( __b, __e, __iob, __err, __v ); }

    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,
                             ios_base::iostate& __err, long double& __v) const
    { return this->__do_get_floating_point ( __b, __e, __iob, __err, __v ); }

    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,
                             ios_base::iostate& __err, void*& __v) const;
};

template <class _CharT, class _InputIterator>
locale::id
num_get<_CharT, _InputIterator>::id;

template <class _Tp>
__attribute__ ((__visibility__("hidden"))) _Tp
__num_get_signed_integral(const char* __a, const char* __a_end,
                          ios_base::iostate& __err, int __base)
{
    if (__a != __a_end)
    {
        typename remove_reference<decltype((*__error()))>::type __save_errno = (*__error());
        (*__error()) = 0;
        char *__p2;
        long long __ll = strtoll_l(__a, &__p2, __base, 0);
        typename remove_reference<decltype((*__error()))>::type __current_errno = (*__error());
        if (__current_errno == 0)
            (*__error()) = __save_errno;
        if (__p2 != __a_end)
        {
            __err = ios_base::failbit;
            return 0;
        }
        else if (__current_errno == 34 ||
                 __ll < numeric_limits<_Tp>::min() ||
                 numeric_limits<_Tp>::max() < __ll)
        {
            __err = ios_base::failbit;
            if (__ll > 0)
                return numeric_limits<_Tp>::max();
            else
                return numeric_limits<_Tp>::min();
        }
        return static_cast<_Tp>(__ll);
    }
    __err = ios_base::failbit;
    return 0;
}

template <class _Tp>
__attribute__ ((__visibility__("hidden"))) _Tp
__num_get_unsigned_integral(const char* __a, const char* __a_end,
                            ios_base::iostate& __err, int __base)
{
    if (__a != __a_end)
    {
        const bool __negate = *__a == '-';
        if (__negate && ++__a == __a_end) {
          __err = ios_base::failbit;
          return 0;
        }
        typename remove_reference<decltype((*__error()))>::type __save_errno = (*__error());
        (*__error()) = 0;
        char *__p2;
        unsigned long long __ll = strtoull_l(__a, &__p2, __base, 0);
        typename remove_reference<decltype((*__error()))>::type __current_errno = (*__error());
        if (__current_errno == 0)
            (*__error()) = __save_errno;
        if (__p2 != __a_end)
        {
            __err = ios_base::failbit;
            return 0;
        }
        else if (__current_errno == 34 || numeric_limits<_Tp>::max() < __ll)
        {
            __err = ios_base::failbit;
            return numeric_limits<_Tp>::max();
        }
        _Tp __res = static_cast<_Tp>(__ll);
        if (__negate) __res = -__res;
        return __res;
    }
    __err = ios_base::failbit;
    return 0;
}

template <class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
_Tp __do_strtod(const char* __a, char** __p2);

template <>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
float __do_strtod<float>(const char* __a, char** __p2) {
    return strtof_l(__a, __p2, 0);
}

template <>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
double __do_strtod<double>(const char* __a, char** __p2) {
    return strtod_l(__a, __p2, 0);
}

template <>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
long double __do_strtod<long double>(const char* __a, char** __p2) {
    return strtold_l(__a, __p2, 0);
}

template <class _Tp>
__attribute__ ((__visibility__("hidden")))
_Tp
__num_get_float(const char* __a, const char* __a_end, ios_base::iostate& __err)
{
    if (__a != __a_end)
    {
        typename remove_reference<decltype((*__error()))>::type __save_errno = (*__error());
        (*__error()) = 0;
        char *__p2;
        _Tp __ld = __do_strtod<_Tp>(__a, &__p2);
        typename remove_reference<decltype((*__error()))>::type __current_errno = (*__error());
        if (__current_errno == 0)
            (*__error()) = __save_errno;
        if (__p2 != __a_end)
        {
            __err = ios_base::failbit;
            return 0;
        }
        else if (__current_errno == 34)
            __err = ios_base::failbit;
        return __ld;
    }
    __err = ios_base::failbit;
    return 0;
}

template <class _CharT, class _InputIterator>
_InputIterator
num_get<_CharT, _InputIterator>::do_get(iter_type __b, iter_type __e,
                                        ios_base& __iob,
                                        ios_base::iostate& __err,
                                        bool& __v) const
{
    if ((__iob.flags() & ios_base::boolalpha) == 0)
    {
        long __lv = -1;
        __b = do_get(__b, __e, __iob, __err, __lv);
        switch (__lv)
        {
        case 0:
            __v = false;
            break;
        case 1:
            __v = true;
            break;
        default:
            __v = true;
            __err = ios_base::failbit;
            break;
        }
        return __b;
    }
    const ctype<_CharT>& __ct = use_facet<ctype<_CharT> >(__iob.getloc());
    const numpunct<_CharT>& __np = use_facet<numpunct<_CharT> >(__iob.getloc());
    typedef typename numpunct<_CharT>::string_type string_type;
    const string_type __names[2] = {__np.truename(), __np.falsename()};
    const string_type* __i = std::__1::__scan_keyword(__b, __e, __names, __names+2,
                                                   __ct, __err);
    __v = __i == __names;
    return __b;
}



template <class _CharT, class _InputIterator>
template <class _Signed>
_InputIterator
num_get<_CharT, _InputIterator>::__do_get_signed(iter_type __b, iter_type __e,
                                        ios_base& __iob,
                                        ios_base::iostate& __err,
                                        _Signed& __v) const
{

    int __base = this->__get_base(__iob);

    char_type __thousands_sep;
    const int __atoms_size = 26;





    char_type __atoms[__atoms_size];
    string __grouping = this->__stage2_int_prep(__iob, __atoms, __thousands_sep);

    string __buf;
    __buf.resize(__buf.capacity());
    char* __a = &__buf[0];
    char* __a_end = __a;
    unsigned __g[__num_get_base::__num_get_buf_sz];
    unsigned* __g_end = __g;
    unsigned __dc = 0;
    for (; __b != __e; ++__b)
    {
        if (__a_end == __a + __buf.size())
        {
            size_t __tmp = __buf.size();
            __buf.resize(2*__buf.size());
            __buf.resize(__buf.capacity());
            __a = &__buf[0];
            __a_end = __a + __tmp;
        }
        if (this->__stage2_int_loop(*__b, __base, __a, __a_end, __dc,
                                    __thousands_sep, __grouping, __g, __g_end,
                                    __atoms))
            break;
    }
    if (__grouping.size() != 0 && __g_end-__g < __num_get_base::__num_get_buf_sz)
        *__g_end++ = __dc;

    __v = __num_get_signed_integral<_Signed>(__a, __a_end, __err, __base);

    __check_grouping(__grouping, __g, __g_end, __err);

    if (__b == __e)
        __err |= ios_base::eofbit;
    return __b;
}



template <class _CharT, class _InputIterator>
template <class _Unsigned>
_InputIterator
num_get<_CharT, _InputIterator>::__do_get_unsigned(iter_type __b, iter_type __e,
                                        ios_base& __iob,
                                        ios_base::iostate& __err,
                                        _Unsigned& __v) const
{

    int __base = this->__get_base(__iob);

    char_type __thousands_sep;
    const int __atoms_size = 26;





    char_type __atoms[__atoms_size];
    string __grouping = this->__stage2_int_prep(__iob, __atoms, __thousands_sep);

    string __buf;
    __buf.resize(__buf.capacity());
    char* __a = &__buf[0];
    char* __a_end = __a;
    unsigned __g[__num_get_base::__num_get_buf_sz];
    unsigned* __g_end = __g;
    unsigned __dc = 0;
    for (; __b != __e; ++__b)
    {
        if (__a_end == __a + __buf.size())
        {
            size_t __tmp = __buf.size();
            __buf.resize(2*__buf.size());
            __buf.resize(__buf.capacity());
            __a = &__buf[0];
            __a_end = __a + __tmp;
        }
        if (this->__stage2_int_loop(*__b, __base, __a, __a_end, __dc,
                                    __thousands_sep, __grouping, __g, __g_end,
                                    __atoms))
            break;
    }
    if (__grouping.size() != 0 && __g_end-__g < __num_get_base::__num_get_buf_sz)
        *__g_end++ = __dc;

    __v = __num_get_unsigned_integral<_Unsigned>(__a, __a_end, __err, __base);

    __check_grouping(__grouping, __g, __g_end, __err);

    if (__b == __e)
        __err |= ios_base::eofbit;
    return __b;
}



template <class _CharT, class _InputIterator>
template <class _Fp>
_InputIterator
num_get<_CharT, _InputIterator>::__do_get_floating_point(iter_type __b, iter_type __e,
                                        ios_base& __iob,
                                        ios_base::iostate& __err,
                                        _Fp& __v) const
{


    char_type __atoms[32];
    char_type __decimal_point;
    char_type __thousands_sep;
    string __grouping = this->__stage2_float_prep(__iob, __atoms,
                                                  __decimal_point,
                                                  __thousands_sep);
    string __buf;
    __buf.resize(__buf.capacity());
    char* __a = &__buf[0];
    char* __a_end = __a;
    unsigned __g[__num_get_base::__num_get_buf_sz];
    unsigned* __g_end = __g;
    unsigned __dc = 0;
    bool __in_units = true;
    char __exp = 'E';
    for (; __b != __e; ++__b)
    {
        if (__a_end == __a + __buf.size())
        {
            size_t __tmp = __buf.size();
            __buf.resize(2*__buf.size());
            __buf.resize(__buf.capacity());
            __a = &__buf[0];
            __a_end = __a + __tmp;
        }
        if (this->__stage2_float_loop(*__b, __in_units, __exp, __a, __a_end,
                                      __decimal_point, __thousands_sep,
                                      __grouping, __g, __g_end,
                                      __dc, __atoms))
            break;
    }
    if (__grouping.size() != 0 && __in_units && __g_end-__g < __num_get_base::__num_get_buf_sz)
        *__g_end++ = __dc;

    __v = __num_get_float<_Fp>(__a, __a_end, __err);

    __check_grouping(__grouping, __g, __g_end, __err);

    if (__b == __e)
        __err |= ios_base::eofbit;
    return __b;
}

template <class _CharT, class _InputIterator>
_InputIterator
num_get<_CharT, _InputIterator>::do_get(iter_type __b, iter_type __e,
                                        ios_base& __iob,
                                        ios_base::iostate& __err,
                                        void*& __v) const
{

    int __base = 16;

    char_type __atoms[26];
    char_type __thousands_sep = 0;
    string __grouping;
    use_facet<ctype<_CharT> >(__iob.getloc()).widen(__num_get_base::__src,
                                                    __num_get_base::__src + 26, __atoms);
    string __buf;
    __buf.resize(__buf.capacity());
    char* __a = &__buf[0];
    char* __a_end = __a;
    unsigned __g[__num_get_base::__num_get_buf_sz];
    unsigned* __g_end = __g;
    unsigned __dc = 0;
    for (; __b != __e; ++__b)
    {
        if (__a_end == __a + __buf.size())
        {
            size_t __tmp = __buf.size();
            __buf.resize(2*__buf.size());
            __buf.resize(__buf.capacity());
            __a = &__buf[0];
            __a_end = __a + __tmp;
        }
        if (this->__stage2_int_loop(*__b, __base, __a, __a_end, __dc,
                                    __thousands_sep, __grouping,
                                    __g, __g_end, __atoms))
            break;
    }

    __buf.resize(__a_end - __a);
    if (sscanf_l(__buf.c_str(), 0, "%p", &__v) != 1)
        __err = ios_base::failbit;

    if (__b == __e)
        __err |= ios_base::eofbit;
    return __b;
}

extern template class __attribute__ ((__visibility__("default"))) num_get<char>;

extern template class __attribute__ ((__visibility__("default"))) num_get<wchar_t>;


struct __attribute__ ((__visibility__("default"))) __num_put_base
{
protected:
    static void __format_int(char* __fmt, const char* __len, bool __signd,
                             ios_base::fmtflags __flags);
    static bool __format_float(char* __fmt, const char* __len,
                               ios_base::fmtflags __flags);
    static char* __identify_padding(char* __nb, char* __ne,
                                    const ios_base& __iob);
};

template <class _CharT>
struct __num_put
    : protected __num_put_base
{
    static void __widen_and_group_int(char* __nb, char* __np, char* __ne,
                                      _CharT* __ob, _CharT*& __op, _CharT*& __oe,
                                      const locale& __loc);
    static void __widen_and_group_float(char* __nb, char* __np, char* __ne,
                                        _CharT* __ob, _CharT*& __op, _CharT*& __oe,
                                        const locale& __loc);
};

template <class _CharT>
void
__num_put<_CharT>::__widen_and_group_int(char* __nb, char* __np, char* __ne,
                                         _CharT* __ob, _CharT*& __op, _CharT*& __oe,
                                         const locale& __loc)
{
    const ctype<_CharT>& __ct = use_facet<ctype<_CharT> > (__loc);
    const numpunct<_CharT>& __npt = use_facet<numpunct<_CharT> >(__loc);
    string __grouping = __npt.grouping();
    if (__grouping.empty())
    {
        __ct.widen(__nb, __ne, __ob);
        __oe = __ob + (__ne - __nb);
    }
    else
    {
        __oe = __ob;
        char* __nf = __nb;
        if (*__nf == '-' || *__nf == '+')
            *__oe++ = __ct.widen(*__nf++);
        if (__ne - __nf >= 2 && __nf[0] == '0' && (__nf[1] == 'x' ||
                                                   __nf[1] == 'X'))
        {
            *__oe++ = __ct.widen(*__nf++);
            *__oe++ = __ct.widen(*__nf++);
        }
        reverse(__nf, __ne);
        _CharT __thousands_sep = __npt.thousands_sep();
        unsigned __dc = 0;
        unsigned __dg = 0;
        for (char* __p = __nf; __p < __ne; ++__p)
        {
            if (static_cast<unsigned>(__grouping[__dg]) > 0 &&
                __dc == static_cast<unsigned>(__grouping[__dg]))
            {
                *__oe++ = __thousands_sep;
                __dc = 0;
                if (__dg < __grouping.size()-1)
                    ++__dg;
            }
            *__oe++ = __ct.widen(*__p);
            ++__dc;
        }
        reverse(__ob + (__nf - __nb), __oe);
    }
    if (__np == __ne)
        __op = __oe;
    else
        __op = __ob + (__np - __nb);
}

template <class _CharT>
void
__num_put<_CharT>::__widen_and_group_float(char* __nb, char* __np, char* __ne,
                                           _CharT* __ob, _CharT*& __op, _CharT*& __oe,
                                           const locale& __loc)
{
    const ctype<_CharT>& __ct = use_facet<ctype<_CharT> > (__loc);
    const numpunct<_CharT>& __npt = use_facet<numpunct<_CharT> >(__loc);
    string __grouping = __npt.grouping();
    __oe = __ob;
    char* __nf = __nb;
    if (*__nf == '-' || *__nf == '+')
        *__oe++ = __ct.widen(*__nf++);
    char* __ns;
    if (__ne - __nf >= 2 && __nf[0] == '0' && (__nf[1] == 'x' ||
                                               __nf[1] == 'X'))
    {
        *__oe++ = __ct.widen(*__nf++);
        *__oe++ = __ct.widen(*__nf++);
        for (__ns = __nf; __ns < __ne; ++__ns)
            if (!isxdigit_l(*__ns, 0))
                break;
    }
    else
    {
        for (__ns = __nf; __ns < __ne; ++__ns)
            if (!isdigit_l(*__ns, 0))
                break;
    }
    if (__grouping.empty())
    {
        __ct.widen(__nf, __ns, __oe);
        __oe += __ns - __nf;
    }
    else
    {
        reverse(__nf, __ns);
        _CharT __thousands_sep = __npt.thousands_sep();
        unsigned __dc = 0;
        unsigned __dg = 0;
        for (char* __p = __nf; __p < __ns; ++__p)
        {
            if (__grouping[__dg] > 0 && __dc == static_cast<unsigned>(__grouping[__dg]))
            {
                *__oe++ = __thousands_sep;
                __dc = 0;
                if (__dg < __grouping.size()-1)
                    ++__dg;
            }
            *__oe++ = __ct.widen(*__p);
            ++__dc;
        }
        reverse(__ob + (__nf - __nb), __oe);
    }
    for (__nf = __ns; __nf < __ne; ++__nf)
    {
        if (*__nf == '.')
        {
            *__oe++ = __npt.decimal_point();
            ++__nf;
            break;
        }
        else
            *__oe++ = __ct.widen(*__nf);
    }
    __ct.widen(__nf, __ne, __oe);
    __oe += __ne - __nf;
    if (__np == __ne)
        __op = __oe;
    else
        __op = __ob + (__np - __nb);
}

extern template struct __attribute__ ((__visibility__("default"))) __num_put<char>;

extern template struct __attribute__ ((__visibility__("default"))) __num_put<wchar_t>;


template <class _CharT, class _OutputIterator = ostreambuf_iterator<_CharT> >
class __attribute__ ((__type_visibility__("default"))) num_put
    : public locale::facet,
      private __num_put<_CharT>
{
public:
    typedef _CharT char_type;
    typedef _OutputIterator iter_type;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit num_put(size_t __refs = 0)
        : locale::facet(__refs) {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iter_type put(iter_type __s, ios_base& __iob, char_type __fl,
                  bool __v) const
    {
        return do_put(__s, __iob, __fl, __v);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iter_type put(iter_type __s, ios_base& __iob, char_type __fl,
                  long __v) const
    {
        return do_put(__s, __iob, __fl, __v);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iter_type put(iter_type __s, ios_base& __iob, char_type __fl,
                  long long __v) const
    {
        return do_put(__s, __iob, __fl, __v);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iter_type put(iter_type __s, ios_base& __iob, char_type __fl,
                  unsigned long __v) const
    {
        return do_put(__s, __iob, __fl, __v);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iter_type put(iter_type __s, ios_base& __iob, char_type __fl,
                  unsigned long long __v) const
    {
        return do_put(__s, __iob, __fl, __v);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iter_type put(iter_type __s, ios_base& __iob, char_type __fl,
                  double __v) const
    {
        return do_put(__s, __iob, __fl, __v);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iter_type put(iter_type __s, ios_base& __iob, char_type __fl,
                  long double __v) const
    {
        return do_put(__s, __iob, __fl, __v);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iter_type put(iter_type __s, ios_base& __iob, char_type __fl,
                  const void* __v) const
    {
        return do_put(__s, __iob, __fl, __v);
    }

    static locale::id id;

protected:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    ~num_put() {}

    virtual iter_type do_put(iter_type __s, ios_base& __iob, char_type __fl,
                             bool __v) const;
    virtual iter_type do_put(iter_type __s, ios_base& __iob, char_type __fl,
                             long __v) const;
    virtual iter_type do_put(iter_type __s, ios_base& __iob, char_type __fl,
                             long long __v) const;
    virtual iter_type do_put(iter_type __s, ios_base& __iob, char_type __fl,
                             unsigned long) const;
    virtual iter_type do_put(iter_type __s, ios_base& __iob, char_type __fl,
                             unsigned long long) const;
    virtual iter_type do_put(iter_type __s, ios_base& __iob, char_type __fl,
                             double __v) const;
    virtual iter_type do_put(iter_type __s, ios_base& __iob, char_type __fl,
                             long double __v) const;
    virtual iter_type do_put(iter_type __s, ios_base& __iob, char_type __fl,
                             const void* __v) const;
};

template <class _CharT, class _OutputIterator>
locale::id
num_put<_CharT, _OutputIterator>::id;

template <class _CharT, class _OutputIterator>
__attribute__ ((__visibility__("hidden")))
_OutputIterator
__pad_and_output(_OutputIterator __s,
                 const _CharT* __ob, const _CharT* __op, const _CharT* __oe,
                 ios_base& __iob, _CharT __fl)
{
    streamsize __sz = __oe - __ob;
    streamsize __ns = __iob.width();
    if (__ns > __sz)
        __ns -= __sz;
    else
        __ns = 0;
    for (;__ob < __op; ++__ob, ++__s)
        *__s = *__ob;
    for (; __ns; --__ns, ++__s)
        *__s = __fl;
    for (; __ob < __oe; ++__ob, ++__s)
        *__s = *__ob;
    __iob.width(0);
    return __s;
}

template <class _CharT, class _Traits>
__attribute__ ((__visibility__("hidden")))
ostreambuf_iterator<_CharT, _Traits>
__pad_and_output(ostreambuf_iterator<_CharT, _Traits> __s,
                 const _CharT* __ob, const _CharT* __op, const _CharT* __oe,
                 ios_base& __iob, _CharT __fl)
{
    if (__s.__sbuf_ == nullptr)
        return __s;
    streamsize __sz = __oe - __ob;
    streamsize __ns = __iob.width();
    if (__ns > __sz)
        __ns -= __sz;
    else
        __ns = 0;
    streamsize __np = __op - __ob;
    if (__np > 0)
    {
        if (__s.__sbuf_->sputn(__ob, __np) != __np)
        {
            __s.__sbuf_ = nullptr;
            return __s;
        }
    }
    if (__ns > 0)
    {
        basic_string<_CharT, _Traits> __sp(__ns, __fl);
        if (__s.__sbuf_->sputn(__sp.data(), __ns) != __ns)
        {
            __s.__sbuf_ = nullptr;
            return __s;
        }
    }
    __np = __oe - __op;
    if (__np > 0)
    {
        if (__s.__sbuf_->sputn(__op, __np) != __np)
        {
            __s.__sbuf_ = nullptr;
            return __s;
        }
    }
    __iob.width(0);
    return __s;
}

template <class _CharT, class _OutputIterator>
_OutputIterator
num_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base& __iob,
                                         char_type __fl, bool __v) const
{
    if ((__iob.flags() & ios_base::boolalpha) == 0)
        return do_put(__s, __iob, __fl, (unsigned long)__v);
    const numpunct<char_type>& __np = use_facet<numpunct<char_type> >(__iob.getloc());
    typedef typename numpunct<char_type>::string_type string_type;




    string_type __nm = __v ? __np.truename() : __np.falsename();

    for (typename string_type::iterator __i = __nm.begin(); __i != __nm.end(); ++__i, ++__s)
        *__s = *__i;
    return __s;
}

template <class _CharT, class _OutputIterator>
_OutputIterator
num_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base& __iob,
                                         char_type __fl, long __v) const
{

    char __fmt[6] = {'%', 0};
    const char* __len = "l";
    this->__format_int(__fmt+1, __len, true, __iob.flags());


    constexpr const unsigned __nbuf
        = (numeric_limits<unsigned long>::digits / 3)
        + ((numeric_limits<unsigned long>::digits % 3) != 0)
        + 2;
    char __nar[__nbuf];
    int __nc = snprintf_l(__nar, sizeof(__nar), 0, __fmt, __v);
    char* __ne = __nar + __nc;
    char* __np = this->__identify_padding(__nar, __ne, __iob);

    char_type __o[2*(__nbuf-1) - 1];
    char_type* __op;
    char_type* __oe;
    this->__widen_and_group_int(__nar, __np, __ne, __o, __op, __oe, __iob.getloc());


    return __pad_and_output(__s, __o, __op, __oe, __iob, __fl);
}

template <class _CharT, class _OutputIterator>
_OutputIterator
num_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base& __iob,
                                         char_type __fl, long long __v) const
{

    char __fmt[8] = {'%', 0};
    const char* __len = "ll";
    this->__format_int(__fmt+1, __len, true, __iob.flags());


    constexpr const unsigned __nbuf
        = (numeric_limits<unsigned long long>::digits / 3)
        + ((numeric_limits<unsigned long long>::digits % 3) != 0)
        + 2;
    char __nar[__nbuf];
    int __nc = snprintf_l(__nar, sizeof(__nar), 0, __fmt, __v);
    char* __ne = __nar + __nc;
    char* __np = this->__identify_padding(__nar, __ne, __iob);

    char_type __o[2*(__nbuf-1) - 1];
    char_type* __op;
    char_type* __oe;
    this->__widen_and_group_int(__nar, __np, __ne, __o, __op, __oe, __iob.getloc());


    return __pad_and_output(__s, __o, __op, __oe, __iob, __fl);
}

template <class _CharT, class _OutputIterator>
_OutputIterator
num_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base& __iob,
                                         char_type __fl, unsigned long __v) const
{

    char __fmt[6] = {'%', 0};
    const char* __len = "l";
    this->__format_int(__fmt+1, __len, false, __iob.flags());

    constexpr const unsigned __nbuf
        = (numeric_limits<unsigned long>::digits / 3)
        + ((numeric_limits<unsigned long>::digits % 3) != 0)
        + 2;
    char __nar[__nbuf];
    int __nc = snprintf_l(__nar, sizeof(__nar), 0, __fmt, __v);
    char* __ne = __nar + __nc;
    char* __np = this->__identify_padding(__nar, __ne, __iob);

    char_type __o[2*(__nbuf-1) - 1];
    char_type* __op;
    char_type* __oe;
    this->__widen_and_group_int(__nar, __np, __ne, __o, __op, __oe, __iob.getloc());


    return __pad_and_output(__s, __o, __op, __oe, __iob, __fl);
}

template <class _CharT, class _OutputIterator>
_OutputIterator
num_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base& __iob,
                                         char_type __fl, unsigned long long __v) const
{

    char __fmt[8] = {'%', 0};
    const char* __len = "ll";
    this->__format_int(__fmt+1, __len, false, __iob.flags());

    constexpr const unsigned __nbuf
        = (numeric_limits<unsigned long long>::digits / 3)
        + ((numeric_limits<unsigned long long>::digits % 3) != 0)
        + 2;
    char __nar[__nbuf];
    int __nc = snprintf_l(__nar, sizeof(__nar), 0, __fmt, __v);
    char* __ne = __nar + __nc;
    char* __np = this->__identify_padding(__nar, __ne, __iob);

    char_type __o[2*(__nbuf-1) - 1];
    char_type* __op;
    char_type* __oe;
    this->__widen_and_group_int(__nar, __np, __ne, __o, __op, __oe, __iob.getloc());


    return __pad_and_output(__s, __o, __op, __oe, __iob, __fl);
}

template <class _CharT, class _OutputIterator>
_OutputIterator
num_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base& __iob,
                                         char_type __fl, double __v) const
{

    char __fmt[8] = {'%', 0};
    const char* __len = "";
    bool __specify_precision = this->__format_float(__fmt+1, __len, __iob.flags());
    const unsigned __nbuf = 30;
    char __nar[__nbuf];
    char* __nb = __nar;
    int __nc;
    if (__specify_precision)
        __nc = snprintf_l(__nb, __nbuf, 0, __fmt, (int)__iob.precision(), __v);

    else
        __nc = snprintf_l(__nb, __nbuf, 0, __fmt, __v);
    unique_ptr<char, void(*)(void*)> __nbh(nullptr, free);
    if (__nc > static_cast<int>(__nbuf-1))
    {
        if (__specify_precision)
            __nc = asprintf_l(&__nb, 0, __fmt, (int)__iob.precision(), __v);
        else
            __nc = asprintf_l(&__nb, 0, __fmt, __v);
        if (__nc == -1)
            __throw_bad_alloc();
        __nbh.reset(__nb);
    }
    char* __ne = __nb + __nc;
    char* __np = this->__identify_padding(__nb, __ne, __iob);

    char_type __o[2*(__nbuf-1) - 1];
    char_type* __ob = __o;
    unique_ptr<char_type, void(*)(void*)> __obh(0, free);
    if (__nb != __nar)
    {
        __ob = (char_type*)malloc(2*static_cast<size_t>(__nc)*sizeof(char_type));
        if (__ob == 0)
            __throw_bad_alloc();
        __obh.reset(__ob);
    }
    char_type* __op;
    char_type* __oe;
    this->__widen_and_group_float(__nb, __np, __ne, __ob, __op, __oe, __iob.getloc());


    __s = __pad_and_output(__s, __ob, __op, __oe, __iob, __fl);
    return __s;
}

template <class _CharT, class _OutputIterator>
_OutputIterator
num_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base& __iob,
                                         char_type __fl, long double __v) const
{

    char __fmt[8] = {'%', 0};
    const char* __len = "L";
    bool __specify_precision = this->__format_float(__fmt+1, __len, __iob.flags());
    const unsigned __nbuf = 30;
    char __nar[__nbuf];
    char* __nb = __nar;
    int __nc;
    if (__specify_precision)
        __nc = snprintf_l(__nb, __nbuf, 0, __fmt, (int)__iob.precision(), __v);

    else
        __nc = snprintf_l(__nb, __nbuf, 0, __fmt, __v);
    unique_ptr<char, void(*)(void*)> __nbh(nullptr, free);
    if (__nc > static_cast<int>(__nbuf-1))
    {
        if (__specify_precision)
            __nc = asprintf_l(&__nb, 0, __fmt, (int)__iob.precision(), __v);
        else
            __nc = asprintf_l(&__nb, 0, __fmt, __v);
        if (__nc == -1)
            __throw_bad_alloc();
        __nbh.reset(__nb);
    }
    char* __ne = __nb + __nc;
    char* __np = this->__identify_padding(__nb, __ne, __iob);

    char_type __o[2*(__nbuf-1) - 1];
    char_type* __ob = __o;
    unique_ptr<char_type, void(*)(void*)> __obh(0, free);
    if (__nb != __nar)
    {
        __ob = (char_type*)malloc(2*static_cast<size_t>(__nc)*sizeof(char_type));
        if (__ob == 0)
            __throw_bad_alloc();
        __obh.reset(__ob);
    }
    char_type* __op;
    char_type* __oe;
    this->__widen_and_group_float(__nb, __np, __ne, __ob, __op, __oe, __iob.getloc());


    __s = __pad_and_output(__s, __ob, __op, __oe, __iob, __fl);
    return __s;
}

template <class _CharT, class _OutputIterator>
_OutputIterator
num_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base& __iob,
                                         char_type __fl, const void* __v) const
{

    char __fmt[6] = "%p";
    const unsigned __nbuf = 20;
    char __nar[__nbuf];
    int __nc = snprintf_l(__nar, sizeof(__nar), 0, __fmt, __v);
    char* __ne = __nar + __nc;
    char* __np = this->__identify_padding(__nar, __ne, __iob);

    char_type __o[2*(__nbuf-1) - 1];
    char_type* __op;
    char_type* __oe;
    const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__iob.getloc());
    __ct.widen(__nar, __ne, __o);
    __oe = __o + (__ne - __nar);
    if (__np == __ne)
        __op = __oe;
    else
        __op = __o + (__np - __nar);


    return __pad_and_output(__s, __o, __op, __oe, __iob, __fl);
}

extern template class __attribute__ ((__visibility__("default"))) num_put<char>;

extern template class __attribute__ ((__visibility__("default"))) num_put<wchar_t>;


template <class _CharT, class _InputIterator>
__attribute__ ((__visibility__("hidden")))
int
__get_up_to_n_digits(_InputIterator& __b, _InputIterator __e,
                     ios_base::iostate& __err, const ctype<_CharT>& __ct, int __n)
{

    if (__b == __e)
    {
        __err |= ios_base::eofbit | ios_base::failbit;
        return 0;
    }

    _CharT __c = *__b;
    if (!__ct.is(ctype_base::digit, __c))
    {
        __err |= ios_base::failbit;
        return 0;
    }
    int __r = __ct.narrow(__c, 0) - '0';
    for (++__b, (void) --__n; __b != __e && __n > 0; ++__b, (void) --__n)
    {

        __c = *__b;
        if (!__ct.is(ctype_base::digit, __c))
            return __r;
        __r = __r * 10 + __ct.narrow(__c, 0) - '0';
    }
    if (__b == __e)
        __err |= ios_base::eofbit;
    return __r;
}

class __attribute__ ((__visibility__("default"))) time_base
{
public:
    enum dateorder {no_order, dmy, mdy, ymd, ydm};
};

template <class _CharT>
class __attribute__ ((__type_visibility__("default"))) __time_get_c_storage
{
protected:
    typedef basic_string<_CharT> string_type;

    virtual const string_type* __weeks() const;
    virtual const string_type* __months() const;
    virtual const string_type* __am_pm() const;
    virtual const string_type& __c() const;
    virtual const string_type& __r() const;
    virtual const string_type& __x() const;
    virtual const string_type& __X() const;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    ~__time_get_c_storage() {}
};

template <> __attribute__ ((__visibility__("default"))) const string* __time_get_c_storage<char>::__weeks() const;
template <> __attribute__ ((__visibility__("default"))) const string* __time_get_c_storage<char>::__months() const;
template <> __attribute__ ((__visibility__("default"))) const string* __time_get_c_storage<char>::__am_pm() const;
template <> __attribute__ ((__visibility__("default"))) const string& __time_get_c_storage<char>::__c() const;
template <> __attribute__ ((__visibility__("default"))) const string& __time_get_c_storage<char>::__r() const;
template <> __attribute__ ((__visibility__("default"))) const string& __time_get_c_storage<char>::__x() const;
template <> __attribute__ ((__visibility__("default"))) const string& __time_get_c_storage<char>::__X() const;


template <> __attribute__ ((__visibility__("default"))) const wstring* __time_get_c_storage<wchar_t>::__weeks() const;
template <> __attribute__ ((__visibility__("default"))) const wstring* __time_get_c_storage<wchar_t>::__months() const;
template <> __attribute__ ((__visibility__("default"))) const wstring* __time_get_c_storage<wchar_t>::__am_pm() const;
template <> __attribute__ ((__visibility__("default"))) const wstring& __time_get_c_storage<wchar_t>::__c() const;
template <> __attribute__ ((__visibility__("default"))) const wstring& __time_get_c_storage<wchar_t>::__r() const;
template <> __attribute__ ((__visibility__("default"))) const wstring& __time_get_c_storage<wchar_t>::__x() const;
template <> __attribute__ ((__visibility__("default"))) const wstring& __time_get_c_storage<wchar_t>::__X() const;


template <class _CharT, class _InputIterator = istreambuf_iterator<_CharT> >
class __attribute__ ((__type_visibility__("default"))) time_get
    : public locale::facet,
      public time_base,
      private __time_get_c_storage<_CharT>
{
public:
    typedef _CharT char_type;
    typedef _InputIterator iter_type;
    typedef time_base::dateorder dateorder;
    typedef basic_string<char_type> string_type;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit time_get(size_t __refs = 0)
        : locale::facet(__refs) {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    dateorder date_order() const
    {
        return this->do_date_order();
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iter_type get_time(iter_type __b, iter_type __e, ios_base& __iob,
                       ios_base::iostate& __err, tm* __tm) const
    {
        return do_get_time(__b, __e, __iob, __err, __tm);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iter_type get_date(iter_type __b, iter_type __e, ios_base& __iob,
                       ios_base::iostate& __err, tm* __tm) const
    {
        return do_get_date(__b, __e, __iob, __err, __tm);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iter_type get_weekday(iter_type __b, iter_type __e, ios_base& __iob,
                          ios_base::iostate& __err, tm* __tm) const
    {
        return do_get_weekday(__b, __e, __iob, __err, __tm);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iter_type get_monthname(iter_type __b, iter_type __e, ios_base& __iob,
                            ios_base::iostate& __err, tm* __tm) const
    {
        return do_get_monthname(__b, __e, __iob, __err, __tm);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iter_type get_year(iter_type __b, iter_type __e, ios_base& __iob,
                       ios_base::iostate& __err, tm* __tm) const
    {
        return do_get_year(__b, __e, __iob, __err, __tm);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,
                  ios_base::iostate& __err, tm *__tm,
                  char __fmt, char __mod = 0) const
    {
        return do_get(__b, __e, __iob, __err, __tm, __fmt, __mod);
    }

    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,
                  ios_base::iostate& __err, tm* __tm,
                  const char_type* __fmtb, const char_type* __fmte) const;

    static locale::id id;

protected:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    ~time_get() {}

    virtual dateorder do_date_order() const;
    virtual iter_type do_get_time(iter_type __b, iter_type __e, ios_base& __iob,
                                  ios_base::iostate& __err, tm* __tm) const;
    virtual iter_type do_get_date(iter_type __b, iter_type __e, ios_base& __iob,
                                  ios_base::iostate& __err, tm* __tm) const;
    virtual iter_type do_get_weekday(iter_type __b, iter_type __e, ios_base& __iob,
                                     ios_base::iostate& __err, tm* __tm) const;
    virtual iter_type do_get_monthname(iter_type __b, iter_type __e, ios_base& __iob,
                                       ios_base::iostate& __err, tm* __tm) const;
    virtual iter_type do_get_year(iter_type __b, iter_type __e, ios_base& __iob,
                                  ios_base::iostate& __err, tm* __tm) const;
    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,
                             ios_base::iostate& __err, tm* __tm,
                             char __fmt, char __mod) const;
private:
    void __get_white_space(iter_type& __b, iter_type __e,
                           ios_base::iostate& __err, const ctype<char_type>& __ct) const;
    void __get_percent(iter_type& __b, iter_type __e, ios_base::iostate& __err,
                       const ctype<char_type>& __ct) const;

    void __get_weekdayname(int& __m,
                           iter_type& __b, iter_type __e,
                           ios_base::iostate& __err,
                           const ctype<char_type>& __ct) const;
    void __get_monthname(int& __m,
                         iter_type& __b, iter_type __e,
                         ios_base::iostate& __err,
                         const ctype<char_type>& __ct) const;
    void __get_day(int& __d,
                   iter_type& __b, iter_type __e,
                   ios_base::iostate& __err,
                   const ctype<char_type>& __ct) const;
    void __get_month(int& __m,
                     iter_type& __b, iter_type __e,
                     ios_base::iostate& __err,
                     const ctype<char_type>& __ct) const;
    void __get_year(int& __y,
                   iter_type& __b, iter_type __e,
                   ios_base::iostate& __err,
                   const ctype<char_type>& __ct) const;
    void __get_year4(int& __y,
                    iter_type& __b, iter_type __e,
                    ios_base::iostate& __err,
                    const ctype<char_type>& __ct) const;
    void __get_hour(int& __d,
                    iter_type& __b, iter_type __e,
                    ios_base::iostate& __err,
                    const ctype<char_type>& __ct) const;
    void __get_12_hour(int& __h,
                       iter_type& __b, iter_type __e,
                       ios_base::iostate& __err,
                       const ctype<char_type>& __ct) const;
    void __get_am_pm(int& __h,
                     iter_type& __b, iter_type __e,
                     ios_base::iostate& __err,
                     const ctype<char_type>& __ct) const;
    void __get_minute(int& __m,
                      iter_type& __b, iter_type __e,
                      ios_base::iostate& __err,
                      const ctype<char_type>& __ct) const;
    void __get_second(int& __s,
                      iter_type& __b, iter_type __e,
                      ios_base::iostate& __err,
                      const ctype<char_type>& __ct) const;
    void __get_weekday(int& __w,
                       iter_type& __b, iter_type __e,
                       ios_base::iostate& __err,
                       const ctype<char_type>& __ct) const;
    void __get_day_year_num(int& __w,
                            iter_type& __b, iter_type __e,
                            ios_base::iostate& __err,
                            const ctype<char_type>& __ct) const;
};

template <class _CharT, class _InputIterator>
locale::id
time_get<_CharT, _InputIterator>::id;



template <class _CharT, class _InputIterator>
void
time_get<_CharT, _InputIterator>::__get_weekdayname(int& __w,
                                                    iter_type& __b, iter_type __e,
                                                    ios_base::iostate& __err,
                                                    const ctype<char_type>& __ct) const
{

    const string_type* __wk = this->__weeks();
    ptrdiff_t __i = std::__1::__scan_keyword(__b, __e, __wk, __wk+14, __ct, __err, false) - __wk;
    if (__i < 14)
        __w = __i % 7;
}

template <class _CharT, class _InputIterator>
void
time_get<_CharT, _InputIterator>::__get_monthname(int& __m,
                                                  iter_type& __b, iter_type __e,
                                                  ios_base::iostate& __err,
                                                  const ctype<char_type>& __ct) const
{

    const string_type* __month = this->__months();
    ptrdiff_t __i = std::__1::__scan_keyword(__b, __e, __month, __month+24, __ct, __err, false) - __month;
    if (__i < 24)
        __m = __i % 12;
}

template <class _CharT, class _InputIterator>
void
time_get<_CharT, _InputIterator>::__get_day(int& __d,
                                            iter_type& __b, iter_type __e,
                                            ios_base::iostate& __err,
                                            const ctype<char_type>& __ct) const
{
    int __t = std::__1::__get_up_to_n_digits(__b, __e, __err, __ct, 2);
    if (!(__err & ios_base::failbit) && 1 <= __t && __t <= 31)
        __d = __t;
    else
        __err |= ios_base::failbit;
}

template <class _CharT, class _InputIterator>
void
time_get<_CharT, _InputIterator>::__get_month(int& __m,
                                              iter_type& __b, iter_type __e,
                                              ios_base::iostate& __err,
                                              const ctype<char_type>& __ct) const
{
    int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 2) - 1;
    if (!(__err & ios_base::failbit) && __t <= 11)
        __m = __t;
    else
        __err |= ios_base::failbit;
}

template <class _CharT, class _InputIterator>
void
time_get<_CharT, _InputIterator>::__get_year(int& __y,
                                             iter_type& __b, iter_type __e,
                                             ios_base::iostate& __err,
                                             const ctype<char_type>& __ct) const
{
    int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 4);
    if (!(__err & ios_base::failbit))
    {
        if (__t < 69)
            __t += 2000;
        else if (69 <= __t && __t <= 99)
            __t += 1900;
        __y = __t - 1900;
    }
}

template <class _CharT, class _InputIterator>
void
time_get<_CharT, _InputIterator>::__get_year4(int& __y,
                                              iter_type& __b, iter_type __e,
                                              ios_base::iostate& __err,
                                              const ctype<char_type>& __ct) const
{
    int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 4);
    if (!(__err & ios_base::failbit))
        __y = __t - 1900;
}

template <class _CharT, class _InputIterator>
void
time_get<_CharT, _InputIterator>::__get_hour(int& __h,
                                             iter_type& __b, iter_type __e,
                                             ios_base::iostate& __err,
                                             const ctype<char_type>& __ct) const
{
    int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 2);
    if (!(__err & ios_base::failbit) && __t <= 23)
        __h = __t;
    else
        __err |= ios_base::failbit;
}

template <class _CharT, class _InputIterator>
void
time_get<_CharT, _InputIterator>::__get_12_hour(int& __h,
                                                iter_type& __b, iter_type __e,
                                                ios_base::iostate& __err,
                                                const ctype<char_type>& __ct) const
{
    int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 2);
    if (!(__err & ios_base::failbit) && 1 <= __t && __t <= 12)
        __h = __t;
    else
        __err |= ios_base::failbit;
}

template <class _CharT, class _InputIterator>
void
time_get<_CharT, _InputIterator>::__get_minute(int& __m,
                                               iter_type& __b, iter_type __e,
                                               ios_base::iostate& __err,
                                               const ctype<char_type>& __ct) const
{
    int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 2);
    if (!(__err & ios_base::failbit) && __t <= 59)
        __m = __t;
    else
        __err |= ios_base::failbit;
}

template <class _CharT, class _InputIterator>
void
time_get<_CharT, _InputIterator>::__get_second(int& __s,
                                               iter_type& __b, iter_type __e,
                                               ios_base::iostate& __err,
                                               const ctype<char_type>& __ct) const
{
    int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 2);
    if (!(__err & ios_base::failbit) && __t <= 60)
        __s = __t;
    else
        __err |= ios_base::failbit;
}

template <class _CharT, class _InputIterator>
void
time_get<_CharT, _InputIterator>::__get_weekday(int& __w,
                                                iter_type& __b, iter_type __e,
                                                ios_base::iostate& __err,
                                                const ctype<char_type>& __ct) const
{
    int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 1);
    if (!(__err & ios_base::failbit) && __t <= 6)
        __w = __t;
    else
        __err |= ios_base::failbit;
}

template <class _CharT, class _InputIterator>
void
time_get<_CharT, _InputIterator>::__get_day_year_num(int& __d,
                                                     iter_type& __b, iter_type __e,
                                                     ios_base::iostate& __err,
                                                     const ctype<char_type>& __ct) const
{
    int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 3);
    if (!(__err & ios_base::failbit) && __t <= 365)
        __d = __t;
    else
        __err |= ios_base::failbit;
}

template <class _CharT, class _InputIterator>
void
time_get<_CharT, _InputIterator>::__get_white_space(iter_type& __b, iter_type __e,
                                                    ios_base::iostate& __err,
                                                    const ctype<char_type>& __ct) const
{
    for (; __b != __e && __ct.is(ctype_base::space, *__b); ++__b)
        ;
    if (__b == __e)
        __err |= ios_base::eofbit;
}

template <class _CharT, class _InputIterator>
void
time_get<_CharT, _InputIterator>::__get_am_pm(int& __h,
                                              iter_type& __b, iter_type __e,
                                              ios_base::iostate& __err,
                                              const ctype<char_type>& __ct) const
{
    const string_type* __ap = this->__am_pm();
    if (__ap[0].size() + __ap[1].size() == 0)
    {
        __err |= ios_base::failbit;
        return;
    }
    ptrdiff_t __i = std::__1::__scan_keyword(__b, __e, __ap, __ap+2, __ct, __err, false) - __ap;
    if (__i == 0 && __h == 12)
        __h = 0;
    else if (__i == 1 && __h < 12)
        __h += 12;
}

template <class _CharT, class _InputIterator>
void
time_get<_CharT, _InputIterator>::__get_percent(iter_type& __b, iter_type __e,
                                                ios_base::iostate& __err,
                                                const ctype<char_type>& __ct) const
{
    if (__b == __e)
    {
        __err |= ios_base::eofbit | ios_base::failbit;
        return;
    }
    if (__ct.narrow(*__b, 0) != '%')
        __err |= ios_base::failbit;
    else if(++__b == __e)
        __err |= ios_base::eofbit;
}



template <class _CharT, class _InputIterator>
_InputIterator
time_get<_CharT, _InputIterator>::get(iter_type __b, iter_type __e,
                                      ios_base& __iob,
                                      ios_base::iostate& __err, tm* __tm,
                                      const char_type* __fmtb, const char_type* __fmte) const
{
    const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__iob.getloc());
    __err = ios_base::goodbit;
    while (__fmtb != __fmte && __err == ios_base::goodbit)
    {
        if (__b == __e)
        {
            __err = ios_base::failbit;
            break;
        }
        if (__ct.narrow(*__fmtb, 0) == '%')
        {
            if (++__fmtb == __fmte)
            {
                __err = ios_base::failbit;
                break;
            }
            char __cmd = __ct.narrow(*__fmtb, 0);
            char __opt = '\0';
            if (__cmd == 'E' || __cmd == '0')
            {
                if (++__fmtb == __fmte)
                {
                    __err = ios_base::failbit;
                    break;
                }
                __opt = __cmd;
                __cmd = __ct.narrow(*__fmtb, 0);
            }
            __b = do_get(__b, __e, __iob, __err, __tm, __cmd, __opt);
            ++__fmtb;
        }
        else if (__ct.is(ctype_base::space, *__fmtb))
        {
            for (++__fmtb; __fmtb != __fmte && __ct.is(ctype_base::space, *__fmtb); ++__fmtb)
                ;
            for ( ; __b != __e && __ct.is(ctype_base::space, *__b); ++__b)
                ;
        }
        else if (__ct.toupper(*__b) == __ct.toupper(*__fmtb))
        {
            ++__b;
            ++__fmtb;
        }
        else
            __err = ios_base::failbit;
    }
    if (__b == __e)
        __err |= ios_base::eofbit;
    return __b;
}

template <class _CharT, class _InputIterator>
typename time_get<_CharT, _InputIterator>::dateorder
time_get<_CharT, _InputIterator>::do_date_order() const
{
    return mdy;
}

template <class _CharT, class _InputIterator>
_InputIterator
time_get<_CharT, _InputIterator>::do_get_time(iter_type __b, iter_type __e,
                                              ios_base& __iob,
                                              ios_base::iostate& __err,
                                              tm* __tm) const
{
    const char_type __fmt[] = {'%', 'H', ':', '%', 'M', ':', '%', 'S'};
    return get(__b, __e, __iob, __err, __tm, __fmt, __fmt + sizeof(__fmt)/sizeof(__fmt[0]));
}

template <class _CharT, class _InputIterator>
_InputIterator
time_get<_CharT, _InputIterator>::do_get_date(iter_type __b, iter_type __e,
                                              ios_base& __iob,
                                              ios_base::iostate& __err,
                                              tm* __tm) const
{
    const string_type& __fmt = this->__x();
    return get(__b, __e, __iob, __err, __tm, __fmt.data(), __fmt.data() + __fmt.size());
}

template <class _CharT, class _InputIterator>
_InputIterator
time_get<_CharT, _InputIterator>::do_get_weekday(iter_type __b, iter_type __e,
                                                 ios_base& __iob,
                                                 ios_base::iostate& __err,
                                                 tm* __tm) const
{
    const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__iob.getloc());
    __get_weekdayname(__tm->tm_wday, __b, __e, __err, __ct);
    return __b;
}

template <class _CharT, class _InputIterator>
_InputIterator
time_get<_CharT, _InputIterator>::do_get_monthname(iter_type __b, iter_type __e,
                                                   ios_base& __iob,
                                                   ios_base::iostate& __err,
                                                   tm* __tm) const
{
    const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__iob.getloc());
    __get_monthname(__tm->tm_mon, __b, __e, __err, __ct);
    return __b;
}

template <class _CharT, class _InputIterator>
_InputIterator
time_get<_CharT, _InputIterator>::do_get_year(iter_type __b, iter_type __e,
                                              ios_base& __iob,
                                              ios_base::iostate& __err,
                                              tm* __tm) const
{
    const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__iob.getloc());
    __get_year(__tm->tm_year, __b, __e, __err, __ct);
    return __b;
}

template <class _CharT, class _InputIterator>
_InputIterator
time_get<_CharT, _InputIterator>::do_get(iter_type __b, iter_type __e,
                                         ios_base& __iob,
                                         ios_base::iostate& __err, tm* __tm,
                                         char __fmt, char) const
{
    __err = ios_base::goodbit;
    const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__iob.getloc());
    switch (__fmt)
    {
    case 'a':
    case 'A':
        __get_weekdayname(__tm->tm_wday, __b, __e, __err, __ct);
        break;
    case 'b':
    case 'B':
    case 'h':
        __get_monthname(__tm->tm_mon, __b, __e, __err, __ct);
        break;
    case 'c':
        {
        const string_type& __fm = this->__c();
        __b = get(__b, __e, __iob, __err, __tm, __fm.data(), __fm.data() + __fm.size());
        }
        break;
    case 'd':
    case 'e':
        __get_day(__tm->tm_mday, __b, __e, __err, __ct);
        break;
    case 'D':
        {
        const char_type __fm[] = {'%', 'm', '/', '%', 'd', '/', '%', 'y'};
        __b = get(__b, __e, __iob, __err, __tm, __fm, __fm + sizeof(__fm)/sizeof(__fm[0]));
        }
        break;
    case 'F':
        {
        const char_type __fm[] = {'%', 'Y', '-', '%', 'm', '-', '%', 'd'};
        __b = get(__b, __e, __iob, __err, __tm, __fm, __fm + sizeof(__fm)/sizeof(__fm[0]));
        }
        break;
    case 'H':
        __get_hour(__tm->tm_hour, __b, __e, __err, __ct);
        break;
    case 'I':
        __get_12_hour(__tm->tm_hour, __b, __e, __err, __ct);
        break;
    case 'j':
        __get_day_year_num(__tm->tm_yday, __b, __e, __err, __ct);
        break;
    case 'm':
        __get_month(__tm->tm_mon, __b, __e, __err, __ct);
        break;
    case 'M':
        __get_minute(__tm->tm_min, __b, __e, __err, __ct);
        break;
    case 'n':
    case 't':
        __get_white_space(__b, __e, __err, __ct);
        break;
    case 'p':
        __get_am_pm(__tm->tm_hour, __b, __e, __err, __ct);
        break;
    case 'r':
        {
        const char_type __fm[] = {'%', 'I', ':', '%', 'M', ':', '%', 'S', ' ', '%', 'p'};
        __b = get(__b, __e, __iob, __err, __tm, __fm, __fm + sizeof(__fm)/sizeof(__fm[0]));
        }
        break;
    case 'R':
        {
        const char_type __fm[] = {'%', 'H', ':', '%', 'M'};
        __b = get(__b, __e, __iob, __err, __tm, __fm, __fm + sizeof(__fm)/sizeof(__fm[0]));
        }
        break;
    case 'S':
        __get_second(__tm->tm_sec, __b, __e, __err, __ct);
        break;
    case 'T':
        {
        const char_type __fm[] = {'%', 'H', ':', '%', 'M', ':', '%', 'S'};
        __b = get(__b, __e, __iob, __err, __tm, __fm, __fm + sizeof(__fm)/sizeof(__fm[0]));
        }
        break;
    case 'w':
        __get_weekday(__tm->tm_wday, __b, __e, __err, __ct);
        break;
    case 'x':
        return do_get_date(__b, __e, __iob, __err, __tm);
    case 'X':
        {
        const string_type& __fm = this->__X();
        __b = get(__b, __e, __iob, __err, __tm, __fm.data(), __fm.data() + __fm.size());
        }
        break;
    case 'y':
        __get_year(__tm->tm_year, __b, __e, __err, __ct);
        break;
    case 'Y':
        __get_year4(__tm->tm_year, __b, __e, __err, __ct);
        break;
    case '%':
        __get_percent(__b, __e, __err, __ct);
        break;
    default:
        __err |= ios_base::failbit;
    }
    return __b;
}

extern template class __attribute__ ((__visibility__("default"))) time_get<char>;

extern template class __attribute__ ((__visibility__("default"))) time_get<wchar_t>;


class __attribute__ ((__visibility__("default"))) __time_get
{
protected:
    locale_t __loc_;

    __time_get(const char* __nm);
    __time_get(const string& __nm);
    ~__time_get();
};

template <class _CharT>
class __attribute__ ((__type_visibility__("default"))) __time_get_storage
    : public __time_get
{
protected:
    typedef basic_string<_CharT> string_type;

    string_type __weeks_[14];
    string_type __months_[24];
    string_type __am_pm_[2];
    string_type __c_;
    string_type __r_;
    string_type __x_;
    string_type __X_;

    explicit __time_get_storage(const char* __nm);
    explicit __time_get_storage(const string& __nm);

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) ~__time_get_storage() {}

    time_base::dateorder __do_date_order() const;

private:
    void init(const ctype<_CharT>&);
    string_type __analyze(char __fmt, const ctype<_CharT>&);
};
# 2447 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/locale" 3
template <> __attribute__ ((__visibility__("default"))) time_base::dateorder __time_get_storage<char>::__do_date_order() const; template <> __attribute__ ((__visibility__("default"))) __time_get_storage<char>::__time_get_storage(const char*); template <> __attribute__ ((__visibility__("default"))) __time_get_storage<char>::__time_get_storage(const string&); template <> __attribute__ ((__visibility__("default"))) void __time_get_storage<char>::init(const ctype<char>&); template <> __attribute__ ((__visibility__("default"))) __time_get_storage<char>::string_type __time_get_storage<char>::__analyze(char, const ctype<char>&); extern template __attribute__ ((__visibility__("default"))) time_base::dateorder __time_get_storage<char>::__do_date_order() const; extern template __attribute__ ((__visibility__("default"))) __time_get_storage<char>::__time_get_storage(const char*); extern template __attribute__ ((__visibility__("default"))) __time_get_storage<char>::__time_get_storage(const string&); extern template __attribute__ ((__visibility__("default"))) void __time_get_storage<char>::init(const ctype<char>&); extern template __attribute__ ((__visibility__("default"))) __time_get_storage<char>::string_type __time_get_storage<char>::__analyze(char, const ctype<char>&);
template <> __attribute__ ((__visibility__("default"))) time_base::dateorder __time_get_storage<wchar_t>::__do_date_order() const; template <> __attribute__ ((__visibility__("default"))) __time_get_storage<wchar_t>::__time_get_storage(const char*); template <> __attribute__ ((__visibility__("default"))) __time_get_storage<wchar_t>::__time_get_storage(const string&); template <> __attribute__ ((__visibility__("default"))) void __time_get_storage<wchar_t>::init(const ctype<wchar_t>&); template <> __attribute__ ((__visibility__("default"))) __time_get_storage<wchar_t>::string_type __time_get_storage<wchar_t>::__analyze(char, const ctype<wchar_t>&); extern template __attribute__ ((__visibility__("default"))) time_base::dateorder __time_get_storage<wchar_t>::__do_date_order() const; extern template __attribute__ ((__visibility__("default"))) __time_get_storage<wchar_t>::__time_get_storage(const char*); extern template __attribute__ ((__visibility__("default"))) __time_get_storage<wchar_t>::__time_get_storage(const string&); extern template __attribute__ ((__visibility__("default"))) void __time_get_storage<wchar_t>::init(const ctype<wchar_t>&); extern template __attribute__ ((__visibility__("default"))) __time_get_storage<wchar_t>::string_type __time_get_storage<wchar_t>::__analyze(char, const ctype<wchar_t>&);


template <class _CharT, class _InputIterator = istreambuf_iterator<_CharT> >
class __attribute__ ((__type_visibility__("default"))) time_get_byname
    : public time_get<_CharT, _InputIterator>,
      private __time_get_storage<_CharT>
{
public:
    typedef time_base::dateorder dateorder;
    typedef _InputIterator iter_type;
    typedef _CharT char_type;
    typedef basic_string<char_type> string_type;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit time_get_byname(const char* __nm, size_t __refs = 0)
        : time_get<_CharT, _InputIterator>(__refs),
          __time_get_storage<_CharT>(__nm) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit time_get_byname(const string& __nm, size_t __refs = 0)
        : time_get<_CharT, _InputIterator>(__refs),
          __time_get_storage<_CharT>(__nm) {}

protected:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    ~time_get_byname() {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    virtual dateorder do_date_order() const {return this->__do_date_order();}
private:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    virtual const string_type* __weeks() const {return this->__weeks_;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    virtual const string_type* __months() const {return this->__months_;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    virtual const string_type* __am_pm() const {return this->__am_pm_;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    virtual const string_type& __c() const {return this->__c_;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    virtual const string_type& __r() const {return this->__r_;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    virtual const string_type& __x() const {return this->__x_;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    virtual const string_type& __X() const {return this->__X_;}
};

extern template class __attribute__ ((__visibility__("default"))) time_get_byname<char>;

extern template class __attribute__ ((__visibility__("default"))) time_get_byname<wchar_t>;


class __attribute__ ((__visibility__("default"))) __time_put
{
    locale_t __loc_;
protected:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) __time_put() : __loc_(0) {}
    __time_put(const char* __nm);
    __time_put(const string& __nm);
    ~__time_put();
    void __do_put(char* __nb, char*& __ne, const tm* __tm,
                  char __fmt, char __mod) const;
    void __do_put(wchar_t* __wb, wchar_t*& __we, const tm* __tm,
                  char __fmt, char __mod) const;
};

template <class _CharT, class _OutputIterator = ostreambuf_iterator<_CharT> >
class __attribute__ ((__type_visibility__("default"))) time_put
    : public locale::facet,
      private __time_put
{
public:
    typedef _CharT char_type;
    typedef _OutputIterator iter_type;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit time_put(size_t __refs = 0)
        : locale::facet(__refs) {}

    iter_type put(iter_type __s, ios_base& __iob, char_type __fl, const tm* __tm,
                  const char_type* __pb, const char_type* __pe) const;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iter_type put(iter_type __s, ios_base& __iob, char_type __fl,
                  const tm* __tm, char __fmt, char __mod = 0) const
    {
        return do_put(__s, __iob, __fl, __tm, __fmt, __mod);
    }

    static locale::id id;

protected:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    ~time_put() {}
    virtual iter_type do_put(iter_type __s, ios_base&, char_type, const tm* __tm,
                             char __fmt, char __mod) const;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit time_put(const char* __nm, size_t __refs)
        : locale::facet(__refs),
          __time_put(__nm) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit time_put(const string& __nm, size_t __refs)
        : locale::facet(__refs),
          __time_put(__nm) {}
};

template <class _CharT, class _OutputIterator>
locale::id
time_put<_CharT, _OutputIterator>::id;

template <class _CharT, class _OutputIterator>
_OutputIterator
time_put<_CharT, _OutputIterator>::put(iter_type __s, ios_base& __iob,
                                       char_type __fl, const tm* __tm,
                                       const char_type* __pb,
                                       const char_type* __pe) const
{
    const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__iob.getloc());
    for (; __pb != __pe; ++__pb)
    {
        if (__ct.narrow(*__pb, 0) == '%')
        {
            if (++__pb == __pe)
            {
                *__s++ = __pb[-1];
                break;
            }
            char __mod = 0;
            char __fmt = __ct.narrow(*__pb, 0);
            if (__fmt == 'E' || __fmt == 'O')
            {
                if (++__pb == __pe)
                {
                    *__s++ = __pb[-2];
                    *__s++ = __pb[-1];
                    break;
                }
                __mod = __fmt;
                __fmt = __ct.narrow(*__pb, 0);
            }
            __s = do_put(__s, __iob, __fl, __tm, __fmt, __mod);
        }
        else
            *__s++ = *__pb;
    }
    return __s;
}

template <class _CharT, class _OutputIterator>
_OutputIterator
time_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base&,
                                          char_type, const tm* __tm,
                                          char __fmt, char __mod) const
{
    char_type __nar[100];
    char_type* __nb = __nar;
    char_type* __ne = __nb + 100;
    __do_put(__nb, __ne, __tm, __fmt, __mod);
    return std::__1::copy(__nb, __ne, __s);
}

extern template class __attribute__ ((__visibility__("default"))) time_put<char>;

extern template class __attribute__ ((__visibility__("default"))) time_put<wchar_t>;


template <class _CharT, class _OutputIterator = ostreambuf_iterator<_CharT> >
class __attribute__ ((__type_visibility__("default"))) time_put_byname
    : public time_put<_CharT, _OutputIterator>
{
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit time_put_byname(const char* __nm, size_t __refs = 0)
        : time_put<_CharT, _OutputIterator>(__nm, __refs) {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit time_put_byname(const string& __nm, size_t __refs = 0)
        : time_put<_CharT, _OutputIterator>(__nm, __refs) {}

protected:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    ~time_put_byname() {}
};

extern template class __attribute__ ((__visibility__("default"))) time_put_byname<char>;

extern template class __attribute__ ((__visibility__("default"))) time_put_byname<wchar_t>;




class __attribute__ ((__visibility__("default"))) money_base
{
public:
    enum part {none, space, symbol, sign, value};
    struct pattern {char field[4];};

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) money_base() {}
};



template <class _CharT, bool _International = false>
class __attribute__ ((__type_visibility__("default"))) moneypunct
    : public locale::facet,
      public money_base
{
public:
    typedef _CharT char_type;
    typedef basic_string<char_type> string_type;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit moneypunct(size_t __refs = 0)
        : locale::facet(__refs) {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) char_type decimal_point() const {return do_decimal_point();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) char_type thousands_sep() const {return do_thousands_sep();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) string grouping() const {return do_grouping();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) string_type curr_symbol() const {return do_curr_symbol();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) string_type positive_sign() const {return do_positive_sign();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) string_type negative_sign() const {return do_negative_sign();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) int frac_digits() const {return do_frac_digits();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) pattern pos_format() const {return do_pos_format();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) pattern neg_format() const {return do_neg_format();}

    static locale::id id;
    static const bool intl = _International;

protected:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    ~moneypunct() {}

    virtual char_type do_decimal_point() const {return numeric_limits<char_type>::max();}
    virtual char_type do_thousands_sep() const {return numeric_limits<char_type>::max();}
    virtual string do_grouping() const {return string();}
    virtual string_type do_curr_symbol() const {return string_type();}
    virtual string_type do_positive_sign() const {return string_type();}
    virtual string_type do_negative_sign() const {return string_type(1, '-');}
    virtual int do_frac_digits() const {return 0;}
    virtual pattern do_pos_format() const
        {pattern __p = {{symbol, sign, none, value}}; return __p;}
    virtual pattern do_neg_format() const
        {pattern __p = {{symbol, sign, none, value}}; return __p;}
};

template <class _CharT, bool _International>
locale::id
moneypunct<_CharT, _International>::id;

template <class _CharT, bool _International>
const bool
moneypunct<_CharT, _International>::intl;

extern template class __attribute__ ((__visibility__("default"))) moneypunct<char, false>;
extern template class __attribute__ ((__visibility__("default"))) moneypunct<char, true>;

extern template class __attribute__ ((__visibility__("default"))) moneypunct<wchar_t, false>;
extern template class __attribute__ ((__visibility__("default"))) moneypunct<wchar_t, true>;




template <class _CharT, bool _International = false>
class __attribute__ ((__type_visibility__("default"))) moneypunct_byname
    : public moneypunct<_CharT, _International>
{
public:
    typedef money_base::pattern pattern;
    typedef _CharT char_type;
    typedef basic_string<char_type> string_type;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit moneypunct_byname(const char* __nm, size_t __refs = 0)
        : moneypunct<_CharT, _International>(__refs) {init(__nm);}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit moneypunct_byname(const string& __nm, size_t __refs = 0)
        : moneypunct<_CharT, _International>(__refs) {init(__nm.c_str());}

protected:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    ~moneypunct_byname() {}

    virtual char_type do_decimal_point() const {return __decimal_point_;}
    virtual char_type do_thousands_sep() const {return __thousands_sep_;}
    virtual string do_grouping() const {return __grouping_;}
    virtual string_type do_curr_symbol() const {return __curr_symbol_;}
    virtual string_type do_positive_sign() const {return __positive_sign_;}
    virtual string_type do_negative_sign() const {return __negative_sign_;}
    virtual int do_frac_digits() const {return __frac_digits_;}
    virtual pattern do_pos_format() const {return __pos_format_;}
    virtual pattern do_neg_format() const {return __neg_format_;}

private:
    char_type __decimal_point_;
    char_type __thousands_sep_;
    string __grouping_;
    string_type __curr_symbol_;
    string_type __positive_sign_;
    string_type __negative_sign_;
    int __frac_digits_;
    pattern __pos_format_;
    pattern __neg_format_;

    void init(const char*);
};

template<> __attribute__ ((__visibility__("default"))) void moneypunct_byname<char, false>::init(const char*);
template<> __attribute__ ((__visibility__("default"))) void moneypunct_byname<char, true>::init(const char*);
extern template class __attribute__ ((__visibility__("default"))) moneypunct_byname<char, false>;
extern template class __attribute__ ((__visibility__("default"))) moneypunct_byname<char, true>;


template<> __attribute__ ((__visibility__("default"))) void moneypunct_byname<wchar_t, false>::init(const char*);
template<> __attribute__ ((__visibility__("default"))) void moneypunct_byname<wchar_t, true>::init(const char*);
extern template class __attribute__ ((__visibility__("default"))) moneypunct_byname<wchar_t, false>;
extern template class __attribute__ ((__visibility__("default"))) moneypunct_byname<wchar_t, true>;




template <class _CharT>
class __money_get
{
protected:
    typedef _CharT char_type;
    typedef basic_string<char_type> string_type;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) __money_get() {}

    static void __gather_info(bool __intl, const locale& __loc,
                              money_base::pattern& __pat, char_type& __dp,
                              char_type& __ts, string& __grp,
                              string_type& __sym, string_type& __psn,
                              string_type& __nsn, int& __fd);
};

template <class _CharT>
void
__money_get<_CharT>::__gather_info(bool __intl, const locale& __loc,
                                   money_base::pattern& __pat, char_type& __dp,
                                   char_type& __ts, string& __grp,
                                   string_type& __sym, string_type& __psn,
                                   string_type& __nsn, int& __fd)
{
    if (__intl)
    {
        const moneypunct<char_type, true>& __mp =
            use_facet<moneypunct<char_type, true> >(__loc);
        __pat = __mp.neg_format();
        __nsn = __mp.negative_sign();
        __psn = __mp.positive_sign();
        __dp = __mp.decimal_point();
        __ts = __mp.thousands_sep();
        __grp = __mp.grouping();
        __sym = __mp.curr_symbol();
        __fd = __mp.frac_digits();
    }
    else
    {
        const moneypunct<char_type, false>& __mp =
            use_facet<moneypunct<char_type, false> >(__loc);
        __pat = __mp.neg_format();
        __nsn = __mp.negative_sign();
        __psn = __mp.positive_sign();
        __dp = __mp.decimal_point();
        __ts = __mp.thousands_sep();
        __grp = __mp.grouping();
        __sym = __mp.curr_symbol();
        __fd = __mp.frac_digits();
    }
}

extern template class __attribute__ ((__visibility__("default"))) __money_get<char>;

extern template class __attribute__ ((__visibility__("default"))) __money_get<wchar_t>;


template <class _CharT, class _InputIterator = istreambuf_iterator<_CharT> >
class __attribute__ ((__type_visibility__("default"))) money_get
    : public locale::facet,
      private __money_get<_CharT>
{
public:
    typedef _CharT char_type;
    typedef _InputIterator iter_type;
    typedef basic_string<char_type> string_type;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit money_get(size_t __refs = 0)
        : locale::facet(__refs) {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iter_type get(iter_type __b, iter_type __e, bool __intl, ios_base& __iob,
                  ios_base::iostate& __err, long double& __v) const
    {
        return do_get(__b, __e, __intl, __iob, __err, __v);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iter_type get(iter_type __b, iter_type __e, bool __intl, ios_base& __iob,
                  ios_base::iostate& __err, string_type& __v) const
    {
        return do_get(__b, __e, __intl, __iob, __err, __v);
    }

    static locale::id id;

protected:

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    ~money_get() {}

    virtual iter_type do_get(iter_type __b, iter_type __e, bool __intl,
                             ios_base& __iob, ios_base::iostate& __err,
                             long double& __v) const;
    virtual iter_type do_get(iter_type __b, iter_type __e, bool __intl,
                             ios_base& __iob, ios_base::iostate& __err,
                             string_type& __v) const;

private:
    static bool __do_get(iter_type& __b, iter_type __e,
                         bool __intl, const locale& __loc,
                         ios_base::fmtflags __flags, ios_base::iostate& __err,
                         bool& __neg, const ctype<char_type>& __ct,
                         unique_ptr<char_type, void(*)(void*)>& __wb,
                         char_type*& __wn, char_type* __we);
};

template <class _CharT, class _InputIterator>
locale::id
money_get<_CharT, _InputIterator>::id;

__attribute__ ((__visibility__("default"))) void __do_nothing(void*);

template <class _Tp>
__attribute__ ((__visibility__("hidden")))
void
__double_or_nothing(unique_ptr<_Tp, void(*)(void*)>& __b, _Tp*& __n, _Tp*& __e)
{
    bool __owns = __b.get_deleter() != __do_nothing;
    size_t __cur_cap = static_cast<size_t>(__e-__b.get()) * sizeof(_Tp);
    size_t __new_cap = __cur_cap < numeric_limits<size_t>::max() / 2 ?
                       2 * __cur_cap : numeric_limits<size_t>::max();
    if (__new_cap == 0)
        __new_cap = sizeof(_Tp);
    size_t __n_off = static_cast<size_t>(__n - __b.get());
    _Tp* __t = (_Tp*)realloc(__owns ? __b.get() : 0, __new_cap);
    if (__t == 0)
        __throw_bad_alloc();
    if (__owns)
        __b.release();
    __b = unique_ptr<_Tp, void(*)(void*)>(__t, free);
    __new_cap /= sizeof(_Tp);
    __n = __b.get() + __n_off;
    __e = __b.get() + __new_cap;
}


template <class _CharT, class _InputIterator>
bool
money_get<_CharT, _InputIterator>::__do_get(iter_type& __b, iter_type __e,
                                            bool __intl, const locale& __loc,
                                            ios_base::fmtflags __flags,
                                            ios_base::iostate& __err,
                                            bool& __neg,
                                            const ctype<char_type>& __ct,
                                            unique_ptr<char_type, void(*)(void*)>& __wb,
                                            char_type*& __wn, char_type* __we)
{
    const unsigned __bz = 100;
    unsigned __gbuf[__bz];
    unique_ptr<unsigned, void(*)(void*)> __gb(__gbuf, __do_nothing);
    unsigned* __gn = __gb.get();
    unsigned* __ge = __gn + __bz;
    money_base::pattern __pat;
    char_type __dp;
    char_type __ts;
    string __grp;
    string_type __sym;
    string_type __psn;
    string_type __nsn;


    string_type __spaces;
    int __fd;
    __money_get<_CharT>::__gather_info(__intl, __loc, __pat, __dp, __ts, __grp,
                                       __sym, __psn, __nsn, __fd);
    const string_type* __trailing_sign = 0;
    __wn = __wb.get();
    for (unsigned __p = 0; __p < 4 && __b != __e; ++__p)
    {
        switch (__pat.field[__p])
        {
        case money_base::space:
            if (__p != 3)
            {
                if (__ct.is(ctype_base::space, *__b))
                    __spaces.push_back(*__b++);
                else
                {
                    __err |= ios_base::failbit;
                    return false;
                }
            }
            [[fallthrough]];
        case money_base::none:
            if (__p != 3)
            {
                while (__b != __e && __ct.is(ctype_base::space, *__b))
                    __spaces.push_back(*__b++);
            }
            break;
        case money_base::sign:
            if (__psn.size() + __nsn.size() > 0)
            {
                if (__psn.size() == 0 || __nsn.size() == 0)
                {
                    if (__psn.size() > 0)
                    {
                        if (*__b == __psn[0])
                        {
                            ++__b;
                            if (__psn.size() > 1)
                                __trailing_sign = &__psn;
                        }
                        else
                            __neg = true;
                    }
                    else if (*__b == __nsn[0])
                    {
                        ++__b;
                        __neg = true;
                        if (__nsn.size() > 1)
                            __trailing_sign = &__nsn;
                    }
                }
                else
                {
                    if (*__b == __psn[0])
                    {
                        ++__b;
                        if (__psn.size() > 1)
                            __trailing_sign = &__psn;
                    }
                    else if (*__b == __nsn[0])
                    {
                        ++__b;
                        __neg = true;
                        if (__nsn.size() > 1)
                            __trailing_sign = &__nsn;
                    }
                    else
                    {
                        __err |= ios_base::failbit;
                        return false;
                    }
                }
            }
            break;
        case money_base::symbol:
            {
            bool __more_needed = __trailing_sign ||
                                 (__p < 2) ||
                                 (__p == 2 && __pat.field[3] != static_cast<char>(money_base::none));
            bool __sb = (__flags & ios_base::showbase) != 0;
            if (__sb || __more_needed)
            {
                typename string_type::const_iterator __sym_space_end = __sym.begin();
                if (__p > 0 && (__pat.field[__p - 1] == money_base::none ||
                                __pat.field[__p - 1] == money_base::space)) {


                    while (__sym_space_end != __sym.end() &&
                           __ct.is(ctype_base::space, *__sym_space_end))
                        ++__sym_space_end;
                    const size_t __num_spaces = __sym_space_end - __sym.begin();
                    if (__num_spaces > __spaces.size() ||
                        !equal(__spaces.end() - __num_spaces, __spaces.end(),
                               __sym.begin())) {



                        __sym_space_end = __sym.begin();
                    }
                }
                typename string_type::const_iterator __sym_curr_char = __sym_space_end;
                while (__sym_curr_char != __sym.end() && __b != __e &&
                       *__b == *__sym_curr_char) {
                    ++__b;
                    ++__sym_curr_char;
                }
                if (__sb && __sym_curr_char != __sym.end())
                {
                    __err |= ios_base::failbit;
                    return false;
                }
            }
            }
            break;
        case money_base::value:
            {
            unsigned __ng = 0;
            for (; __b != __e; ++__b)
            {
                char_type __c = *__b;
                if (__ct.is(ctype_base::digit, __c))
                {
                    if (__wn == __we)
                        __double_or_nothing(__wb, __wn, __we);
                    *__wn++ = __c;
                    ++__ng;
                }
                else if (__grp.size() > 0 && __ng > 0 && __c == __ts)
                {
                    if (__gn == __ge)
                        __double_or_nothing(__gb, __gn, __ge);
                    *__gn++ = __ng;
                    __ng = 0;
                }
                else
                    break;
            }
            if (__gb.get() != __gn && __ng > 0)
            {
                if (__gn == __ge)
                    __double_or_nothing(__gb, __gn, __ge);
                *__gn++ = __ng;
            }
            if (__fd > 0)
            {
                if (__b == __e || *__b != __dp)
                {
                    __err |= ios_base::failbit;
                    return false;
                }
                for (++__b; __fd > 0; --__fd, ++__b)
                {
                    if (__b == __e || !__ct.is(ctype_base::digit, *__b))
                    {
                        __err |= ios_base::failbit;
                        return false;
                    }
                    if (__wn == __we)
                        __double_or_nothing(__wb, __wn, __we);
                    *__wn++ = *__b;
                }
            }
            if (__wn == __wb.get())
            {
                __err |= ios_base::failbit;
                return false;
            }
            }
            break;
        }
    }
    if (__trailing_sign)
    {
        for (unsigned __i = 1; __i < __trailing_sign->size(); ++__i, ++__b)
        {
            if (__b == __e || *__b != (*__trailing_sign)[__i])
            {
                __err |= ios_base::failbit;
                return false;
            }
        }
    }
    if (__gb.get() != __gn)
    {
        ios_base::iostate __et = ios_base::goodbit;
        __check_grouping(__grp, __gb.get(), __gn, __et);
        if (__et)
        {
            __err |= ios_base::failbit;
            return false;
        }
    }
    return true;
}

template <class _CharT, class _InputIterator>
_InputIterator
money_get<_CharT, _InputIterator>::do_get(iter_type __b, iter_type __e,
                                          bool __intl, ios_base& __iob,
                                          ios_base::iostate& __err,
                                          long double& __v) const
{
    const int __bz = 100;
    char_type __wbuf[__bz];
    unique_ptr<char_type, void(*)(void*)> __wb(__wbuf, __do_nothing);
    char_type* __wn;
    char_type* __we = __wbuf + __bz;
    locale __loc = __iob.getloc();
    const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__loc);
    bool __neg = false;
    if (__do_get(__b, __e, __intl, __loc, __iob.flags(), __err, __neg, __ct,
                 __wb, __wn, __we))
    {
        const char __src[] = "0123456789";
        char_type __atoms[sizeof(__src)-1];
        __ct.widen(__src, __src + (sizeof(__src)-1), __atoms);
        char __nbuf[__bz];
        char* __nc = __nbuf;
        unique_ptr<char, void(*)(void*)> __h(nullptr, free);
        if (__wn - __wb.get() > __bz-2)
        {
            __h.reset((char*)malloc(static_cast<size_t>(__wn - __wb.get() + 2)));
            if (__h.get() == nullptr)
                __throw_bad_alloc();
            __nc = __h.get();
        }
        if (__neg)
            *__nc++ = '-';
        for (const char_type* __w = __wb.get(); __w < __wn; ++__w, ++__nc)
            *__nc = __src[find(__atoms, std::__1::end(__atoms), *__w) - __atoms];
        *__nc = char();
        if (sscanf(__nbuf, "%Lf", &__v) != 1)
            __throw_runtime_error("money_get error");
    }
    if (__b == __e)
        __err |= ios_base::eofbit;
    return __b;
}

template <class _CharT, class _InputIterator>
_InputIterator
money_get<_CharT, _InputIterator>::do_get(iter_type __b, iter_type __e,
                                          bool __intl, ios_base& __iob,
                                          ios_base::iostate& __err,
                                          string_type& __v) const
{
    const int __bz = 100;
    char_type __wbuf[__bz];
    unique_ptr<char_type, void(*)(void*)> __wb(__wbuf, __do_nothing);
    char_type* __wn;
    char_type* __we = __wbuf + __bz;
    locale __loc = __iob.getloc();
    const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__loc);
    bool __neg = false;
    if (__do_get(__b, __e, __intl, __loc, __iob.flags(), __err, __neg, __ct,
                 __wb, __wn, __we))
    {
        __v.clear();
        if (__neg)
            __v.push_back(__ct.widen('-'));
        char_type __z = __ct.widen('0');
        char_type* __w;
        for (__w = __wb.get(); __w < __wn-1; ++__w)
            if (*__w != __z)
                break;
        __v.append(__w, __wn);
    }
    if (__b == __e)
        __err |= ios_base::eofbit;
    return __b;
}

extern template class __attribute__ ((__visibility__("default"))) money_get<char>;

extern template class __attribute__ ((__visibility__("default"))) money_get<wchar_t>;




template <class _CharT>
class __money_put
{
protected:
    typedef _CharT char_type;
    typedef basic_string<char_type> string_type;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) __money_put() {}

    static void __gather_info(bool __intl, bool __neg, const locale& __loc,
                              money_base::pattern& __pat, char_type& __dp,
                              char_type& __ts, string& __grp,
                              string_type& __sym, string_type& __sn,
                              int& __fd);
    static void __format(char_type* __mb, char_type*& __mi, char_type*& __me,
                         ios_base::fmtflags __flags,
                         const char_type* __db, const char_type* __de,
                         const ctype<char_type>& __ct, bool __neg,
                         const money_base::pattern& __pat, char_type __dp,
                         char_type __ts, const string& __grp,
                         const string_type& __sym, const string_type& __sn,
                         int __fd);
};

template <class _CharT>
void
__money_put<_CharT>::__gather_info(bool __intl, bool __neg, const locale& __loc,
                                   money_base::pattern& __pat, char_type& __dp,
                                   char_type& __ts, string& __grp,
                                   string_type& __sym, string_type& __sn,
                                   int& __fd)
{
    if (__intl)
    {
        const moneypunct<char_type, true>& __mp =
            use_facet<moneypunct<char_type, true> >(__loc);
        if (__neg)
        {
            __pat = __mp.neg_format();
            __sn = __mp.negative_sign();
        }
        else
        {
            __pat = __mp.pos_format();
            __sn = __mp.positive_sign();
        }
        __dp = __mp.decimal_point();
        __ts = __mp.thousands_sep();
        __grp = __mp.grouping();
        __sym = __mp.curr_symbol();
        __fd = __mp.frac_digits();
    }
    else
    {
        const moneypunct<char_type, false>& __mp =
            use_facet<moneypunct<char_type, false> >(__loc);
        if (__neg)
        {
            __pat = __mp.neg_format();
            __sn = __mp.negative_sign();
        }
        else
        {
            __pat = __mp.pos_format();
            __sn = __mp.positive_sign();
        }
        __dp = __mp.decimal_point();
        __ts = __mp.thousands_sep();
        __grp = __mp.grouping();
        __sym = __mp.curr_symbol();
        __fd = __mp.frac_digits();
    }
}

template <class _CharT>
void
__money_put<_CharT>::__format(char_type* __mb, char_type*& __mi, char_type*& __me,
                              ios_base::fmtflags __flags,
                              const char_type* __db, const char_type* __de,
                              const ctype<char_type>& __ct, bool __neg,
                              const money_base::pattern& __pat, char_type __dp,
                              char_type __ts, const string& __grp,
                              const string_type& __sym, const string_type& __sn,
                              int __fd)
{
    __me = __mb;
    for (unsigned __p = 0; __p < 4; ++__p)
    {
        switch (__pat.field[__p])
        {
        case money_base::none:
            __mi = __me;
            break;
        case money_base::space:
            __mi = __me;
            *__me++ = __ct.widen(' ');
            break;
        case money_base::sign:
            if (!__sn.empty())
                *__me++ = __sn[0];
            break;
        case money_base::symbol:
            if (!__sym.empty() && (__flags & ios_base::showbase))
                __me = std::__1::copy(__sym.begin(), __sym.end(), __me);
            break;
        case money_base::value:
            {

            char_type* __t = __me;

            if (__neg)
                ++__db;

            const char_type* __d;
            for (__d = __db; __d < __de; ++__d)
                if (!__ct.is(ctype_base::digit, *__d))
                    break;

            if (__fd > 0)
            {
                int __f;
                for (__f = __fd; __d > __db && __f > 0; --__f)
                    *__me++ = *--__d;
                char_type __z = __f > 0 ? __ct.widen('0') : char_type();
                for (; __f > 0; --__f)
                    *__me++ = __z;
                *__me++ = __dp;
            }

            if (__d == __db)
            {
                *__me++ = __ct.widen('0');
            }
            else
            {
                unsigned __ng = 0;
                unsigned __ig = 0;
                unsigned __gl = __grp.empty() ? numeric_limits<unsigned>::max()
                                              : static_cast<unsigned>(__grp[__ig]);
                while (__d != __db)
                {
                    if (__ng == __gl)
                    {
                        *__me++ = __ts;
                        __ng = 0;
                        if (++__ig < __grp.size())
                            __gl = __grp[__ig] == numeric_limits<char>::max() ?
                                        numeric_limits<unsigned>::max() :
                                        static_cast<unsigned>(__grp[__ig]);
                    }
                    *__me++ = *--__d;
                    ++__ng;
                }
            }

            reverse(__t, __me);
            }
            break;
        }
    }

    if (__sn.size() > 1)
        __me = std::__1::copy(__sn.begin()+1, __sn.end(), __me);

    if ((__flags & ios_base::adjustfield) == ios_base::left)
        __mi = __me;
    else if ((__flags & ios_base::adjustfield) != ios_base::internal)
        __mi = __mb;
}

extern template class __attribute__ ((__visibility__("default"))) __money_put<char>;

extern template class __attribute__ ((__visibility__("default"))) __money_put<wchar_t>;


template <class _CharT, class _OutputIterator = ostreambuf_iterator<_CharT> >
class __attribute__ ((__type_visibility__("default"))) money_put
    : public locale::facet,
      private __money_put<_CharT>
{
public:
    typedef _CharT char_type;
    typedef _OutputIterator iter_type;
    typedef basic_string<char_type> string_type;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit money_put(size_t __refs = 0)
        : locale::facet(__refs) {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iter_type put(iter_type __s, bool __intl, ios_base& __iob, char_type __fl,
                  long double __units) const
    {
        return do_put(__s, __intl, __iob, __fl, __units);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iter_type put(iter_type __s, bool __intl, ios_base& __iob, char_type __fl,
                  const string_type& __digits) const
    {
        return do_put(__s, __intl, __iob, __fl, __digits);
    }

    static locale::id id;

protected:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    ~money_put() {}

    virtual iter_type do_put(iter_type __s, bool __intl, ios_base& __iob,
                             char_type __fl, long double __units) const;
    virtual iter_type do_put(iter_type __s, bool __intl, ios_base& __iob,
                             char_type __fl, const string_type& __digits) const;
};

template <class _CharT, class _OutputIterator>
locale::id
money_put<_CharT, _OutputIterator>::id;

template <class _CharT, class _OutputIterator>
_OutputIterator
money_put<_CharT, _OutputIterator>::do_put(iter_type __s, bool __intl,
                                           ios_base& __iob, char_type __fl,
                                           long double __units) const
{

    const size_t __bs = 100;
    char __buf[__bs];
    char* __bb = __buf;
    char_type __digits[__bs];
    char_type* __db = __digits;
    int __n = snprintf(__bb, __bs, "%.0Lf", __units);
    unique_ptr<char, void(*)(void*)> __hn(nullptr, free);
    unique_ptr<char_type, void(*)(void*)> __hd(0, free);

    if (static_cast<size_t>(__n) > __bs-1)
    {
        __n = asprintf_l(&__bb, 0, "%.0Lf", __units);
        if (__n == -1)
            __throw_bad_alloc();
        __hn.reset(__bb);
        __hd.reset((char_type*)malloc(static_cast<size_t>(__n) * sizeof(char_type)));
        if (__hd == nullptr)
            __throw_bad_alloc();
        __db = __hd.get();
    }

    locale __loc = __iob.getloc();
    const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__loc);
    __ct.widen(__bb, __bb + __n, __db);
    bool __neg = __n > 0 && __bb[0] == '-';
    money_base::pattern __pat;
    char_type __dp;
    char_type __ts;
    string __grp;
    string_type __sym;
    string_type __sn;
    int __fd;
    this->__gather_info(__intl, __neg, __loc, __pat, __dp, __ts, __grp, __sym, __sn, __fd);

    char_type __mbuf[__bs];
    char_type* __mb = __mbuf;
    unique_ptr<char_type, void(*)(void*)> __hw(0, free);
    size_t __exn = __n > __fd ?
                   (static_cast<size_t>(__n) - static_cast<size_t>(__fd)) * 2 +
                    __sn.size() + __sym.size() + static_cast<size_t>(__fd) + 1
                 : __sn.size() + __sym.size() + static_cast<size_t>(__fd) + 2;
    if (__exn > __bs)
    {
        __hw.reset((char_type*)malloc(__exn * sizeof(char_type)));
        __mb = __hw.get();
        if (__mb == 0)
            __throw_bad_alloc();
    }

    char_type* __mi;
    char_type* __me;
    this->__format(__mb, __mi, __me, __iob.flags(),
                   __db, __db + __n, __ct,
                   __neg, __pat, __dp, __ts, __grp, __sym, __sn, __fd);
    return __pad_and_output(__s, __mb, __mi, __me, __iob, __fl);
}

template <class _CharT, class _OutputIterator>
_OutputIterator
money_put<_CharT, _OutputIterator>::do_put(iter_type __s, bool __intl,
                                           ios_base& __iob, char_type __fl,
                                           const string_type& __digits) const
{

    locale __loc = __iob.getloc();
    const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__loc);
    bool __neg = __digits.size() > 0 && __digits[0] == __ct.widen('-');
    money_base::pattern __pat;
    char_type __dp;
    char_type __ts;
    string __grp;
    string_type __sym;
    string_type __sn;
    int __fd;
    this->__gather_info(__intl, __neg, __loc, __pat, __dp, __ts, __grp, __sym, __sn, __fd);

    char_type __mbuf[100];
    char_type* __mb = __mbuf;
    unique_ptr<char_type, void(*)(void*)> __h(0, free);
    size_t __exn = static_cast<int>(__digits.size()) > __fd ?
                   (__digits.size() - static_cast<size_t>(__fd)) * 2 +
                    __sn.size() + __sym.size() + static_cast<size_t>(__fd) + 1
                 : __sn.size() + __sym.size() + static_cast<size_t>(__fd) + 2;
    if (__exn > 100)
    {
        __h.reset((char_type*)malloc(__exn * sizeof(char_type)));
        __mb = __h.get();
        if (__mb == 0)
            __throw_bad_alloc();
    }

    char_type* __mi;
    char_type* __me;
    this->__format(__mb, __mi, __me, __iob.flags(),
                   __digits.data(), __digits.data() + __digits.size(), __ct,
                   __neg, __pat, __dp, __ts, __grp, __sym, __sn, __fd);
    return __pad_and_output(__s, __mb, __mi, __me, __iob, __fl);
}

extern template class __attribute__ ((__visibility__("default"))) money_put<char>;

extern template class __attribute__ ((__visibility__("default"))) money_put<wchar_t>;




class __attribute__ ((__visibility__("default"))) messages_base
{
public:
    typedef ptrdiff_t catalog;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) messages_base() {}
};

template <class _CharT>
class __attribute__ ((__type_visibility__("default"))) messages
    : public locale::facet,
      public messages_base
{
public:
    typedef _CharT char_type;
    typedef basic_string<_CharT> string_type;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit messages(size_t __refs = 0)
        : locale::facet(__refs) {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    catalog open(const basic_string<char>& __nm, const locale& __loc) const
    {
        return do_open(__nm, __loc);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    string_type get(catalog __c, int __set, int __msgid,
                    const string_type& __dflt) const
    {
        return do_get(__c, __set, __msgid, __dflt);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void close(catalog __c) const
    {
        do_close(__c);
    }

    static locale::id id;

protected:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    ~messages() {}

    virtual catalog do_open(const basic_string<char>&, const locale&) const;
    virtual string_type do_get(catalog, int __set, int __msgid,
                               const string_type& __dflt) const;
    virtual void do_close(catalog) const;
};

template <class _CharT>
locale::id
messages<_CharT>::id;

template <class _CharT>
typename messages<_CharT>::catalog
messages<_CharT>::do_open(const basic_string<char>& __nm, const locale&) const
{

    catalog __cat = (catalog)catopen(__nm.c_str(), 1);
    if (__cat != -1)
        __cat = static_cast<catalog>((static_cast<size_t>(__cat) >> 1));
    return __cat;




}

template <class _CharT>
typename messages<_CharT>::string_type
messages<_CharT>::do_get(catalog __c, int __set, int __msgid,
                         const string_type& __dflt) const
{

    string __ndflt;
    __narrow_to_utf8<sizeof(char_type)*8>()(back_inserter(__ndflt),
                                                       __dflt.c_str(),
                                                       __dflt.c_str() + __dflt.size());
    if (__c != -1)
        __c <<= 1;
    nl_catd __cat = (nl_catd)__c;
    char* __n = catgets(__cat, __set, __msgid, __ndflt.c_str());
    string_type __w;
    __widen_from_utf8<sizeof(char_type)*8>()(back_inserter(__w),
                                                        __n, __n + std::__1::strlen(__n));
    return __w;






}

template <class _CharT>
void
messages<_CharT>::do_close(catalog __c) const
{

    if (__c != -1)
        __c <<= 1;
    nl_catd __cat = (nl_catd)__c;
    catclose(__cat);



}

extern template class __attribute__ ((__visibility__("default"))) messages<char>;

extern template class __attribute__ ((__visibility__("default"))) messages<wchar_t>;


template <class _CharT>
class __attribute__ ((__type_visibility__("default"))) messages_byname
    : public messages<_CharT>
{
public:
    typedef messages_base::catalog catalog;
    typedef basic_string<_CharT> string_type;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit messages_byname(const char*, size_t __refs = 0)
        : messages<_CharT>(__refs) {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit messages_byname(const string&, size_t __refs = 0)
        : messages<_CharT>(__refs) {}

protected:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    ~messages_byname() {}
};

extern template class __attribute__ ((__visibility__("default"))) messages_byname<char>;

extern template class __attribute__ ((__visibility__("default"))) messages_byname<wchar_t>;


template<class _Codecvt, class _Elem = wchar_t,
         class _Wide_alloc = allocator<_Elem>,
         class _Byte_alloc = allocator<char> >
class __attribute__ ((__type_visibility__("default"))) wstring_convert
{
public:
    typedef basic_string<char, char_traits<char>, _Byte_alloc> byte_string;
    typedef basic_string<_Elem, char_traits<_Elem>, _Wide_alloc> wide_string;
    typedef typename _Codecvt::state_type state_type;
    typedef typename wide_string::traits_type::int_type int_type;

private:
    byte_string __byte_err_string_;
    wide_string __wide_err_string_;
    _Codecvt* __cvtptr_;
    state_type __cvtstate_;
    size_t __cvtcount_;

    wstring_convert(const wstring_convert& __wc);
    wstring_convert& operator=(const wstring_convert& __wc);
public:

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    wstring_convert() : wstring_convert(new _Codecvt) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit wstring_convert(_Codecvt* __pcvt);






    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    wstring_convert(_Codecvt* __pcvt, state_type __state);
    explicit wstring_convert(const byte_string& __byte_err,
                    const wide_string& __wide_err = wide_string());

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    wstring_convert(wstring_convert&& __wc);

    ~wstring_convert();

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    wide_string from_bytes(char __byte)
        {return from_bytes(&__byte, &__byte+1);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    wide_string from_bytes(const char* __ptr)
        {return from_bytes(__ptr, __ptr + char_traits<char>::length(__ptr));}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    wide_string from_bytes(const byte_string& __str)
        {return from_bytes(__str.data(), __str.data() + __str.size());}
    wide_string from_bytes(const char* __first, const char* __last);

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    byte_string to_bytes(_Elem __wchar)
        {return to_bytes(&__wchar, &__wchar+1);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    byte_string to_bytes(const _Elem* __wptr)
        {return to_bytes(__wptr, __wptr + char_traits<_Elem>::length(__wptr));}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    byte_string to_bytes(const wide_string& __wstr)
        {return to_bytes(__wstr.data(), __wstr.data() + __wstr.size());}
    byte_string to_bytes(const _Elem* __first, const _Elem* __last);

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_t converted() const noexcept {return __cvtcount_;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    state_type state() const {return __cvtstate_;}
};

template<class _Codecvt, class _Elem, class _Wide_alloc, class _Byte_alloc>
inline
wstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>::
    wstring_convert(_Codecvt* __pcvt)
        : __cvtptr_(__pcvt), __cvtstate_(), __cvtcount_(0)
{
}

template<class _Codecvt, class _Elem, class _Wide_alloc, class _Byte_alloc>
inline
wstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>::
    wstring_convert(_Codecvt* __pcvt, state_type __state)
        : __cvtptr_(__pcvt), __cvtstate_(__state), __cvtcount_(0)
{
}

template<class _Codecvt, class _Elem, class _Wide_alloc, class _Byte_alloc>
wstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>::
    wstring_convert(const byte_string& __byte_err, const wide_string& __wide_err)
        : __byte_err_string_(__byte_err), __wide_err_string_(__wide_err),
          __cvtstate_(), __cvtcount_(0)
{
    __cvtptr_ = new _Codecvt;
}



template<class _Codecvt, class _Elem, class _Wide_alloc, class _Byte_alloc>
inline
wstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>::
    wstring_convert(wstring_convert&& __wc)
        : __byte_err_string_(std::__1::move(__wc.__byte_err_string_)),
          __wide_err_string_(std::__1::move(__wc.__wide_err_string_)),
          __cvtptr_(__wc.__cvtptr_),
          __cvtstate_(__wc.__cvtstate_), __cvtcount_(__wc.__cvtcount_)
{
    __wc.__cvtptr_ = nullptr;
}



template<class _Codecvt, class _Elem, class _Wide_alloc, class _Byte_alloc>
wstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>::~wstring_convert()
{
    delete __cvtptr_;
}

template<class _Codecvt, class _Elem, class _Wide_alloc, class _Byte_alloc>
typename wstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>::wide_string
wstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>::
    from_bytes(const char* __frm, const char* __frm_end)
{
    __cvtcount_ = 0;
    if (__cvtptr_ != nullptr)
    {
        wide_string __ws(2*(__frm_end - __frm), _Elem());
        if (__frm != __frm_end)
            __ws.resize(__ws.capacity());
        codecvt_base::result __r = codecvt_base::ok;
        state_type __st = __cvtstate_;
        if (__frm != __frm_end)
        {
            _Elem* __to = &__ws[0];
            _Elem* __to_end = __to + __ws.size();
            const char* __frm_nxt;
            do
            {
                _Elem* __to_nxt;
                __r = __cvtptr_->in(__st, __frm, __frm_end, __frm_nxt,
                                          __to, __to_end, __to_nxt);
                __cvtcount_ += __frm_nxt - __frm;
                if (__frm_nxt == __frm)
                {
                    __r = codecvt_base::error;
                }
                else if (__r == codecvt_base::noconv)
                {
                    __ws.resize(__to - &__ws[0]);

                    __ws.append((const _Elem*)__frm, (const _Elem*)__frm_end);
                    __frm = __frm_nxt;
                    __r = codecvt_base::ok;
                }
                else if (__r == codecvt_base::ok)
                {
                    __ws.resize(__to_nxt - &__ws[0]);
                    __frm = __frm_nxt;
                }
                else if (__r == codecvt_base::partial)
                {
                    ptrdiff_t __s = __to_nxt - &__ws[0];
                    __ws.resize(2 * __s);
                    __to = &__ws[0] + __s;
                    __to_end = &__ws[0] + __ws.size();
                    __frm = __frm_nxt;
                }
            } while (__r == codecvt_base::partial && __frm_nxt < __frm_end);
        }
        if (__r == codecvt_base::ok)
            return __ws;
    }

    if (__wide_err_string_.empty())
        __throw_range_error("wstring_convert: from_bytes error");

    return __wide_err_string_;
}

template<class _Codecvt, class _Elem, class _Wide_alloc, class _Byte_alloc>
typename wstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>::byte_string
wstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>::
    to_bytes(const _Elem* __frm, const _Elem* __frm_end)
{
    __cvtcount_ = 0;
    if (__cvtptr_ != nullptr)
    {
        byte_string __bs(2*(__frm_end - __frm), char());
        if (__frm != __frm_end)
            __bs.resize(__bs.capacity());
        codecvt_base::result __r = codecvt_base::ok;
        state_type __st = __cvtstate_;
        if (__frm != __frm_end)
        {
            char* __to = &__bs[0];
            char* __to_end = __to + __bs.size();
            const _Elem* __frm_nxt;
            do
            {
                char* __to_nxt;
                __r = __cvtptr_->out(__st, __frm, __frm_end, __frm_nxt,
                                           __to, __to_end, __to_nxt);
                __cvtcount_ += __frm_nxt - __frm;
                if (__frm_nxt == __frm)
                {
                    __r = codecvt_base::error;
                }
                else if (__r == codecvt_base::noconv)
                {
                    __bs.resize(__to - &__bs[0]);

                    __bs.append((const char*)__frm, (const char*)__frm_end);
                    __frm = __frm_nxt;
                    __r = codecvt_base::ok;
                }
                else if (__r == codecvt_base::ok)
                {
                    __bs.resize(__to_nxt - &__bs[0]);
                    __frm = __frm_nxt;
                }
                else if (__r == codecvt_base::partial)
                {
                    ptrdiff_t __s = __to_nxt - &__bs[0];
                    __bs.resize(2 * __s);
                    __to = &__bs[0] + __s;
                    __to_end = &__bs[0] + __bs.size();
                    __frm = __frm_nxt;
                }
            } while (__r == codecvt_base::partial && __frm_nxt < __frm_end);
        }
        if (__r == codecvt_base::ok)
        {
            size_t __s = __bs.size();
            __bs.resize(__bs.capacity());
            char* __to = &__bs[0] + __s;
            char* __to_end = __to + __bs.size();
            do
            {
                char* __to_nxt;
                __r = __cvtptr_->unshift(__st, __to, __to_end, __to_nxt);
                if (__r == codecvt_base::noconv)
                {
                    __bs.resize(__to - &__bs[0]);
                    __r = codecvt_base::ok;
                }
                else if (__r == codecvt_base::ok)
                {
                    __bs.resize(__to_nxt - &__bs[0]);
                }
                else if (__r == codecvt_base::partial)
                {
                    ptrdiff_t __sp = __to_nxt - &__bs[0];
                    __bs.resize(2 * __sp);
                    __to = &__bs[0] + __sp;
                    __to_end = &__bs[0] + __bs.size();
                }
            } while (__r == codecvt_base::partial);
            if (__r == codecvt_base::ok)
                return __bs;
        }
    }

    if (__byte_err_string_.empty())
        __throw_range_error("wstring_convert: to_bytes error");

    return __byte_err_string_;
}

template <class _Codecvt, class _Elem = wchar_t, class _Tr = char_traits<_Elem> >
class __attribute__ ((__type_visibility__("default"))) wbuffer_convert
    : public basic_streambuf<_Elem, _Tr>
{
public:

    typedef _Elem char_type;
    typedef _Tr traits_type;
    typedef typename traits_type::int_type int_type;
    typedef typename traits_type::pos_type pos_type;
    typedef typename traits_type::off_type off_type;
    typedef typename _Codecvt::state_type state_type;

private:
    char* __extbuf_;
    const char* __extbufnext_;
    const char* __extbufend_;
    char __extbuf_min_[8];
    size_t __ebs_;
    char_type* __intbuf_;
    size_t __ibs_;
    streambuf* __bufptr_;
    _Codecvt* __cv_;
    state_type __st_;
    ios_base::openmode __cm_;
    bool __owns_eb_;
    bool __owns_ib_;
    bool __always_noconv_;

    wbuffer_convert(const wbuffer_convert&);
    wbuffer_convert& operator=(const wbuffer_convert&);

public:

    wbuffer_convert() : wbuffer_convert(nullptr) {}
    explicit wbuffer_convert(streambuf* __bytebuf,
                             _Codecvt* __pcvt = new _Codecvt,
                             state_type __state = state_type());







    ~wbuffer_convert();

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    streambuf* rdbuf() const {return __bufptr_;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    streambuf* rdbuf(streambuf* __bytebuf)
    {
        streambuf* __r = __bufptr_;
        __bufptr_ = __bytebuf;
        return __r;
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    state_type state() const {return __st_;}

protected:
    virtual int_type underflow();
    virtual int_type pbackfail(int_type __c = traits_type::eof());
    virtual int_type overflow (int_type __c = traits_type::eof());
    virtual basic_streambuf<char_type, traits_type>* setbuf(char_type* __s,
                                                            streamsize __n);
    virtual pos_type seekoff(off_type __off, ios_base::seekdir __way,
                             ios_base::openmode __wch = ios_base::in | ios_base::out);
    virtual pos_type seekpos(pos_type __sp,
                             ios_base::openmode __wch = ios_base::in | ios_base::out);
    virtual int sync();

private:
    bool __read_mode();
    void __write_mode();
    wbuffer_convert* __close();
};

template <class _Codecvt, class _Elem, class _Tr>
wbuffer_convert<_Codecvt, _Elem, _Tr>::
    wbuffer_convert(streambuf* __bytebuf, _Codecvt* __pcvt, state_type __state)
    : __extbuf_(nullptr),
      __extbufnext_(nullptr),
      __extbufend_(nullptr),
      __ebs_(0),
      __intbuf_(0),
      __ibs_(0),
      __bufptr_(__bytebuf),
      __cv_(__pcvt),
      __st_(__state),
      __cm_(0),
      __owns_eb_(false),
      __owns_ib_(false),
      __always_noconv_(__cv_ ? __cv_->always_noconv() : false)
{
    setbuf(0, 4096);
}

template <class _Codecvt, class _Elem, class _Tr>
wbuffer_convert<_Codecvt, _Elem, _Tr>::~wbuffer_convert()
{
    __close();
    delete __cv_;
    if (__owns_eb_)
        delete [] __extbuf_;
    if (__owns_ib_)
        delete [] __intbuf_;
}

template <class _Codecvt, class _Elem, class _Tr>
typename wbuffer_convert<_Codecvt, _Elem, _Tr>::int_type
wbuffer_convert<_Codecvt, _Elem, _Tr>::underflow()
{
    if (__cv_ == 0 || __bufptr_ == 0)
        return traits_type::eof();
    bool __initial = __read_mode();
    char_type __1buf;
    if (this->gptr() == 0)
        this->setg(&__1buf, &__1buf+1, &__1buf+1);
    const size_t __unget_sz = __initial ? 0 : min<size_t>((this->egptr() - this->eback()) / 2, 4);
    int_type __c = traits_type::eof();
    if (this->gptr() == this->egptr())
    {
        std::__1::memmove(this->eback(), this->egptr() - __unget_sz, __unget_sz * sizeof(char_type));
        if (__always_noconv_)
        {
            streamsize __nmemb = static_cast<streamsize>(this->egptr() - this->eback() - __unget_sz);
            __nmemb = __bufptr_->sgetn((char*)this->eback() + __unget_sz, __nmemb);
            if (__nmemb != 0)
            {
                this->setg(this->eback(),
                           this->eback() + __unget_sz,
                           this->eback() + __unget_sz + __nmemb);
                __c = *this->gptr();
            }
        }
        else
        {
             ((void)0);
             if (__extbufend_ != __extbufnext_)
                std::__1::memmove(__extbuf_, __extbufnext_, __extbufend_ - __extbufnext_);
            __extbufnext_ = __extbuf_ + (__extbufend_ - __extbufnext_);
            __extbufend_ = __extbuf_ + (__extbuf_ == __extbuf_min_ ? sizeof(__extbuf_min_) : __ebs_);
            streamsize __nmemb = std::__1::min(static_cast<streamsize>(this->egptr() - this->eback() - __unget_sz),
                                 static_cast<streamsize>(__extbufend_ - __extbufnext_));
            codecvt_base::result __r;


            streamsize __nr = __bufptr_->sgetn(const_cast<char*>(__extbufnext_), __nmemb);
            if (__nr != 0)
            {
                __extbufend_ = __extbufnext_ + __nr;
                char_type* __inext;
                __r = __cv_->in(__st_, __extbuf_, __extbufend_, __extbufnext_,
                                       this->eback() + __unget_sz,
                                       this->egptr(), __inext);
                if (__r == codecvt_base::noconv)
                {
                    this->setg((char_type*)__extbuf_, (char_type*)__extbuf_,
                               (char_type*) const_cast<char *>(__extbufend_));
                    __c = *this->gptr();
                }
                else if (__inext != this->eback() + __unget_sz)
                {
                    this->setg(this->eback(), this->eback() + __unget_sz, __inext);
                    __c = *this->gptr();
                }
            }
        }
    }
    else
        __c = *this->gptr();
    if (this->eback() == &__1buf)
        this->setg(0, 0, 0);
    return __c;
}

template <class _Codecvt, class _Elem, class _Tr>
typename wbuffer_convert<_Codecvt, _Elem, _Tr>::int_type
wbuffer_convert<_Codecvt, _Elem, _Tr>::pbackfail(int_type __c)
{
    if (__cv_ != 0 && __bufptr_ != 0 && this->eback() < this->gptr())
    {
        if (traits_type::eq_int_type(__c, traits_type::eof()))
        {
            this->gbump(-1);
            return traits_type::not_eof(__c);
        }
        if (traits_type::eq(traits_type::to_char_type(__c), this->gptr()[-1]))
        {
            this->gbump(-1);
            *this->gptr() = traits_type::to_char_type(__c);
            return __c;
        }
    }
    return traits_type::eof();
}

template <class _Codecvt, class _Elem, class _Tr>
typename wbuffer_convert<_Codecvt, _Elem, _Tr>::int_type
wbuffer_convert<_Codecvt, _Elem, _Tr>::overflow(int_type __c)
{
    if (__cv_ == 0 || __bufptr_ == 0)
        return traits_type::eof();
    __write_mode();
    char_type __1buf;
    char_type* __pb_save = this->pbase();
    char_type* __epb_save = this->epptr();
    if (!traits_type::eq_int_type(__c, traits_type::eof()))
    {
        if (this->pptr() == 0)
            this->setp(&__1buf, &__1buf+1);
        *this->pptr() = traits_type::to_char_type(__c);
        this->pbump(1);
    }
    if (this->pptr() != this->pbase())
    {
        if (__always_noconv_)
        {
            streamsize __nmemb = static_cast<streamsize>(this->pptr() - this->pbase());
            if (__bufptr_->sputn((const char*)this->pbase(), __nmemb) != __nmemb)
                return traits_type::eof();
        }
        else
        {
            char* __extbe = __extbuf_;
            codecvt_base::result __r;
            do
            {
                const char_type* __e;
                __r = __cv_->out(__st_, this->pbase(), this->pptr(), __e,
                                        __extbuf_, __extbuf_ + __ebs_, __extbe);
                if (__e == this->pbase())
                    return traits_type::eof();
                if (__r == codecvt_base::noconv)
                {
                    streamsize __nmemb = static_cast<size_t>(this->pptr() - this->pbase());
                    if (__bufptr_->sputn((const char*)this->pbase(), __nmemb) != __nmemb)
                        return traits_type::eof();
                }
                else if (__r == codecvt_base::ok || __r == codecvt_base::partial)
                {
                    streamsize __nmemb = static_cast<size_t>(__extbe - __extbuf_);
                    if (__bufptr_->sputn(__extbuf_, __nmemb) != __nmemb)
                        return traits_type::eof();
                    if (__r == codecvt_base::partial)
                    {
                        this->setp(const_cast<char_type *>(__e), this->pptr());
                        this->__pbump(this->epptr() - this->pbase());
                    }
                }
                else
                    return traits_type::eof();
            } while (__r == codecvt_base::partial);
        }
        this->setp(__pb_save, __epb_save);
    }
    return traits_type::not_eof(__c);
}

template <class _Codecvt, class _Elem, class _Tr>
basic_streambuf<_Elem, _Tr>*
wbuffer_convert<_Codecvt, _Elem, _Tr>::setbuf(char_type* __s, streamsize __n)
{
    this->setg(0, 0, 0);
    this->setp(0, 0);
    if (__owns_eb_)
        delete [] __extbuf_;
    if (__owns_ib_)
        delete [] __intbuf_;
    __ebs_ = __n;
    if (__ebs_ > sizeof(__extbuf_min_))
    {
        if (__always_noconv_ && __s)
        {
            __extbuf_ = (char*)__s;
            __owns_eb_ = false;
        }
        else
        {
            __extbuf_ = new char[__ebs_];
            __owns_eb_ = true;
        }
    }
    else
    {
        __extbuf_ = __extbuf_min_;
        __ebs_ = sizeof(__extbuf_min_);
        __owns_eb_ = false;
    }
    if (!__always_noconv_)
    {
        __ibs_ = max<streamsize>(__n, sizeof(__extbuf_min_));
        if (__s && __ibs_ >= sizeof(__extbuf_min_))
        {
            __intbuf_ = __s;
            __owns_ib_ = false;
        }
        else
        {
            __intbuf_ = new char_type[__ibs_];
            __owns_ib_ = true;
        }
    }
    else
    {
        __ibs_ = 0;
        __intbuf_ = 0;
        __owns_ib_ = false;
    }
    return this;
}

template <class _Codecvt, class _Elem, class _Tr>
typename wbuffer_convert<_Codecvt, _Elem, _Tr>::pos_type
wbuffer_convert<_Codecvt, _Elem, _Tr>::seekoff(off_type __off, ios_base::seekdir __way,
                                        ios_base::openmode __om)
{
    int __width = __cv_->encoding();
    if (__cv_ == 0 || __bufptr_ == 0 || (__width <= 0 && __off != 0) || sync())
        return pos_type(off_type(-1));

    if (__way != ios_base::beg && __way != ios_base::cur && __way != ios_base::end)
        return pos_type(off_type(-1));
    pos_type __r = __bufptr_->pubseekoff(__width * __off, __way, __om);
    __r.state(__st_);
    return __r;
}

template <class _Codecvt, class _Elem, class _Tr>
typename wbuffer_convert<_Codecvt, _Elem, _Tr>::pos_type
wbuffer_convert<_Codecvt, _Elem, _Tr>::seekpos(pos_type __sp, ios_base::openmode __wch)
{
    if (__cv_ == 0 || __bufptr_ == 0 || sync())
        return pos_type(off_type(-1));
    if (__bufptr_->pubseekpos(__sp, __wch) == pos_type(off_type(-1)))
        return pos_type(off_type(-1));
    return __sp;
}

template <class _Codecvt, class _Elem, class _Tr>
int
wbuffer_convert<_Codecvt, _Elem, _Tr>::sync()
{
    if (__cv_ == 0 || __bufptr_ == 0)
        return 0;
    if (__cm_ & ios_base::out)
    {
        if (this->pptr() != this->pbase())
            if (overflow() == traits_type::eof())
                return -1;
        codecvt_base::result __r;
        do
        {
            char* __extbe;
            __r = __cv_->unshift(__st_, __extbuf_, __extbuf_ + __ebs_, __extbe);
            streamsize __nmemb = static_cast<streamsize>(__extbe - __extbuf_);
            if (__bufptr_->sputn(__extbuf_, __nmemb) != __nmemb)
                return -1;
        } while (__r == codecvt_base::partial);
        if (__r == codecvt_base::error)
            return -1;
        if (__bufptr_->pubsync())
            return -1;
    }
    else if (__cm_ & ios_base::in)
    {
        off_type __c;
        if (__always_noconv_)
            __c = this->egptr() - this->gptr();
        else
        {
            int __width = __cv_->encoding();
            __c = __extbufend_ - __extbufnext_;
            if (__width > 0)
                __c += __width * (this->egptr() - this->gptr());
            else
            {
                if (this->gptr() != this->egptr())
                {
                    reverse(this->gptr(), this->egptr());
                    codecvt_base::result __r;
                    const char_type* __e = this->gptr();
                    char* __extbe;
                    do
                    {
                        __r = __cv_->out(__st_, __e, this->egptr(), __e,
                                         __extbuf_, __extbuf_ + __ebs_, __extbe);
                        switch (__r)
                        {
                        case codecvt_base::noconv:
                            __c += this->egptr() - this->gptr();
                            break;
                        case codecvt_base::ok:
                        case codecvt_base::partial:
                            __c += __extbe - __extbuf_;
                            break;
                        default:
                            return -1;
                        }
                    } while (__r == codecvt_base::partial);
                }
            }
        }
        if (__bufptr_->pubseekoff(-__c, ios_base::cur, __cm_) == pos_type(off_type(-1)))
            return -1;
        this->setg(0, 0, 0);
        __cm_ = 0;
    }
    return 0;
}

template <class _Codecvt, class _Elem, class _Tr>
bool
wbuffer_convert<_Codecvt, _Elem, _Tr>::__read_mode()
{
    if (!(__cm_ & ios_base::in))
    {
        this->setp(0, 0);
        if (__always_noconv_)
            this->setg((char_type*)__extbuf_,
                       (char_type*)__extbuf_ + __ebs_,
                       (char_type*)__extbuf_ + __ebs_);
        else
            this->setg(__intbuf_, __intbuf_ + __ibs_, __intbuf_ + __ibs_);
        __cm_ = ios_base::in;
        return true;
    }
    return false;
}

template <class _Codecvt, class _Elem, class _Tr>
void
wbuffer_convert<_Codecvt, _Elem, _Tr>::__write_mode()
{
    if (!(__cm_ & ios_base::out))
    {
        this->setg(0, 0, 0);
        if (__ebs_ > sizeof(__extbuf_min_))
        {
            if (__always_noconv_)
                this->setp((char_type*)__extbuf_,
                           (char_type*)__extbuf_ + (__ebs_ - 1));
            else
                this->setp(__intbuf_, __intbuf_ + (__ibs_ - 1));
        }
        else
            this->setp(0, 0);
        __cm_ = ios_base::out;
    }
}

template <class _Codecvt, class _Elem, class _Tr>
wbuffer_convert<_Codecvt, _Elem, _Tr>*
wbuffer_convert<_Codecvt, _Elem, _Tr>::__close()
{
    wbuffer_convert* __rt = nullptr;
    if (__cv_ != nullptr && __bufptr_ != nullptr)
    {
        __rt = this;
        if ((__cm_ & ios_base::out) && sync())
            __rt = nullptr;
    }
    return __rt;
}

} }
# 141 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/ostream" 2 3
# 146 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/ostream" 3


namespace std { inline namespace __1 {

template <class _CharT, class _Traits>
class __attribute__ ((__type_visibility__("default"))) basic_ostream
    : virtual public basic_ios<_CharT, _Traits>
{
public:

    typedef _CharT char_type;
    typedef _Traits traits_type;
    typedef typename traits_type::int_type int_type;
    typedef typename traits_type::pos_type pos_type;
    typedef typename traits_type::off_type off_type;


    inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit basic_ostream(basic_streambuf<char_type, traits_type>* __sb)
    { this->init(__sb); }
    virtual ~basic_ostream();
protected:
    inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    basic_ostream(basic_ostream&& __rhs);


    inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    basic_ostream& operator=(basic_ostream&& __rhs);

    inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void swap(basic_ostream& __rhs)
    { basic_ios<char_type, traits_type>::swap(__rhs); }

    basic_ostream (const basic_ostream& __rhs) = delete;
    basic_ostream& operator=(const basic_ostream& __rhs) = delete;

public:

    class __attribute__ ((__type_visibility__("default"))) sentry;


    inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    basic_ostream& operator<<(basic_ostream& (*__pf)(basic_ostream&))
    { return __pf(*this); }

    inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    basic_ostream& operator<<(basic_ios<char_type, traits_type>&
                              (*__pf)(basic_ios<char_type,traits_type>&))
    { __pf(*this); return *this; }

    inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    basic_ostream& operator<<(ios_base& (*__pf)(ios_base&))
    { __pf(*this); return *this; }

    basic_ostream& operator<<(bool __n);
    basic_ostream& operator<<(short __n);
    basic_ostream& operator<<(unsigned short __n);
    basic_ostream& operator<<(int __n);
    basic_ostream& operator<<(unsigned int __n);
    basic_ostream& operator<<(long __n);
    basic_ostream& operator<<(unsigned long __n);
    basic_ostream& operator<<(long long __n);
    basic_ostream& operator<<(unsigned long long __n);
    basic_ostream& operator<<(float __f);
    basic_ostream& operator<<(double __f);
    basic_ostream& operator<<(long double __f);
    basic_ostream& operator<<(const void* __p);
    basic_ostream& operator<<(basic_streambuf<char_type, traits_type>* __sb);

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    basic_ostream& operator<<(nullptr_t)
    { return *this << "nullptr"; }


    basic_ostream& put(char_type __c);
    basic_ostream& write(const char_type* __s, streamsize __n);
    basic_ostream& flush();


    inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    pos_type tellp();
    inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    basic_ostream& seekp(pos_type __pos);
    inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    basic_ostream& seekp(off_type __off, ios_base::seekdir __dir);

protected:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    basic_ostream() {}
};

template <class _CharT, class _Traits>
class __attribute__ ((__type_visibility__("default"))) basic_ostream<_CharT, _Traits>::sentry
{
    bool __ok_;
    basic_ostream<_CharT, _Traits>& __os_;

    sentry(const sentry&);
    sentry& operator=(const sentry&);

public:
    explicit sentry(basic_ostream<_CharT, _Traits>& __os);
    ~sentry();

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit operator bool() const {return __ok_;}
};

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>::sentry::sentry(basic_ostream<_CharT, _Traits>& __os)
    : __ok_(false),
      __os_(__os)
{
    if (__os.good())
    {
        if (__os.tie())
            __os.tie()->flush();
        __ok_ = true;
    }
}

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>::sentry::~sentry()
{
    if (__os_.rdbuf() && __os_.good() && (__os_.flags() & ios_base::unitbuf)
                      && !uncaught_exception())
    {

        try
        {

            if (__os_.rdbuf()->pubsync() == -1)
                __os_.setstate(ios_base::badbit);

        }
        catch (...)
        {
        }

    }
}

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>::basic_ostream(basic_ostream&& __rhs)
{
    this->move(__rhs);
}

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>&
basic_ostream<_CharT, _Traits>::operator=(basic_ostream&& __rhs)
{
    swap(__rhs);
    return *this;
}

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>::~basic_ostream()
{
}

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>&
basic_ostream<_CharT, _Traits>::operator<<(basic_streambuf<char_type, traits_type>* __sb)
{

    try
    {

        sentry __s(*this);
        if (__s)
        {
            if (__sb)
            {

                try
                {

                    typedef istreambuf_iterator<_CharT, _Traits> _Ip;
                    typedef ostreambuf_iterator<_CharT, _Traits> _Op;
                    _Ip __i(__sb);
                    _Ip __eof;
                    _Op __o(*this);
                    size_t __c = 0;
                    for (; __i != __eof; ++__i, ++__o, ++__c)
                    {
                        *__o = *__i;
                        if (__o.failed())
                            break;
                    }
                    if (__c == 0)
                        this->setstate(ios_base::failbit);

                }
                catch (...)
                {
                    this->__set_failbit_and_consider_rethrow();
                }

            }
            else
                this->setstate(ios_base::badbit);
        }

    }
    catch (...)
    {
        this->__set_badbit_and_consider_rethrow();
    }

    return *this;
}

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>&
basic_ostream<_CharT, _Traits>::operator<<(bool __n)
{

    try
    {

        sentry __s(*this);
        if (__s)
        {
            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;
            const _Fp& __f = use_facet<_Fp>(this->getloc());
            if (__f.put(*this, *this, this->fill(), __n).failed())
                this->setstate(ios_base::badbit | ios_base::failbit);
        }

    }
    catch (...)
    {
        this->__set_badbit_and_consider_rethrow();
    }

    return *this;
}

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>&
basic_ostream<_CharT, _Traits>::operator<<(short __n)
{

    try
    {

        sentry __s(*this);
        if (__s)
        {
            ios_base::fmtflags __flags = ios_base::flags() & ios_base::basefield;
            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;
            const _Fp& __f = use_facet<_Fp>(this->getloc());
            if (__f.put(*this, *this, this->fill(),
                        __flags == ios_base::oct || __flags == ios_base::hex ?
                        static_cast<long>(static_cast<unsigned short>(__n)) :
                        static_cast<long>(__n)).failed())
                this->setstate(ios_base::badbit | ios_base::failbit);
        }

    }
    catch (...)
    {
        this->__set_badbit_and_consider_rethrow();
    }

    return *this;
}

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>&
basic_ostream<_CharT, _Traits>::operator<<(unsigned short __n)
{

    try
    {

        sentry __s(*this);
        if (__s)
        {
            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;
            const _Fp& __f = use_facet<_Fp>(this->getloc());
            if (__f.put(*this, *this, this->fill(), static_cast<unsigned long>(__n)).failed())
                this->setstate(ios_base::badbit | ios_base::failbit);
        }

    }
    catch (...)
    {
        this->__set_badbit_and_consider_rethrow();
    }

    return *this;
}

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>&
basic_ostream<_CharT, _Traits>::operator<<(int __n)
{

    try
    {

        sentry __s(*this);
        if (__s)
        {
            ios_base::fmtflags __flags = ios_base::flags() & ios_base::basefield;
            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;
            const _Fp& __f = use_facet<_Fp>(this->getloc());
            if (__f.put(*this, *this, this->fill(),
                        __flags == ios_base::oct || __flags == ios_base::hex ?
                        static_cast<long>(static_cast<unsigned int>(__n)) :
                        static_cast<long>(__n)).failed())
                this->setstate(ios_base::badbit | ios_base::failbit);
        }

    }
    catch (...)
    {
        this->__set_badbit_and_consider_rethrow();
    }

    return *this;
}

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>&
basic_ostream<_CharT, _Traits>::operator<<(unsigned int __n)
{

    try
    {

        sentry __s(*this);
        if (__s)
        {
            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;
            const _Fp& __f = use_facet<_Fp>(this->getloc());
            if (__f.put(*this, *this, this->fill(), static_cast<unsigned long>(__n)).failed())
                this->setstate(ios_base::badbit | ios_base::failbit);
        }

    }
    catch (...)
    {
        this->__set_badbit_and_consider_rethrow();
    }

    return *this;
}

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>&
basic_ostream<_CharT, _Traits>::operator<<(long __n)
{

    try
    {

        sentry __s(*this);
        if (__s)
        {
            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;
            const _Fp& __f = use_facet<_Fp>(this->getloc());
            if (__f.put(*this, *this, this->fill(), __n).failed())
                this->setstate(ios_base::badbit | ios_base::failbit);
        }

    }
    catch (...)
    {
        this->__set_badbit_and_consider_rethrow();
    }

    return *this;
}

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>&
basic_ostream<_CharT, _Traits>::operator<<(unsigned long __n)
{

    try
    {

        sentry __s(*this);
        if (__s)
        {
            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;
            const _Fp& __f = use_facet<_Fp>(this->getloc());
            if (__f.put(*this, *this, this->fill(), __n).failed())
                this->setstate(ios_base::badbit | ios_base::failbit);
        }

    }
    catch (...)
    {
        this->__set_badbit_and_consider_rethrow();
    }

    return *this;
}

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>&
basic_ostream<_CharT, _Traits>::operator<<(long long __n)
{

    try
    {

        sentry __s(*this);
        if (__s)
        {
            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;
            const _Fp& __f = use_facet<_Fp>(this->getloc());
            if (__f.put(*this, *this, this->fill(), __n).failed())
                this->setstate(ios_base::badbit | ios_base::failbit);
        }

    }
    catch (...)
    {
        this->__set_badbit_and_consider_rethrow();
    }

    return *this;
}

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>&
basic_ostream<_CharT, _Traits>::operator<<(unsigned long long __n)
{

    try
    {

        sentry __s(*this);
        if (__s)
        {
            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;
            const _Fp& __f = use_facet<_Fp>(this->getloc());
            if (__f.put(*this, *this, this->fill(), __n).failed())
                this->setstate(ios_base::badbit | ios_base::failbit);
        }

    }
    catch (...)
    {
        this->__set_badbit_and_consider_rethrow();
    }

    return *this;
}

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>&
basic_ostream<_CharT, _Traits>::operator<<(float __n)
{

    try
    {

        sentry __s(*this);
        if (__s)
        {
            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;
            const _Fp& __f = use_facet<_Fp>(this->getloc());
            if (__f.put(*this, *this, this->fill(), static_cast<double>(__n)).failed())
                this->setstate(ios_base::badbit | ios_base::failbit);
        }

    }
    catch (...)
    {
        this->__set_badbit_and_consider_rethrow();
    }

    return *this;
}

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>&
basic_ostream<_CharT, _Traits>::operator<<(double __n)
{

    try
    {

        sentry __s(*this);
        if (__s)
        {
            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;
            const _Fp& __f = use_facet<_Fp>(this->getloc());
            if (__f.put(*this, *this, this->fill(), __n).failed())
                this->setstate(ios_base::badbit | ios_base::failbit);
        }

    }
    catch (...)
    {
        this->__set_badbit_and_consider_rethrow();
    }

    return *this;
}

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>&
basic_ostream<_CharT, _Traits>::operator<<(long double __n)
{

    try
    {

        sentry __s(*this);
        if (__s)
        {
            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;
            const _Fp& __f = use_facet<_Fp>(this->getloc());
            if (__f.put(*this, *this, this->fill(), __n).failed())
                this->setstate(ios_base::badbit | ios_base::failbit);
        }

    }
    catch (...)
    {
        this->__set_badbit_and_consider_rethrow();
    }

    return *this;
}

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>&
basic_ostream<_CharT, _Traits>::operator<<(const void* __n)
{

    try
    {

        sentry __s(*this);
        if (__s)
        {
            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;
            const _Fp& __f = use_facet<_Fp>(this->getloc());
            if (__f.put(*this, *this, this->fill(), __n).failed())
                this->setstate(ios_base::badbit | ios_base::failbit);
        }

    }
    catch (...)
    {
        this->__set_badbit_and_consider_rethrow();
    }

    return *this;
}

template<class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>&
__put_character_sequence(basic_ostream<_CharT, _Traits>& __os,
                          const _CharT* __str, size_t __len)
{

    try
    {

        typename basic_ostream<_CharT, _Traits>::sentry __s(__os);
        if (__s)
        {
            typedef ostreambuf_iterator<_CharT, _Traits> _Ip;
            if (__pad_and_output(_Ip(__os),
                                 __str,
                                 (__os.flags() & ios_base::adjustfield) == ios_base::left ?
                                     __str + __len :
                                     __str,
                                 __str + __len,
                                 __os,
                                 __os.fill()).failed())
                __os.setstate(ios_base::badbit | ios_base::failbit);
        }

    }
    catch (...)
    {
        __os.__set_badbit_and_consider_rethrow();
    }

    return __os;
}


template<class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>&
operator<<(basic_ostream<_CharT, _Traits>& __os, _CharT __c)
{
    return std::__1::__put_character_sequence(__os, &__c, 1);
}

template<class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>&
operator<<(basic_ostream<_CharT, _Traits>& __os, char __cn)
{

    try
    {

        typename basic_ostream<_CharT, _Traits>::sentry __s(__os);
        if (__s)
        {
            _CharT __c = __os.widen(__cn);
            typedef ostreambuf_iterator<_CharT, _Traits> _Ip;
            if (__pad_and_output(_Ip(__os),
                                 &__c,
                                 (__os.flags() & ios_base::adjustfield) == ios_base::left ?
                                     &__c + 1 :
                                     &__c,
                                 &__c + 1,
                                 __os,
                                 __os.fill()).failed())
                __os.setstate(ios_base::badbit | ios_base::failbit);
        }

    }
    catch (...)
    {
        __os.__set_badbit_and_consider_rethrow();
    }

    return __os;
}

template<class _Traits>
basic_ostream<char, _Traits>&
operator<<(basic_ostream<char, _Traits>& __os, char __c)
{
    return std::__1::__put_character_sequence(__os, &__c, 1);
}

template<class _Traits>
basic_ostream<char, _Traits>&
operator<<(basic_ostream<char, _Traits>& __os, signed char __c)
{
    return std::__1::__put_character_sequence(__os, (char *) &__c, 1);
}

template<class _Traits>
basic_ostream<char, _Traits>&
operator<<(basic_ostream<char, _Traits>& __os, unsigned char __c)
{
    return std::__1::__put_character_sequence(__os, (char *) &__c, 1);
}

template<class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>&
operator<<(basic_ostream<_CharT, _Traits>& __os, const _CharT* __str)
{
    return std::__1::__put_character_sequence(__os, __str, _Traits::length(__str));
}

template<class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>&
operator<<(basic_ostream<_CharT, _Traits>& __os, const char* __strn)
{

    try
    {

        typename basic_ostream<_CharT, _Traits>::sentry __s(__os);
        if (__s)
        {
            typedef ostreambuf_iterator<_CharT, _Traits> _Ip;
            size_t __len = char_traits<char>::length(__strn);
            const int __bs = 100;
            _CharT __wbb[__bs];
            _CharT* __wb = __wbb;
            unique_ptr<_CharT, void(*)(void*)> __h(0, free);
            if (__len > __bs)
            {
                __wb = (_CharT*)malloc(__len*sizeof(_CharT));
                if (__wb == 0)
                    __throw_bad_alloc();
                __h.reset(__wb);
            }
            for (_CharT* __p = __wb; *__strn != '\0'; ++__strn, ++__p)
                *__p = __os.widen(*__strn);
            if (__pad_and_output(_Ip(__os),
                                 __wb,
                                 (__os.flags() & ios_base::adjustfield) == ios_base::left ?
                                     __wb + __len :
                                     __wb,
                                 __wb + __len,
                                 __os,
                                 __os.fill()).failed())
                __os.setstate(ios_base::badbit | ios_base::failbit);
        }

    }
    catch (...)
    {
        __os.__set_badbit_and_consider_rethrow();
    }

    return __os;
}

template<class _Traits>
basic_ostream<char, _Traits>&
operator<<(basic_ostream<char, _Traits>& __os, const char* __str)
{
    return std::__1::__put_character_sequence(__os, __str, _Traits::length(__str));
}

template<class _Traits>
basic_ostream<char, _Traits>&
operator<<(basic_ostream<char, _Traits>& __os, const signed char* __str)
{
    const char *__s = (const char *) __str;
    return std::__1::__put_character_sequence(__os, __s, _Traits::length(__s));
}

template<class _Traits>
basic_ostream<char, _Traits>&
operator<<(basic_ostream<char, _Traits>& __os, const unsigned char* __str)
{
    const char *__s = (const char *) __str;
    return std::__1::__put_character_sequence(__os, __s, _Traits::length(__s));
}

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>&
basic_ostream<_CharT, _Traits>::put(char_type __c)
{

    try
    {

        sentry __s(*this);
        if (__s)
        {
            typedef ostreambuf_iterator<_CharT, _Traits> _Op;
            _Op __o(*this);
            *__o = __c;
            if (__o.failed())
                this->setstate(ios_base::badbit);
        }

    }
    catch (...)
    {
        this->__set_badbit_and_consider_rethrow();
    }

    return *this;
}

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>&
basic_ostream<_CharT, _Traits>::write(const char_type* __s, streamsize __n)
{

    try
    {

        sentry __sen(*this);
        if (__sen && __n)
        {
            if (this->rdbuf()->sputn(__s, __n) != __n)
                this->setstate(ios_base::badbit);
        }

    }
    catch (...)
    {
        this->__set_badbit_and_consider_rethrow();
    }

    return *this;
}

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>&
basic_ostream<_CharT, _Traits>::flush()
{

    try
    {

        if (this->rdbuf())
        {
            sentry __s(*this);
            if (__s)
            {
                if (this->rdbuf()->pubsync() == -1)
                    this->setstate(ios_base::badbit);
            }
        }

    }
    catch (...)
    {
        this->__set_badbit_and_consider_rethrow();
    }

    return *this;
}

template <class _CharT, class _Traits>
typename basic_ostream<_CharT, _Traits>::pos_type
basic_ostream<_CharT, _Traits>::tellp()
{
    if (this->fail())
        return pos_type(-1);
    return this->rdbuf()->pubseekoff(0, ios_base::cur, ios_base::out);
}

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>&
basic_ostream<_CharT, _Traits>::seekp(pos_type __pos)
{
    sentry __s(*this);
    if (!this->fail())
    {
        if (this->rdbuf()->pubseekpos(__pos, ios_base::out) == pos_type(-1))
            this->setstate(ios_base::failbit);
    }
    return *this;
}

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>&
basic_ostream<_CharT, _Traits>::seekp(off_type __off, ios_base::seekdir __dir)
{
    sentry __s(*this);
    if (!this->fail())
    {
        if (this->rdbuf()->pubseekoff(__off, __dir, ios_base::out) == pos_type(-1))
            this->setstate(ios_base::failbit);
    }
    return *this;
}

template <class _CharT, class _Traits>
inline
basic_ostream<_CharT, _Traits>&
endl(basic_ostream<_CharT, _Traits>& __os)
{
    __os.put(__os.widen('\n'));
    __os.flush();
    return __os;
}

template <class _CharT, class _Traits>
inline
basic_ostream<_CharT, _Traits>&
ends(basic_ostream<_CharT, _Traits>& __os)
{
    __os.put(_CharT());
    return __os;
}

template <class _CharT, class _Traits>
inline
basic_ostream<_CharT, _Traits>&
flush(basic_ostream<_CharT, _Traits>& __os)
{
    __os.flush();
    return __os;
}

template <class _Stream, class _Tp, class = void>
struct __is_ostreamable : false_type { };

template <class _Stream, class _Tp>
struct __is_ostreamable<_Stream, _Tp, decltype(
    declval<_Stream>() << declval<_Tp>(), void()
)> : true_type { };

template <class _Stream, class _Tp, class = typename enable_if<
    _And<is_base_of<ios_base, _Stream>,
         __is_ostreamable<_Stream&, const _Tp&> >::value
>::type>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
_Stream&& operator<<(_Stream&& __os, const _Tp& __x)
{
    __os << __x;
    return std::__1::move(__os);
}

template<class _CharT, class _Traits, class _Allocator>
basic_ostream<_CharT, _Traits>&
operator<<(basic_ostream<_CharT, _Traits>& __os,
           const basic_string<_CharT, _Traits, _Allocator>& __str)
{
    return std::__1::__put_character_sequence(__os, __str.data(), __str.size());
}

template<class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>&
operator<<(basic_ostream<_CharT, _Traits>& __os,
           basic_string_view<_CharT, _Traits> __sv)
{
    return std::__1::__put_character_sequence(__os, __sv.data(), __sv.size());
}

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
basic_ostream<_CharT, _Traits>&
operator<<(basic_ostream<_CharT, _Traits>& __os, const error_code& __ec)
{
    return __os << __ec.category().name() << ':' << __ec.value();
}

template<class _CharT, class _Traits, class _Yp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
basic_ostream<_CharT, _Traits>&
operator<<(basic_ostream<_CharT, _Traits>& __os, shared_ptr<_Yp> const& __p)
{
    return __os << __p.get();
}

template<class _CharT, class _Traits, class _Yp, class _Dp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename enable_if
<
    is_same<void, typename __void_t<decltype((declval<basic_ostream<_CharT, _Traits>&>() << declval<typename unique_ptr<_Yp, _Dp>::pointer>()))>::type>::value,
    basic_ostream<_CharT, _Traits>&
>::type
operator<<(basic_ostream<_CharT, _Traits>& __os, unique_ptr<_Yp, _Dp> const& __p)
{
    return __os << __p.get();
}

template <class _CharT, class _Traits, size_t _Size>
basic_ostream<_CharT, _Traits>&
operator<<(basic_ostream<_CharT, _Traits>& __os, const bitset<_Size>& __x)
{
    return __os << __x.template to_string<_CharT, _Traits>
                        (use_facet<ctype<_CharT> >(__os.getloc()).widen('0'),
                         use_facet<ctype<_CharT> >(__os.getloc()).widen('1'));
}

extern template class __attribute__ ((__visibility__("default"))) basic_ostream<char>;

extern template class __attribute__ ((__visibility__("default"))) basic_ostream<wchar_t>;


} }
# 164 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/istream" 2 3
# 168 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/istream" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 172 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/istream" 2 3


namespace std { inline namespace __1 {

template <class _CharT, class _Traits>
class __attribute__ ((__type_visibility__("default"))) basic_istream
    : virtual public basic_ios<_CharT, _Traits>
{
    streamsize __gc_;
public:

    typedef _CharT char_type;
    typedef _Traits traits_type;
    typedef typename traits_type::int_type int_type;
    typedef typename traits_type::pos_type pos_type;
    typedef typename traits_type::off_type off_type;


    inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit basic_istream(basic_streambuf<char_type, traits_type>* __sb) : __gc_(0)
    { this->init(__sb); }
    virtual ~basic_istream();
protected:
    inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    basic_istream(basic_istream&& __rhs);


    inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    basic_istream& operator=(basic_istream&& __rhs);

    inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void swap(basic_istream& __rhs) {
      std::__1::swap(__gc_, __rhs.__gc_);
      basic_ios<char_type, traits_type>::swap(__rhs);
    }

    basic_istream (const basic_istream& __rhs) = delete;
    basic_istream& operator=(const basic_istream& __rhs) = delete;
public:


    class __attribute__ ((__type_visibility__("default"))) sentry;


    inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    basic_istream& operator>>(basic_istream& (*__pf)(basic_istream&))
    { return __pf(*this); }

    inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    basic_istream& operator>>(basic_ios<char_type, traits_type>&
                              (*__pf)(basic_ios<char_type, traits_type>&))
    { __pf(*this); return *this; }

    inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    basic_istream& operator>>(ios_base& (*__pf)(ios_base&))
    { __pf(*this); return *this; }

    basic_istream& operator>>(basic_streambuf<char_type, traits_type>* __sb);
    basic_istream& operator>>(bool& __n);
    basic_istream& operator>>(short& __n);
    basic_istream& operator>>(unsigned short& __n);
    basic_istream& operator>>(int& __n);
    basic_istream& operator>>(unsigned int& __n);
    basic_istream& operator>>(long& __n);
    basic_istream& operator>>(unsigned long& __n);
    basic_istream& operator>>(long long& __n);
    basic_istream& operator>>(unsigned long long& __n);
    basic_istream& operator>>(float& __f);
    basic_istream& operator>>(double& __f);
    basic_istream& operator>>(long double& __f);
    basic_istream& operator>>(void*& __p);


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    streamsize gcount() const {return __gc_;}
    int_type get();

    inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    basic_istream& get(char_type& __c) {
      int_type __ch = get();
      if (__ch != traits_type::eof())
        __c = traits_type::to_char_type(__ch);
      return *this;
    }

    inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    basic_istream& get(char_type* __s, streamsize __n)
    { return get(__s, __n, this->widen('\n')); }

    basic_istream& get(char_type* __s, streamsize __n, char_type __dlm);

    inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    basic_istream& get(basic_streambuf<char_type, traits_type>& __sb)
    { return get(__sb, this->widen('\n')); }

    basic_istream& get(basic_streambuf<char_type, traits_type>& __sb, char_type __dlm);

    inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    basic_istream& getline(char_type* __s, streamsize __n)
    { return getline(__s, __n, this->widen('\n')); }

    basic_istream& getline(char_type* __s, streamsize __n, char_type __dlm);

    basic_istream& ignore(streamsize __n = 1, int_type __dlm = traits_type::eof());
    int_type peek();
    basic_istream& read (char_type* __s, streamsize __n);
    streamsize readsome(char_type* __s, streamsize __n);

    basic_istream& putback(char_type __c);
    basic_istream& unget();
    int sync();

    pos_type tellg();
    basic_istream& seekg(pos_type __pos);
    basic_istream& seekg(off_type __off, ios_base::seekdir __dir);
};

template <class _CharT, class _Traits>
class __attribute__ ((__type_visibility__("default"))) basic_istream<_CharT, _Traits>::sentry
{
    bool __ok_;

    sentry(const sentry&);
    sentry& operator=(const sentry&);

public:
    explicit sentry(basic_istream<_CharT, _Traits>& __is, bool __noskipws = false);


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit operator bool() const {return __ok_;}
};

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>::sentry::sentry(basic_istream<_CharT, _Traits>& __is,
                                               bool __noskipws)
    : __ok_(false)
{
    if (__is.good())
    {
        if (__is.tie())
            __is.tie()->flush();
        if (!__noskipws && (__is.flags() & ios_base::skipws))
        {
            typedef istreambuf_iterator<_CharT, _Traits> _Ip;
            const ctype<_CharT>& __ct = use_facet<ctype<_CharT> >(__is.getloc());
            _Ip __i(__is);
            _Ip __eof;
            for (; __i != __eof; ++__i)
                if (!__ct.is(__ct.space, *__i))
                    break;
            if (__i == __eof)
                __is.setstate(ios_base::failbit | ios_base::eofbit);
        }
        __ok_ = __is.good();
    }
    else
        __is.setstate(ios_base::failbit);
}

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>::basic_istream(basic_istream&& __rhs)
    : __gc_(__rhs.__gc_)
{
    __rhs.__gc_ = 0;
    this->move(__rhs);
}

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::operator=(basic_istream&& __rhs)
{
    swap(__rhs);
    return *this;
}

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>::~basic_istream()
{
}

template <class _Tp, class _CharT, class _Traits>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
basic_istream<_CharT, _Traits>&
__input_arithmetic(basic_istream<_CharT, _Traits>& __is, _Tp& __n) {
    ios_base::iostate __state = ios_base::goodbit;
    typename basic_istream<_CharT, _Traits>::sentry __s(__is);
    if (__s)
    {

        try
        {

            typedef istreambuf_iterator<_CharT, _Traits> _Ip;
            typedef num_get<_CharT, _Ip> _Fp;
            use_facet<_Fp>(__is.getloc()).get(_Ip(__is), _Ip(), __is, __state, __n);

        }
        catch (...)
        {
            __state |= ios_base::badbit;
            __is.__setstate_nothrow(__state);
            if (__is.exceptions() & ios_base::badbit)
            {
                throw;
            }
        }

        __is.setstate(__state);
    }
    return __is;
}

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::operator>>(unsigned short& __n)
{
    return std::__1::__input_arithmetic<unsigned short>(*this, __n);
}

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::operator>>(unsigned int& __n)
{
    return std::__1::__input_arithmetic<unsigned int>(*this, __n);
}

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::operator>>(long& __n)
{
    return std::__1::__input_arithmetic<long>(*this, __n);
}

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::operator>>(unsigned long& __n)
{
    return std::__1::__input_arithmetic<unsigned long>(*this, __n);
}

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::operator>>(long long& __n)
{
    return std::__1::__input_arithmetic<long long>(*this, __n);
}

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::operator>>(unsigned long long& __n)
{
    return std::__1::__input_arithmetic<unsigned long long>(*this, __n);
}

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::operator>>(float& __n)
{
    return std::__1::__input_arithmetic<float>(*this, __n);
}

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::operator>>(double& __n)
{
    return std::__1::__input_arithmetic<double>(*this, __n);
}

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::operator>>(long double& __n)
{
    return std::__1::__input_arithmetic<long double>(*this, __n);
}

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::operator>>(bool& __n)
{
    return std::__1::__input_arithmetic<bool>(*this, __n);
}

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::operator>>(void*& __n)
{
    return std::__1::__input_arithmetic<void*>(*this, __n);
}

template <class _Tp, class _CharT, class _Traits>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
basic_istream<_CharT, _Traits>&
__input_arithmetic_with_numeric_limits(basic_istream<_CharT, _Traits>& __is, _Tp& __n) {
    ios_base::iostate __state = ios_base::goodbit;
    typename basic_istream<_CharT, _Traits>::sentry __s(__is);
    if (__s)
    {

        try
        {

            typedef istreambuf_iterator<_CharT, _Traits> _Ip;
            typedef num_get<_CharT, _Ip> _Fp;
            long __temp;
            use_facet<_Fp>(__is.getloc()).get(_Ip(__is), _Ip(), __is, __state, __temp);
            if (__temp < numeric_limits<_Tp>::min())
            {
                __state |= ios_base::failbit;
                __n = numeric_limits<_Tp>::min();
            }
            else if (__temp > numeric_limits<_Tp>::max())
            {
                __state |= ios_base::failbit;
                __n = numeric_limits<_Tp>::max();
            }
            else
            {
                __n = static_cast<_Tp>(__temp);
            }

        }
        catch (...)
        {
            __state |= ios_base::badbit;
            __is.__setstate_nothrow(__state);
            if (__is.exceptions() & ios_base::badbit)
            {
                throw;
            }
        }

        __is.setstate(__state);
    }
    return __is;
}

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::operator>>(short& __n)
{
    return std::__1::__input_arithmetic_with_numeric_limits<short>(*this, __n);
}

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::operator>>(int& __n)
{
    return std::__1::__input_arithmetic_with_numeric_limits<int>(*this, __n);
}

template<class _CharT, class _Traits>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
basic_istream<_CharT, _Traits>&
__input_c_string(basic_istream<_CharT, _Traits>& __is, _CharT* __p, size_t __n)
{
    ios_base::iostate __state = ios_base::goodbit;
    typename basic_istream<_CharT, _Traits>::sentry __sen(__is);
    if (__sen)
    {

        try
        {

            _CharT* __s = __p;
            const ctype<_CharT>& __ct = use_facet<ctype<_CharT> >(__is.getloc());
            while (__s != __p + (__n-1))
            {
                typename _Traits::int_type __i = __is.rdbuf()->sgetc();
                if (_Traits::eq_int_type(__i, _Traits::eof()))
                {
                   __state |= ios_base::eofbit;
                   break;
                }
                _CharT __ch = _Traits::to_char_type(__i);
                if (__ct.is(__ct.space, __ch))
                    break;
                *__s++ = __ch;
                 __is.rdbuf()->sbumpc();
            }
            *__s = _CharT();
            __is.width(0);
            if (__s == __p)
               __state |= ios_base::failbit;

        }
        catch (...)
        {
            __state |= ios_base::badbit;
            __is.__setstate_nothrow(__state);
            if (__is.exceptions() & ios_base::badbit)
            {
                throw;
            }
        }

        __is.setstate(__state);
    }
    return __is;
}
# 604 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/istream" 3
template<class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
basic_istream<_CharT, _Traits>&
operator>>(basic_istream<_CharT, _Traits>& __is, _CharT* __s)
{
    streamsize __n = __is.width();
    if (__n <= 0)
        __n = numeric_limits<streamsize>::max() / sizeof(_CharT) - 1;
    return std::__1::__input_c_string(__is, __s, size_t(__n));
}

template<class _Traits>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
basic_istream<char, _Traits>&
operator>>(basic_istream<char, _Traits>& __is, unsigned char* __s)
{
    return __is >> (char*)__s;
}

template<class _Traits>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
basic_istream<char, _Traits>&
operator>>(basic_istream<char, _Traits>& __is, signed char* __s)
{
    return __is >> (char*)__s;
}



template<class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
operator>>(basic_istream<_CharT, _Traits>& __is, _CharT& __c)
{
    ios_base::iostate __state = ios_base::goodbit;
    typename basic_istream<_CharT, _Traits>::sentry __sen(__is);
    if (__sen)
    {

        try
        {

            typename _Traits::int_type __i = __is.rdbuf()->sbumpc();
            if (_Traits::eq_int_type(__i, _Traits::eof()))
                __state |= ios_base::eofbit | ios_base::failbit;
            else
                __c = _Traits::to_char_type(__i);

        }
        catch (...)
        {
            __state |= ios_base::badbit;
            __is.__setstate_nothrow(__state);
            if (__is.exceptions() & ios_base::badbit)
            {
                throw;
            }
        }

        __is.setstate(__state);
    }
    return __is;
}

template<class _Traits>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
basic_istream<char, _Traits>&
operator>>(basic_istream<char, _Traits>& __is, unsigned char& __c)
{
    return __is >> (char&)__c;
}

template<class _Traits>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
basic_istream<char, _Traits>&
operator>>(basic_istream<char, _Traits>& __is, signed char& __c)
{
    return __is >> (char&)__c;
}

template<class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::operator>>(basic_streambuf<char_type, traits_type>* __sb)
{
    ios_base::iostate __state = ios_base::goodbit;
    __gc_ = 0;
    sentry __s(*this, true);
    if (__s)
    {
        if (__sb)
        {

            try
            {

                while (true)
                {
                    typename traits_type::int_type __i = this->rdbuf()->sgetc();
                    if (traits_type::eq_int_type(__i, _Traits::eof()))
                    {
                       __state |= ios_base::eofbit;
                       break;
                    }
                    if (traits_type::eq_int_type(
                            __sb->sputc(traits_type::to_char_type(__i)),
                            traits_type::eof()))
                        break;
                    ++__gc_;
                    this->rdbuf()->sbumpc();
                }
                if (__gc_ == 0)
                   __state |= ios_base::failbit;

            }
            catch (...)
            {
                __state |= ios_base::badbit;
                if (__gc_ == 0)
                    __state |= ios_base::failbit;

                this->__setstate_nothrow(__state);
                if (this->exceptions() & ios_base::failbit || this->exceptions() & ios_base::badbit)
                {
                    throw;
                }
            }

        }
        else
        {
            __state |= ios_base::failbit;
        }
        this->setstate(__state);
    }
    return *this;
}

template<class _CharT, class _Traits>
typename basic_istream<_CharT, _Traits>::int_type
basic_istream<_CharT, _Traits>::get()
{
    ios_base::iostate __state = ios_base::goodbit;
    __gc_ = 0;
    int_type __r = traits_type::eof();
    sentry __s(*this, true);
    if (__s)
    {

        try
        {

            __r = this->rdbuf()->sbumpc();
            if (traits_type::eq_int_type(__r, traits_type::eof()))
               __state |= ios_base::failbit | ios_base::eofbit;
            else
                __gc_ = 1;

        }
        catch (...)
        {
            this->__setstate_nothrow(this->rdstate() | ios_base::badbit);
            if (this->exceptions() & ios_base::badbit)
            {
                throw;
            }
        }

        this->setstate(__state);
    }
    return __r;
}

template<class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::get(char_type* __s, streamsize __n, char_type __dlm)
{
    ios_base::iostate __state = ios_base::goodbit;
    __gc_ = 0;
    sentry __sen(*this, true);
    if (__sen)
    {
        if (__n > 0)
        {

            try
            {

                while (__gc_ < __n-1)
                {
                    int_type __i = this->rdbuf()->sgetc();
                    if (traits_type::eq_int_type(__i, traits_type::eof()))
                    {
                       __state |= ios_base::eofbit;
                       break;
                    }
                    char_type __ch = traits_type::to_char_type(__i);
                    if (traits_type::eq(__ch, __dlm))
                        break;
                    *__s++ = __ch;
                    ++__gc_;
                     this->rdbuf()->sbumpc();
                }
                if (__gc_ == 0)
                   __state |= ios_base::failbit;

            }
            catch (...)
            {
                __state |= ios_base::badbit;
                this->__setstate_nothrow(__state);
                if (this->exceptions() & ios_base::badbit)
                {
                    if (__n > 0)
                        *__s = char_type();
                    throw;
                }
            }

        }
        else
        {
            __state |= ios_base::failbit;
        }

        if (__n > 0)
            *__s = char_type();
        this->setstate(__state);
    }
    if (__n > 0)
        *__s = char_type();
    return *this;
}

template<class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::get(basic_streambuf<char_type, traits_type>& __sb,
                                    char_type __dlm)
{
    ios_base::iostate __state = ios_base::goodbit;
    __gc_ = 0;
    sentry __sen(*this, true);
    if (__sen)
    {

        try
        {

            while (true)
            {
                typename traits_type::int_type __i = this->rdbuf()->sgetc();
                if (traits_type::eq_int_type(__i, traits_type::eof()))
                {
                   __state |= ios_base::eofbit;
                   break;
                }
                char_type __ch = traits_type::to_char_type(__i);
                if (traits_type::eq(__ch, __dlm))
                    break;
                if (traits_type::eq_int_type(__sb.sputc(__ch), traits_type::eof()))
                    break;
                ++__gc_;
                this->rdbuf()->sbumpc();
            }

        }
        catch (...)
        {
            __state |= ios_base::badbit;

        }

        if (__gc_ == 0)
           __state |= ios_base::failbit;
        this->setstate(__state);
    }
    return *this;
}

template<class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::getline(char_type* __s, streamsize __n, char_type __dlm)
{
    ios_base::iostate __state = ios_base::goodbit;
    __gc_ = 0;
    sentry __sen(*this, true);
    if (__sen)
    {

        try
        {

            while (true)
            {
                typename traits_type::int_type __i = this->rdbuf()->sgetc();
                if (traits_type::eq_int_type(__i, traits_type::eof()))
                {
                   __state |= ios_base::eofbit;
                   break;
                }
                char_type __ch = traits_type::to_char_type(__i);
                if (traits_type::eq(__ch, __dlm))
                {
                    this->rdbuf()->sbumpc();
                    ++__gc_;
                    break;
                }
                if (__gc_ >= __n-1)
                {
                    __state |= ios_base::failbit;
                    break;
                }
                *__s++ = __ch;
                this->rdbuf()->sbumpc();
                ++__gc_;
            }

        }
        catch (...)
        {
            __state |= ios_base::badbit;
            this->__setstate_nothrow(__state);
            if (this->exceptions() & ios_base::badbit)
            {
                if (__n > 0)
                    *__s = char_type();
                if (__gc_ == 0)
                    __state |= ios_base::failbit;
                throw;
            }
        }

    }
    if (__n > 0)
        *__s = char_type();
    if (__gc_ == 0)
        __state |= ios_base::failbit;
    this->setstate(__state);
    return *this;
}

template<class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::ignore(streamsize __n, int_type __dlm)
{
    ios_base::iostate __state = ios_base::goodbit;
    __gc_ = 0;
    sentry __sen(*this, true);
    if (__sen)
    {

        try
        {

            if (__n == numeric_limits<streamsize>::max())
            {
                while (true)
                {
                    typename traits_type::int_type __i = this->rdbuf()->sbumpc();
                    if (traits_type::eq_int_type(__i, traits_type::eof()))
                    {
                       __state |= ios_base::eofbit;
                       break;
                    }
                    ++__gc_;
                    if (traits_type::eq_int_type(__i, __dlm))
                        break;
                }
            }
            else
            {
                while (__gc_ < __n)
                {
                    typename traits_type::int_type __i = this->rdbuf()->sbumpc();
                    if (traits_type::eq_int_type(__i, traits_type::eof()))
                    {
                       __state |= ios_base::eofbit;
                       break;
                    }
                    ++__gc_;
                    if (traits_type::eq_int_type(__i, __dlm))
                        break;
                }
            }

        }
        catch (...)
        {
            __state |= ios_base::badbit;
            this->__setstate_nothrow(__state);
            if (this->exceptions() & ios_base::badbit)
            {
                throw;
            }
        }

        this->setstate(__state);
    }
    return *this;
}

template<class _CharT, class _Traits>
typename basic_istream<_CharT, _Traits>::int_type
basic_istream<_CharT, _Traits>::peek()
{
    ios_base::iostate __state = ios_base::goodbit;
    __gc_ = 0;
    int_type __r = traits_type::eof();
    sentry __sen(*this, true);
    if (__sen)
    {

        try
        {

            __r = this->rdbuf()->sgetc();
            if (traits_type::eq_int_type(__r, traits_type::eof()))
                __state |= ios_base::eofbit;

        }
        catch (...)
        {
            __state |= ios_base::badbit;
            this->__setstate_nothrow(__state);
            if (this->exceptions() & ios_base::badbit)
            {
                throw;
            }
        }

        this->setstate(__state);
    }
    return __r;
}

template<class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::read(char_type* __s, streamsize __n)
{
    ios_base::iostate __state = ios_base::goodbit;
    __gc_ = 0;
    sentry __sen(*this, true);
    if (__sen)
    {

        try
        {

            __gc_ = this->rdbuf()->sgetn(__s, __n);
            if (__gc_ != __n)
                __state |= ios_base::failbit | ios_base::eofbit;

        }
        catch (...)
        {
            __state |= ios_base::badbit;
            this->__setstate_nothrow(__state);
            if (this->exceptions() & ios_base::badbit)
            {
                throw;
            }
        }

    }
    else
    {
        __state |= ios_base::failbit;
    }
    this->setstate(__state);
    return *this;
}

template<class _CharT, class _Traits>
streamsize
basic_istream<_CharT, _Traits>::readsome(char_type* __s, streamsize __n)
{
    ios_base::iostate __state = ios_base::goodbit;
    __gc_ = 0;
    sentry __sen(*this, true);
    if (__sen)
    {

        try
        {

            streamsize __c = this->rdbuf()->in_avail();
            switch (__c)
            {
            case -1:
                __state |= ios_base::eofbit;
                break;
            case 0:
                break;
            default:
                __n = std::__1::min(__c, __n);
                __gc_ = this->rdbuf()->sgetn(__s, __n);
                if (__gc_ != __n)
                    __state |= ios_base::failbit | ios_base::eofbit;
                break;
            }

        }
        catch (...)
        {
            __state |= ios_base::badbit;
            this->__setstate_nothrow(__state);
            if (this->exceptions() & ios_base::badbit)
            {
                throw;
            }
        }

    }
    else
    {
        __state |= ios_base::failbit;
    }
    this->setstate(__state);
    return __gc_;
}

template<class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::putback(char_type __c)
{
    ios_base::iostate __state = this->rdstate() & ~ios_base::eofbit;
    __gc_ = 0;
    this->clear(__state);
    sentry __sen(*this, true);
    if (__sen)
    {

        try
        {

            if (this->rdbuf() == nullptr || this->rdbuf()->sputbackc(__c) == traits_type::eof())
                __state |= ios_base::badbit;

        }
        catch (...)
        {
            __state |= ios_base::badbit;
            this->__setstate_nothrow(__state);
            if (this->exceptions() & ios_base::badbit)
            {
                throw;
            }
        }

    }
    else
    {
        __state |= ios_base::failbit;
    }
    this->setstate(__state);
    return *this;
}

template<class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::unget()
{
    ios_base::iostate __state = this->rdstate() & ~ios_base::eofbit;
    __gc_ = 0;
    this->clear(__state);
    sentry __sen(*this, true);
    if (__sen)
    {

        try
        {

            if (this->rdbuf() == nullptr || this->rdbuf()->sungetc() == traits_type::eof())
                __state |= ios_base::badbit;

        }
        catch (...)
        {
            __state |= ios_base::badbit;
            this->__setstate_nothrow(__state);
            if (this->exceptions() & ios_base::badbit)
            {
                throw;
            }
        }

    }
    else
    {
        __state |= ios_base::failbit;
    }
    this->setstate(__state);
    return *this;
}

template<class _CharT, class _Traits>
int
basic_istream<_CharT, _Traits>::sync()
{
    ios_base::iostate __state = ios_base::goodbit;
    int __r = 0;
    sentry __sen(*this, true);
    if (__sen)
    {

        try
        {

            if (this->rdbuf() == nullptr)
                return -1;
            if (this->rdbuf()->pubsync() == -1)
            {
                __state |= ios_base::badbit;
                return -1;
            }

        }
        catch (...)
        {
            __state |= ios_base::badbit;
            this->__setstate_nothrow(__state);
            if (this->exceptions() & ios_base::badbit)
            {
                throw;
            }
        }

        this->setstate(__state);
    }
    return __r;
}

template<class _CharT, class _Traits>
typename basic_istream<_CharT, _Traits>::pos_type
basic_istream<_CharT, _Traits>::tellg()
{
    ios_base::iostate __state = ios_base::goodbit;
    pos_type __r(-1);
    sentry __sen(*this, true);
    if (__sen)
    {

        try
        {

        __r = this->rdbuf()->pubseekoff(0, ios_base::cur, ios_base::in);

        }
        catch (...)
        {
            __state |= ios_base::badbit;
            this->__setstate_nothrow(__state);
            if (this->exceptions() & ios_base::badbit)
            {
                throw;
            }
        }

        this->setstate(__state);
    }
    return __r;
}

template<class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::seekg(pos_type __pos)
{
    ios_base::iostate __state = this->rdstate() & ~ios_base::eofbit;
    this->clear(__state);
    sentry __sen(*this, true);
    if (__sen)
    {

        try
        {

            if (this->rdbuf()->pubseekpos(__pos, ios_base::in) == pos_type(-1))
                __state |= ios_base::failbit;

        }
        catch (...)
        {
            __state |= ios_base::badbit;
            this->__setstate_nothrow(__state);
            if (this->exceptions() & ios_base::badbit)
            {
                throw;
            }
        }

        this->setstate(__state);
    }
    return *this;
}

template<class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::seekg(off_type __off, ios_base::seekdir __dir)
{
    ios_base::iostate __state = this->rdstate() & ~ios_base::eofbit;
    this->clear(__state);
    sentry __sen(*this, true);
    if (__sen)
    {

        try
        {

            if (this->rdbuf()->pubseekoff(__off, __dir, ios_base::in) == pos_type(-1))
                __state |= ios_base::failbit;

        }
        catch (...)
        {
            __state |= ios_base::badbit;
            this->__setstate_nothrow(__state);
            if (this->exceptions() & ios_base::badbit)
            {
                throw;
            }
        }

        this->setstate(__state);
    }
    return *this;
}

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
ws(basic_istream<_CharT, _Traits>& __is)
{
    ios_base::iostate __state = ios_base::goodbit;
    typename basic_istream<_CharT, _Traits>::sentry __sen(__is, true);
    if (__sen)
    {

        try
        {

            const ctype<_CharT>& __ct = use_facet<ctype<_CharT> >(__is.getloc());
            while (true)
            {
                typename _Traits::int_type __i = __is.rdbuf()->sgetc();
                if (_Traits::eq_int_type(__i, _Traits::eof()))
                {
                   __state |= ios_base::eofbit;
                   break;
                }
                if (!__ct.is(__ct.space, _Traits::to_char_type(__i)))
                    break;
                __is.rdbuf()->sbumpc();
            }

        }
        catch (...)
        {
            __state |= ios_base::badbit;
            __is.__setstate_nothrow(__state);
            if (__is.exceptions() & ios_base::badbit)
            {
                throw;
            }
        }

        __is.setstate(__state);
    }
    return __is;
}

template <class _Stream, class _Tp, class = void>
struct __is_istreamable : false_type { };

template <class _Stream, class _Tp>
struct __is_istreamable<_Stream, _Tp, decltype(
    declval<_Stream>() >> declval<_Tp>(), void()
)> : true_type { };

template <class _Stream, class _Tp, class = typename enable_if<
    _And<is_base_of<ios_base, _Stream>,
         __is_istreamable<_Stream&, _Tp&&> >::value
>::type>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
_Stream&& operator>>(_Stream&& __is, _Tp&& __x)
{
    __is >> std::__1::forward<_Tp>(__x);
    return std::__1::move(__is);
}

template <class _CharT, class _Traits>
class __attribute__ ((__type_visibility__("default"))) basic_iostream
    : public basic_istream<_CharT, _Traits>,
      public basic_ostream<_CharT, _Traits>
{
public:

    typedef _CharT char_type;
    typedef _Traits traits_type;
    typedef typename traits_type::int_type int_type;
    typedef typename traits_type::pos_type pos_type;
    typedef typename traits_type::off_type off_type;


    inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit basic_iostream(basic_streambuf<char_type, traits_type>* __sb)
      : basic_istream<_CharT, _Traits>(__sb)
    {}

    virtual ~basic_iostream();
protected:
    inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    basic_iostream(basic_iostream&& __rhs);


    inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    basic_iostream& operator=(basic_iostream&& __rhs);

    inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void swap(basic_iostream& __rhs)
    { basic_istream<char_type, traits_type>::swap(__rhs); }
};

template <class _CharT, class _Traits>
basic_iostream<_CharT, _Traits>::basic_iostream(basic_iostream&& __rhs)
    : basic_istream<_CharT, _Traits>(std::__1::move(__rhs))
{
}

template <class _CharT, class _Traits>
basic_iostream<_CharT, _Traits>&
basic_iostream<_CharT, _Traits>::operator=(basic_iostream&& __rhs)
{
    swap(__rhs);
    return *this;
}

template <class _CharT, class _Traits>
basic_iostream<_CharT, _Traits>::~basic_iostream()
{
}

template<class _CharT, class _Traits, class _Allocator>
basic_istream<_CharT, _Traits>&
operator>>(basic_istream<_CharT, _Traits>& __is,
           basic_string<_CharT, _Traits, _Allocator>& __str)
{
    ios_base::iostate __state = ios_base::goodbit;
    typename basic_istream<_CharT, _Traits>::sentry __sen(__is);
    if (__sen)
    {

        try
        {

            __str.clear();
            streamsize __n = __is.width();
            if (__n <= 0)
                __n = __str.max_size();
            if (__n <= 0)
                __n = numeric_limits<streamsize>::max();
            streamsize __c = 0;
            const ctype<_CharT>& __ct = use_facet<ctype<_CharT> >(__is.getloc());
            while (__c < __n)
            {
                typename _Traits::int_type __i = __is.rdbuf()->sgetc();
                if (_Traits::eq_int_type(__i, _Traits::eof()))
                {
                   __state |= ios_base::eofbit;
                   break;
                }
                _CharT __ch = _Traits::to_char_type(__i);
                if (__ct.is(__ct.space, __ch))
                    break;
                __str.push_back(__ch);
                ++__c;
                 __is.rdbuf()->sbumpc();
            }
            __is.width(0);
            if (__c == 0)
               __state |= ios_base::failbit;

        }
        catch (...)
        {
            __state |= ios_base::badbit;
            __is.__setstate_nothrow(__state);
            if (__is.exceptions() & ios_base::badbit)
            {
                throw;
            }
        }

        __is.setstate(__state);
    }
    return __is;
}

template<class _CharT, class _Traits, class _Allocator>
basic_istream<_CharT, _Traits>&
getline(basic_istream<_CharT, _Traits>& __is,
        basic_string<_CharT, _Traits, _Allocator>& __str, _CharT __dlm)
{
    ios_base::iostate __state = ios_base::goodbit;
    typename basic_istream<_CharT, _Traits>::sentry __sen(__is, true);
    if (__sen)
    {

        try
        {

            __str.clear();
            streamsize __extr = 0;
            while (true)
            {
                typename _Traits::int_type __i = __is.rdbuf()->sbumpc();
                if (_Traits::eq_int_type(__i, _Traits::eof()))
                {
                   __state |= ios_base::eofbit;
                   break;
                }
                ++__extr;
                _CharT __ch = _Traits::to_char_type(__i);
                if (_Traits::eq(__ch, __dlm))
                    break;
                __str.push_back(__ch);
                if (__str.size() == __str.max_size())
                {
                    __state |= ios_base::failbit;
                    break;
                }
            }
            if (__extr == 0)
               __state |= ios_base::failbit;

        }
        catch (...)
        {
            __state |= ios_base::badbit;
            __is.__setstate_nothrow(__state);
            if (__is.exceptions() & ios_base::badbit)
            {
                throw;
            }
        }

        __is.setstate(__state);
    }
    return __is;
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
basic_istream<_CharT, _Traits>&
getline(basic_istream<_CharT, _Traits>& __is,
        basic_string<_CharT, _Traits, _Allocator>& __str)
{
    return getline(__is, __str, __is.widen('\n'));
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
basic_istream<_CharT, _Traits>&
getline(basic_istream<_CharT, _Traits>&& __is,
        basic_string<_CharT, _Traits, _Allocator>& __str, _CharT __dlm)
{
    return getline(__is, __str, __dlm);
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
basic_istream<_CharT, _Traits>&
getline(basic_istream<_CharT, _Traits>&& __is,
        basic_string<_CharT, _Traits, _Allocator>& __str)
{
    return getline(__is, __str, __is.widen('\n'));
}

template <class _CharT, class _Traits, size_t _Size>
basic_istream<_CharT, _Traits>&
operator>>(basic_istream<_CharT, _Traits>& __is, bitset<_Size>& __x)
{
    ios_base::iostate __state = ios_base::goodbit;
    typename basic_istream<_CharT, _Traits>::sentry __sen(__is);
    if (__sen)
    {

        try
        {

            basic_string<_CharT, _Traits> __str;
            const ctype<_CharT>& __ct = use_facet<ctype<_CharT> >(__is.getloc());
            size_t __c = 0;
            _CharT __zero = __ct.widen('0');
            _CharT __one = __ct.widen('1');
            while (__c < _Size)
            {
                typename _Traits::int_type __i = __is.rdbuf()->sgetc();
                if (_Traits::eq_int_type(__i, _Traits::eof()))
                {
                   __state |= ios_base::eofbit;
                   break;
                }
                _CharT __ch = _Traits::to_char_type(__i);
                if (!_Traits::eq(__ch, __zero) && !_Traits::eq(__ch, __one))
                    break;
                __str.push_back(__ch);
                ++__c;
                 __is.rdbuf()->sbumpc();
            }
            __x = bitset<_Size>(__str);
            if (_Size > 0 && __c == 0)
               __state |= ios_base::failbit;

        }
        catch (...)
        {
            __state |= ios_base::badbit;
            __is.__setstate_nothrow(__state);
            if (__is.exceptions() & ios_base::badbit)
            {
                throw;
            }
        }

        __is.setstate(__state);
    }
    return __is;
}

extern template class __attribute__ ((__visibility__("default"))) basic_istream<char>;

extern template class __attribute__ ((__visibility__("default"))) basic_istream<wchar_t>;

extern template class __attribute__ ((__visibility__("default"))) basic_iostream<char>;

} }
# 185 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/sstream" 2 3
# 190 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/sstream" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 194 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/sstream" 2 3


namespace std { inline namespace __1 {



template <class _CharT, class _Traits, class _Allocator>
class __attribute__ ((__type_visibility__("default"))) basic_stringbuf
    : public basic_streambuf<_CharT, _Traits>
{
public:
    typedef _CharT char_type;
    typedef _Traits traits_type;
    typedef typename traits_type::int_type int_type;
    typedef typename traits_type::pos_type pos_type;
    typedef typename traits_type::off_type off_type;
    typedef _Allocator allocator_type;

    typedef basic_string<char_type, traits_type, allocator_type> string_type;

private:

    string_type __str_;
    mutable char_type* __hm_;
    ios_base::openmode __mode_;

public:

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    basic_stringbuf()
        : __hm_(nullptr), __mode_(ios_base::in | ios_base::out) {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit basic_stringbuf(ios_base::openmode __wch)
        : __hm_(nullptr), __mode_(__wch) {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit basic_stringbuf(const string_type& __s,
                             ios_base::openmode __wch = ios_base::in | ios_base::out)
        : __str_(__s.get_allocator()), __hm_(nullptr), __mode_(__wch)
    {
        str(__s);
    }

    basic_stringbuf(basic_stringbuf&& __rhs);


    basic_stringbuf& operator=(basic_stringbuf&& __rhs);
    void swap(basic_stringbuf& __rhs);


    string_type str() const;
    void str(const string_type& __s);

protected:

    virtual int_type underflow();
    virtual int_type pbackfail(int_type __c = traits_type::eof());
    virtual int_type overflow (int_type __c = traits_type::eof());
    virtual pos_type seekoff(off_type __off, ios_base::seekdir __way,
                             ios_base::openmode __wch = ios_base::in | ios_base::out);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    virtual pos_type seekpos(pos_type __sp,
                             ios_base::openmode __wch = ios_base::in | ios_base::out) {
        return seekoff(__sp, ios_base::beg, __wch);
    }
};

template <class _CharT, class _Traits, class _Allocator>
basic_stringbuf<_CharT, _Traits, _Allocator>::basic_stringbuf(basic_stringbuf&& __rhs)
    : __mode_(__rhs.__mode_)
{
    char_type* __p = const_cast<char_type*>(__rhs.__str_.data());
    ptrdiff_t __binp = -1;
    ptrdiff_t __ninp = -1;
    ptrdiff_t __einp = -1;
    if (__rhs.eback() != nullptr)
    {
        __binp = __rhs.eback() - __p;
        __ninp = __rhs.gptr() - __p;
        __einp = __rhs.egptr() - __p;
    }
    ptrdiff_t __bout = -1;
    ptrdiff_t __nout = -1;
    ptrdiff_t __eout = -1;
    if (__rhs.pbase() != nullptr)
    {
        __bout = __rhs.pbase() - __p;
        __nout = __rhs.pptr() - __p;
        __eout = __rhs.epptr() - __p;
    }
    ptrdiff_t __hm = __rhs.__hm_ == nullptr ? -1 : __rhs.__hm_ - __p;
    __str_ = std::__1::move(__rhs.__str_);
    __p = const_cast<char_type*>(__str_.data());
    if (__binp != -1)
        this->setg(__p + __binp, __p + __ninp, __p + __einp);
    if (__bout != -1)
    {
        this->setp(__p + __bout, __p + __eout);
        this->__pbump(__nout);
    }
    __hm_ = __hm == -1 ? nullptr : __p + __hm;
    __p = const_cast<char_type*>(__rhs.__str_.data());
    __rhs.setg(__p, __p, __p);
    __rhs.setp(__p, __p);
    __rhs.__hm_ = __p;
    this->pubimbue(__rhs.getloc());
}

template <class _CharT, class _Traits, class _Allocator>
basic_stringbuf<_CharT, _Traits, _Allocator>&
basic_stringbuf<_CharT, _Traits, _Allocator>::operator=(basic_stringbuf&& __rhs)
{
    char_type* __p = const_cast<char_type*>(__rhs.__str_.data());
    ptrdiff_t __binp = -1;
    ptrdiff_t __ninp = -1;
    ptrdiff_t __einp = -1;
    if (__rhs.eback() != nullptr)
    {
        __binp = __rhs.eback() - __p;
        __ninp = __rhs.gptr() - __p;
        __einp = __rhs.egptr() - __p;
    }
    ptrdiff_t __bout = -1;
    ptrdiff_t __nout = -1;
    ptrdiff_t __eout = -1;
    if (__rhs.pbase() != nullptr)
    {
        __bout = __rhs.pbase() - __p;
        __nout = __rhs.pptr() - __p;
        __eout = __rhs.epptr() - __p;
    }
    ptrdiff_t __hm = __rhs.__hm_ == nullptr ? -1 : __rhs.__hm_ - __p;
    __str_ = std::__1::move(__rhs.__str_);
    __p = const_cast<char_type*>(__str_.data());
    if (__binp != -1)
        this->setg(__p + __binp, __p + __ninp, __p + __einp);
    else
        this->setg(nullptr, nullptr, nullptr);
    if (__bout != -1)
    {
        this->setp(__p + __bout, __p + __eout);
        this->__pbump(__nout);
    }
    else
        this->setp(nullptr, nullptr);

    __hm_ = __hm == -1 ? nullptr : __p + __hm;
    __mode_ = __rhs.__mode_;
    __p = const_cast<char_type*>(__rhs.__str_.data());
    __rhs.setg(__p, __p, __p);
    __rhs.setp(__p, __p);
    __rhs.__hm_ = __p;
    this->pubimbue(__rhs.getloc());
    return *this;
}

template <class _CharT, class _Traits, class _Allocator>
void
basic_stringbuf<_CharT, _Traits, _Allocator>::swap(basic_stringbuf& __rhs)
{
    char_type* __p = const_cast<char_type*>(__rhs.__str_.data());
    ptrdiff_t __rbinp = -1;
    ptrdiff_t __rninp = -1;
    ptrdiff_t __reinp = -1;
    if (__rhs.eback() != nullptr)
    {
        __rbinp = __rhs.eback() - __p;
        __rninp = __rhs.gptr() - __p;
        __reinp = __rhs.egptr() - __p;
    }
    ptrdiff_t __rbout = -1;
    ptrdiff_t __rnout = -1;
    ptrdiff_t __reout = -1;
    if (__rhs.pbase() != nullptr)
    {
        __rbout = __rhs.pbase() - __p;
        __rnout = __rhs.pptr() - __p;
        __reout = __rhs.epptr() - __p;
    }
    ptrdiff_t __rhm = __rhs.__hm_ == nullptr ? -1 : __rhs.__hm_ - __p;
    __p = const_cast<char_type*>(__str_.data());
    ptrdiff_t __lbinp = -1;
    ptrdiff_t __lninp = -1;
    ptrdiff_t __leinp = -1;
    if (this->eback() != nullptr)
    {
        __lbinp = this->eback() - __p;
        __lninp = this->gptr() - __p;
        __leinp = this->egptr() - __p;
    }
    ptrdiff_t __lbout = -1;
    ptrdiff_t __lnout = -1;
    ptrdiff_t __leout = -1;
    if (this->pbase() != nullptr)
    {
        __lbout = this->pbase() - __p;
        __lnout = this->pptr() - __p;
        __leout = this->epptr() - __p;
    }
    ptrdiff_t __lhm = __hm_ == nullptr ? -1 : __hm_ - __p;
    std::__1::swap(__mode_, __rhs.__mode_);
    __str_.swap(__rhs.__str_);
    __p = const_cast<char_type*>(__str_.data());
    if (__rbinp != -1)
        this->setg(__p + __rbinp, __p + __rninp, __p + __reinp);
    else
        this->setg(nullptr, nullptr, nullptr);
    if (__rbout != -1)
    {
        this->setp(__p + __rbout, __p + __reout);
        this->__pbump(__rnout);
    }
    else
        this->setp(nullptr, nullptr);
    __hm_ = __rhm == -1 ? nullptr : __p + __rhm;
    __p = const_cast<char_type*>(__rhs.__str_.data());
    if (__lbinp != -1)
        __rhs.setg(__p + __lbinp, __p + __lninp, __p + __leinp);
    else
        __rhs.setg(nullptr, nullptr, nullptr);
    if (__lbout != -1)
    {
        __rhs.setp(__p + __lbout, __p + __leout);
        __rhs.__pbump(__lnout);
    }
    else
        __rhs.setp(nullptr, nullptr);
    __rhs.__hm_ = __lhm == -1 ? nullptr : __p + __lhm;
    locale __tl = __rhs.getloc();
    __rhs.pubimbue(this->getloc());
    this->pubimbue(__tl);
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void
swap(basic_stringbuf<_CharT, _Traits, _Allocator>& __x,
     basic_stringbuf<_CharT, _Traits, _Allocator>& __y)
{
    __x.swap(__y);
}

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>
basic_stringbuf<_CharT, _Traits, _Allocator>::str() const
{
    if (__mode_ & ios_base::out)
    {
        if (__hm_ < this->pptr())
            __hm_ = this->pptr();
        return string_type(this->pbase(), __hm_, __str_.get_allocator());
    }
    else if (__mode_ & ios_base::in)
        return string_type(this->eback(), this->egptr(), __str_.get_allocator());
    return string_type(__str_.get_allocator());
}

template <class _CharT, class _Traits, class _Allocator>
void
basic_stringbuf<_CharT, _Traits, _Allocator>::str(const string_type& __s)
{
    __str_ = __s;
    __hm_ = nullptr;
    if (__mode_ & ios_base::in)
    {
        __hm_ = const_cast<char_type*>(__str_.data()) + __str_.size();
        this->setg(const_cast<char_type*>(__str_.data()),
                   const_cast<char_type*>(__str_.data()),
                   __hm_);
    }
    if (__mode_ & ios_base::out)
    {
        typename string_type::size_type __sz = __str_.size();
        __hm_ = const_cast<char_type*>(__str_.data()) + __sz;
        __str_.resize(__str_.capacity());
        this->setp(const_cast<char_type*>(__str_.data()),
                   const_cast<char_type*>(__str_.data()) + __str_.size());
        if (__mode_ & (ios_base::app | ios_base::ate))
        {
            while (__sz > 2147483647)
            {
                this->pbump(2147483647);
                __sz -= 2147483647;
            }
            if (__sz > 0)
                this->pbump(__sz);
        }
    }
}

template <class _CharT, class _Traits, class _Allocator>
typename basic_stringbuf<_CharT, _Traits, _Allocator>::int_type
basic_stringbuf<_CharT, _Traits, _Allocator>::underflow()
{
    if (__hm_ < this->pptr())
        __hm_ = this->pptr();
    if (__mode_ & ios_base::in)
    {
        if (this->egptr() < __hm_)
            this->setg(this->eback(), this->gptr(), __hm_);
        if (this->gptr() < this->egptr())
            return traits_type::to_int_type(*this->gptr());
    }
    return traits_type::eof();
}

template <class _CharT, class _Traits, class _Allocator>
typename basic_stringbuf<_CharT, _Traits, _Allocator>::int_type
basic_stringbuf<_CharT, _Traits, _Allocator>::pbackfail(int_type __c)
{
    if (__hm_ < this->pptr())
        __hm_ = this->pptr();
    if (this->eback() < this->gptr())
    {
        if (traits_type::eq_int_type(__c, traits_type::eof()))
        {
            this->setg(this->eback(), this->gptr()-1, __hm_);
            return traits_type::not_eof(__c);
        }
        if ((__mode_ & ios_base::out) ||
            traits_type::eq(traits_type::to_char_type(__c), this->gptr()[-1]))
        {
            this->setg(this->eback(), this->gptr()-1, __hm_);
            *this->gptr() = traits_type::to_char_type(__c);
            return __c;
        }
    }
    return traits_type::eof();
}

template <class _CharT, class _Traits, class _Allocator>
typename basic_stringbuf<_CharT, _Traits, _Allocator>::int_type
basic_stringbuf<_CharT, _Traits, _Allocator>::overflow(int_type __c)
{
    if (!traits_type::eq_int_type(__c, traits_type::eof()))
    {
        ptrdiff_t __ninp = this->gptr() - this->eback();
        if (this->pptr() == this->epptr())
        {
            if (!(__mode_ & ios_base::out))
                return traits_type::eof();

            try
            {

                ptrdiff_t __nout = this->pptr() - this->pbase();
                ptrdiff_t __hm = __hm_ - this->pbase();
                __str_.push_back(char_type());
                __str_.resize(__str_.capacity());
                char_type* __p = const_cast<char_type*>(__str_.data());
                this->setp(__p, __p + __str_.size());
                this->__pbump(__nout);
                __hm_ = this->pbase() + __hm;

            }
            catch (...)
            {
                return traits_type::eof();
            }

        }
        __hm_ = std::__1::max(this->pptr() + 1, __hm_);
        if (__mode_ & ios_base::in)
        {
            char_type* __p = const_cast<char_type*>(__str_.data());
            this->setg(__p, __p + __ninp, __hm_);
        }
        return this->sputc(traits_type::to_char_type(__c));
    }
    return traits_type::not_eof(__c);
}

template <class _CharT, class _Traits, class _Allocator>
typename basic_stringbuf<_CharT, _Traits, _Allocator>::pos_type
basic_stringbuf<_CharT, _Traits, _Allocator>::seekoff(off_type __off,
                                                      ios_base::seekdir __way,
                                                      ios_base::openmode __wch)
{
    if (__hm_ < this->pptr())
        __hm_ = this->pptr();
    if ((__wch & (ios_base::in | ios_base::out)) == 0)
        return pos_type(-1);
    if ((__wch & (ios_base::in | ios_base::out)) == (ios_base::in | ios_base::out)
        && __way == ios_base::cur)
        return pos_type(-1);
    const ptrdiff_t __hm = __hm_ == nullptr ? 0 : __hm_ - __str_.data();
    off_type __noff;
    switch (__way)
    {
    case ios_base::beg:
        __noff = 0;
        break;
    case ios_base::cur:
        if (__wch & ios_base::in)
            __noff = this->gptr() - this->eback();
        else
            __noff = this->pptr() - this->pbase();
        break;
    case ios_base::end:
        __noff = __hm;
        break;
    default:
        return pos_type(-1);
    }
    __noff += __off;
    if (__noff < 0 || __hm < __noff)
        return pos_type(-1);
    if (__noff != 0)
    {
        if ((__wch & ios_base::in) && this->gptr() == nullptr)
            return pos_type(-1);
        if ((__wch & ios_base::out) && this->pptr() == nullptr)
            return pos_type(-1);
    }
    if (__wch & ios_base::in)
        this->setg(this->eback(), this->eback() + __noff, __hm_);
    if (__wch & ios_base::out)
    {
        this->setp(this->pbase(), this->epptr());
        this->pbump(__noff);
    }
    return pos_type(__noff);
}



template <class _CharT, class _Traits, class _Allocator>
class __attribute__ ((__type_visibility__("default"))) basic_istringstream
    : public basic_istream<_CharT, _Traits>
{
public:
    typedef _CharT char_type;
    typedef _Traits traits_type;
    typedef typename traits_type::int_type int_type;
    typedef typename traits_type::pos_type pos_type;
    typedef typename traits_type::off_type off_type;
    typedef _Allocator allocator_type;

    typedef basic_string<char_type, traits_type, allocator_type> string_type;

private:
    basic_stringbuf<char_type, traits_type, allocator_type> __sb_;

public:

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    basic_istringstream()
        : basic_istream<_CharT, _Traits>(&__sb_), __sb_(ios_base::in) {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit basic_istringstream(ios_base::openmode __wch)
        : basic_istream<_CharT, _Traits>(&__sb_), __sb_(__wch | ios_base::in) {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit basic_istringstream(const string_type& __s,
                                 ios_base::openmode __wch = ios_base::in)
        : basic_istream<_CharT, _Traits>(&__sb_)
        , __sb_(__s, __wch | ios_base::in)
    { }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    basic_istringstream(basic_istringstream&& __rhs)
        : basic_istream<_CharT, _Traits>(std::__1::move(__rhs))
        , __sb_(std::__1::move(__rhs.__sb_))
    {
        basic_istream<_CharT, _Traits>::set_rdbuf(&__sb_);
    }


    basic_istringstream& operator=(basic_istringstream&& __rhs) {
        basic_istream<char_type, traits_type>::operator=(std::__1::move(__rhs));
        __sb_ = std::__1::move(__rhs.__sb_);
        return *this;
    }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void swap(basic_istringstream& __rhs) {
        basic_istream<char_type, traits_type>::swap(__rhs);
        __sb_.swap(__rhs.__sb_);
    }


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    basic_stringbuf<char_type, traits_type, allocator_type>* rdbuf() const {
        return const_cast<basic_stringbuf<char_type, traits_type, allocator_type>*>(&__sb_);
    }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    string_type str() const {
        return __sb_.str();
    }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void str(const string_type& __s) {
        __sb_.str(__s);
    }
};

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void
swap(basic_istringstream<_CharT, _Traits, _Allocator>& __x,
     basic_istringstream<_CharT, _Traits, _Allocator>& __y)
{
    __x.swap(__y);
}



template <class _CharT, class _Traits, class _Allocator>
class __attribute__ ((__type_visibility__("default"))) basic_ostringstream
    : public basic_ostream<_CharT, _Traits>
{
public:
    typedef _CharT char_type;
    typedef _Traits traits_type;
    typedef typename traits_type::int_type int_type;
    typedef typename traits_type::pos_type pos_type;
    typedef typename traits_type::off_type off_type;
    typedef _Allocator allocator_type;

    typedef basic_string<char_type, traits_type, allocator_type> string_type;

private:
    basic_stringbuf<char_type, traits_type, allocator_type> __sb_;

public:

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    basic_ostringstream()
        : basic_ostream<_CharT, _Traits>(&__sb_), __sb_(ios_base::out) {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit basic_ostringstream(ios_base::openmode __wch)
        : basic_ostream<_CharT, _Traits>(&__sb_), __sb_(__wch | ios_base::out) {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit basic_ostringstream(const string_type& __s,
                                 ios_base::openmode __wch = ios_base::out)
        : basic_ostream<_CharT, _Traits>(&__sb_)
        , __sb_(__s, __wch | ios_base::out)
    { }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    basic_ostringstream(basic_ostringstream&& __rhs)
        : basic_ostream<_CharT, _Traits>(std::__1::move(__rhs))
        , __sb_(std::__1::move(__rhs.__sb_))
    {
        basic_ostream<_CharT, _Traits>::set_rdbuf(&__sb_);
    }


    basic_ostringstream& operator=(basic_ostringstream&& __rhs) {
        basic_ostream<char_type, traits_type>::operator=(std::__1::move(__rhs));
        __sb_ = std::__1::move(__rhs.__sb_);
        return *this;
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void swap(basic_ostringstream& __rhs) {
        basic_ostream<char_type, traits_type>::swap(__rhs);
        __sb_.swap(__rhs.__sb_);
    }


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    basic_stringbuf<char_type, traits_type, allocator_type>* rdbuf() const {
        return const_cast<basic_stringbuf<char_type, traits_type, allocator_type>*>(&__sb_);
    }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    string_type str() const {
        return __sb_.str();
    }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void str(const string_type& __s) {
        __sb_.str(__s);
    }
};

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void
swap(basic_ostringstream<_CharT, _Traits, _Allocator>& __x,
     basic_ostringstream<_CharT, _Traits, _Allocator>& __y)
{
    __x.swap(__y);
}



template <class _CharT, class _Traits, class _Allocator>
class __attribute__ ((__type_visibility__("default"))) basic_stringstream
    : public basic_iostream<_CharT, _Traits>
{
public:
    typedef _CharT char_type;
    typedef _Traits traits_type;
    typedef typename traits_type::int_type int_type;
    typedef typename traits_type::pos_type pos_type;
    typedef typename traits_type::off_type off_type;
    typedef _Allocator allocator_type;

    typedef basic_string<char_type, traits_type, allocator_type> string_type;

private:
    basic_stringbuf<char_type, traits_type, allocator_type> __sb_;

public:

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    basic_stringstream()
        : basic_iostream<_CharT, _Traits>(&__sb_), __sb_(ios_base::in | ios_base::out) {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit basic_stringstream(ios_base::openmode __wch)
        : basic_iostream<_CharT, _Traits>(&__sb_), __sb_(__wch) {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit basic_stringstream(const string_type& __s,
                                ios_base::openmode __wch = ios_base::in | ios_base::out)
        : basic_iostream<_CharT, _Traits>(&__sb_)
        , __sb_(__s, __wch)
    { }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    basic_stringstream(basic_stringstream&& __rhs)
        : basic_iostream<_CharT, _Traits>(std::__1::move(__rhs))
        , __sb_(std::__1::move(__rhs.__sb_))
    {
        basic_istream<_CharT, _Traits>::set_rdbuf(&__sb_);
    }


    basic_stringstream& operator=(basic_stringstream&& __rhs) {
        basic_iostream<char_type, traits_type>::operator=(std::__1::move(__rhs));
        __sb_ = std::__1::move(__rhs.__sb_);
        return *this;
    }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void swap(basic_stringstream& __rhs) {
        basic_iostream<char_type, traits_type>::swap(__rhs);
        __sb_.swap(__rhs.__sb_);
    }


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    basic_stringbuf<char_type, traits_type, allocator_type>* rdbuf() const {
        return const_cast<basic_stringbuf<char_type, traits_type, allocator_type>*>(&__sb_);
    }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    string_type str() const {
        return __sb_.str();
    }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void str(const string_type& __s) {
        __sb_.str(__s);
    }
};

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void
swap(basic_stringstream<_CharT, _Traits, _Allocator>& __x,
     basic_stringstream<_CharT, _Traits, _Allocator>& __y)
{
    __x.swap(__y);
}


extern template class __attribute__ ((__visibility__("default"))) basic_stringbuf<char>;
extern template class __attribute__ ((__visibility__("default"))) basic_stringstream<char>;
extern template class __attribute__ ((__visibility__("default"))) basic_ostringstream<char>;
extern template class __attribute__ ((__visibility__("default"))) basic_istringstream<char>;


} }
# 243 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/complex" 2 3
# 247 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/complex" 3


namespace std { inline namespace __1 {

template<class _Tp> class __attribute__ ((__type_visibility__("default"))) complex;

template<class _Tp> complex<_Tp> operator*(const complex<_Tp>& __z, const complex<_Tp>& __w);
template<class _Tp> complex<_Tp> operator/(const complex<_Tp>& __x, const complex<_Tp>& __y);

template<class _Tp>
class __attribute__ ((__type_visibility__("default"))) complex
{
public:
    typedef _Tp value_type;
private:
    value_type __re_;
    value_type __im_;
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
    complex(const value_type& __re = value_type(), const value_type& __im = value_type())
        : __re_(__re), __im_(__im) {}
    template<class _Xp> __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
    complex(const complex<_Xp>& __c)
        : __re_(__c.real()), __im_(__c.imag()) {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr value_type real() const {return __re_;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr value_type imag() const {return __im_;}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) void real(value_type __re) {__re_ = __re;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) void imag(value_type __im) {__im_ = __im;}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) complex& operator= (const value_type& __re)
        {__re_ = __re; __im_ = value_type(); return *this;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) complex& operator+=(const value_type& __re) {__re_ += __re; return *this;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) complex& operator-=(const value_type& __re) {__re_ -= __re; return *this;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) complex& operator*=(const value_type& __re) {__re_ *= __re; __im_ *= __re; return *this;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) complex& operator/=(const value_type& __re) {__re_ /= __re; __im_ /= __re; return *this;}

    template<class _Xp> __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) complex& operator= (const complex<_Xp>& __c)
        {
            __re_ = __c.real();
            __im_ = __c.imag();
            return *this;
        }
    template<class _Xp> __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) complex& operator+=(const complex<_Xp>& __c)
        {
            __re_ += __c.real();
            __im_ += __c.imag();
            return *this;
        }
    template<class _Xp> __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) complex& operator-=(const complex<_Xp>& __c)
        {
            __re_ -= __c.real();
            __im_ -= __c.imag();
            return *this;
        }
    template<class _Xp> __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) complex& operator*=(const complex<_Xp>& __c)
        {
            *this = *this * complex(__c.real(), __c.imag());
            return *this;
        }
    template<class _Xp> __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) complex& operator/=(const complex<_Xp>& __c)
        {
            *this = *this / complex(__c.real(), __c.imag());
            return *this;
        }
};

template<> class __attribute__ ((__type_visibility__("default"))) complex<double>;
template<> class __attribute__ ((__type_visibility__("default"))) complex<long double>;

template<>
class __attribute__ ((__type_visibility__("default"))) complex<float>
{
    float __re_;
    float __im_;
public:
    typedef float value_type;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr complex(float __re = 0.0f, float __im = 0.0f)
        : __re_(__re), __im_(__im) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit constexpr complex(const complex<double>& __c);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit constexpr complex(const complex<long double>& __c);

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr float real() const {return __re_;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr float imag() const {return __im_;}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) void real(value_type __re) {__re_ = __re;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) void imag(value_type __im) {__im_ = __im;}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) complex& operator= (float __re)
        {__re_ = __re; __im_ = value_type(); return *this;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) complex& operator+=(float __re) {__re_ += __re; return *this;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) complex& operator-=(float __re) {__re_ -= __re; return *this;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) complex& operator*=(float __re) {__re_ *= __re; __im_ *= __re; return *this;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) complex& operator/=(float __re) {__re_ /= __re; __im_ /= __re; return *this;}

    template<class _Xp> __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) complex& operator= (const complex<_Xp>& __c)
        {
            __re_ = __c.real();
            __im_ = __c.imag();
            return *this;
        }
    template<class _Xp> __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) complex& operator+=(const complex<_Xp>& __c)
        {
            __re_ += __c.real();
            __im_ += __c.imag();
            return *this;
        }
    template<class _Xp> __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) complex& operator-=(const complex<_Xp>& __c)
        {
            __re_ -= __c.real();
            __im_ -= __c.imag();
            return *this;
        }
    template<class _Xp> __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) complex& operator*=(const complex<_Xp>& __c)
        {
            *this = *this * complex(__c.real(), __c.imag());
            return *this;
        }
    template<class _Xp> __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) complex& operator/=(const complex<_Xp>& __c)
        {
            *this = *this / complex(__c.real(), __c.imag());
            return *this;
        }
};

template<>
class __attribute__ ((__type_visibility__("default"))) complex<double>
{
    double __re_;
    double __im_;
public:
    typedef double value_type;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr complex(double __re = 0.0, double __im = 0.0)
        : __re_(__re), __im_(__im) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    constexpr complex(const complex<float>& __c);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit constexpr complex(const complex<long double>& __c);

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr double real() const {return __re_;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr double imag() const {return __im_;}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) void real(value_type __re) {__re_ = __re;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) void imag(value_type __im) {__im_ = __im;}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) complex& operator= (double __re)
        {__re_ = __re; __im_ = value_type(); return *this;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) complex& operator+=(double __re) {__re_ += __re; return *this;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) complex& operator-=(double __re) {__re_ -= __re; return *this;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) complex& operator*=(double __re) {__re_ *= __re; __im_ *= __re; return *this;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) complex& operator/=(double __re) {__re_ /= __re; __im_ /= __re; return *this;}

    template<class _Xp> __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) complex& operator= (const complex<_Xp>& __c)
        {
            __re_ = __c.real();
            __im_ = __c.imag();
            return *this;
        }
    template<class _Xp> __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) complex& operator+=(const complex<_Xp>& __c)
        {
            __re_ += __c.real();
            __im_ += __c.imag();
            return *this;
        }
    template<class _Xp> __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) complex& operator-=(const complex<_Xp>& __c)
        {
            __re_ -= __c.real();
            __im_ -= __c.imag();
            return *this;
        }
    template<class _Xp> __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) complex& operator*=(const complex<_Xp>& __c)
        {
            *this = *this * complex(__c.real(), __c.imag());
            return *this;
        }
    template<class _Xp> __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) complex& operator/=(const complex<_Xp>& __c)
        {
            *this = *this / complex(__c.real(), __c.imag());
            return *this;
        }
};

template<>
class __attribute__ ((__type_visibility__("default"))) complex<long double>
{
    long double __re_;
    long double __im_;
public:
    typedef long double value_type;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr complex(long double __re = 0.0L, long double __im = 0.0L)
        : __re_(__re), __im_(__im) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    constexpr complex(const complex<float>& __c);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    constexpr complex(const complex<double>& __c);

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr long double real() const {return __re_;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr long double imag() const {return __im_;}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) void real(value_type __re) {__re_ = __re;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) void imag(value_type __im) {__im_ = __im;}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) complex& operator= (long double __re)
        {__re_ = __re; __im_ = value_type(); return *this;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) complex& operator+=(long double __re) {__re_ += __re; return *this;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) complex& operator-=(long double __re) {__re_ -= __re; return *this;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) complex& operator*=(long double __re) {__re_ *= __re; __im_ *= __re; return *this;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) complex& operator/=(long double __re) {__re_ /= __re; __im_ /= __re; return *this;}

    template<class _Xp> __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) complex& operator= (const complex<_Xp>& __c)
        {
            __re_ = __c.real();
            __im_ = __c.imag();
            return *this;
        }
    template<class _Xp> __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) complex& operator+=(const complex<_Xp>& __c)
        {
            __re_ += __c.real();
            __im_ += __c.imag();
            return *this;
        }
    template<class _Xp> __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) complex& operator-=(const complex<_Xp>& __c)
        {
            __re_ -= __c.real();
            __im_ -= __c.imag();
            return *this;
        }
    template<class _Xp> __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) complex& operator*=(const complex<_Xp>& __c)
        {
            *this = *this * complex(__c.real(), __c.imag());
            return *this;
        }
    template<class _Xp> __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) complex& operator/=(const complex<_Xp>& __c)
        {
            *this = *this / complex(__c.real(), __c.imag());
            return *this;
        }
};

inline
constexpr
complex<float>::complex(const complex<double>& __c)
    : __re_(__c.real()), __im_(__c.imag()) {}

inline
constexpr
complex<float>::complex(const complex<long double>& __c)
    : __re_(__c.real()), __im_(__c.imag()) {}

inline
constexpr
complex<double>::complex(const complex<float>& __c)
    : __re_(__c.real()), __im_(__c.imag()) {}

inline
constexpr
complex<double>::complex(const complex<long double>& __c)
    : __re_(__c.real()), __im_(__c.imag()) {}

inline
constexpr
complex<long double>::complex(const complex<float>& __c)
    : __re_(__c.real()), __im_(__c.imag()) {}

inline
constexpr
complex<long double>::complex(const complex<double>& __c)
    : __re_(__c.real()), __im_(__c.imag()) {}



template<class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
complex<_Tp>
operator+(const complex<_Tp>& __x, const complex<_Tp>& __y)
{
    complex<_Tp> __t(__x);
    __t += __y;
    return __t;
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
complex<_Tp>
operator+(const complex<_Tp>& __x, const _Tp& __y)
{
    complex<_Tp> __t(__x);
    __t += __y;
    return __t;
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
complex<_Tp>
operator+(const _Tp& __x, const complex<_Tp>& __y)
{
    complex<_Tp> __t(__y);
    __t += __x;
    return __t;
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
complex<_Tp>
operator-(const complex<_Tp>& __x, const complex<_Tp>& __y)
{
    complex<_Tp> __t(__x);
    __t -= __y;
    return __t;
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
complex<_Tp>
operator-(const complex<_Tp>& __x, const _Tp& __y)
{
    complex<_Tp> __t(__x);
    __t -= __y;
    return __t;
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
complex<_Tp>
operator-(const _Tp& __x, const complex<_Tp>& __y)
{
    complex<_Tp> __t(-__y);
    __t += __x;
    return __t;
}

template<class _Tp>
complex<_Tp>
operator*(const complex<_Tp>& __z, const complex<_Tp>& __w)
{
    _Tp __a = __z.real();
    _Tp __b = __z.imag();
    _Tp __c = __w.real();
    _Tp __d = __w.imag();
    _Tp __ac = __a * __c;
    _Tp __bd = __b * __d;
    _Tp __ad = __a * __d;
    _Tp __bc = __b * __c;
    _Tp __x = __ac - __bd;
    _Tp __y = __ad + __bc;
    if (__libcpp_isnan_or_builtin(__x) && __libcpp_isnan_or_builtin(__y))
    {
        bool __recalc = false;
        if (__libcpp_isinf_or_builtin(__a) || __libcpp_isinf_or_builtin(__b))
        {
            __a = copysign(__libcpp_isinf_or_builtin(__a) ? _Tp(1) : _Tp(0), __a);
            __b = copysign(__libcpp_isinf_or_builtin(__b) ? _Tp(1) : _Tp(0), __b);
            if (__libcpp_isnan_or_builtin(__c))
                __c = copysign(_Tp(0), __c);
            if (__libcpp_isnan_or_builtin(__d))
                __d = copysign(_Tp(0), __d);
            __recalc = true;
        }
        if (__libcpp_isinf_or_builtin(__c) || __libcpp_isinf_or_builtin(__d))
        {
            __c = copysign(__libcpp_isinf_or_builtin(__c) ? _Tp(1) : _Tp(0), __c);
            __d = copysign(__libcpp_isinf_or_builtin(__d) ? _Tp(1) : _Tp(0), __d);
            if (__libcpp_isnan_or_builtin(__a))
                __a = copysign(_Tp(0), __a);
            if (__libcpp_isnan_or_builtin(__b))
                __b = copysign(_Tp(0), __b);
            __recalc = true;
        }
        if (!__recalc && (__libcpp_isinf_or_builtin(__ac) || __libcpp_isinf_or_builtin(__bd) ||
                          __libcpp_isinf_or_builtin(__ad) || __libcpp_isinf_or_builtin(__bc)))
        {
            if (__libcpp_isnan_or_builtin(__a))
                __a = copysign(_Tp(0), __a);
            if (__libcpp_isnan_or_builtin(__b))
                __b = copysign(_Tp(0), __b);
            if (__libcpp_isnan_or_builtin(__c))
                __c = copysign(_Tp(0), __c);
            if (__libcpp_isnan_or_builtin(__d))
                __d = copysign(_Tp(0), __d);
            __recalc = true;
        }
        if (__recalc)
        {
            __x = _Tp(__builtin_huge_valf()) * (__a * __c - __b * __d);
            __y = _Tp(__builtin_huge_valf()) * (__a * __d + __b * __c);
        }
    }
    return complex<_Tp>(__x, __y);
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
complex<_Tp>
operator*(const complex<_Tp>& __x, const _Tp& __y)
{
    complex<_Tp> __t(__x);
    __t *= __y;
    return __t;
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
complex<_Tp>
operator*(const _Tp& __x, const complex<_Tp>& __y)
{
    complex<_Tp> __t(__y);
    __t *= __x;
    return __t;
}

template<class _Tp>
complex<_Tp>
operator/(const complex<_Tp>& __z, const complex<_Tp>& __w)
{
    int __ilogbw = 0;
    _Tp __a = __z.real();
    _Tp __b = __z.imag();
    _Tp __c = __w.real();
    _Tp __d = __w.imag();
    _Tp __logbw = logb(fmax(fabs(__c), fabs(__d)));
    if (__libcpp_isfinite_or_builtin(__logbw))
    {
        __ilogbw = static_cast<int>(__logbw);
        __c = scalbn(__c, -__ilogbw);
        __d = scalbn(__d, -__ilogbw);
    }
    _Tp __denom = __c * __c + __d * __d;
    _Tp __x = scalbn((__a * __c + __b * __d) / __denom, -__ilogbw);
    _Tp __y = scalbn((__b * __c - __a * __d) / __denom, -__ilogbw);
    if (__libcpp_isnan_or_builtin(__x) && __libcpp_isnan_or_builtin(__y))
    {
        if ((__denom == _Tp(0)) && (!__libcpp_isnan_or_builtin(__a) || !__libcpp_isnan_or_builtin(__b)))
        {
            __x = copysign(_Tp(__builtin_huge_valf()), __c) * __a;
            __y = copysign(_Tp(__builtin_huge_valf()), __c) * __b;
        }
        else if ((__libcpp_isinf_or_builtin(__a) || __libcpp_isinf_or_builtin(__b)) && __libcpp_isfinite_or_builtin(__c) && __libcpp_isfinite_or_builtin(__d))
        {
            __a = copysign(__libcpp_isinf_or_builtin(__a) ? _Tp(1) : _Tp(0), __a);
            __b = copysign(__libcpp_isinf_or_builtin(__b) ? _Tp(1) : _Tp(0), __b);
            __x = _Tp(__builtin_huge_valf()) * (__a * __c + __b * __d);
            __y = _Tp(__builtin_huge_valf()) * (__b * __c - __a * __d);
        }
        else if (__libcpp_isinf_or_builtin(__logbw) && __logbw > _Tp(0) && __libcpp_isfinite_or_builtin(__a) && __libcpp_isfinite_or_builtin(__b))
        {
            __c = copysign(__libcpp_isinf_or_builtin(__c) ? _Tp(1) : _Tp(0), __c);
            __d = copysign(__libcpp_isinf_or_builtin(__d) ? _Tp(1) : _Tp(0), __d);
            __x = _Tp(0) * (__a * __c + __b * __d);
            __y = _Tp(0) * (__b * __c - __a * __d);
        }
    }
    return complex<_Tp>(__x, __y);
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
complex<_Tp>
operator/(const complex<_Tp>& __x, const _Tp& __y)
{
    return complex<_Tp>(__x.real() / __y, __x.imag() / __y);
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
complex<_Tp>
operator/(const _Tp& __x, const complex<_Tp>& __y)
{
    complex<_Tp> __t(__x);
    __t /= __y;
    return __t;
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
complex<_Tp>
operator+(const complex<_Tp>& __x)
{
    return __x;
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
complex<_Tp>
operator-(const complex<_Tp>& __x)
{
    return complex<_Tp>(-__x.real(), -__x.imag());
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
bool
operator==(const complex<_Tp>& __x, const complex<_Tp>& __y)
{
    return __x.real() == __y.real() && __x.imag() == __y.imag();
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
bool
operator==(const complex<_Tp>& __x, const _Tp& __y)
{
    return __x.real() == __y && __x.imag() == 0;
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
bool
operator==(const _Tp& __x, const complex<_Tp>& __y)
{
    return __x == __y.real() && 0 == __y.imag();
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
bool
operator!=(const complex<_Tp>& __x, const complex<_Tp>& __y)
{
    return !(__x == __y);
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
bool
operator!=(const complex<_Tp>& __x, const _Tp& __y)
{
    return !(__x == __y);
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
bool
operator!=(const _Tp& __x, const complex<_Tp>& __y)
{
    return !(__x == __y);
}



template <class _Tp, bool = is_integral<_Tp>::value,
                     bool = is_floating_point<_Tp>::value
                     >
struct __libcpp_complex_overload_traits {};


template <class _Tp>
struct __libcpp_complex_overload_traits<_Tp, true, false>
{
    typedef double _ValueType;
    typedef complex<double> _ComplexType;
};


template <class _Tp>
struct __libcpp_complex_overload_traits<_Tp, false, true>
{
    typedef _Tp _ValueType;
    typedef complex<_Tp> _ComplexType;
};



template<class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
_Tp
real(const complex<_Tp>& __c)
{
    return __c.real();
}

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
typename __libcpp_complex_overload_traits<_Tp>::_ValueType
real(_Tp __re)
{
    return __re;
}



template<class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
_Tp
imag(const complex<_Tp>& __c)
{
    return __c.imag();
}

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
typename __libcpp_complex_overload_traits<_Tp>::_ValueType
imag(_Tp)
{
    return 0;
}



template<class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
_Tp
abs(const complex<_Tp>& __c)
{
    return hypot(__c.real(), __c.imag());
}



template<class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
_Tp
arg(const complex<_Tp>& __c)
{
    return atan2(__c.imag(), __c.real());
}

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename enable_if<
    is_same<_Tp, long double>::value,
    long double
>::type
arg(_Tp __re)
{
    return atan2l(0.L, __re);
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename enable_if
<
    is_integral<_Tp>::value || is_same<_Tp, double>::value,
    double
>::type
arg(_Tp __re)
{
    return atan2(0., __re);
}

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename enable_if<
    is_same<_Tp, float>::value,
    float
>::type
arg(_Tp __re)
{
    return atan2f(0.F, __re);
}



template<class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
_Tp
norm(const complex<_Tp>& __c)
{
    if (__libcpp_isinf_or_builtin(__c.real()))
        return abs(__c.real());
    if (__libcpp_isinf_or_builtin(__c.imag()))
        return abs(__c.imag());
    return __c.real() * __c.real() + __c.imag() * __c.imag();
}

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename __libcpp_complex_overload_traits<_Tp>::_ValueType
norm(_Tp __re)
{
    typedef typename __libcpp_complex_overload_traits<_Tp>::_ValueType _ValueType;
    return static_cast<_ValueType>(__re) * __re;
}



template<class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
complex<_Tp>
conj(const complex<_Tp>& __c)
{
    return complex<_Tp>(__c.real(), -__c.imag());
}

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename __libcpp_complex_overload_traits<_Tp>::_ComplexType
conj(_Tp __re)
{
    typedef typename __libcpp_complex_overload_traits<_Tp>::_ComplexType _ComplexType;
    return _ComplexType(__re);
}





template<class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
complex<_Tp>
proj(const complex<_Tp>& __c)
{
    complex<_Tp> __r = __c;
    if (__libcpp_isinf_or_builtin(__c.real()) || __libcpp_isinf_or_builtin(__c.imag()))
        __r = complex<_Tp>(__builtin_huge_valf(), copysign(_Tp(0), __c.imag()));
    return __r;
}

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename enable_if
<
    is_floating_point<_Tp>::value,
    typename __libcpp_complex_overload_traits<_Tp>::_ComplexType
>::type
proj(_Tp __re)
{
    if (__libcpp_isinf_or_builtin(__re))
        __re = abs(__re);
    return complex<_Tp>(__re);
}

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename enable_if
<
    is_integral<_Tp>::value,
    typename __libcpp_complex_overload_traits<_Tp>::_ComplexType
>::type
proj(_Tp __re)
{
    typedef typename __libcpp_complex_overload_traits<_Tp>::_ComplexType _ComplexType;
    return _ComplexType(__re);
}



template<class _Tp>
complex<_Tp>
polar(const _Tp& __rho, const _Tp& __theta = _Tp())
{
    if (__libcpp_isnan_or_builtin(__rho) || signbit(__rho))
        return complex<_Tp>(_Tp(__builtin_nanf("0x7fc00000")), _Tp(__builtin_nanf("0x7fc00000")));
    if (__libcpp_isnan_or_builtin(__theta))
    {
        if (__libcpp_isinf_or_builtin(__rho))
            return complex<_Tp>(__rho, __theta);
        return complex<_Tp>(__theta, __theta);
    }
    if (__libcpp_isinf_or_builtin(__theta))
    {
        if (__libcpp_isinf_or_builtin(__rho))
            return complex<_Tp>(__rho, _Tp(__builtin_nanf("0x7fc00000")));
        return complex<_Tp>(_Tp(__builtin_nanf("0x7fc00000")), _Tp(__builtin_nanf("0x7fc00000")));
    }
    _Tp __x = __rho * cos(__theta);
    if (__libcpp_isnan_or_builtin(__x))
        __x = 0;
    _Tp __y = __rho * sin(__theta);
    if (__libcpp_isnan_or_builtin(__y))
        __y = 0;
    return complex<_Tp>(__x, __y);
}



template<class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
complex<_Tp>
log(const complex<_Tp>& __x)
{
    return complex<_Tp>(log(abs(__x)), arg(__x));
}



template<class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
complex<_Tp>
log10(const complex<_Tp>& __x)
{
    return log(__x) / log(_Tp(10));
}



template<class _Tp>
complex<_Tp>
sqrt(const complex<_Tp>& __x)
{
    if (__libcpp_isinf_or_builtin(__x.imag()))
        return complex<_Tp>(_Tp(__builtin_huge_valf()), __x.imag());
    if (__libcpp_isinf_or_builtin(__x.real()))
    {
        if (__x.real() > _Tp(0))
            return complex<_Tp>(__x.real(), __libcpp_isnan_or_builtin(__x.imag()) ? __x.imag() : copysign(_Tp(0), __x.imag()));
        return complex<_Tp>(__libcpp_isnan_or_builtin(__x.imag()) ? __x.imag() : _Tp(0), copysign(__x.real(), __x.imag()));
    }
    return polar(sqrt(abs(__x)), arg(__x) / _Tp(2));
}



template<class _Tp>
complex<_Tp>
exp(const complex<_Tp>& __x)
{
    _Tp __i = __x.imag();
    if (__libcpp_isinf_or_builtin(__x.real()))
    {
        if (__x.real() < _Tp(0))
        {
            if (!__libcpp_isfinite_or_builtin(__i))
                __i = _Tp(1);
        }
        else if (__i == 0 || !__libcpp_isfinite_or_builtin(__i))
        {
            if (__libcpp_isinf_or_builtin(__i))
                __i = _Tp(__builtin_nanf("0x7fc00000"));
            return complex<_Tp>(__x.real(), __i);
        }
    }
    else if (__libcpp_isnan_or_builtin(__x.real()) && __x.imag() == 0)
        return __x;
    _Tp __e = exp(__x.real());
    return complex<_Tp>(__e * cos(__i), __e * sin(__i));
}



template<class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
complex<_Tp>
pow(const complex<_Tp>& __x, const complex<_Tp>& __y)
{
    return exp(__y * log(__x));
}

template<class _Tp, class _Up>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
complex<typename __promote<_Tp, _Up>::type>
pow(const complex<_Tp>& __x, const complex<_Up>& __y)
{
    typedef complex<typename __promote<_Tp, _Up>::type> result_type;
    return std::__1::pow(result_type(__x), result_type(__y));
}

template<class _Tp, class _Up>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename enable_if
<
    is_arithmetic<_Up>::value,
    complex<typename __promote<_Tp, _Up>::type>
>::type
pow(const complex<_Tp>& __x, const _Up& __y)
{
    typedef complex<typename __promote<_Tp, _Up>::type> result_type;
    return std::__1::pow(result_type(__x), result_type(__y));
}

template<class _Tp, class _Up>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename enable_if
<
    is_arithmetic<_Tp>::value,
    complex<typename __promote<_Tp, _Up>::type>
>::type
pow(const _Tp& __x, const complex<_Up>& __y)
{
    typedef complex<typename __promote<_Tp, _Up>::type> result_type;
    return std::__1::pow(result_type(__x), result_type(__y));
}



template<class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
complex<_Tp>
__sqr(const complex<_Tp>& __x)
{
    return complex<_Tp>((__x.real() - __x.imag()) * (__x.real() + __x.imag()),
                        _Tp(2) * __x.real() * __x.imag());
}



template<class _Tp>
complex<_Tp>
asinh(const complex<_Tp>& __x)
{
    const _Tp __pi(atan2(+0., -0.));
    if (__libcpp_isinf_or_builtin(__x.real()))
    {
        if (__libcpp_isnan_or_builtin(__x.imag()))
            return __x;
        if (__libcpp_isinf_or_builtin(__x.imag()))
            return complex<_Tp>(__x.real(), copysign(__pi * _Tp(0.25), __x.imag()));
        return complex<_Tp>(__x.real(), copysign(_Tp(0), __x.imag()));
    }
    if (__libcpp_isnan_or_builtin(__x.real()))
    {
        if (__libcpp_isinf_or_builtin(__x.imag()))
            return complex<_Tp>(__x.imag(), __x.real());
        if (__x.imag() == 0)
            return __x;
        return complex<_Tp>(__x.real(), __x.real());
    }
    if (__libcpp_isinf_or_builtin(__x.imag()))
        return complex<_Tp>(copysign(__x.imag(), __x.real()), copysign(__pi/_Tp(2), __x.imag()));
    complex<_Tp> __z = log(__x + sqrt(__sqr(__x) + _Tp(1)));
    return complex<_Tp>(copysign(__z.real(), __x.real()), copysign(__z.imag(), __x.imag()));
}



template<class _Tp>
complex<_Tp>
acosh(const complex<_Tp>& __x)
{
    const _Tp __pi(atan2(+0., -0.));
    if (__libcpp_isinf_or_builtin(__x.real()))
    {
        if (__libcpp_isnan_or_builtin(__x.imag()))
            return complex<_Tp>(abs(__x.real()), __x.imag());
        if (__libcpp_isinf_or_builtin(__x.imag()))
        {
            if (__x.real() > 0)
                return complex<_Tp>(__x.real(), copysign(__pi * _Tp(0.25), __x.imag()));
            else
                return complex<_Tp>(-__x.real(), copysign(__pi * _Tp(0.75), __x.imag()));
        }
        if (__x.real() < 0)
            return complex<_Tp>(-__x.real(), copysign(__pi, __x.imag()));
        return complex<_Tp>(__x.real(), copysign(_Tp(0), __x.imag()));
    }
    if (__libcpp_isnan_or_builtin(__x.real()))
    {
        if (__libcpp_isinf_or_builtin(__x.imag()))
            return complex<_Tp>(abs(__x.imag()), __x.real());
        return complex<_Tp>(__x.real(), __x.real());
    }
    if (__libcpp_isinf_or_builtin(__x.imag()))
        return complex<_Tp>(abs(__x.imag()), copysign(__pi/_Tp(2), __x.imag()));
    complex<_Tp> __z = log(__x + sqrt(__sqr(__x) - _Tp(1)));
    return complex<_Tp>(copysign(__z.real(), _Tp(0)), copysign(__z.imag(), __x.imag()));
}



template<class _Tp>
complex<_Tp>
atanh(const complex<_Tp>& __x)
{
    const _Tp __pi(atan2(+0., -0.));
    if (__libcpp_isinf_or_builtin(__x.imag()))
    {
        return complex<_Tp>(copysign(_Tp(0), __x.real()), copysign(__pi/_Tp(2), __x.imag()));
    }
    if (__libcpp_isnan_or_builtin(__x.imag()))
    {
        if (__libcpp_isinf_or_builtin(__x.real()) || __x.real() == 0)
            return complex<_Tp>(copysign(_Tp(0), __x.real()), __x.imag());
        return complex<_Tp>(__x.imag(), __x.imag());
    }
    if (__libcpp_isnan_or_builtin(__x.real()))
    {
        return complex<_Tp>(__x.real(), __x.real());
    }
    if (__libcpp_isinf_or_builtin(__x.real()))
    {
        return complex<_Tp>(copysign(_Tp(0), __x.real()), copysign(__pi/_Tp(2), __x.imag()));
    }
    if (abs(__x.real()) == _Tp(1) && __x.imag() == _Tp(0))
    {
        return complex<_Tp>(copysign(_Tp(__builtin_huge_valf()), __x.real()), copysign(_Tp(0), __x.imag()));
    }
    complex<_Tp> __z = log((_Tp(1) + __x) / (_Tp(1) - __x)) / _Tp(2);
    return complex<_Tp>(copysign(__z.real(), __x.real()), copysign(__z.imag(), __x.imag()));
}



template<class _Tp>
complex<_Tp>
sinh(const complex<_Tp>& __x)
{
    if (__libcpp_isinf_or_builtin(__x.real()) && !__libcpp_isfinite_or_builtin(__x.imag()))
        return complex<_Tp>(__x.real(), _Tp(__builtin_nanf("0x7fc00000")));
    if (__x.real() == 0 && !__libcpp_isfinite_or_builtin(__x.imag()))
        return complex<_Tp>(__x.real(), _Tp(__builtin_nanf("0x7fc00000")));
    if (__x.imag() == 0 && !__libcpp_isfinite_or_builtin(__x.real()))
        return __x;
    return complex<_Tp>(sinh(__x.real()) * cos(__x.imag()), cosh(__x.real()) * sin(__x.imag()));
}



template<class _Tp>
complex<_Tp>
cosh(const complex<_Tp>& __x)
{
    if (__libcpp_isinf_or_builtin(__x.real()) && !__libcpp_isfinite_or_builtin(__x.imag()))
        return complex<_Tp>(abs(__x.real()), _Tp(__builtin_nanf("0x7fc00000")));
    if (__x.real() == 0 && !__libcpp_isfinite_or_builtin(__x.imag()))
        return complex<_Tp>(_Tp(__builtin_nanf("0x7fc00000")), __x.real());
    if (__x.real() == 0 && __x.imag() == 0)
        return complex<_Tp>(_Tp(1), __x.imag());
    if (__x.imag() == 0 && !__libcpp_isfinite_or_builtin(__x.real()))
        return complex<_Tp>(abs(__x.real()), __x.imag());
    return complex<_Tp>(cosh(__x.real()) * cos(__x.imag()), sinh(__x.real()) * sin(__x.imag()));
}



template<class _Tp>
complex<_Tp>
tanh(const complex<_Tp>& __x)
{
    if (__libcpp_isinf_or_builtin(__x.real()))
    {
        if (!__libcpp_isfinite_or_builtin(__x.imag()))
            return complex<_Tp>(_Tp(1), _Tp(0));
        return complex<_Tp>(_Tp(1), copysign(_Tp(0), sin(_Tp(2) * __x.imag())));
    }
    if (__libcpp_isnan_or_builtin(__x.real()) && __x.imag() == 0)
        return __x;
    _Tp __2r(_Tp(2) * __x.real());
    _Tp __2i(_Tp(2) * __x.imag());
    _Tp __d(cosh(__2r) + cos(__2i));
    _Tp __2rsh(sinh(__2r));
    if (__libcpp_isinf_or_builtin(__2rsh) && __libcpp_isinf_or_builtin(__d))
        return complex<_Tp>(__2rsh > _Tp(0) ? _Tp(1) : _Tp(-1),
                            __2i > _Tp(0) ? _Tp(0) : _Tp(-0.));
    return complex<_Tp>(__2rsh/__d, sin(__2i)/__d);
}



template<class _Tp>
complex<_Tp>
asin(const complex<_Tp>& __x)
{
    complex<_Tp> __z = asinh(complex<_Tp>(-__x.imag(), __x.real()));
    return complex<_Tp>(__z.imag(), -__z.real());
}



template<class _Tp>
complex<_Tp>
acos(const complex<_Tp>& __x)
{
    const _Tp __pi(atan2(+0., -0.));
    if (__libcpp_isinf_or_builtin(__x.real()))
    {
        if (__libcpp_isnan_or_builtin(__x.imag()))
            return complex<_Tp>(__x.imag(), __x.real());
        if (__libcpp_isinf_or_builtin(__x.imag()))
        {
            if (__x.real() < _Tp(0))
                return complex<_Tp>(_Tp(0.75) * __pi, -__x.imag());
            return complex<_Tp>(_Tp(0.25) * __pi, -__x.imag());
        }
        if (__x.real() < _Tp(0))
            return complex<_Tp>(__pi, signbit(__x.imag()) ? -__x.real() : __x.real());
        return complex<_Tp>(_Tp(0), signbit(__x.imag()) ? __x.real() : -__x.real());
    }
    if (__libcpp_isnan_or_builtin(__x.real()))
    {
        if (__libcpp_isinf_or_builtin(__x.imag()))
            return complex<_Tp>(__x.real(), -__x.imag());
        return complex<_Tp>(__x.real(), __x.real());
    }
    if (__libcpp_isinf_or_builtin(__x.imag()))
        return complex<_Tp>(__pi/_Tp(2), -__x.imag());
    if (__x.real() == 0 && (__x.imag() == 0 || isnan(__x.imag())))
        return complex<_Tp>(__pi/_Tp(2), -__x.imag());
    complex<_Tp> __z = log(__x + sqrt(__sqr(__x) - _Tp(1)));
    if (signbit(__x.imag()))
        return complex<_Tp>(abs(__z.imag()), abs(__z.real()));
    return complex<_Tp>(abs(__z.imag()), -abs(__z.real()));
}



template<class _Tp>
complex<_Tp>
atan(const complex<_Tp>& __x)
{
    complex<_Tp> __z = atanh(complex<_Tp>(-__x.imag(), __x.real()));
    return complex<_Tp>(__z.imag(), -__z.real());
}



template<class _Tp>
complex<_Tp>
sin(const complex<_Tp>& __x)
{
    complex<_Tp> __z = sinh(complex<_Tp>(-__x.imag(), __x.real()));
    return complex<_Tp>(__z.imag(), -__z.real());
}



template<class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
complex<_Tp>
cos(const complex<_Tp>& __x)
{
    return cosh(complex<_Tp>(-__x.imag(), __x.real()));
}



template<class _Tp>
complex<_Tp>
tan(const complex<_Tp>& __x)
{
    complex<_Tp> __z = tanh(complex<_Tp>(-__x.imag(), __x.real()));
    return complex<_Tp>(__z.imag(), -__z.real());
}

template<class _Tp, class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
operator>>(basic_istream<_CharT, _Traits>& __is, complex<_Tp>& __x)
{
    if (__is.good())
    {
        ws(__is);
        if (__is.peek() == _CharT('('))
        {
            __is.get();
            _Tp __r;
            __is >> __r;
            if (!__is.fail())
            {
                ws(__is);
                _CharT __c = __is.peek();
                if (__c == _CharT(','))
                {
                    __is.get();
                    _Tp __i;
                    __is >> __i;
                    if (!__is.fail())
                    {
                        ws(__is);
                        __c = __is.peek();
                        if (__c == _CharT(')'))
                        {
                            __is.get();
                            __x = complex<_Tp>(__r, __i);
                        }
                        else
                            __is.setstate(__is.failbit);
                    }
                    else
                        __is.setstate(__is.failbit);
                }
                else if (__c == _CharT(')'))
                {
                    __is.get();
                    __x = complex<_Tp>(__r, _Tp(0));
                }
                else
                    __is.setstate(__is.failbit);
            }
            else
                __is.setstate(__is.failbit);
        }
        else
        {
            _Tp __r;
            __is >> __r;
            if (!__is.fail())
                __x = complex<_Tp>(__r, _Tp(0));
            else
                __is.setstate(__is.failbit);
        }
    }
    else
        __is.setstate(__is.failbit);
    return __is;
}


template<class _Tp, class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>&
operator<<(basic_ostream<_CharT, _Traits>& __os, const complex<_Tp>& __x)
{
    basic_ostringstream<_CharT, _Traits> __s;
    __s.flags(__os.flags());
    __s.imbue(__os.getloc());
    __s.precision(__os.precision());
    __s << '(' << __x.real() << ',' << __x.imag() << ')';
    return __os << __s.str();
}




inline namespace literals
{
  inline namespace complex_literals
  {
    constexpr complex<long double> operator""il(long double __im)
    {
        return { 0.0l, __im };
    }

    constexpr complex<long double> operator""il(unsigned long long __im)
    {
        return { 0.0l, static_cast<long double>(__im) };
    }


    constexpr complex<double> operator""i(long double __im)
    {
        return { 0.0, static_cast<double>(__im) };
    }

    constexpr complex<double> operator""i(unsigned long long __im)
    {
        return { 0.0, static_cast<double>(__im) };
    }


    constexpr complex<float> operator""if(long double __im)
    {
        return { 0.0f, static_cast<float>(__im) };
    }

    constexpr complex<float> operator""if(unsigned long long __im)
    {
        return { 0.0f, static_cast<float>(__im) };
    }
  }
}


} }
# 21 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/ccomplex" 2 3
# 24 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/ccomplex" 3
# 92 "/usr/local/include/bits/stdc++.h" 2


# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cfenv" 1 3
# 56 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cfenv" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/fenv.h" 1 3
# 57 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/fenv.h" 3


# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/fenv.h" 1 3 4
# 45 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/fenv.h" 3 4
extern "C" {
# 129 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/fenv.h" 3 4
typedef struct {
    unsigned long long __fpsr;
    unsigned long long __fpcr;
} fenv_t;

typedef unsigned short fexcept_t;
# 154 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/fenv.h" 3 4
enum {
    __fpcr_trap_invalid = 0x00000100,
    __fpcr_trap_divbyzero = 0x00000200,
    __fpcr_trap_overflow = 0x00000400,
    __fpcr_trap_underflow = 0x00000800,
    __fpcr_trap_inexact = 0x00001000,
    __fpcr_trap_denormal = 0x00008000,
    __fpcr_flush_to_zero = 0x01000000,
};


enum { __fpsr_saturation = 0x08000000 };

extern const fenv_t _FE_DFL_ENV;
# 184 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/fenv.h" 3 4
extern const fenv_t _FE_DFL_DISABLE_DENORMS_ENV;
# 297 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/fenv.h" 3 4
extern int feclearexcept(int );
extern int fegetexceptflag(fexcept_t * , int );
extern int feraiseexcept(int );
extern int fesetexceptflag(const fexcept_t * , int );
extern int fetestexcept(int );
# 318 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/fenv.h" 3 4
extern int fegetround(void);
extern int fesetround(int );
# 351 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/fenv.h" 3 4
extern int fegetenv(fenv_t * );
extern int feholdexcept(fenv_t * );
extern int fesetenv(const fenv_t * );
extern int feupdateenv(const fenv_t * );


}
# 60 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/fenv.h" 2 3



extern "C++" {
# 112 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/fenv.h" 3
}
# 57 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cfenv" 2 3
# 60 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cfenv" 3


namespace std { inline namespace __1 {

using ::fenv_t __attribute__((using_if_exists));
using ::fexcept_t __attribute__((using_if_exists));

using ::feclearexcept __attribute__((using_if_exists));
using ::fegetexceptflag __attribute__((using_if_exists));
using ::feraiseexcept __attribute__((using_if_exists));
using ::fesetexceptflag __attribute__((using_if_exists));
using ::fetestexcept __attribute__((using_if_exists));
using ::fegetround __attribute__((using_if_exists));
using ::fesetround __attribute__((using_if_exists));
using ::fegetenv __attribute__((using_if_exists));
using ::feholdexcept __attribute__((using_if_exists));
using ::fesetenv __attribute__((using_if_exists));
using ::feupdateenv __attribute__((using_if_exists));

} }
# 95 "/usr/local/include/bits/stdc++.h" 2


# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cinttypes" 1 3
# 239 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cinttypes" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/inttypes.h" 1 3
# 242 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/inttypes.h" 3
# 251 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/inttypes.h" 3
# 1 "/Library/Developer/CommandLineTools/usr/lib/clang/13.1.6/include/inttypes.h" 1 3
# 21 "/Library/Developer/CommandLineTools/usr/lib/clang/13.1.6/include/inttypes.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/inttypes.h" 1 3 4
# 227 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/inttypes.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_wchar_t.h" 1 3 4
# 228 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/inttypes.h" 2 3 4



extern "C" {


__attribute__((availability(macosx,introduced=10.4)))
extern intmax_t
imaxabs(intmax_t j);


typedef struct {
 intmax_t quot;
 intmax_t rem;
} imaxdiv_t;

__attribute__((availability(macosx,introduced=10.4)))
extern imaxdiv_t
imaxdiv(intmax_t __numer, intmax_t __denom);


__attribute__((availability(macosx,introduced=10.4)))
extern intmax_t
strtoimax(const char * __nptr,
   char ** __endptr,
   int __base);

__attribute__((availability(macosx,introduced=10.4)))
extern uintmax_t
strtoumax(const char * __nptr,
   char ** __endptr,
   int __base);


__attribute__((availability(macosx,introduced=10.4)))
extern intmax_t
wcstoimax(const wchar_t * __nptr,
   wchar_t ** __endptr,
   int __base);

__attribute__((availability(macosx,introduced=10.4)))
extern uintmax_t
wcstoumax(const wchar_t * __nptr,
   wchar_t ** __endptr,
   int __base);






}


# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/xlocale/_inttypes.h" 1 3 4
# 29 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/xlocale/_inttypes.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/stddef.h" 1 3 4
# 30 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/xlocale/_inttypes.h" 2 3 4


extern "C" {
intmax_t strtoimax_l(const char * nptr, char ** endptr,
  int base, locale_t);
uintmax_t strtoumax_l(const char * nptr, char ** endptr,
  int base, locale_t);
intmax_t wcstoimax_l(const wchar_t * nptr,
  wchar_t ** endptr, int base, locale_t);
uintmax_t wcstoumax_l(const wchar_t * nptr,
  wchar_t ** endptr, int base, locale_t);





}
# 283 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/inttypes.h" 2 3 4
# 22 "/Library/Developer/CommandLineTools/usr/lib/clang/13.1.6/include/inttypes.h" 2 3
# 252 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/inttypes.h" 2 3
# 240 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cinttypes" 2 3
# 243 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cinttypes" 3


namespace std { inline namespace __1 {

using ::imaxdiv_t __attribute__((using_if_exists));
using ::imaxabs __attribute__((using_if_exists));
using ::imaxdiv __attribute__((using_if_exists));
using ::strtoimax __attribute__((using_if_exists));
using ::strtoumax __attribute__((using_if_exists));
using ::wcstoimax __attribute__((using_if_exists));
using ::wcstoumax __attribute__((using_if_exists));

} }
# 98 "/usr/local/include/bits/stdc++.h" 2





# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cstdbool" 1 3
# 26 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cstdbool" 3
# 104 "/usr/local/include/bits/stdc++.h" 2





# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/ctgmath" 1 3
# 26 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/ctgmath" 3
# 110 "/usr/local/include/bits/stdc++.h" 2
# 127 "/usr/local/include/bits/stdc++.h"
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/deque" 1 3
# 165 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/deque" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__split_buffer" 1 3







# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 1 3
# 9 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__split_buffer" 2 3
# 12 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__split_buffer" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 16 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__split_buffer" 2 3


namespace std { inline namespace __1 {

template <bool>
class __split_buffer_common
{
protected:
    [[noreturn]] void __throw_length_error() const;
    [[noreturn]] void __throw_out_of_range() const;
};

template <class _Tp, class _Allocator = allocator<_Tp> >
struct __split_buffer
    : private __split_buffer_common<true>
{
private:
    __split_buffer(const __split_buffer&);
    __split_buffer& operator=(const __split_buffer&);
public:
    typedef _Tp value_type;
    typedef _Allocator allocator_type;
    typedef typename remove_reference<allocator_type>::type __alloc_rr;
    typedef allocator_traits<__alloc_rr> __alloc_traits;
    typedef value_type& reference;
    typedef const value_type& const_reference;
    typedef typename __alloc_traits::size_type size_type;
    typedef typename __alloc_traits::difference_type difference_type;
    typedef typename __alloc_traits::pointer pointer;
    typedef typename __alloc_traits::const_pointer const_pointer;
    typedef pointer iterator;
    typedef const_pointer const_iterator;

    pointer __first_;
    pointer __begin_;
    pointer __end_;
    __compressed_pair<pointer, allocator_type> __end_cap_;

    typedef typename add_lvalue_reference<allocator_type>::type __alloc_ref;
    typedef typename add_lvalue_reference<allocator_type>::type __alloc_const_ref;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) __alloc_rr& __alloc() noexcept {return __end_cap_.second();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) const __alloc_rr& __alloc() const noexcept {return __end_cap_.second();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) pointer& __end_cap() noexcept {return __end_cap_.first();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) const pointer& __end_cap() const noexcept {return __end_cap_.first();}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __split_buffer()
        noexcept(is_nothrow_default_constructible<allocator_type>::value);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit __split_buffer(__alloc_rr& __a);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit __split_buffer(const __alloc_rr& __a);
    __split_buffer(size_type __cap, size_type __start, __alloc_rr& __a);
    ~__split_buffer();

    __split_buffer(__split_buffer&& __c)
        noexcept(is_nothrow_move_constructible<allocator_type>::value);
    __split_buffer(__split_buffer&& __c, const __alloc_rr& __a);
    __split_buffer& operator=(__split_buffer&& __c)
        noexcept((__alloc_traits::propagate_on_container_move_assignment::value && is_nothrow_move_assignable<allocator_type>::value) || !__alloc_traits::propagate_on_container_move_assignment::value);



    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) iterator begin() noexcept {return __begin_;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) const_iterator begin() const noexcept {return __begin_;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) iterator end() noexcept {return __end_;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) const_iterator end() const noexcept {return __end_;}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void clear() noexcept
        {__destruct_at_end(__begin_);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) size_type size() const {return static_cast<size_type>(__end_ - __begin_);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) bool empty() const {return __end_ == __begin_;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) size_type capacity() const {return static_cast<size_type>(__end_cap() - __first_);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) size_type __front_spare() const {return static_cast<size_type>(__begin_ - __first_);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) size_type __back_spare() const {return static_cast<size_type>(__end_cap() - __end_);}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) reference front() {return *__begin_;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) const_reference front() const {return *__begin_;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) reference back() {return *(__end_ - 1);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) const_reference back() const {return *(__end_ - 1);}

    void reserve(size_type __n);
    void shrink_to_fit() noexcept;
    void push_front(const_reference __x);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) void push_back(const_reference __x);
    void push_front(value_type&& __x);
    void push_back(value_type&& __x);
    template <class... _Args>
        void emplace_back(_Args&&... __args);

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) void pop_front() {__destruct_at_begin(__begin_+1);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) void pop_back() {__destruct_at_end(__end_-1);}

    void __construct_at_end(size_type __n);
    void __construct_at_end(size_type __n, const_reference __x);
    template <class _InputIter>
        typename enable_if
        <
            __is_cpp17_input_iterator<_InputIter>::value &&
           !__is_cpp17_forward_iterator<_InputIter>::value,
            void
        >::type
        __construct_at_end(_InputIter __first, _InputIter __last);
    template <class _ForwardIterator>
        typename enable_if
        <
            __is_cpp17_forward_iterator<_ForwardIterator>::value,
            void
        >::type
        __construct_at_end(_ForwardIterator __first, _ForwardIterator __last);

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) void __destruct_at_begin(pointer __new_begin)
        {__destruct_at_begin(__new_begin, is_trivially_destructible<value_type>());}
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        void __destruct_at_begin(pointer __new_begin, false_type);
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        void __destruct_at_begin(pointer __new_begin, true_type);

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void __destruct_at_end(pointer __new_last) noexcept
        {__destruct_at_end(__new_last, false_type());}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        void __destruct_at_end(pointer __new_last, false_type) noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        void __destruct_at_end(pointer __new_last, true_type) noexcept;

    void swap(__split_buffer& __x)
        noexcept(!__alloc_traits::propagate_on_container_swap::value|| __is_nothrow_swappable<__alloc_rr>::value);


    bool __invariants() const;

private:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void __move_assign_alloc(__split_buffer& __c, true_type)
        noexcept(is_nothrow_move_assignable<allocator_type>::value)
        {
            __alloc() = std::__1::move(__c.__alloc());
        }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void __move_assign_alloc(__split_buffer&, false_type) noexcept
        {}

    struct _ConstructTransaction {
      explicit _ConstructTransaction(pointer* __p, size_type __n) noexcept
      : __pos_(*__p), __end_(*__p + __n), __dest_(__p) {
      }
      ~_ConstructTransaction() {
        *__dest_ = __pos_;
      }
      pointer __pos_;
     const pointer __end_;
    private:
     pointer *__dest_;
    };
};

template <class _Tp, class _Allocator>
bool
__split_buffer<_Tp, _Allocator>::__invariants() const
{
    if (__first_ == nullptr)
    {
        if (__begin_ != nullptr)
            return false;
        if (__end_ != nullptr)
            return false;
        if (__end_cap() != nullptr)
            return false;
    }
    else
    {
        if (__begin_ < __first_)
            return false;
        if (__end_ < __begin_)
            return false;
        if (__end_cap() < __end_)
            return false;
    }
    return true;
}






template <class _Tp, class _Allocator>
void
__split_buffer<_Tp, _Allocator>::__construct_at_end(size_type __n)
{
    _ConstructTransaction __tx(&this->__end_, __n);
    for (; __tx.__pos_ != __tx.__end_; ++__tx.__pos_) {
        __alloc_traits::construct(this->__alloc(), std::__1::__to_address(__tx.__pos_));
    }
}







template <class _Tp, class _Allocator>
void
__split_buffer<_Tp, _Allocator>::__construct_at_end(size_type __n, const_reference __x)
{
    _ConstructTransaction __tx(&this->__end_, __n);
    for (; __tx.__pos_ != __tx.__end_; ++__tx.__pos_) {
        __alloc_traits::construct(this->__alloc(),
            std::__1::__to_address(__tx.__pos_), __x);
    }
}

template <class _Tp, class _Allocator>
template <class _InputIter>
typename enable_if
<
     __is_cpp17_input_iterator<_InputIter>::value &&
    !__is_cpp17_forward_iterator<_InputIter>::value,
    void
>::type
__split_buffer<_Tp, _Allocator>::__construct_at_end(_InputIter __first, _InputIter __last)
{
    __alloc_rr& __a = this->__alloc();
    for (; __first != __last; ++__first)
    {
        if (__end_ == __end_cap())
        {
            size_type __old_cap = __end_cap() - __first_;
            size_type __new_cap = std::__1::max<size_type>(2 * __old_cap, 8);
            __split_buffer __buf(__new_cap, 0, __a);
            for (pointer __p = __begin_; __p != __end_; ++__p, ++__buf.__end_)
                __alloc_traits::construct(__buf.__alloc(),
                        std::__1::__to_address(__buf.__end_), std::__1::move(*__p));
            swap(__buf);
        }
        __alloc_traits::construct(__a, std::__1::__to_address(this->__end_), *__first);
        ++this->__end_;
    }
}

template <class _Tp, class _Allocator>
template <class _ForwardIterator>
typename enable_if
<
    __is_cpp17_forward_iterator<_ForwardIterator>::value,
    void
>::type
__split_buffer<_Tp, _Allocator>::__construct_at_end(_ForwardIterator __first, _ForwardIterator __last)
{
    _ConstructTransaction __tx(&this->__end_, std::__1::distance(__first, __last));
    for (; __tx.__pos_ != __tx.__end_; ++__tx.__pos_, ++__first) {
        __alloc_traits::construct(this->__alloc(),
            std::__1::__to_address(__tx.__pos_), *__first);
    }
}

template <class _Tp, class _Allocator>
inline
void
__split_buffer<_Tp, _Allocator>::__destruct_at_begin(pointer __new_begin, false_type)
{
    while (__begin_ != __new_begin)
        __alloc_traits::destroy(__alloc(), std::__1::__to_address(__begin_++));
}

template <class _Tp, class _Allocator>
inline
void
__split_buffer<_Tp, _Allocator>::__destruct_at_begin(pointer __new_begin, true_type)
{
    __begin_ = __new_begin;
}

template <class _Tp, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void
__split_buffer<_Tp, _Allocator>::__destruct_at_end(pointer __new_last, false_type) noexcept
{
    while (__new_last != __end_)
        __alloc_traits::destroy(__alloc(), std::__1::__to_address(--__end_));
}

template <class _Tp, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void
__split_buffer<_Tp, _Allocator>::__destruct_at_end(pointer __new_last, true_type) noexcept
{
    __end_ = __new_last;
}

template <class _Tp, class _Allocator>
__split_buffer<_Tp, _Allocator>::__split_buffer(size_type __cap, size_type __start, __alloc_rr& __a)
    : __end_cap_(nullptr, __a)
{
    __first_ = __cap != 0 ? __alloc_traits::allocate(__alloc(), __cap) : nullptr;
    __begin_ = __end_ = __first_ + __start;
    __end_cap() = __first_ + __cap;
}

template <class _Tp, class _Allocator>
inline
__split_buffer<_Tp, _Allocator>::__split_buffer()
    noexcept(is_nothrow_default_constructible<allocator_type>::value)
    : __first_(nullptr), __begin_(nullptr), __end_(nullptr), __end_cap_(nullptr, __default_init_tag())
{
}

template <class _Tp, class _Allocator>
inline
__split_buffer<_Tp, _Allocator>::__split_buffer(__alloc_rr& __a)
    : __first_(nullptr), __begin_(nullptr), __end_(nullptr), __end_cap_(nullptr, __a)
{
}

template <class _Tp, class _Allocator>
inline
__split_buffer<_Tp, _Allocator>::__split_buffer(const __alloc_rr& __a)
    : __first_(nullptr), __begin_(nullptr), __end_(nullptr), __end_cap_(nullptr, __a)
{
}

template <class _Tp, class _Allocator>
__split_buffer<_Tp, _Allocator>::~__split_buffer()
{
    clear();
    if (__first_)
        __alloc_traits::deallocate(__alloc(), __first_, capacity());
}

template <class _Tp, class _Allocator>
__split_buffer<_Tp, _Allocator>::__split_buffer(__split_buffer&& __c)
    noexcept(is_nothrow_move_constructible<allocator_type>::value)
    : __first_(std::__1::move(__c.__first_)),
      __begin_(std::__1::move(__c.__begin_)),
      __end_(std::__1::move(__c.__end_)),
      __end_cap_(std::__1::move(__c.__end_cap_))
{
    __c.__first_ = nullptr;
    __c.__begin_ = nullptr;
    __c.__end_ = nullptr;
    __c.__end_cap() = nullptr;
}

template <class _Tp, class _Allocator>
__split_buffer<_Tp, _Allocator>::__split_buffer(__split_buffer&& __c, const __alloc_rr& __a)
    : __end_cap_(nullptr, __a)
{
    if (__a == __c.__alloc())
    {
        __first_ = __c.__first_;
        __begin_ = __c.__begin_;
        __end_ = __c.__end_;
        __end_cap() = __c.__end_cap();
        __c.__first_ = nullptr;
        __c.__begin_ = nullptr;
        __c.__end_ = nullptr;
        __c.__end_cap() = nullptr;
    }
    else
    {
        size_type __cap = __c.size();
        __first_ = __alloc_traits::allocate(__alloc(), __cap);
        __begin_ = __end_ = __first_;
        __end_cap() = __first_ + __cap;
        typedef move_iterator<iterator> _Ip;
        __construct_at_end(_Ip(__c.begin()), _Ip(__c.end()));
    }
}

template <class _Tp, class _Allocator>
__split_buffer<_Tp, _Allocator>&
__split_buffer<_Tp, _Allocator>::operator=(__split_buffer&& __c)
    noexcept((__alloc_traits::propagate_on_container_move_assignment::value && is_nothrow_move_assignable<allocator_type>::value) || !__alloc_traits::propagate_on_container_move_assignment::value)


{
    clear();
    shrink_to_fit();
    __first_ = __c.__first_;
    __begin_ = __c.__begin_;
    __end_ = __c.__end_;
    __end_cap() = __c.__end_cap();
    __move_assign_alloc(__c,
        integral_constant<bool,
                          __alloc_traits::propagate_on_container_move_assignment::value>());
    __c.__first_ = __c.__begin_ = __c.__end_ = __c.__end_cap() = nullptr;
    return *this;
}

template <class _Tp, class _Allocator>
void
__split_buffer<_Tp, _Allocator>::swap(__split_buffer& __x)
        noexcept(!__alloc_traits::propagate_on_container_swap::value|| __is_nothrow_swappable<__alloc_rr>::value)

{
    std::__1::swap(__first_, __x.__first_);
    std::__1::swap(__begin_, __x.__begin_);
    std::__1::swap(__end_, __x.__end_);
    std::__1::swap(__end_cap(), __x.__end_cap());
    std::__1::__swap_allocator(__alloc(), __x.__alloc());
}

template <class _Tp, class _Allocator>
void
__split_buffer<_Tp, _Allocator>::reserve(size_type __n)
{
    if (__n < capacity())
    {
        __split_buffer<value_type, __alloc_rr&> __t(__n, 0, __alloc());
        __t.__construct_at_end(move_iterator<pointer>(__begin_),
                               move_iterator<pointer>(__end_));
        std::__1::swap(__first_, __t.__first_);
        std::__1::swap(__begin_, __t.__begin_);
        std::__1::swap(__end_, __t.__end_);
        std::__1::swap(__end_cap(), __t.__end_cap());
    }
}

template <class _Tp, class _Allocator>
void
__split_buffer<_Tp, _Allocator>::shrink_to_fit() noexcept
{
    if (capacity() > size())
    {

        try
        {

            __split_buffer<value_type, __alloc_rr&> __t(size(), 0, __alloc());
            __t.__construct_at_end(move_iterator<pointer>(__begin_),
                                   move_iterator<pointer>(__end_));
            __t.__end_ = __t.__begin_ + (__end_ - __begin_);
            std::__1::swap(__first_, __t.__first_);
            std::__1::swap(__begin_, __t.__begin_);
            std::__1::swap(__end_, __t.__end_);
            std::__1::swap(__end_cap(), __t.__end_cap());

        }
        catch (...)
        {
        }

    }
}

template <class _Tp, class _Allocator>
void
__split_buffer<_Tp, _Allocator>::push_front(const_reference __x)
{
    if (__begin_ == __first_)
    {
        if (__end_ < __end_cap())
        {
            difference_type __d = __end_cap() - __end_;
            __d = (__d + 1) / 2;
            __begin_ = std::__1::move_backward(__begin_, __end_, __end_ + __d);
            __end_ += __d;
        }
        else
        {
            size_type __c = max<size_type>(2 * static_cast<size_t>(__end_cap() - __first_), 1);
            __split_buffer<value_type, __alloc_rr&> __t(__c, (__c + 3) / 4, __alloc());
            __t.__construct_at_end(move_iterator<pointer>(__begin_),
                                   move_iterator<pointer>(__end_));
            std::__1::swap(__first_, __t.__first_);
            std::__1::swap(__begin_, __t.__begin_);
            std::__1::swap(__end_, __t.__end_);
            std::__1::swap(__end_cap(), __t.__end_cap());
        }
    }
    __alloc_traits::construct(__alloc(), std::__1::__to_address(__begin_-1), __x);
    --__begin_;
}

template <class _Tp, class _Allocator>
void
__split_buffer<_Tp, _Allocator>::push_front(value_type&& __x)
{
    if (__begin_ == __first_)
    {
        if (__end_ < __end_cap())
        {
            difference_type __d = __end_cap() - __end_;
            __d = (__d + 1) / 2;
            __begin_ = std::__1::move_backward(__begin_, __end_, __end_ + __d);
            __end_ += __d;
        }
        else
        {
            size_type __c = max<size_type>(2 * static_cast<size_t>(__end_cap() - __first_), 1);
            __split_buffer<value_type, __alloc_rr&> __t(__c, (__c + 3) / 4, __alloc());
            __t.__construct_at_end(move_iterator<pointer>(__begin_),
                                   move_iterator<pointer>(__end_));
            std::__1::swap(__first_, __t.__first_);
            std::__1::swap(__begin_, __t.__begin_);
            std::__1::swap(__end_, __t.__end_);
            std::__1::swap(__end_cap(), __t.__end_cap());
        }
    }
    __alloc_traits::construct(__alloc(), std::__1::__to_address(__begin_-1),
            std::__1::move(__x));
    --__begin_;
}

template <class _Tp, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void
__split_buffer<_Tp, _Allocator>::push_back(const_reference __x)
{
    if (__end_ == __end_cap())
    {
        if (__begin_ > __first_)
        {
            difference_type __d = __begin_ - __first_;
            __d = (__d + 1) / 2;
            __end_ = std::__1::move(__begin_, __end_, __begin_ - __d);
            __begin_ -= __d;
        }
        else
        {
            size_type __c = max<size_type>(2 * static_cast<size_t>(__end_cap() - __first_), 1);
            __split_buffer<value_type, __alloc_rr&> __t(__c, __c / 4, __alloc());
            __t.__construct_at_end(move_iterator<pointer>(__begin_),
                                   move_iterator<pointer>(__end_));
            std::__1::swap(__first_, __t.__first_);
            std::__1::swap(__begin_, __t.__begin_);
            std::__1::swap(__end_, __t.__end_);
            std::__1::swap(__end_cap(), __t.__end_cap());
        }
    }
    __alloc_traits::construct(__alloc(), std::__1::__to_address(__end_), __x);
    ++__end_;
}

template <class _Tp, class _Allocator>
void
__split_buffer<_Tp, _Allocator>::push_back(value_type&& __x)
{
    if (__end_ == __end_cap())
    {
        if (__begin_ > __first_)
        {
            difference_type __d = __begin_ - __first_;
            __d = (__d + 1) / 2;
            __end_ = std::__1::move(__begin_, __end_, __begin_ - __d);
            __begin_ -= __d;
        }
        else
        {
            size_type __c = max<size_type>(2 * static_cast<size_t>(__end_cap() - __first_), 1);
            __split_buffer<value_type, __alloc_rr&> __t(__c, __c / 4, __alloc());
            __t.__construct_at_end(move_iterator<pointer>(__begin_),
                                   move_iterator<pointer>(__end_));
            std::__1::swap(__first_, __t.__first_);
            std::__1::swap(__begin_, __t.__begin_);
            std::__1::swap(__end_, __t.__end_);
            std::__1::swap(__end_cap(), __t.__end_cap());
        }
    }
    __alloc_traits::construct(__alloc(), std::__1::__to_address(__end_),
            std::__1::move(__x));
    ++__end_;
}

template <class _Tp, class _Allocator>
template <class... _Args>
void
__split_buffer<_Tp, _Allocator>::emplace_back(_Args&&... __args)
{
    if (__end_ == __end_cap())
    {
        if (__begin_ > __first_)
        {
            difference_type __d = __begin_ - __first_;
            __d = (__d + 1) / 2;
            __end_ = std::__1::move(__begin_, __end_, __begin_ - __d);
            __begin_ -= __d;
        }
        else
        {
            size_type __c = max<size_type>(2 * static_cast<size_t>(__end_cap() - __first_), 1);
            __split_buffer<value_type, __alloc_rr&> __t(__c, __c / 4, __alloc());
            __t.__construct_at_end(move_iterator<pointer>(__begin_),
                                   move_iterator<pointer>(__end_));
            std::__1::swap(__first_, __t.__first_);
            std::__1::swap(__begin_, __t.__begin_);
            std::__1::swap(__end_, __t.__end_);
            std::__1::swap(__end_cap(), __t.__end_cap());
        }
    }
    __alloc_traits::construct(__alloc(), std::__1::__to_address(__end_),
                              std::__1::forward<_Args>(__args)...);
    ++__end_;
}

template <class _Tp, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void
swap(__split_buffer<_Tp, _Allocator>& __x, __split_buffer<_Tp, _Allocator>& __y)
        noexcept(noexcept(__x.swap(__y)))
{
    __x.swap(__y);
}

} }
# 166 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/deque" 2 3







# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 1 3
# 174 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/deque" 2 3
# 178 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/deque" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 182 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/deque" 2 3


namespace std { inline namespace __1 {

template <class _Tp, class _Allocator> class __deque_base;
template <class _Tp, class _Allocator = allocator<_Tp> > class __attribute__ ((__type_visibility__("default"))) deque;

template <class _ValueType, class _Pointer, class _Reference, class _MapPointer,
          class _DiffType, _DiffType _BlockSize>
class __attribute__ ((__type_visibility__("default"))) __deque_iterator;

template <class _RAIter,
          class _V2, class _P2, class _R2, class _M2, class _D2, _D2 _B2>
__deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>
copy(_RAIter __f,
     _RAIter __l,
     __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> __r,
     typename enable_if<__is_cpp17_random_access_iterator<_RAIter>::value>::type* = 0);

template <class _V1, class _P1, class _R1, class _M1, class _D1, _D1 _B1,
          class _OutputIterator>
_OutputIterator
copy(__deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __f,
     __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __l,
     _OutputIterator __r);

template <class _V1, class _P1, class _R1, class _M1, class _D1, _D1 _B1,
          class _V2, class _P2, class _R2, class _M2, class _D2, _D2 _B2>
__deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>
copy(__deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __f,
     __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __l,
     __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> __r);

template <class _RAIter,
          class _V2, class _P2, class _R2, class _M2, class _D2, _D2 _B2>
__deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>
copy_backward(_RAIter __f,
              _RAIter __l,
              __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> __r,
              typename enable_if<__is_cpp17_random_access_iterator<_RAIter>::value>::type* = 0);

template <class _V1, class _P1, class _R1, class _M1, class _D1, _D1 _B1,
          class _OutputIterator>
_OutputIterator
copy_backward(__deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __f,
              __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __l,
              _OutputIterator __r);

template <class _V1, class _P1, class _R1, class _M1, class _D1, _D1 _B1,
          class _V2, class _P2, class _R2, class _M2, class _D2, _D2 _B2>
__deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>
copy_backward(__deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __f,
              __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __l,
              __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> __r);

template <class _RAIter,
          class _V2, class _P2, class _R2, class _M2, class _D2, _D2 _B2>
__deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>
move(_RAIter __f,
     _RAIter __l,
     __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> __r,
     typename enable_if<__is_cpp17_random_access_iterator<_RAIter>::value>::type* = 0);

template <class _V1, class _P1, class _R1, class _M1, class _D1, _D1 _B1,
          class _OutputIterator>
_OutputIterator
move(__deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __f,
     __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __l,
     _OutputIterator __r);

template <class _V1, class _P1, class _R1, class _M1, class _D1, _D1 _B1,
          class _V2, class _P2, class _R2, class _M2, class _D2, _D2 _B2>
__deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>
move(__deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __f,
     __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __l,
     __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> __r);

template <class _RAIter,
          class _V2, class _P2, class _R2, class _M2, class _D2, _D2 _B2>
__deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>
move_backward(_RAIter __f,
              _RAIter __l,
              __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> __r,
              typename enable_if<__is_cpp17_random_access_iterator<_RAIter>::value>::type* = 0);

template <class _V1, class _P1, class _R1, class _M1, class _D1, _D1 _B1,
          class _OutputIterator>
_OutputIterator
move_backward(__deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __f,
              __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __l,
              _OutputIterator __r);

template <class _V1, class _P1, class _R1, class _M1, class _D1, _D1 _B1,
          class _V2, class _P2, class _R2, class _M2, class _D2, _D2 _B2>
__deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>
move_backward(__deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __f,
              __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __l,
              __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> __r);

template <class _ValueType, class _DiffType>
struct __deque_block_size {
  static const _DiffType value = sizeof(_ValueType) < 256 ? 4096 / sizeof(_ValueType) : 16;
};

template <class _ValueType, class _Pointer, class _Reference, class _MapPointer,
          class _DiffType, _DiffType _BS =





                               __deque_block_size<_ValueType, _DiffType>::value

          >
class __attribute__ ((__type_visibility__("default"))) __deque_iterator
{
    typedef _MapPointer __map_iterator;
public:
    typedef _Pointer pointer;
    typedef _DiffType difference_type;
private:
    __map_iterator __m_iter_;
    pointer __ptr_;

    static const difference_type __block_size;
public:
    typedef _ValueType value_type;
    typedef random_access_iterator_tag iterator_category;
    typedef _Reference reference;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) __deque_iterator() noexcept

     : __m_iter_(nullptr), __ptr_(nullptr)

     {}

    template <class _Pp, class _Rp, class _MP>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __deque_iterator(const __deque_iterator<value_type, _Pp, _Rp, _MP, difference_type, _BS>& __it,
                typename enable_if<is_convertible<_Pp, pointer>::value>::type* = 0) noexcept
        : __m_iter_(__it.__m_iter_), __ptr_(__it.__ptr_) {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) reference operator*() const {return *__ptr_;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) pointer operator->() const {return __ptr_;}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) __deque_iterator& operator++()
    {
        if (++__ptr_ - *__m_iter_ == __block_size)
        {
            ++__m_iter_;
            __ptr_ = *__m_iter_;
        }
        return *this;
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) __deque_iterator operator++(int)
    {
        __deque_iterator __tmp = *this;
        ++(*this);
        return __tmp;
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) __deque_iterator& operator--()
    {
        if (__ptr_ == *__m_iter_)
        {
            --__m_iter_;
            __ptr_ = *__m_iter_ + __block_size;
        }
        --__ptr_;
        return *this;
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) __deque_iterator operator--(int)
    {
        __deque_iterator __tmp = *this;
        --(*this);
        return __tmp;
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) __deque_iterator& operator+=(difference_type __n)
    {
        if (__n != 0)
        {
            __n += __ptr_ - *__m_iter_;
            if (__n > 0)
            {
                __m_iter_ += __n / __block_size;
                __ptr_ = *__m_iter_ + __n % __block_size;
            }
            else
            {
                difference_type __z = __block_size - 1 - __n;
                __m_iter_ -= __z / __block_size;
                __ptr_ = *__m_iter_ + (__block_size - 1 - __z % __block_size);
            }
        }
        return *this;
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) __deque_iterator& operator-=(difference_type __n)
    {
        return *this += -__n;
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) __deque_iterator operator+(difference_type __n) const
    {
        __deque_iterator __t(*this);
        __t += __n;
        return __t;
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) __deque_iterator operator-(difference_type __n) const
    {
        __deque_iterator __t(*this);
        __t -= __n;
        return __t;
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    friend __deque_iterator operator+(difference_type __n, const __deque_iterator& __it)
        {return __it + __n;}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    friend difference_type operator-(const __deque_iterator& __x, const __deque_iterator& __y)
    {
        if (__x != __y)
            return (__x.__m_iter_ - __y.__m_iter_) * __block_size
                 + (__x.__ptr_ - *__x.__m_iter_)
                 - (__y.__ptr_ - *__y.__m_iter_);
        return 0;
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) reference operator[](difference_type __n) const
        {return *(*this + __n);}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) friend
        bool operator==(const __deque_iterator& __x, const __deque_iterator& __y)
        {return __x.__ptr_ == __y.__ptr_;}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) friend
        bool operator!=(const __deque_iterator& __x, const __deque_iterator& __y)
        {return !(__x == __y);}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) friend
        bool operator<(const __deque_iterator& __x, const __deque_iterator& __y)
        {return __x.__m_iter_ < __y.__m_iter_ ||
               (__x.__m_iter_ == __y.__m_iter_ && __x.__ptr_ < __y.__ptr_);}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) friend
        bool operator>(const __deque_iterator& __x, const __deque_iterator& __y)
        {return __y < __x;}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) friend
        bool operator<=(const __deque_iterator& __x, const __deque_iterator& __y)
        {return !(__y < __x);}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) friend
        bool operator>=(const __deque_iterator& __x, const __deque_iterator& __y)
        {return !(__x < __y);}

private:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) __deque_iterator(__map_iterator __m, pointer __p) noexcept
        : __m_iter_(__m), __ptr_(__p) {}

    template <class _Tp, class _Ap> friend class __deque_base;
    template <class _Tp, class _Ap> friend class __attribute__ ((__type_visibility__("default"))) deque;
    template <class _Vp, class _Pp, class _Rp, class _MP, class _Dp, _Dp>
        friend class __attribute__ ((__type_visibility__("default"))) __deque_iterator;

    template <class _RAIter,
              class _V2, class _P2, class _R2, class _M2, class _D2, _D2 _B2>
    friend
    __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>
    copy(_RAIter __f,
         _RAIter __l,
         __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> __r,
         typename enable_if<__is_cpp17_random_access_iterator<_RAIter>::value>::type*);

    template <class _V1, class _P1, class _R1, class _M1, class _D1, _D1 _B1,
              class _OutputIterator>
    friend
    _OutputIterator
    copy(__deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __f,
         __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __l,
         _OutputIterator __r);

    template <class _V1, class _P1, class _R1, class _M1, class _D1, _D1 _B1,
              class _V2, class _P2, class _R2, class _M2, class _D2, _D2 _B2>
    friend
    __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>
    copy(__deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __f,
         __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __l,
         __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> __r);

    template <class _RAIter,
              class _V2, class _P2, class _R2, class _M2, class _D2, _D2 _B2>
    friend
    __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>
    copy_backward(_RAIter __f,
                  _RAIter __l,
                  __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> __r,
                  typename enable_if<__is_cpp17_random_access_iterator<_RAIter>::value>::type*);

    template <class _V1, class _P1, class _R1, class _M1, class _D1, _D1 _B1,
              class _OutputIterator>
    friend
    _OutputIterator
    copy_backward(__deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __f,
                  __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __l,
                  _OutputIterator __r);

    template <class _V1, class _P1, class _R1, class _M1, class _D1, _D1 _B1,
              class _V2, class _P2, class _R2, class _M2, class _D2, _D2 _B2>
    friend
    __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>
    copy_backward(__deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __f,
                  __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __l,
                  __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> __r);

    template <class _RAIter,
              class _V2, class _P2, class _R2, class _M2, class _D2, _D2 _B2>
    friend
    __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>
    move(_RAIter __f,
         _RAIter __l,
         __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> __r,
         typename enable_if<__is_cpp17_random_access_iterator<_RAIter>::value>::type*);

    template <class _V1, class _P1, class _R1, class _M1, class _D1, _D1 _B1,
              class _OutputIterator>
    friend
    _OutputIterator
    move(__deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __f,
         __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __l,
         _OutputIterator __r);

    template <class _V1, class _P1, class _R1, class _M1, class _D1, _D1 _B1,
              class _V2, class _P2, class _R2, class _M2, class _D2, _D2 _B2>
    friend
    __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>
    move(__deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __f,
         __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __l,
         __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> __r);

    template <class _RAIter,
              class _V2, class _P2, class _R2, class _M2, class _D2, _D2 _B2>
    friend
    __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>
    move_backward(_RAIter __f,
                  _RAIter __l,
                  __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> __r,
                  typename enable_if<__is_cpp17_random_access_iterator<_RAIter>::value>::type*);

    template <class _V1, class _P1, class _R1, class _M1, class _D1, _D1 _B1,
              class _OutputIterator>
    friend
    _OutputIterator
    move_backward(__deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __f,
                  __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __l,
                  _OutputIterator __r);

    template <class _V1, class _P1, class _R1, class _M1, class _D1, _D1 _B1,
              class _V2, class _P2, class _R2, class _M2, class _D2, _D2 _B2>
    friend
    __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>
    move_backward(__deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __f,
                  __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __l,
                  __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> __r);
};

template <class _ValueType, class _Pointer, class _Reference, class _MapPointer,
          class _DiffType, _DiffType _BlockSize>
const _DiffType __deque_iterator<_ValueType, _Pointer, _Reference, _MapPointer,
                                 _DiffType, _BlockSize>::__block_size =
    __deque_block_size<_ValueType, _DiffType>::value;



template <class _RAIter,
          class _V2, class _P2, class _R2, class _M2, class _D2, _D2 _B2>
__deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>
copy(_RAIter __f,
     _RAIter __l,
     __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> __r,
     typename enable_if<__is_cpp17_random_access_iterator<_RAIter>::value>::type*)
{
    typedef typename __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>::difference_type difference_type;
    typedef typename __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>::pointer pointer;
    const difference_type __block_size = __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>::__block_size;
    while (__f != __l)
    {
        pointer __rb = __r.__ptr_;
        pointer __re = *__r.__m_iter_ + __block_size;
        difference_type __bs = __re - __rb;
        difference_type __n = __l - __f;
        _RAIter __m = __l;
        if (__n > __bs)
        {
            __n = __bs;
            __m = __f + __n;
        }
        std::__1::copy(__f, __m, __rb);
        __f = __m;
        __r += __n;
    }
    return __r;
}

template <class _V1, class _P1, class _R1, class _M1, class _D1, _D1 _B1,
          class _OutputIterator>
_OutputIterator
copy(__deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __f,
     __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __l,
     _OutputIterator __r)
{
    typedef typename __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1>::difference_type difference_type;
    typedef typename __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1>::pointer pointer;
    const difference_type __block_size = __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1>::__block_size;
    difference_type __n = __l - __f;
    while (__n > 0)
    {
        pointer __fb = __f.__ptr_;
        pointer __fe = *__f.__m_iter_ + __block_size;
        difference_type __bs = __fe - __fb;
        if (__bs > __n)
        {
            __bs = __n;
            __fe = __fb + __bs;
        }
        __r = std::__1::copy(__fb, __fe, __r);
        __n -= __bs;
        __f += __bs;
    }
    return __r;
}

template <class _V1, class _P1, class _R1, class _M1, class _D1, _D1 _B1,
          class _V2, class _P2, class _R2, class _M2, class _D2, _D2 _B2>
__deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>
copy(__deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __f,
     __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __l,
     __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> __r)
{
    typedef typename __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1>::difference_type difference_type;
    typedef typename __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1>::pointer pointer;
    const difference_type __block_size = __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1>::__block_size;
    difference_type __n = __l - __f;
    while (__n > 0)
    {
        pointer __fb = __f.__ptr_;
        pointer __fe = *__f.__m_iter_ + __block_size;
        difference_type __bs = __fe - __fb;
        if (__bs > __n)
        {
            __bs = __n;
            __fe = __fb + __bs;
        }
        __r = std::__1::copy(__fb, __fe, __r);
        __n -= __bs;
        __f += __bs;
    }
    return __r;
}



template <class _RAIter,
          class _V2, class _P2, class _R2, class _M2, class _D2, _D2 _B2>
__deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>
copy_backward(_RAIter __f,
              _RAIter __l,
              __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> __r,
              typename enable_if<__is_cpp17_random_access_iterator<_RAIter>::value>::type*)
{
    typedef typename __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>::difference_type difference_type;
    typedef typename __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>::pointer pointer;
    while (__f != __l)
    {
        __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> __rp = std::__1::prev(__r);
        pointer __rb = *__rp.__m_iter_;
        pointer __re = __rp.__ptr_ + 1;
        difference_type __bs = __re - __rb;
        difference_type __n = __l - __f;
        _RAIter __m = __f;
        if (__n > __bs)
        {
            __n = __bs;
            __m = __l - __n;
        }
        std::__1::copy_backward(__m, __l, __re);
        __l = __m;
        __r -= __n;
    }
    return __r;
}

template <class _V1, class _P1, class _R1, class _M1, class _D1, _D1 _B1,
          class _OutputIterator>
_OutputIterator
copy_backward(__deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __f,
              __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __l,
              _OutputIterator __r)
{
    typedef typename __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1>::difference_type difference_type;
    typedef typename __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1>::pointer pointer;
    difference_type __n = __l - __f;
    while (__n > 0)
    {
        --__l;
        pointer __lb = *__l.__m_iter_;
        pointer __le = __l.__ptr_ + 1;
        difference_type __bs = __le - __lb;
        if (__bs > __n)
        {
            __bs = __n;
            __lb = __le - __bs;
        }
        __r = std::__1::copy_backward(__lb, __le, __r);
        __n -= __bs;
        __l -= __bs - 1;
    }
    return __r;
}

template <class _V1, class _P1, class _R1, class _M1, class _D1, _D1 _B1,
          class _V2, class _P2, class _R2, class _M2, class _D2, _D2 _B2>
__deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>
copy_backward(__deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __f,
              __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __l,
              __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> __r)
{
    typedef typename __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1>::difference_type difference_type;
    typedef typename __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1>::pointer pointer;
    difference_type __n = __l - __f;
    while (__n > 0)
    {
        --__l;
        pointer __lb = *__l.__m_iter_;
        pointer __le = __l.__ptr_ + 1;
        difference_type __bs = __le - __lb;
        if (__bs > __n)
        {
            __bs = __n;
            __lb = __le - __bs;
        }
        __r = std::__1::copy_backward(__lb, __le, __r);
        __n -= __bs;
        __l -= __bs - 1;
    }
    return __r;
}



template <class _RAIter,
          class _V2, class _P2, class _R2, class _M2, class _D2, _D2 _B2>
__deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>
move(_RAIter __f,
     _RAIter __l,
     __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> __r,
     typename enable_if<__is_cpp17_random_access_iterator<_RAIter>::value>::type*)
{
    typedef typename __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>::difference_type difference_type;
    typedef typename __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>::pointer pointer;
    const difference_type __block_size = __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>::__block_size;
    while (__f != __l)
    {
        pointer __rb = __r.__ptr_;
        pointer __re = *__r.__m_iter_ + __block_size;
        difference_type __bs = __re - __rb;
        difference_type __n = __l - __f;
        _RAIter __m = __l;
        if (__n > __bs)
        {
            __n = __bs;
            __m = __f + __n;
        }
        std::__1::move(__f, __m, __rb);
        __f = __m;
        __r += __n;
    }
    return __r;
}

template <class _V1, class _P1, class _R1, class _M1, class _D1, _D1 _B1,
          class _OutputIterator>
_OutputIterator
move(__deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __f,
     __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __l,
     _OutputIterator __r)
{
    typedef typename __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1>::difference_type difference_type;
    typedef typename __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1>::pointer pointer;
    const difference_type __block_size = __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1>::__block_size;
    difference_type __n = __l - __f;
    while (__n > 0)
    {
        pointer __fb = __f.__ptr_;
        pointer __fe = *__f.__m_iter_ + __block_size;
        difference_type __bs = __fe - __fb;
        if (__bs > __n)
        {
            __bs = __n;
            __fe = __fb + __bs;
        }
        __r = std::__1::move(__fb, __fe, __r);
        __n -= __bs;
        __f += __bs;
    }
    return __r;
}

template <class _V1, class _P1, class _R1, class _M1, class _D1, _D1 _B1,
          class _V2, class _P2, class _R2, class _M2, class _D2, _D2 _B2>
__deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>
move(__deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __f,
     __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __l,
     __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> __r)
{
    typedef typename __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1>::difference_type difference_type;
    typedef typename __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1>::pointer pointer;
    const difference_type __block_size = __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1>::__block_size;
    difference_type __n = __l - __f;
    while (__n > 0)
    {
        pointer __fb = __f.__ptr_;
        pointer __fe = *__f.__m_iter_ + __block_size;
        difference_type __bs = __fe - __fb;
        if (__bs > __n)
        {
            __bs = __n;
            __fe = __fb + __bs;
        }
        __r = std::__1::move(__fb, __fe, __r);
        __n -= __bs;
        __f += __bs;
    }
    return __r;
}



template <class _RAIter,
          class _V2, class _P2, class _R2, class _M2, class _D2, _D2 _B2>
__deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>
move_backward(_RAIter __f,
              _RAIter __l,
              __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> __r,
              typename enable_if<__is_cpp17_random_access_iterator<_RAIter>::value>::type*)
{
    typedef typename __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>::difference_type difference_type;
    typedef typename __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>::pointer pointer;
    while (__f != __l)
    {
        __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> __rp = std::__1::prev(__r);
        pointer __rb = *__rp.__m_iter_;
        pointer __re = __rp.__ptr_ + 1;
        difference_type __bs = __re - __rb;
        difference_type __n = __l - __f;
        _RAIter __m = __f;
        if (__n > __bs)
        {
            __n = __bs;
            __m = __l - __n;
        }
        std::__1::move_backward(__m, __l, __re);
        __l = __m;
        __r -= __n;
    }
    return __r;
}

template <class _V1, class _P1, class _R1, class _M1, class _D1, _D1 _B1,
          class _OutputIterator>
_OutputIterator
move_backward(__deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __f,
              __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __l,
              _OutputIterator __r)
{
    typedef typename __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1>::difference_type difference_type;
    typedef typename __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1>::pointer pointer;
    difference_type __n = __l - __f;
    while (__n > 0)
    {
        --__l;
        pointer __lb = *__l.__m_iter_;
        pointer __le = __l.__ptr_ + 1;
        difference_type __bs = __le - __lb;
        if (__bs > __n)
        {
            __bs = __n;
            __lb = __le - __bs;
        }
        __r = std::__1::move_backward(__lb, __le, __r);
        __n -= __bs;
        __l -= __bs - 1;
    }
    return __r;
}

template <class _V1, class _P1, class _R1, class _M1, class _D1, _D1 _B1,
          class _V2, class _P2, class _R2, class _M2, class _D2, _D2 _B2>
__deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>
move_backward(__deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __f,
              __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __l,
              __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> __r)
{
    typedef typename __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1>::difference_type difference_type;
    typedef typename __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1>::pointer pointer;
    difference_type __n = __l - __f;
    while (__n > 0)
    {
        --__l;
        pointer __lb = *__l.__m_iter_;
        pointer __le = __l.__ptr_ + 1;
        difference_type __bs = __le - __lb;
        if (__bs > __n)
        {
            __bs = __n;
            __lb = __le - __bs;
        }
        __r = std::__1::move_backward(__lb, __le, __r);
        __n -= __bs;
        __l -= __bs - 1;
    }
    return __r;
}

template <bool>
class __deque_base_common
{
protected:
    [[noreturn]] void __throw_length_error() const;
    [[noreturn]] void __throw_out_of_range() const;
};

template <bool __b>
void
__deque_base_common<__b>::__throw_length_error() const
{
    std::__1::__throw_length_error("deque");
}

template <bool __b>
void
__deque_base_common<__b>::__throw_out_of_range() const
{
    std::__1::__throw_out_of_range("deque");
}

template <class _Tp, class _Allocator>
class __deque_base
    : protected __deque_base_common<true>
{
    __deque_base(const __deque_base& __c);
    __deque_base& operator=(const __deque_base& __c);
public:
    typedef _Allocator allocator_type;
    typedef allocator_traits<allocator_type> __alloc_traits;
    typedef typename __alloc_traits::size_type size_type;

    typedef _Tp value_type;
    typedef value_type& reference;
    typedef const value_type& const_reference;
    typedef typename __alloc_traits::difference_type difference_type;
    typedef typename __alloc_traits::pointer pointer;
    typedef typename __alloc_traits::const_pointer const_pointer;

    static const difference_type __block_size;

    typedef typename __rebind_alloc_helper<__alloc_traits, pointer>::type __pointer_allocator;
    typedef allocator_traits<__pointer_allocator> __map_traits;
    typedef typename __map_traits::pointer __map_pointer;
    typedef typename __rebind_alloc_helper<__alloc_traits, const_pointer>::type __const_pointer_allocator;
    typedef typename allocator_traits<__const_pointer_allocator>::const_pointer __map_const_pointer;
    typedef __split_buffer<pointer, __pointer_allocator> __map;

    typedef __deque_iterator<value_type, pointer, reference, __map_pointer,
                             difference_type> iterator;
    typedef __deque_iterator<value_type, const_pointer, const_reference, __map_const_pointer,
                             difference_type> const_iterator;

    struct __deque_block_range {
      explicit __deque_block_range(pointer __b, pointer __e) noexcept : __begin_(__b), __end_(__e) {}
      const pointer __begin_;
      const pointer __end_;
    };

    struct __deque_range {
      iterator __pos_;
      const iterator __end_;

      __deque_range(iterator __pos, iterator __e) noexcept
        : __pos_(__pos), __end_(__e) {}

      explicit operator bool() const noexcept {
        return __pos_ != __end_;
      }

      __deque_range begin() const {
        return *this;
      }

      __deque_range end() const {
        return __deque_range(__end_, __end_);
      }
      __deque_block_range operator*() const noexcept {
         if (__pos_.__m_iter_ == __end_.__m_iter_) {
          return __deque_block_range(__pos_.__ptr_, __end_.__ptr_);
        }
        return __deque_block_range(__pos_.__ptr_, *__pos_.__m_iter_ + __block_size);
      }

      __deque_range& operator++() noexcept {
        if (__pos_.__m_iter_ == __end_.__m_iter_) {
          __pos_ = __end_;
        } else {
          ++__pos_.__m_iter_;
          __pos_.__ptr_ = *__pos_.__m_iter_;
        }
        return *this;
      }


      friend bool operator==(__deque_range const& __lhs, __deque_range const& __rhs) {
        return __lhs.__pos_ == __rhs.__pos_;
      }
      friend bool operator!=(__deque_range const& __lhs, __deque_range const& __rhs) {
        return !(__lhs == __rhs);
      }
    };



    struct _ConstructTransaction {
      _ConstructTransaction(__deque_base* __db, __deque_block_range& __r)
        : __pos_(__r.__begin_), __end_(__r.__end_), __begin_(__r.__begin_), __base_(__db) {}


      ~_ConstructTransaction() {
        __base_->size() += (__pos_ - __begin_);
      }

      pointer __pos_;
      const pointer __end_;
    private:
      const pointer __begin_;
      __deque_base * const __base_;
    };

protected:
    __map __map_;
    size_type __start_;
    __compressed_pair<size_type, allocator_type> __size_;

    iterator begin() noexcept;
    const_iterator begin() const noexcept;
    iterator end() noexcept;
    const_iterator end() const noexcept;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) size_type& size() {return __size_.first();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const size_type& size() const noexcept {return __size_.first();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) allocator_type& __alloc() {return __size_.second();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const allocator_type& __alloc() const noexcept {return __size_.second();}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __deque_base()
        noexcept(is_nothrow_default_constructible<allocator_type>::value);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit __deque_base(const allocator_type& __a);
public:
    ~__deque_base();


    __deque_base(__deque_base&& __c)
        noexcept(is_nothrow_move_constructible<allocator_type>::value);
    __deque_base(__deque_base&& __c, const allocator_type& __a);


    void swap(__deque_base& __c)

        noexcept;




protected:
    void clear() noexcept;

    bool __invariants() const;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void __move_assign(__deque_base& __c)
        noexcept(__alloc_traits::propagate_on_container_move_assignment::value && is_nothrow_move_assignable<allocator_type>::value)

    {
        __map_ = std::__1::move(__c.__map_);
        __start_ = __c.__start_;
        size() = __c.size();
        __move_assign_alloc(__c);
        __c.__start_ = __c.size() = 0;
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void __move_assign_alloc(__deque_base& __c)
        noexcept(!__alloc_traits::propagate_on_container_move_assignment::value || is_nothrow_move_assignable<allocator_type>::value)

        {__move_assign_alloc(__c, integral_constant<bool,
                      __alloc_traits::propagate_on_container_move_assignment::value>());}

private:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void __move_assign_alloc(__deque_base& __c, true_type)
        noexcept(is_nothrow_move_assignable<allocator_type>::value)
        {
            __alloc() = std::__1::move(__c.__alloc());
        }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void __move_assign_alloc(__deque_base&, false_type) noexcept
        {}
};

template <class _Tp, class _Allocator>
const typename __deque_base<_Tp, _Allocator>::difference_type
    __deque_base<_Tp, _Allocator>::__block_size =
        __deque_block_size<value_type, difference_type>::value;

template <class _Tp, class _Allocator>
bool
__deque_base<_Tp, _Allocator>::__invariants() const
{
    if (!__map_.__invariants())
        return false;
    if (__map_.size() >= size_type(-1) / __block_size)
        return false;
    for (typename __map::const_iterator __i = __map_.begin(), __e = __map_.end();
         __i != __e; ++__i)
        if (*__i == nullptr)
            return false;
    if (__map_.size() != 0)
    {
        if (size() >= __map_.size() * __block_size)
            return false;
        if (__start_ >= __map_.size() * __block_size - size())
            return false;
    }
    else
    {
        if (size() != 0)
            return false;
        if (__start_ != 0)
            return false;
    }
    return true;
}

template <class _Tp, class _Allocator>
typename __deque_base<_Tp, _Allocator>::iterator
__deque_base<_Tp, _Allocator>::begin() noexcept
{
    __map_pointer __mp = __map_.begin() + __start_ / __block_size;
    return iterator(__mp, __map_.empty() ? 0 : *__mp + __start_ % __block_size);
}

template <class _Tp, class _Allocator>
typename __deque_base<_Tp, _Allocator>::const_iterator
__deque_base<_Tp, _Allocator>::begin() const noexcept
{
    __map_const_pointer __mp = static_cast<__map_const_pointer>(__map_.begin() + __start_ / __block_size);
    return const_iterator(__mp, __map_.empty() ? 0 : *__mp + __start_ % __block_size);
}

template <class _Tp, class _Allocator>
typename __deque_base<_Tp, _Allocator>::iterator
__deque_base<_Tp, _Allocator>::end() noexcept
{
    size_type __p = size() + __start_;
    __map_pointer __mp = __map_.begin() + __p / __block_size;
    return iterator(__mp, __map_.empty() ? 0 : *__mp + __p % __block_size);
}

template <class _Tp, class _Allocator>
typename __deque_base<_Tp, _Allocator>::const_iterator
__deque_base<_Tp, _Allocator>::end() const noexcept
{
    size_type __p = size() + __start_;
    __map_const_pointer __mp = static_cast<__map_const_pointer>(__map_.begin() + __p / __block_size);
    return const_iterator(__mp, __map_.empty() ? 0 : *__mp + __p % __block_size);
}

template <class _Tp, class _Allocator>
inline
__deque_base<_Tp, _Allocator>::__deque_base()
    noexcept(is_nothrow_default_constructible<allocator_type>::value)
    : __start_(0), __size_(0, __default_init_tag()) {}

template <class _Tp, class _Allocator>
inline
__deque_base<_Tp, _Allocator>::__deque_base(const allocator_type& __a)
    : __map_(__pointer_allocator(__a)), __start_(0), __size_(0, __a) {}

template <class _Tp, class _Allocator>
__deque_base<_Tp, _Allocator>::~__deque_base()
{
    clear();
    typename __map::iterator __i = __map_.begin();
    typename __map::iterator __e = __map_.end();
    for (; __i != __e; ++__i)
        __alloc_traits::deallocate(__alloc(), *__i, __block_size);
}



template <class _Tp, class _Allocator>
__deque_base<_Tp, _Allocator>::__deque_base(__deque_base&& __c)
    noexcept(is_nothrow_move_constructible<allocator_type>::value)
    : __map_(std::__1::move(__c.__map_)),
      __start_(std::__1::move(__c.__start_)),
      __size_(std::__1::move(__c.__size_))
{
    __c.__start_ = 0;
    __c.size() = 0;
}

template <class _Tp, class _Allocator>
__deque_base<_Tp, _Allocator>::__deque_base(__deque_base&& __c, const allocator_type& __a)
    : __map_(std::__1::move(__c.__map_), __pointer_allocator(__a)),
      __start_(std::__1::move(__c.__start_)),
      __size_(std::__1::move(__c.size()), __a)
{
    if (__a == __c.__alloc())
    {
        __c.__start_ = 0;
        __c.size() = 0;
    }
    else
    {
        __map_.clear();
        __start_ = 0;
        size() = 0;
    }
}



template <class _Tp, class _Allocator>
void
__deque_base<_Tp, _Allocator>::swap(__deque_base& __c)

        noexcept




{
    __map_.swap(__c.__map_);
    std::__1::swap(__start_, __c.__start_);
    std::__1::swap(size(), __c.size());
    std::__1::__swap_allocator(__alloc(), __c.__alloc());
}

template <class _Tp, class _Allocator>
void
__deque_base<_Tp, _Allocator>::clear() noexcept
{
    allocator_type& __a = __alloc();
    for (iterator __i = begin(), __e = end(); __i != __e; ++__i)
        __alloc_traits::destroy(__a, std::__1::addressof(*__i));
    size() = 0;
    while (__map_.size() > 2)
    {
        __alloc_traits::deallocate(__a, __map_.front(), __block_size);
        __map_.pop_front();
    }
    switch (__map_.size())
    {
    case 1:
        __start_ = __block_size / 2;
        break;
    case 2:
        __start_ = __block_size;
        break;
    }
}

template <class _Tp, class _Allocator >
class __attribute__ ((__type_visibility__("default"))) deque
    : private __deque_base<_Tp, _Allocator>
{
public:


    typedef _Tp value_type;
    typedef _Allocator allocator_type;

    static_assert((is_same<typename allocator_type::value_type, value_type>::value),
                  "Allocator::value_type must be same type as value_type");

    typedef __deque_base<value_type, allocator_type> __base;

    typedef typename __base::__alloc_traits __alloc_traits;
    typedef typename __base::reference reference;
    typedef typename __base::const_reference const_reference;
    typedef typename __base::iterator iterator;
    typedef typename __base::const_iterator const_iterator;
    typedef typename __base::size_type size_type;
    typedef typename __base::difference_type difference_type;

    typedef typename __base::pointer pointer;
    typedef typename __base::const_pointer const_pointer;
    typedef std::__1::reverse_iterator<iterator> reverse_iterator;
    typedef std::__1::reverse_iterator<const_iterator> const_reverse_iterator;

    using typename __base::__deque_range;
    using typename __base::__deque_block_range;
    using typename __base::_ConstructTransaction;


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    deque()
        noexcept(is_nothrow_default_constructible<allocator_type>::value)
        {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) explicit deque(const allocator_type& __a) : __base(__a) {}
    explicit deque(size_type __n);

    explicit deque(size_type __n, const _Allocator& __a);

    deque(size_type __n, const value_type& __v);
    deque(size_type __n, const value_type& __v, const allocator_type& __a);
    template <class _InputIter>
        deque(_InputIter __f, _InputIter __l,
              typename enable_if<__is_cpp17_input_iterator<_InputIter>::value>::type* = 0);
    template <class _InputIter>
        deque(_InputIter __f, _InputIter __l, const allocator_type& __a,
              typename enable_if<__is_cpp17_input_iterator<_InputIter>::value>::type* = 0);
    deque(const deque& __c);
    deque(const deque& __c, const __identity_t<allocator_type>& __a);

    deque& operator=(const deque& __c);


    deque(initializer_list<value_type> __il);
    deque(initializer_list<value_type> __il, const allocator_type& __a);

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    deque& operator=(initializer_list<value_type> __il) {assign(__il); return *this;}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    deque(deque&& __c) noexcept(is_nothrow_move_constructible<__base>::value);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    deque(deque&& __c, const __identity_t<allocator_type>& __a);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    deque& operator=(deque&& __c)
        noexcept(__alloc_traits::propagate_on_container_move_assignment::value && is_nothrow_move_assignable<allocator_type>::value);


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void assign(initializer_list<value_type> __il) {assign(__il.begin(), __il.end());}


    template <class _InputIter>
        void assign(_InputIter __f, _InputIter __l,
                    typename enable_if<__is_cpp17_input_iterator<_InputIter>::value &&
                                      !__is_cpp17_random_access_iterator<_InputIter>::value>::type* = 0);
    template <class _RAIter>
        void assign(_RAIter __f, _RAIter __l,
                    typename enable_if<__is_cpp17_random_access_iterator<_RAIter>::value>::type* = 0);
    void assign(size_type __n, const value_type& __v);

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    allocator_type get_allocator() const noexcept;



    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iterator begin() noexcept {return __base::begin();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_iterator begin() const noexcept {return __base::begin();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iterator end() noexcept {return __base::end();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_iterator end() const noexcept {return __base::end();}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    reverse_iterator rbegin() noexcept
        {return reverse_iterator(__base::end());}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_reverse_iterator rbegin() const noexcept
        {return const_reverse_iterator(__base::end());}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    reverse_iterator rend() noexcept
        {return reverse_iterator(__base::begin());}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_reverse_iterator rend() const noexcept
        {return const_reverse_iterator(__base::begin());}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_iterator cbegin() const noexcept
        {return __base::begin();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_iterator cend() const noexcept
        {return __base::end();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_reverse_iterator crbegin() const noexcept
        {return const_reverse_iterator(__base::end());}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_reverse_iterator crend() const noexcept
        {return const_reverse_iterator(__base::begin());}


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_type size() const noexcept {return __base::size();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_type max_size() const noexcept
        {return std::__1::min<size_type>(
            __alloc_traits::max_size(__base::__alloc()),
            numeric_limits<difference_type>::max());}
    void resize(size_type __n);
    void resize(size_type __n, const value_type& __v);
    void shrink_to_fit() noexcept;
                                  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    bool empty() const noexcept {return __base::size() == 0;}


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    reference operator[](size_type __i) noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_reference operator[](size_type __i) const noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    reference at(size_type __i);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_reference at(size_type __i) const;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    reference front() noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_reference front() const noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    reference back() noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_reference back() const noexcept;


    void push_front(const value_type& __v);
    void push_back(const value_type& __v);


    template <class... _Args> reference emplace_front(_Args&&... __args);
    template <class... _Args> reference emplace_back (_Args&&... __args);




    template <class... _Args> iterator emplace(const_iterator __p, _Args&&... __args);

    void push_front(value_type&& __v);
    void push_back(value_type&& __v);
    iterator insert(const_iterator __p, value_type&& __v);

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iterator insert(const_iterator __p, initializer_list<value_type> __il)
        {return insert(__p, __il.begin(), __il.end());}

    iterator insert(const_iterator __p, const value_type& __v);
    iterator insert(const_iterator __p, size_type __n, const value_type& __v);
    template <class _InputIter>
        iterator insert(const_iterator __p, _InputIter __f, _InputIter __l,
                         typename enable_if<__is_cpp17_input_iterator<_InputIter>::value
                                         &&!__is_cpp17_forward_iterator<_InputIter>::value>::type* = 0);
    template <class _ForwardIterator>
        iterator insert(const_iterator __p, _ForwardIterator __f, _ForwardIterator __l,
                               typename enable_if<__is_cpp17_forward_iterator<_ForwardIterator>::value
                                         &&!__is_cpp17_bidirectional_iterator<_ForwardIterator>::value>::type* = 0);
    template <class _BiIter>
        iterator insert(const_iterator __p, _BiIter __f, _BiIter __l,
                         typename enable_if<__is_cpp17_bidirectional_iterator<_BiIter>::value>::type* = 0);

    void pop_front();
    void pop_back();
    iterator erase(const_iterator __p);
    iterator erase(const_iterator __f, const_iterator __l);

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void swap(deque& __c)

        noexcept;




    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void clear() noexcept;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    bool __invariants() const {return __base::__invariants();}

    typedef typename __base::__map_const_pointer __map_const_pointer;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    static size_type __recommend_blocks(size_type __n)
    {
        return __n / __base::__block_size + (__n % __base::__block_size != 0);
    }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_type __capacity() const
    {
        return __base::__map_.size() == 0 ? 0 : __base::__map_.size() * __base::__block_size - 1;
    }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_type __block_count() const
    {
        return __base::__map_.size();
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_type __front_spare() const
    {
        return __base::__start_;
    }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_type __front_spare_blocks() const {
      return __front_spare() / __base::__block_size;
    }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_type __back_spare() const
    {
        return __capacity() - (__base::__start_ + __base::size());
    }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_type __back_spare_blocks() const {
      return __back_spare() / __base::__block_size;
    }

 private:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    bool __maybe_remove_front_spare(bool __keep_one = true) {
      if (__front_spare_blocks() >= 2 || (!__keep_one && __front_spare_blocks())) {
        __alloc_traits::deallocate(__base::__alloc(), __base::__map_.front(),
                                   __base::__block_size);
        __base::__map_.pop_front();
        __base::__start_ -= __base::__block_size;
        return true;
      }
      return false;
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    bool __maybe_remove_back_spare(bool __keep_one = true) {
      if (__back_spare_blocks() >= 2 || (!__keep_one && __back_spare_blocks())) {
        __alloc_traits::deallocate(__base::__alloc(), __base::__map_.back(),
                                   __base::__block_size);
        __base::__map_.pop_back();
        return true;
      }
      return false;
    }

    template <class _InpIter>
        void __append(_InpIter __f, _InpIter __l,
                 typename enable_if<__is_cpp17_input_iterator<_InpIter>::value &&
                                   !__is_cpp17_forward_iterator<_InpIter>::value>::type* = 0);
    template <class _ForIter>
        void __append(_ForIter __f, _ForIter __l,
                      typename enable_if<__is_cpp17_forward_iterator<_ForIter>::value>::type* = 0);
    void __append(size_type __n);
    void __append(size_type __n, const value_type& __v);
    void __erase_to_end(const_iterator __f);
    void __add_front_capacity();
    void __add_front_capacity(size_type __n);
    void __add_back_capacity();
    void __add_back_capacity(size_type __n);
    iterator __move_and_check(iterator __f, iterator __l, iterator __r,
                              const_pointer& __vt);
    iterator __move_backward_and_check(iterator __f, iterator __l, iterator __r,
                                       const_pointer& __vt);
    void __move_construct_and_check(iterator __f, iterator __l,
                                    iterator __r, const_pointer& __vt);
    void __move_construct_backward_and_check(iterator __f, iterator __l,
                                             iterator __r, const_pointer& __vt);

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void __copy_assign_alloc(const deque& __c)
        {__copy_assign_alloc(__c, integral_constant<bool,
                      __alloc_traits::propagate_on_container_copy_assignment::value>());}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void __copy_assign_alloc(const deque& __c, true_type)
        {
            if (__base::__alloc() != __c.__alloc())
            {
                clear();
                shrink_to_fit();
            }
            __base::__alloc() = __c.__alloc();
            __base::__map_.__alloc() = __c.__map_.__alloc();
        }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void __copy_assign_alloc(const deque&, false_type)
        {}

    void __move_assign(deque& __c, true_type)
        noexcept(is_nothrow_move_assignable<allocator_type>::value);
    void __move_assign(deque& __c, false_type);
};


template<class _InputIterator,
         class _Alloc = allocator<__iter_value_type<_InputIterator>>,
         class = _EnableIf<__is_allocator<_Alloc>::value>
         >
deque(_InputIterator, _InputIterator)
  -> deque<__iter_value_type<_InputIterator>, _Alloc>;

template<class _InputIterator,
         class _Alloc,
         class = _EnableIf<__is_allocator<_Alloc>::value>
         >
deque(_InputIterator, _InputIterator, _Alloc)
  -> deque<__iter_value_type<_InputIterator>, _Alloc>;



template <class _Tp, class _Allocator>
deque<_Tp, _Allocator>::deque(size_type __n)
{
    if (__n > 0)
        __append(__n);
}


template <class _Tp, class _Allocator>
deque<_Tp, _Allocator>::deque(size_type __n, const _Allocator& __a)
    : __base(__a)
{
    if (__n > 0)
        __append(__n);
}


template <class _Tp, class _Allocator>
deque<_Tp, _Allocator>::deque(size_type __n, const value_type& __v)
{
    if (__n > 0)
        __append(__n, __v);
}

template <class _Tp, class _Allocator>
deque<_Tp, _Allocator>::deque(size_type __n, const value_type& __v, const allocator_type& __a)
    : __base(__a)
{
    if (__n > 0)
        __append(__n, __v);
}

template <class _Tp, class _Allocator>
template <class _InputIter>
deque<_Tp, _Allocator>::deque(_InputIter __f, _InputIter __l,
              typename enable_if<__is_cpp17_input_iterator<_InputIter>::value>::type*)
{
    __append(__f, __l);
}

template <class _Tp, class _Allocator>
template <class _InputIter>
deque<_Tp, _Allocator>::deque(_InputIter __f, _InputIter __l, const allocator_type& __a,
              typename enable_if<__is_cpp17_input_iterator<_InputIter>::value>::type*)
    : __base(__a)
{
    __append(__f, __l);
}

template <class _Tp, class _Allocator>
deque<_Tp, _Allocator>::deque(const deque& __c)
    : __base(__alloc_traits::select_on_container_copy_construction(__c.__alloc()))
{
    __append(__c.begin(), __c.end());
}

template <class _Tp, class _Allocator>
deque<_Tp, _Allocator>::deque(const deque& __c, const __identity_t<allocator_type>& __a)
    : __base(__a)
{
    __append(__c.begin(), __c.end());
}

template <class _Tp, class _Allocator>
deque<_Tp, _Allocator>&
deque<_Tp, _Allocator>::operator=(const deque& __c)
{
    if (this != &__c)
    {
        __copy_assign_alloc(__c);
        assign(__c.begin(), __c.end());
    }
    return *this;
}



template <class _Tp, class _Allocator>
deque<_Tp, _Allocator>::deque(initializer_list<value_type> __il)
{
    __append(__il.begin(), __il.end());
}

template <class _Tp, class _Allocator>
deque<_Tp, _Allocator>::deque(initializer_list<value_type> __il, const allocator_type& __a)
    : __base(__a)
{
    __append(__il.begin(), __il.end());
}

template <class _Tp, class _Allocator>
inline
deque<_Tp, _Allocator>::deque(deque&& __c)
    noexcept(is_nothrow_move_constructible<__base>::value)
    : __base(std::__1::move(__c))
{
}

template <class _Tp, class _Allocator>
inline
deque<_Tp, _Allocator>::deque(deque&& __c, const __identity_t<allocator_type>& __a)
    : __base(std::__1::move(__c), __a)
{
    if (__a != __c.__alloc())
    {
        typedef move_iterator<iterator> _Ip;
        assign(_Ip(__c.begin()), _Ip(__c.end()));
    }
}

template <class _Tp, class _Allocator>
inline
deque<_Tp, _Allocator>&
deque<_Tp, _Allocator>::operator=(deque&& __c)
        noexcept(__alloc_traits::propagate_on_container_move_assignment::value && is_nothrow_move_assignable<allocator_type>::value)

{
    __move_assign(__c, integral_constant<bool,
          __alloc_traits::propagate_on_container_move_assignment::value>());
    return *this;
}

template <class _Tp, class _Allocator>
void
deque<_Tp, _Allocator>::__move_assign(deque& __c, false_type)
{
    if (__base::__alloc() != __c.__alloc())
    {
        typedef move_iterator<iterator> _Ip;
        assign(_Ip(__c.begin()), _Ip(__c.end()));
    }
    else
        __move_assign(__c, true_type());
}

template <class _Tp, class _Allocator>
void
deque<_Tp, _Allocator>::__move_assign(deque& __c, true_type)
    noexcept(is_nothrow_move_assignable<allocator_type>::value)
{
    clear();
    shrink_to_fit();
    __base::__move_assign(__c);
}



template <class _Tp, class _Allocator>
template <class _InputIter>
void
deque<_Tp, _Allocator>::assign(_InputIter __f, _InputIter __l,
                               typename enable_if<__is_cpp17_input_iterator<_InputIter>::value &&
                                                 !__is_cpp17_random_access_iterator<_InputIter>::value>::type*)
{
    iterator __i = __base::begin();
    iterator __e = __base::end();
    for (; __f != __l && __i != __e; ++__f, (void) ++__i)
        *__i = *__f;
    if (__f != __l)
        __append(__f, __l);
    else
        __erase_to_end(__i);
}

template <class _Tp, class _Allocator>
template <class _RAIter>
void
deque<_Tp, _Allocator>::assign(_RAIter __f, _RAIter __l,
                               typename enable_if<__is_cpp17_random_access_iterator<_RAIter>::value>::type*)
{
    if (static_cast<size_type>(__l - __f) > __base::size())
    {
        _RAIter __m = __f + __base::size();
        std::__1::copy(__f, __m, __base::begin());
        __append(__m, __l);
    }
    else
        __erase_to_end(std::__1::copy(__f, __l, __base::begin()));
}

template <class _Tp, class _Allocator>
void
deque<_Tp, _Allocator>::assign(size_type __n, const value_type& __v)
{
    if (__n > __base::size())
    {
        std::__1::fill_n(__base::begin(), __base::size(), __v);
        __n -= __base::size();
        __append(__n, __v);
    }
    else
        __erase_to_end(std::__1::fill_n(__base::begin(), __n, __v));
}

template <class _Tp, class _Allocator>
inline
_Allocator
deque<_Tp, _Allocator>::get_allocator() const noexcept
{
    return __base::__alloc();
}

template <class _Tp, class _Allocator>
void
deque<_Tp, _Allocator>::resize(size_type __n)
{
    if (__n > __base::size())
        __append(__n - __base::size());
    else if (__n < __base::size())
        __erase_to_end(__base::begin() + __n);
}

template <class _Tp, class _Allocator>
void
deque<_Tp, _Allocator>::resize(size_type __n, const value_type& __v)
{
    if (__n > __base::size())
        __append(__n - __base::size(), __v);
    else if (__n < __base::size())
        __erase_to_end(__base::begin() + __n);
}

template <class _Tp, class _Allocator>
void
deque<_Tp, _Allocator>::shrink_to_fit() noexcept
{
    allocator_type& __a = __base::__alloc();
    if (empty())
    {
        while (__base::__map_.size() > 0)
        {
            __alloc_traits::deallocate(__a, __base::__map_.back(), __base::__block_size);
            __base::__map_.pop_back();
        }
        __base::__start_ = 0;
    }
    else
    {
      __maybe_remove_front_spare( false);
      __maybe_remove_back_spare( false);
    }
    __base::__map_.shrink_to_fit();
}

template <class _Tp, class _Allocator>
inline
typename deque<_Tp, _Allocator>::reference
deque<_Tp, _Allocator>::operator[](size_type __i) noexcept
{
    size_type __p = __base::__start_ + __i;
    return *(*(__base::__map_.begin() + __p / __base::__block_size) + __p % __base::__block_size);
}

template <class _Tp, class _Allocator>
inline
typename deque<_Tp, _Allocator>::const_reference
deque<_Tp, _Allocator>::operator[](size_type __i) const noexcept
{
    size_type __p = __base::__start_ + __i;
    return *(*(__base::__map_.begin() + __p / __base::__block_size) + __p % __base::__block_size);
}

template <class _Tp, class _Allocator>
inline
typename deque<_Tp, _Allocator>::reference
deque<_Tp, _Allocator>::at(size_type __i)
{
    if (__i >= __base::size())
        __base::__throw_out_of_range();
    size_type __p = __base::__start_ + __i;
    return *(*(__base::__map_.begin() + __p / __base::__block_size) + __p % __base::__block_size);
}

template <class _Tp, class _Allocator>
inline
typename deque<_Tp, _Allocator>::const_reference
deque<_Tp, _Allocator>::at(size_type __i) const
{
    if (__i >= __base::size())
        __base::__throw_out_of_range();
    size_type __p = __base::__start_ + __i;
    return *(*(__base::__map_.begin() + __p / __base::__block_size) + __p % __base::__block_size);
}

template <class _Tp, class _Allocator>
inline
typename deque<_Tp, _Allocator>::reference
deque<_Tp, _Allocator>::front() noexcept
{
    return *(*(__base::__map_.begin() + __base::__start_ / __base::__block_size)
                                      + __base::__start_ % __base::__block_size);
}

template <class _Tp, class _Allocator>
inline
typename deque<_Tp, _Allocator>::const_reference
deque<_Tp, _Allocator>::front() const noexcept
{
    return *(*(__base::__map_.begin() + __base::__start_ / __base::__block_size)
                                      + __base::__start_ % __base::__block_size);
}

template <class _Tp, class _Allocator>
inline
typename deque<_Tp, _Allocator>::reference
deque<_Tp, _Allocator>::back() noexcept
{
    size_type __p = __base::size() + __base::__start_ - 1;
    return *(*(__base::__map_.begin() + __p / __base::__block_size) + __p % __base::__block_size);
}

template <class _Tp, class _Allocator>
inline
typename deque<_Tp, _Allocator>::const_reference
deque<_Tp, _Allocator>::back() const noexcept
{
    size_type __p = __base::size() + __base::__start_ - 1;
    return *(*(__base::__map_.begin() + __p / __base::__block_size) + __p % __base::__block_size);
}

template <class _Tp, class _Allocator>
void
deque<_Tp, _Allocator>::push_back(const value_type& __v)
{
    allocator_type& __a = __base::__alloc();
    if (__back_spare() == 0)
        __add_back_capacity();

    __alloc_traits::construct(__a, std::__1::addressof(*__base::end()), __v);
    ++__base::size();
}

template <class _Tp, class _Allocator>
void
deque<_Tp, _Allocator>::push_front(const value_type& __v)
{
    allocator_type& __a = __base::__alloc();
    if (__front_spare() == 0)
        __add_front_capacity();

    __alloc_traits::construct(__a, std::__1::addressof(*--__base::begin()), __v);
    --__base::__start_;
    ++__base::size();
}


template <class _Tp, class _Allocator>
void
deque<_Tp, _Allocator>::push_back(value_type&& __v)
{
    allocator_type& __a = __base::__alloc();
    if (__back_spare() == 0)
        __add_back_capacity();

    __alloc_traits::construct(__a, std::__1::addressof(*__base::end()), std::__1::move(__v));
    ++__base::size();
}

template <class _Tp, class _Allocator>
template <class... _Args>

typename deque<_Tp, _Allocator>::reference



deque<_Tp, _Allocator>::emplace_back(_Args&&... __args)
{
    allocator_type& __a = __base::__alloc();
    if (__back_spare() == 0)
        __add_back_capacity();

    __alloc_traits::construct(__a, std::__1::addressof(*__base::end()),
                              std::__1::forward<_Args>(__args)...);
    ++__base::size();

    return *--__base::end();

}

template <class _Tp, class _Allocator>
void
deque<_Tp, _Allocator>::push_front(value_type&& __v)
{
    allocator_type& __a = __base::__alloc();
    if (__front_spare() == 0)
        __add_front_capacity();

    __alloc_traits::construct(__a, std::__1::addressof(*--__base::begin()), std::__1::move(__v));
    --__base::__start_;
    ++__base::size();
}


template <class _Tp, class _Allocator>
template <class... _Args>

typename deque<_Tp, _Allocator>::reference



deque<_Tp, _Allocator>::emplace_front(_Args&&... __args)
{
    allocator_type& __a = __base::__alloc();
    if (__front_spare() == 0)
        __add_front_capacity();

    __alloc_traits::construct(__a, std::__1::addressof(*--__base::begin()), std::__1::forward<_Args>(__args)...);
    --__base::__start_;
    ++__base::size();

    return *__base::begin();

}

template <class _Tp, class _Allocator>
typename deque<_Tp, _Allocator>::iterator
deque<_Tp, _Allocator>::insert(const_iterator __p, value_type&& __v)
{
    size_type __pos = __p - __base::begin();
    size_type __to_end = __base::size() - __pos;
    allocator_type& __a = __base::__alloc();
    if (__pos < __to_end)
    {
        if (__front_spare() == 0)
            __add_front_capacity();

        if (__pos == 0)
        {
            __alloc_traits::construct(__a, std::__1::addressof(*--__base::begin()), std::__1::move(__v));
            --__base::__start_;
            ++__base::size();
        }
        else
        {
            iterator __b = __base::begin();
            iterator __bm1 = std::__1::prev(__b);
            __alloc_traits::construct(__a, std::__1::addressof(*__bm1), std::__1::move(*__b));
            --__base::__start_;
            ++__base::size();
            if (__pos > 1)
                __b = std::__1::move(std::__1::next(__b), __b + __pos, __b);
            *__b = std::__1::move(__v);
        }
    }
    else
    {
        if (__back_spare() == 0)
            __add_back_capacity();

        size_type __de = __base::size() - __pos;
        if (__de == 0)
        {
            __alloc_traits::construct(__a, std::__1::addressof(*__base::end()), std::__1::move(__v));
            ++__base::size();
        }
        else
        {
            iterator __e = __base::end();
            iterator __em1 = std::__1::prev(__e);
            __alloc_traits::construct(__a, std::__1::addressof(*__e), std::__1::move(*__em1));
            ++__base::size();
            if (__de > 1)
                __e = std::__1::move_backward(__e - __de, __em1, __e);
            *--__e = std::__1::move(__v);
        }
    }
    return __base::begin() + __pos;
}

template <class _Tp, class _Allocator>
template <class... _Args>
typename deque<_Tp, _Allocator>::iterator
deque<_Tp, _Allocator>::emplace(const_iterator __p, _Args&&... __args)
{
    size_type __pos = __p - __base::begin();
    size_type __to_end = __base::size() - __pos;
    allocator_type& __a = __base::__alloc();
    if (__pos < __to_end)
    {
        if (__front_spare() == 0)
            __add_front_capacity();

        if (__pos == 0)
        {
            __alloc_traits::construct(__a, std::__1::addressof(*--__base::begin()), std::__1::forward<_Args>(__args)...);
            --__base::__start_;
            ++__base::size();
        }
        else
        {
            __temp_value<value_type, _Allocator> __tmp(this->__alloc(), std::__1::forward<_Args>(__args)...);
            iterator __b = __base::begin();
            iterator __bm1 = std::__1::prev(__b);
            __alloc_traits::construct(__a, std::__1::addressof(*__bm1), std::__1::move(*__b));
            --__base::__start_;
            ++__base::size();
            if (__pos > 1)
                __b = std::__1::move(std::__1::next(__b), __b + __pos, __b);
            *__b = std::__1::move(__tmp.get());
        }
    }
    else
    {
        if (__back_spare() == 0)
            __add_back_capacity();

        size_type __de = __base::size() - __pos;
        if (__de == 0)
        {
            __alloc_traits::construct(__a, std::__1::addressof(*__base::end()), std::__1::forward<_Args>(__args)...);
            ++__base::size();
        }
        else
        {
            __temp_value<value_type, _Allocator> __tmp(this->__alloc(), std::__1::forward<_Args>(__args)...);
            iterator __e = __base::end();
            iterator __em1 = std::__1::prev(__e);
            __alloc_traits::construct(__a, std::__1::addressof(*__e), std::__1::move(*__em1));
            ++__base::size();
            if (__de > 1)
                __e = std::__1::move_backward(__e - __de, __em1, __e);
            *--__e = std::__1::move(__tmp.get());
        }
    }
    return __base::begin() + __pos;
}




template <class _Tp, class _Allocator>
typename deque<_Tp, _Allocator>::iterator
deque<_Tp, _Allocator>::insert(const_iterator __p, const value_type& __v)
{
    size_type __pos = __p - __base::begin();
    size_type __to_end = __base::size() - __pos;
    allocator_type& __a = __base::__alloc();
    if (__pos < __to_end)
    {
        if (__front_spare() == 0)
            __add_front_capacity();

        if (__pos == 0)
        {
            __alloc_traits::construct(__a, std::__1::addressof(*--__base::begin()), __v);
            --__base::__start_;
            ++__base::size();
        }
        else
        {
            const_pointer __vt = pointer_traits<const_pointer>::pointer_to(__v);
            iterator __b = __base::begin();
            iterator __bm1 = std::__1::prev(__b);
            if (__vt == pointer_traits<const_pointer>::pointer_to(*__b))
                __vt = pointer_traits<const_pointer>::pointer_to(*__bm1);
            __alloc_traits::construct(__a, std::__1::addressof(*__bm1), std::__1::move(*__b));
            --__base::__start_;
            ++__base::size();
            if (__pos > 1)
                __b = __move_and_check(std::__1::next(__b), __b + __pos, __b, __vt);
            *__b = *__vt;
        }
    }
    else
    {
        if (__back_spare() == 0)
            __add_back_capacity();

        size_type __de = __base::size() - __pos;
        if (__de == 0)
        {
            __alloc_traits::construct(__a, std::__1::addressof(*__base::end()), __v);
            ++__base::size();
        }
        else
        {
            const_pointer __vt = pointer_traits<const_pointer>::pointer_to(__v);
            iterator __e = __base::end();
            iterator __em1 = std::__1::prev(__e);
            if (__vt == pointer_traits<const_pointer>::pointer_to(*__em1))
                __vt = pointer_traits<const_pointer>::pointer_to(*__e);
            __alloc_traits::construct(__a, std::__1::addressof(*__e), std::__1::move(*__em1));
            ++__base::size();
            if (__de > 1)
                __e = __move_backward_and_check(__e - __de, __em1, __e, __vt);
            *--__e = *__vt;
        }
    }
    return __base::begin() + __pos;
}

template <class _Tp, class _Allocator>
typename deque<_Tp, _Allocator>::iterator
deque<_Tp, _Allocator>::insert(const_iterator __p, size_type __n, const value_type& __v)
{
    size_type __pos = __p - __base::begin();
    size_type __to_end = __base::size() - __pos;
    allocator_type& __a = __base::__alloc();
    if (__pos < __to_end)
    {
        if (__n > __front_spare())
            __add_front_capacity(__n - __front_spare());

        iterator __old_begin = __base::begin();
        iterator __i = __old_begin;
        if (__n > __pos)
        {
            for (size_type __m = __n - __pos; __m; --__m, --__base::__start_, ++__base::size())
                __alloc_traits::construct(__a, std::__1::addressof(*--__i), __v);
            __n = __pos;
        }
        if (__n > 0)
        {
            const_pointer __vt = pointer_traits<const_pointer>::pointer_to(__v);
            iterator __obn = __old_begin + __n;
            __move_construct_backward_and_check(__old_begin, __obn, __i, __vt);
            if (__n < __pos)
                __old_begin = __move_and_check(__obn, __old_begin + __pos, __old_begin, __vt);
            std::__1::fill_n(__old_begin, __n, *__vt);
        }
    }
    else
    {
        size_type __back_capacity = __back_spare();
        if (__n > __back_capacity)
            __add_back_capacity(__n - __back_capacity);

        iterator __old_end = __base::end();
        iterator __i = __old_end;
        size_type __de = __base::size() - __pos;
        if (__n > __de)
        {
            for (size_type __m = __n - __de; __m; --__m, ++__i, ++__base::size())
                __alloc_traits::construct(__a, std::__1::addressof(*__i), __v);
            __n = __de;
        }
        if (__n > 0)
        {
            const_pointer __vt = pointer_traits<const_pointer>::pointer_to(__v);
            iterator __oen = __old_end - __n;
            __move_construct_and_check(__oen, __old_end, __i, __vt);
            if (__n < __de)
                __old_end = __move_backward_and_check(__old_end - __de, __oen, __old_end, __vt);
            std::__1::fill_n(__old_end - __n, __n, *__vt);
        }
    }
    return __base::begin() + __pos;
}

template <class _Tp, class _Allocator>
template <class _InputIter>
typename deque<_Tp, _Allocator>::iterator
deque<_Tp, _Allocator>::insert(const_iterator __p, _InputIter __f, _InputIter __l,
                               typename enable_if<__is_cpp17_input_iterator<_InputIter>::value
                                               &&!__is_cpp17_forward_iterator<_InputIter>::value>::type*)
{
    __split_buffer<value_type, allocator_type&> __buf(__base::__alloc());
    __buf.__construct_at_end(__f, __l);
    typedef typename __split_buffer<value_type, allocator_type&>::iterator __bi;
    return insert(__p, move_iterator<__bi>(__buf.begin()), move_iterator<__bi>(__buf.end()));
}

template <class _Tp, class _Allocator>
template <class _ForwardIterator>
typename deque<_Tp, _Allocator>::iterator
deque<_Tp, _Allocator>::insert(const_iterator __p, _ForwardIterator __f, _ForwardIterator __l,
                               typename enable_if<__is_cpp17_forward_iterator<_ForwardIterator>::value
                                               &&!__is_cpp17_bidirectional_iterator<_ForwardIterator>::value>::type*)
{
    size_type __n = std::__1::distance(__f, __l);
    __split_buffer<value_type, allocator_type&> __buf(__n, 0, __base::__alloc());
    __buf.__construct_at_end(__f, __l);
    typedef typename __split_buffer<value_type, allocator_type&>::iterator __fwd;
    return insert(__p, move_iterator<__fwd>(__buf.begin()), move_iterator<__fwd>(__buf.end()));
}

template <class _Tp, class _Allocator>
template <class _BiIter>
typename deque<_Tp, _Allocator>::iterator
deque<_Tp, _Allocator>::insert(const_iterator __p, _BiIter __f, _BiIter __l,
                               typename enable_if<__is_cpp17_bidirectional_iterator<_BiIter>::value>::type*)
{
    size_type __n = std::__1::distance(__f, __l);
    size_type __pos = __p - __base::begin();
    size_type __to_end = __base::size() - __pos;
    allocator_type& __a = __base::__alloc();
    if (__pos < __to_end)
    {
        if (__n > __front_spare())
            __add_front_capacity(__n - __front_spare());

        iterator __old_begin = __base::begin();
        iterator __i = __old_begin;
        _BiIter __m = __f;
        if (__n > __pos)
        {
            __m = __pos < __n / 2 ? std::__1::prev(__l, __pos) : std::__1::next(__f, __n - __pos);
            for (_BiIter __j = __m; __j != __f; --__base::__start_, ++__base::size())
                __alloc_traits::construct(__a, std::__1::addressof(*--__i), *--__j);
            __n = __pos;
        }
        if (__n > 0)
        {
            iterator __obn = __old_begin + __n;
            for (iterator __j = __obn; __j != __old_begin;)
            {
                __alloc_traits::construct(__a, std::__1::addressof(*--__i), std::__1::move(*--__j));
                --__base::__start_;
                ++__base::size();
            }
            if (__n < __pos)
                __old_begin = std::__1::move(__obn, __old_begin + __pos, __old_begin);
            std::__1::copy(__m, __l, __old_begin);
        }
    }
    else
    {
        size_type __back_capacity = __back_spare();
        if (__n > __back_capacity)
            __add_back_capacity(__n - __back_capacity);

        iterator __old_end = __base::end();
        iterator __i = __old_end;
        _BiIter __m = __l;
        size_type __de = __base::size() - __pos;
        if (__n > __de)
        {
            __m = __de < __n / 2 ? std::__1::next(__f, __de) : std::__1::prev(__l, __n - __de);
            for (_BiIter __j = __m; __j != __l; ++__i, (void) ++__j, ++__base::size())
                __alloc_traits::construct(__a, std::__1::addressof(*__i), *__j);
            __n = __de;
        }
        if (__n > 0)
        {
            iterator __oen = __old_end - __n;
            for (iterator __j = __oen; __j != __old_end; ++__i, ++__j, ++__base::size())
                __alloc_traits::construct(__a, std::__1::addressof(*__i), std::__1::move(*__j));
            if (__n < __de)
                __old_end = std::__1::move_backward(__old_end - __de, __oen, __old_end);
            std::__1::copy_backward(__f, __m, __old_end);
        }
    }
    return __base::begin() + __pos;
}

template <class _Tp, class _Allocator>
template <class _InpIter>
void
deque<_Tp, _Allocator>::__append(_InpIter __f, _InpIter __l,
                                 typename enable_if<__is_cpp17_input_iterator<_InpIter>::value &&
                                                   !__is_cpp17_forward_iterator<_InpIter>::value>::type*)
{
    for (; __f != __l; ++__f)



        emplace_back(*__f);

}

template <class _Tp, class _Allocator>
template <class _ForIter>
void
deque<_Tp, _Allocator>::__append(_ForIter __f, _ForIter __l,
                                 typename enable_if<__is_cpp17_forward_iterator<_ForIter>::value>::type*)
{
    size_type __n = std::__1::distance(__f, __l);
    allocator_type& __a = __base::__alloc();
    size_type __back_capacity = __back_spare();
    if (__n > __back_capacity)
        __add_back_capacity(__n - __back_capacity);

    for (__deque_block_range __br : __deque_range(__base::end(), __base::end() + __n)) {
      _ConstructTransaction __tx(this, __br);
      for (; __tx.__pos_ != __tx.__end_; ++__tx.__pos_, (void)++__f) {
        __alloc_traits::construct(__a, std::__1::__to_address(__tx.__pos_), *__f);
      }
    }
}

template <class _Tp, class _Allocator>
void
deque<_Tp, _Allocator>::__append(size_type __n)
{
    allocator_type& __a = __base::__alloc();
    size_type __back_capacity = __back_spare();
    if (__n > __back_capacity)
        __add_back_capacity(__n - __back_capacity);

    for (__deque_block_range __br : __deque_range(__base::end(), __base::end() + __n)) {
      _ConstructTransaction __tx(this, __br);
      for (; __tx.__pos_ != __tx.__end_; ++__tx.__pos_) {
        __alloc_traits::construct(__a, std::__1::__to_address(__tx.__pos_));
      }
    }
}

template <class _Tp, class _Allocator>
void
deque<_Tp, _Allocator>::__append(size_type __n, const value_type& __v)
{
    allocator_type& __a = __base::__alloc();
    size_type __back_capacity = __back_spare();
    if (__n > __back_capacity)
        __add_back_capacity(__n - __back_capacity);

    for (__deque_block_range __br : __deque_range(__base::end(), __base::end() + __n)) {
      _ConstructTransaction __tx(this, __br);
      for (; __tx.__pos_ != __tx.__end_; ++__tx.__pos_) {
        __alloc_traits::construct(__a, std::__1::__to_address(__tx.__pos_), __v);
      }
    }

}



template <class _Tp, class _Allocator>
void
deque<_Tp, _Allocator>::__add_front_capacity()
{
    allocator_type& __a = __base::__alloc();
    if (__back_spare() >= __base::__block_size)
    {
        __base::__start_ += __base::__block_size;
        pointer __pt = __base::__map_.back();
        __base::__map_.pop_back();
        __base::__map_.push_front(__pt);
    }

    else if (__base::__map_.size() < __base::__map_.capacity())
    {


        if (__base::__map_.__front_spare() > 0)
            __base::__map_.push_front(__alloc_traits::allocate(__a, __base::__block_size));
        else
        {
            __base::__map_.push_back(__alloc_traits::allocate(__a, __base::__block_size));

            pointer __pt = __base::__map_.back();
            __base::__map_.pop_back();
            __base::__map_.push_front(__pt);
        }
        __base::__start_ = __base::__map_.size() == 1 ?
                               __base::__block_size / 2 :
                               __base::__start_ + __base::__block_size;
    }

    else
    {
        __split_buffer<pointer, typename __base::__pointer_allocator&>
            __buf(max<size_type>(2 * __base::__map_.capacity(), 1),
                  0, __base::__map_.__alloc());

        typedef __allocator_destructor<_Allocator> _Dp;
        unique_ptr<pointer, _Dp> __hold(
            __alloc_traits::allocate(__a, __base::__block_size),
                _Dp(__a, __base::__block_size));
        __buf.push_back(__hold.get());
        __hold.release();

        for (typename __base::__map_pointer __i = __base::__map_.begin();
                __i != __base::__map_.end(); ++__i)
            __buf.push_back(*__i);
        std::__1::swap(__base::__map_.__first_, __buf.__first_);
        std::__1::swap(__base::__map_.__begin_, __buf.__begin_);
        std::__1::swap(__base::__map_.__end_, __buf.__end_);
        std::__1::swap(__base::__map_.__end_cap(), __buf.__end_cap());
        __base::__start_ = __base::__map_.size() == 1 ?
                               __base::__block_size / 2 :
                               __base::__start_ + __base::__block_size;
    }
}



template <class _Tp, class _Allocator>
void
deque<_Tp, _Allocator>::__add_front_capacity(size_type __n)
{
    allocator_type& __a = __base::__alloc();
    size_type __nb = __recommend_blocks(__n + __base::__map_.empty());

    size_type __back_capacity = __back_spare() / __base::__block_size;
    __back_capacity = std::__1::min(__back_capacity, __nb);
    __nb -= __back_capacity;

    if (__nb == 0)
    {
        __base::__start_ += __base::__block_size * __back_capacity;
        for (; __back_capacity > 0; --__back_capacity)
        {
            pointer __pt = __base::__map_.back();
            __base::__map_.pop_back();
            __base::__map_.push_front(__pt);
        }
    }

    else if (__nb <= __base::__map_.capacity() - __base::__map_.size())
    {


        for (; __nb > 0; --__nb, __base::__start_ += __base::__block_size - (__base::__map_.size() == 1))
        {
            if (__base::__map_.__front_spare() == 0)
                break;
            __base::__map_.push_front(__alloc_traits::allocate(__a, __base::__block_size));
        }
        for (; __nb > 0; --__nb, ++__back_capacity)
            __base::__map_.push_back(__alloc_traits::allocate(__a, __base::__block_size));

        __base::__start_ += __back_capacity * __base::__block_size;
        for (; __back_capacity > 0; --__back_capacity)
        {
            pointer __pt = __base::__map_.back();
            __base::__map_.pop_back();
            __base::__map_.push_front(__pt);
        }
    }

    else
    {
        size_type __ds = (__nb + __back_capacity) * __base::__block_size - __base::__map_.empty();
        __split_buffer<pointer, typename __base::__pointer_allocator&>
            __buf(max<size_type>(2* __base::__map_.capacity(),
                                 __nb + __base::__map_.size()),
                  0, __base::__map_.__alloc());

        try
        {

            for (; __nb > 0; --__nb)
                __buf.push_back(__alloc_traits::allocate(__a, __base::__block_size));

        }
        catch (...)
        {
            for (typename __base::__map_pointer __i = __buf.begin();
                    __i != __buf.end(); ++__i)
                __alloc_traits::deallocate(__a, *__i, __base::__block_size);
            throw;
        }

        for (; __back_capacity > 0; --__back_capacity)
        {
            __buf.push_back(__base::__map_.back());
            __base::__map_.pop_back();
        }
        for (typename __base::__map_pointer __i = __base::__map_.begin();
                __i != __base::__map_.end(); ++__i)
            __buf.push_back(*__i);
        std::__1::swap(__base::__map_.__first_, __buf.__first_);
        std::__1::swap(__base::__map_.__begin_, __buf.__begin_);
        std::__1::swap(__base::__map_.__end_, __buf.__end_);
        std::__1::swap(__base::__map_.__end_cap(), __buf.__end_cap());
        __base::__start_ += __ds;
    }
}



template <class _Tp, class _Allocator>
void
deque<_Tp, _Allocator>::__add_back_capacity()
{
    allocator_type& __a = __base::__alloc();
    if (__front_spare() >= __base::__block_size)
    {
        __base::__start_ -= __base::__block_size;
        pointer __pt = __base::__map_.front();
        __base::__map_.pop_front();
        __base::__map_.push_back(__pt);
    }

    else if (__base::__map_.size() < __base::__map_.capacity())
    {


        if (__base::__map_.__back_spare() != 0)
            __base::__map_.push_back(__alloc_traits::allocate(__a, __base::__block_size));
        else
        {
            __base::__map_.push_front(__alloc_traits::allocate(__a, __base::__block_size));

            pointer __pt = __base::__map_.front();
            __base::__map_.pop_front();
            __base::__map_.push_back(__pt);
        }
    }

    else
    {
        __split_buffer<pointer, typename __base::__pointer_allocator&>
            __buf(max<size_type>(2* __base::__map_.capacity(), 1),
                  __base::__map_.size(),
                  __base::__map_.__alloc());

        typedef __allocator_destructor<_Allocator> _Dp;
        unique_ptr<pointer, _Dp> __hold(
            __alloc_traits::allocate(__a, __base::__block_size),
                _Dp(__a, __base::__block_size));
        __buf.push_back(__hold.get());
        __hold.release();

        for (typename __base::__map_pointer __i = __base::__map_.end();
                __i != __base::__map_.begin();)
            __buf.push_front(*--__i);
        std::__1::swap(__base::__map_.__first_, __buf.__first_);
        std::__1::swap(__base::__map_.__begin_, __buf.__begin_);
        std::__1::swap(__base::__map_.__end_, __buf.__end_);
        std::__1::swap(__base::__map_.__end_cap(), __buf.__end_cap());
    }
}



template <class _Tp, class _Allocator>
void
deque<_Tp, _Allocator>::__add_back_capacity(size_type __n)
{
    allocator_type& __a = __base::__alloc();
    size_type __nb = __recommend_blocks(__n + __base::__map_.empty());

    size_type __front_capacity = __front_spare() / __base::__block_size;
    __front_capacity = std::__1::min(__front_capacity, __nb);
    __nb -= __front_capacity;

    if (__nb == 0)
    {
        __base::__start_ -= __base::__block_size * __front_capacity;
        for (; __front_capacity > 0; --__front_capacity)
        {
            pointer __pt = __base::__map_.front();
            __base::__map_.pop_front();
            __base::__map_.push_back(__pt);
        }
    }

    else if (__nb <= __base::__map_.capacity() - __base::__map_.size())
    {


        for (; __nb > 0; --__nb)
        {
            if (__base::__map_.__back_spare() == 0)
                break;
            __base::__map_.push_back(__alloc_traits::allocate(__a, __base::__block_size));
        }
        for (; __nb > 0; --__nb, ++__front_capacity, __base::__start_ +=
                                 __base::__block_size - (__base::__map_.size() == 1))
            __base::__map_.push_front(__alloc_traits::allocate(__a, __base::__block_size));

        __base::__start_ -= __base::__block_size * __front_capacity;
        for (; __front_capacity > 0; --__front_capacity)
        {
            pointer __pt = __base::__map_.front();
            __base::__map_.pop_front();
            __base::__map_.push_back(__pt);
        }
    }

    else
    {
        size_type __ds = __front_capacity * __base::__block_size;
        __split_buffer<pointer, typename __base::__pointer_allocator&>
            __buf(max<size_type>(2* __base::__map_.capacity(),
                                 __nb + __base::__map_.size()),
                  __base::__map_.size() - __front_capacity,
                  __base::__map_.__alloc());

        try
        {

            for (; __nb > 0; --__nb)
                __buf.push_back(__alloc_traits::allocate(__a, __base::__block_size));

        }
        catch (...)
        {
            for (typename __base::__map_pointer __i = __buf.begin();
                    __i != __buf.end(); ++__i)
                __alloc_traits::deallocate(__a, *__i, __base::__block_size);
            throw;
        }

        for (; __front_capacity > 0; --__front_capacity)
        {
            __buf.push_back(__base::__map_.front());
            __base::__map_.pop_front();
        }
        for (typename __base::__map_pointer __i = __base::__map_.end();
                __i != __base::__map_.begin();)
            __buf.push_front(*--__i);
        std::__1::swap(__base::__map_.__first_, __buf.__first_);
        std::__1::swap(__base::__map_.__begin_, __buf.__begin_);
        std::__1::swap(__base::__map_.__end_, __buf.__end_);
        std::__1::swap(__base::__map_.__end_cap(), __buf.__end_cap());
        __base::__start_ -= __ds;
    }
}

template <class _Tp, class _Allocator>
void
deque<_Tp, _Allocator>::pop_front()
{
    allocator_type& __a = __base::__alloc();
    __alloc_traits::destroy(__a, std::__1::__to_address(*(__base::__map_.begin() +
                                                    __base::__start_ / __base::__block_size) +
                                                    __base::__start_ % __base::__block_size));
    --__base::size();
    ++__base::__start_;
    __maybe_remove_front_spare();
}

template <class _Tp, class _Allocator>
void
deque<_Tp, _Allocator>::pop_back()
{
    ((void)0);
    allocator_type& __a = __base::__alloc();
    size_type __p = __base::size() + __base::__start_ - 1;
    __alloc_traits::destroy(__a, std::__1::__to_address(*(__base::__map_.begin() +
                                                    __p / __base::__block_size) +
                                                    __p % __base::__block_size));
    --__base::size();
    __maybe_remove_back_spare();
}



template <class _Tp, class _Allocator>
typename deque<_Tp, _Allocator>::iterator
deque<_Tp, _Allocator>::__move_and_check(iterator __f, iterator __l, iterator __r,
                                         const_pointer& __vt)
{



    difference_type __n = __l - __f;
    while (__n > 0)
    {
        pointer __fb = __f.__ptr_;
        pointer __fe = *__f.__m_iter_ + __base::__block_size;
        difference_type __bs = __fe - __fb;
        if (__bs > __n)
        {
            __bs = __n;
            __fe = __fb + __bs;
        }
        if (__fb <= __vt && __vt < __fe)
            __vt = (const_iterator(static_cast<__map_const_pointer>(__f.__m_iter_), __vt) -= __f - __r).__ptr_;
        __r = std::__1::move(__fb, __fe, __r);
        __n -= __bs;
        __f += __bs;
    }
    return __r;
}



template <class _Tp, class _Allocator>
typename deque<_Tp, _Allocator>::iterator
deque<_Tp, _Allocator>::__move_backward_and_check(iterator __f, iterator __l, iterator __r,
                                                  const_pointer& __vt)
{



    difference_type __n = __l - __f;
    while (__n > 0)
    {
        --__l;
        pointer __lb = *__l.__m_iter_;
        pointer __le = __l.__ptr_ + 1;
        difference_type __bs = __le - __lb;
        if (__bs > __n)
        {
            __bs = __n;
            __lb = __le - __bs;
        }
        if (__lb <= __vt && __vt < __le)
            __vt = (const_iterator(static_cast<__map_const_pointer>(__l.__m_iter_), __vt) += __r - __l - 1).__ptr_;
        __r = std::__1::move_backward(__lb, __le, __r);
        __n -= __bs;
        __l -= __bs - 1;
    }
    return __r;
}



template <class _Tp, class _Allocator>
void
deque<_Tp, _Allocator>::__move_construct_and_check(iterator __f, iterator __l,
                                                   iterator __r, const_pointer& __vt)
{
    allocator_type& __a = __base::__alloc();



    difference_type __n = __l - __f;
    while (__n > 0)
    {
        pointer __fb = __f.__ptr_;
        pointer __fe = *__f.__m_iter_ + __base::__block_size;
        difference_type __bs = __fe - __fb;
        if (__bs > __n)
        {
            __bs = __n;
            __fe = __fb + __bs;
        }
        if (__fb <= __vt && __vt < __fe)
            __vt = (const_iterator(static_cast<__map_const_pointer>(__f.__m_iter_), __vt) += __r - __f).__ptr_;
        for (; __fb != __fe; ++__fb, ++__r, ++__base::size())
            __alloc_traits::construct(__a, std::__1::addressof(*__r), std::__1::move(*__fb));
        __n -= __bs;
        __f += __bs;
    }
}



template <class _Tp, class _Allocator>
void
deque<_Tp, _Allocator>::__move_construct_backward_and_check(iterator __f, iterator __l,
                                                            iterator __r, const_pointer& __vt)
{
    allocator_type& __a = __base::__alloc();







    difference_type __n = __l - __f;
    while (__n > 0)
    {
        --__l;
        pointer __lb = *__l.__m_iter_;
        pointer __le = __l.__ptr_ + 1;
        difference_type __bs = __le - __lb;
        if (__bs > __n)
        {
            __bs = __n;
            __lb = __le - __bs;
        }
        if (__lb <= __vt && __vt < __le)
            __vt = (const_iterator(static_cast<__map_const_pointer>(__l.__m_iter_), __vt) -= __l - __r + 1).__ptr_;
        while (__le != __lb)
        {
            __alloc_traits::construct(__a, std::__1::addressof(*--__r), std::__1::move(*--__le));
            --__base::__start_;
            ++__base::size();
        }
        __n -= __bs;
        __l -= __bs - 1;
    }
}

template <class _Tp, class _Allocator>
typename deque<_Tp, _Allocator>::iterator
deque<_Tp, _Allocator>::erase(const_iterator __f)
{
    iterator __b = __base::begin();
    difference_type __pos = __f - __b;
    iterator __p = __b + __pos;
    allocator_type& __a = __base::__alloc();
    if (static_cast<size_t>(__pos) <= (__base::size() - 1) / 2)
    {
        std::__1::move_backward(__b, __p, std::__1::next(__p));
        __alloc_traits::destroy(__a, std::__1::addressof(*__b));
        --__base::size();
        ++__base::__start_;
        __maybe_remove_front_spare();
    }
    else
    {
        iterator __i = std::__1::move(std::__1::next(__p), __base::end(), __p);
        __alloc_traits::destroy(__a, std::__1::addressof(*__i));
        --__base::size();
        __maybe_remove_back_spare();
    }
    return __base::begin() + __pos;
}

template <class _Tp, class _Allocator>
typename deque<_Tp, _Allocator>::iterator
deque<_Tp, _Allocator>::erase(const_iterator __f, const_iterator __l)
{
    difference_type __n = __l - __f;
    iterator __b = __base::begin();
    difference_type __pos = __f - __b;
    iterator __p = __b + __pos;
    if (__n > 0)
    {
        allocator_type& __a = __base::__alloc();
        if (static_cast<size_t>(__pos) <= (__base::size() - __n) / 2)
        {
            iterator __i = std::__1::move_backward(__b, __p, __p + __n);
            for (; __b != __i; ++__b)
                __alloc_traits::destroy(__a, std::__1::addressof(*__b));
            __base::size() -= __n;
            __base::__start_ += __n;
            while (__maybe_remove_front_spare()) {
            }
        }
        else
        {
            iterator __i = std::__1::move(__p + __n, __base::end(), __p);
            for (iterator __e = __base::end(); __i != __e; ++__i)
                __alloc_traits::destroy(__a, std::__1::addressof(*__i));
            __base::size() -= __n;
            while (__maybe_remove_back_spare()) {
            }
        }
    }
    return __base::begin() + __pos;
}

template <class _Tp, class _Allocator>
void
deque<_Tp, _Allocator>::__erase_to_end(const_iterator __f)
{
    iterator __e = __base::end();
    difference_type __n = __e - __f;
    if (__n > 0)
    {
        allocator_type& __a = __base::__alloc();
        iterator __b = __base::begin();
        difference_type __pos = __f - __b;
        for (iterator __p = __b + __pos; __p != __e; ++__p)
            __alloc_traits::destroy(__a, std::__1::addressof(*__p));
        __base::size() -= __n;
        while (__maybe_remove_back_spare()) {
        }
    }
}

template <class _Tp, class _Allocator>
inline
void
deque<_Tp, _Allocator>::swap(deque& __c)

        noexcept




{
    __base::swap(__c);
}

template <class _Tp, class _Allocator>
inline
void
deque<_Tp, _Allocator>::clear() noexcept
{
    __base::clear();
}

template <class _Tp, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator==(const deque<_Tp, _Allocator>& __x, const deque<_Tp, _Allocator>& __y)
{
    const typename deque<_Tp, _Allocator>::size_type __sz = __x.size();
    return __sz == __y.size() && std::__1::equal(__x.begin(), __x.end(), __y.begin());
}

template <class _Tp, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator!=(const deque<_Tp, _Allocator>& __x, const deque<_Tp, _Allocator>& __y)
{
    return !(__x == __y);
}

template <class _Tp, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator< (const deque<_Tp, _Allocator>& __x, const deque<_Tp, _Allocator>& __y)
{
    return std::__1::lexicographical_compare(__x.begin(), __x.end(), __y.begin(), __y.end());
}

template <class _Tp, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator> (const deque<_Tp, _Allocator>& __x, const deque<_Tp, _Allocator>& __y)
{
    return __y < __x;
}

template <class _Tp, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator>=(const deque<_Tp, _Allocator>& __x, const deque<_Tp, _Allocator>& __y)
{
    return !(__x < __y);
}

template <class _Tp, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator<=(const deque<_Tp, _Allocator>& __x, const deque<_Tp, _Allocator>& __y)
{
    return !(__y < __x);
}

template <class _Tp, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void
swap(deque<_Tp, _Allocator>& __x, deque<_Tp, _Allocator>& __y)
    noexcept(noexcept(__x.swap(__y)))
{
    __x.swap(__y);
}
# 3047 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/deque" 3
} }
# 128 "/usr/local/include/bits/stdc++.h" 2





# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/fstream" 1 3
# 192 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/fstream" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/filesystem" 1 3
# 242 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/filesystem" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/memory" 1 3
# 974 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/memory" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 1 3
# 20 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/assert.h" 1 3 4
# 44 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/assert.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/stdlib.h" 1 3 4
# 45 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/assert.h" 2 3 4
# 81 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/assert.h" 3 4
extern "C" {
void __assert_rtn(const char *, const char *, int, const char *) __attribute__((__noreturn__)) __attribute__((__cold__)) __attribute__((__disable_tail_calls__));



}
# 21 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 2 3
# 24 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 3
# 975 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/memory" 2 3
# 243 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/filesystem" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/stack" 1 3
# 97 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/stack" 3


namespace std { inline namespace __1 {

template <class _Tp, class _Container = deque<_Tp> > class __attribute__ ((__type_visibility__("default"))) stack;

template <class _Tp, class _Container>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator==(const stack<_Tp, _Container>& __x, const stack<_Tp, _Container>& __y);

template <class _Tp, class _Container>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator< (const stack<_Tp, _Container>& __x, const stack<_Tp, _Container>& __y);

template <class _Tp, class _Container >
class __attribute__ ((__type_visibility__("default"))) stack
{
public:
    typedef _Container container_type;
    typedef typename container_type::value_type value_type;
    typedef typename container_type::reference reference;
    typedef typename container_type::const_reference const_reference;
    typedef typename container_type::size_type size_type;
    static_assert((is_same<_Tp, value_type>::value), "" );

protected:
    container_type c;

public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    stack()
        noexcept(is_nothrow_default_constructible<container_type>::value)
        : c() {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    stack(const stack& __q) : c(__q.c) {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    stack& operator=(const stack& __q) {c = __q.c; return *this;}



    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    stack(stack&& __q)
        noexcept(is_nothrow_move_constructible<container_type>::value)
        : c(std::__1::move(__q.c)) {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    stack& operator=(stack&& __q)
        noexcept(is_nothrow_move_assignable<container_type>::value)
        {c = std::__1::move(__q.c); return *this;}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit stack(container_type&& __c) : c(std::__1::move(__c)) {}


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit stack(const container_type& __c) : c(__c) {}

    template <class _Alloc>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        explicit stack(const _Alloc& __a,
                       _EnableIf<uses_allocator<container_type, _Alloc>::value>* = 0)
            : c(__a) {}
    template <class _Alloc>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        stack(const container_type& __c, const _Alloc& __a,
              _EnableIf<uses_allocator<container_type, _Alloc>::value>* = 0)
            : c(__c, __a) {}
    template <class _Alloc>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        stack(const stack& __s, const _Alloc& __a,
              _EnableIf<uses_allocator<container_type, _Alloc>::value>* = 0)
            : c(__s.c, __a) {}

    template <class _Alloc>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        stack(container_type&& __c, const _Alloc& __a,
              _EnableIf<uses_allocator<container_type, _Alloc>::value>* = 0)
            : c(std::__1::move(__c), __a) {}
    template <class _Alloc>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        stack(stack&& __s, const _Alloc& __a,
              _EnableIf<uses_allocator<container_type, _Alloc>::value>* = 0)
            : c(std::__1::move(__s.c), __a) {}


                                  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    bool empty() const {return c.empty();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_type size() const {return c.size();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    reference top() {return c.back();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_reference top() const {return c.back();}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void push(const value_type& __v) {c.push_back(__v);}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void push(value_type&& __v) {c.push_back(std::__1::move(__v));}

    template <class... _Args>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))

        decltype(auto) emplace(_Args&&... __args)
        { return c.emplace_back(std::__1::forward<_Args>(__args)...);}






    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void pop() {c.pop_back();}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void swap(stack& __s)
        noexcept(__is_nothrow_swappable<container_type>::value)
    {
        using std::__1::swap;
        swap(c, __s.c);
    }

    template <class T1, class _C1>
    friend
    bool
    operator==(const stack<T1, _C1>& __x, const stack<T1, _C1>& __y);

    template <class T1, class _C1>
    friend
    bool
    operator< (const stack<T1, _C1>& __x, const stack<T1, _C1>& __y);
};


template<class _Container,
         class = _EnableIf<!__is_allocator<_Container>::value>
>
stack(_Container)
    -> stack<typename _Container::value_type, _Container>;

template<class _Container,
         class _Alloc,
         class = _EnableIf<!__is_allocator<_Container>::value>,
         class = _EnableIf<uses_allocator<_Container, _Alloc>::value>
         >
stack(_Container, _Alloc)
    -> stack<typename _Container::value_type, _Container>;


template <class _Tp, class _Container>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator==(const stack<_Tp, _Container>& __x, const stack<_Tp, _Container>& __y)
{
    return __x.c == __y.c;
}

template <class _Tp, class _Container>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator< (const stack<_Tp, _Container>& __x, const stack<_Tp, _Container>& __y)
{
    return __x.c < __y.c;
}

template <class _Tp, class _Container>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator!=(const stack<_Tp, _Container>& __x, const stack<_Tp, _Container>& __y)
{
    return !(__x == __y);
}

template <class _Tp, class _Container>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator> (const stack<_Tp, _Container>& __x, const stack<_Tp, _Container>& __y)
{
    return __y < __x;
}

template <class _Tp, class _Container>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator>=(const stack<_Tp, _Container>& __x, const stack<_Tp, _Container>& __y)
{
    return !(__x < __y);
}

template <class _Tp, class _Container>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator<=(const stack<_Tp, _Container>& __x, const stack<_Tp, _Container>& __y)
{
    return !(__y < __x);
}

template <class _Tp, class _Container>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
_EnableIf<__is_swappable<_Container>::value, void>
swap(stack<_Tp, _Container>& __x, stack<_Tp, _Container>& __y)
    noexcept(noexcept(__x.swap(__y)))
{
    __x.swap(__y);
}

template <class _Tp, class _Container, class _Alloc>
struct __attribute__ ((__type_visibility__("default"))) uses_allocator<stack<_Tp, _Container>, _Alloc>
    : public uses_allocator<_Container, _Alloc>
{
};

} }
# 244 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/filesystem" 2 3








# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/iomanip" 1 3
# 52 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/iomanip" 3


namespace std { inline namespace __1 {



class __iom_t1
{
    ios_base::fmtflags __mask_;
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit __iom_t1(ios_base::fmtflags __m) : __mask_(__m) {}

    template <class _CharT, class _Traits>
    friend
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __is, const __iom_t1& __x)
    {
        __is.unsetf(__x.__mask_);
        return __is;
    }

    template <class _CharT, class _Traits>
    friend
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __os, const __iom_t1& __x)
    {
        __os.unsetf(__x.__mask_);
        return __os;
    }
};

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
__iom_t1
resetiosflags(ios_base::fmtflags __mask)
{
    return __iom_t1(__mask);
}



class __iom_t2
{
    ios_base::fmtflags __mask_;
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit __iom_t2(ios_base::fmtflags __m) : __mask_(__m) {}

    template <class _CharT, class _Traits>
    friend
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __is, const __iom_t2& __x)
    {
        __is.setf(__x.__mask_);
        return __is;
    }

    template <class _CharT, class _Traits>
    friend
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __os, const __iom_t2& __x)
    {
        __os.setf(__x.__mask_);
        return __os;
    }
};

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
__iom_t2
setiosflags(ios_base::fmtflags __mask)
{
    return __iom_t2(__mask);
}



class __iom_t3
{
    int __base_;
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit __iom_t3(int __b) : __base_(__b) {}

    template <class _CharT, class _Traits>
    friend
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __is, const __iom_t3& __x)
    {
        __is.setf(__x.__base_ == 8 ? ios_base::oct :
                  __x.__base_ == 10 ? ios_base::dec :
                  __x.__base_ == 16 ? ios_base::hex :
                  ios_base::fmtflags(0), ios_base::basefield);
        return __is;
    }

    template <class _CharT, class _Traits>
    friend
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __os, const __iom_t3& __x)
    {
        __os.setf(__x.__base_ == 8 ? ios_base::oct :
                  __x.__base_ == 10 ? ios_base::dec :
                  __x.__base_ == 16 ? ios_base::hex :
                  ios_base::fmtflags(0), ios_base::basefield);
        return __os;
    }
};

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
__iom_t3
setbase(int __base)
{
    return __iom_t3(__base);
}



template<class _CharT>
class __iom_t4
{
    _CharT __fill_;
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit __iom_t4(_CharT __c) : __fill_(__c) {}

    template <class _Traits>
    friend
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __os, const __iom_t4& __x)
    {
        __os.fill(__x.__fill_);
        return __os;
    }
};

template<class _CharT>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
__iom_t4<_CharT>
setfill(_CharT __c)
{
    return __iom_t4<_CharT>(__c);
}



class __iom_t5
{
    int __n_;
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit __iom_t5(int __n) : __n_(__n) {}

    template <class _CharT, class _Traits>
    friend
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __is, const __iom_t5& __x)
    {
        __is.precision(__x.__n_);
        return __is;
    }

    template <class _CharT, class _Traits>
    friend
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __os, const __iom_t5& __x)
    {
        __os.precision(__x.__n_);
        return __os;
    }
};

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
__iom_t5
setprecision(int __n)
{
    return __iom_t5(__n);
}



class __iom_t6
{
    int __n_;
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit __iom_t6(int __n) : __n_(__n) {}

    template <class _CharT, class _Traits>
    friend
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __is, const __iom_t6& __x)
    {
        __is.width(__x.__n_);
        return __is;
    }

    template <class _CharT, class _Traits>
    friend
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __os, const __iom_t6& __x)
    {
        __os.width(__x.__n_);
        return __os;
    }
};

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
__iom_t6
setw(int __n)
{
    return __iom_t6(__n);
}



template <class _MoneyT> class __iom_t7;

template <class _CharT, class _Traits, class _MoneyT>
basic_istream<_CharT, _Traits>&
operator>>(basic_istream<_CharT, _Traits>& __is, const __iom_t7<_MoneyT>& __x);

template <class _MoneyT>
class __iom_t7
{
    _MoneyT& __mon_;
    bool __intl_;
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __iom_t7(_MoneyT& __mon, bool __intl)
        : __mon_(__mon), __intl_(__intl) {}

    template <class _CharT, class _Traits, class _Mp>
    friend
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __is, const __iom_t7<_Mp>& __x);
};

template <class _CharT, class _Traits, class _MoneyT>
basic_istream<_CharT, _Traits>&
operator>>(basic_istream<_CharT, _Traits>& __is, const __iom_t7<_MoneyT>& __x)
{

    try
    {

        typename basic_istream<_CharT, _Traits>::sentry __s(__is);
        if (__s)
        {
            typedef istreambuf_iterator<_CharT, _Traits> _Ip;
            typedef money_get<_CharT, _Ip> _Fp;
            ios_base::iostate __err = ios_base::goodbit;
            const _Fp& __mf = use_facet<_Fp>(__is.getloc());
            __mf.get(_Ip(__is), _Ip(), __x.__intl_, __is, __err, __x.__mon_);
            __is.setstate(__err);
        }

    }
    catch (...)
    {
        __is.__set_badbit_and_consider_rethrow();
    }

    return __is;
}

template <class _MoneyT>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
__iom_t7<_MoneyT>
get_money(_MoneyT& __mon, bool __intl = false)
{
    return __iom_t7<_MoneyT>(__mon, __intl);
}



template <class _MoneyT> class __iom_t8;

template <class _CharT, class _Traits, class _MoneyT>
basic_ostream<_CharT, _Traits>&
operator<<(basic_ostream<_CharT, _Traits>& __os, const __iom_t8<_MoneyT>& __x);

template <class _MoneyT>
class __iom_t8
{
    const _MoneyT& __mon_;
    bool __intl_;
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __iom_t8(const _MoneyT& __mon, bool __intl)
        : __mon_(__mon), __intl_(__intl) {}

    template <class _CharT, class _Traits, class _Mp>
    friend
    basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __os, const __iom_t8<_Mp>& __x);
};

template <class _CharT, class _Traits, class _MoneyT>
basic_ostream<_CharT, _Traits>&
operator<<(basic_ostream<_CharT, _Traits>& __os, const __iom_t8<_MoneyT>& __x)
{

    try
    {

        typename basic_ostream<_CharT, _Traits>::sentry __s(__os);
        if (__s)
        {
            typedef ostreambuf_iterator<_CharT, _Traits> _Op;
            typedef money_put<_CharT, _Op> _Fp;
            const _Fp& __mf = use_facet<_Fp>(__os.getloc());
            if (__mf.put(_Op(__os), __x.__intl_, __os, __os.fill(), __x.__mon_).failed())
                __os.setstate(ios_base::badbit);
        }

    }
    catch (...)
    {
        __os.__set_badbit_and_consider_rethrow();
    }

    return __os;
}

template <class _MoneyT>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
__iom_t8<_MoneyT>
put_money(const _MoneyT& __mon, bool __intl = false)
{
    return __iom_t8<_MoneyT>(__mon, __intl);
}



template <class _CharT> class __iom_t9;

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
operator>>(basic_istream<_CharT, _Traits>& __is, const __iom_t9<_CharT>& __x);

template <class _CharT>
class __iom_t9
{
    tm* __tm_;
    const _CharT* __fmt_;
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __iom_t9(tm* __tm, const _CharT* __fmt)
        : __tm_(__tm), __fmt_(__fmt) {}

    template <class _Cp, class _Traits>
    friend
    basic_istream<_Cp, _Traits>&
    operator>>(basic_istream<_Cp, _Traits>& __is, const __iom_t9<_Cp>& __x);
};

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
operator>>(basic_istream<_CharT, _Traits>& __is, const __iom_t9<_CharT>& __x)
{

    try
    {

        typename basic_istream<_CharT, _Traits>::sentry __s(__is);
        if (__s)
        {
            typedef istreambuf_iterator<_CharT, _Traits> _Ip;
            typedef time_get<_CharT, _Ip> _Fp;
            ios_base::iostate __err = ios_base::goodbit;
            const _Fp& __tf = use_facet<_Fp>(__is.getloc());
            __tf.get(_Ip(__is), _Ip(), __is, __err, __x.__tm_,
                     __x.__fmt_, __x.__fmt_ + _Traits::length(__x.__fmt_));
            __is.setstate(__err);
        }

    }
    catch (...)
    {
        __is.__set_badbit_and_consider_rethrow();
    }

    return __is;
}

template <class _CharT>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
__iom_t9<_CharT>
get_time(tm* __tm, const _CharT* __fmt)
{
    return __iom_t9<_CharT>(__tm, __fmt);
}



template <class _CharT> class __iom_t10;

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>&
operator<<(basic_ostream<_CharT, _Traits>& __os, const __iom_t10<_CharT>& __x);

template <class _CharT>
class __iom_t10
{
    const tm* __tm_;
    const _CharT* __fmt_;
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __iom_t10(const tm* __tm, const _CharT* __fmt)
        : __tm_(__tm), __fmt_(__fmt) {}

    template <class _Cp, class _Traits>
    friend
    basic_ostream<_Cp, _Traits>&
    operator<<(basic_ostream<_Cp, _Traits>& __os, const __iom_t10<_Cp>& __x);
};

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>&
operator<<(basic_ostream<_CharT, _Traits>& __os, const __iom_t10<_CharT>& __x)
{

    try
    {

        typename basic_ostream<_CharT, _Traits>::sentry __s(__os);
        if (__s)
        {
            typedef ostreambuf_iterator<_CharT, _Traits> _Op;
            typedef time_put<_CharT, _Op> _Fp;
            const _Fp& __tf = use_facet<_Fp>(__os.getloc());
            if (__tf.put(_Op(__os), __os, __os.fill(), __x.__tm_,
                         __x.__fmt_, __x.__fmt_ + _Traits::length(__x.__fmt_)).failed())
                __os.setstate(ios_base::badbit);
        }

    }
    catch (...)
    {
        __os.__set_badbit_and_consider_rethrow();
    }

    return __os;
}

template <class _CharT>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
__iom_t10<_CharT>
put_time(const tm* __tm, const _CharT* __fmt)
{
    return __iom_t10<_CharT>(__tm, __fmt);
}

template <class _CharT, class _Traits, class _ForwardIterator>
basic_ostream<_CharT, _Traits> &
__quoted_output ( basic_ostream<_CharT, _Traits> &__os,
        _ForwardIterator __first, _ForwardIterator __last, _CharT __delim, _CharT __escape )
{
    basic_string<_CharT, _Traits> __str;
    __str.push_back(__delim);
    for ( ; __first != __last; ++ __first )
    {
        if (_Traits::eq (*__first, __escape) || _Traits::eq (*__first, __delim))
            __str.push_back(__escape);
        __str.push_back(*__first);
    }
    __str.push_back(__delim);
    return std::__1::__put_character_sequence(__os, __str.data(), __str.size());
}

template <class _CharT, class _Traits, class _String>
basic_istream<_CharT, _Traits> &
__quoted_input ( basic_istream<_CharT, _Traits> &__is, _String & __string, _CharT __delim, _CharT __escape )
{
    __string.clear ();
    _CharT __c;
    __is >> __c;
    if ( __is.fail ())
        return __is;

    if (!_Traits::eq (__c, __delim))
    {
        __is.unget ();
        __is >> __string;
        return __is;
    }

    __save_flags<_CharT, _Traits> sf(__is);
    noskipws (__is);
    while (true)
        {
        __is >> __c;
        if ( __is.fail ())
            break;
        if (_Traits::eq (__c, __escape))
        {
            __is >> __c;
            if ( __is.fail ())
                break;
        }
        else if (_Traits::eq (__c, __delim))
            break;
        __string.push_back ( __c );
        }
    return __is;
}


template <class _CharT, class _Traits, class _Iter>
basic_ostream<_CharT, _Traits>& operator<<(
         basic_ostream<_CharT, _Traits>& __os,
         const __quoted_output_proxy<_CharT, _Iter, _Traits> & __proxy)
{
    return __quoted_output (__os, __proxy.__first, __proxy.__last, __proxy.__delim, __proxy.__escape);
}

template <class _CharT, class _Traits, class _Allocator>
struct __quoted_proxy
{
    basic_string<_CharT, _Traits, _Allocator> &__string;
    _CharT __delim;
    _CharT __escape;

    __quoted_proxy(basic_string<_CharT, _Traits, _Allocator> &__s, _CharT __d, _CharT __e)
    : __string(__s), __delim(__d), __escape(__e) {}
};

template <class _CharT, class _Traits, class _Allocator>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
basic_ostream<_CharT, _Traits>& operator<<(
        basic_ostream<_CharT, _Traits>& __os,
        const __quoted_proxy<_CharT, _Traits, _Allocator> & __proxy)
{
    return __quoted_output (__os, __proxy.__string.cbegin (), __proxy.__string.cend (), __proxy.__delim, __proxy.__escape);
}


template <class _CharT, class _Traits, class _Allocator>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
basic_istream<_CharT, _Traits>& operator>>(
        basic_istream<_CharT, _Traits>& __is,
        const __quoted_proxy<_CharT, _Traits, _Allocator> & __proxy)
{
    return __quoted_input ( __is, __proxy.__string, __proxy.__delim, __proxy.__escape );
}


template <class _CharT>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
__quoted_output_proxy<_CharT, const _CharT *>
quoted ( const _CharT *__s, _CharT __delim = _CharT('"'), _CharT __escape =_CharT('\\'))
{
    const _CharT *__end = __s;
    while ( *__end ) ++__end;
    return __quoted_output_proxy<_CharT, const _CharT *> ( __s, __end, __delim, __escape );
}


template <class _CharT, class _Traits, class _Allocator>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
__quoted_output_proxy<_CharT, typename basic_string <_CharT, _Traits, _Allocator>::const_iterator>
__quoted ( const basic_string <_CharT, _Traits, _Allocator> &__s, _CharT __delim = _CharT('"'), _CharT __escape=_CharT('\\'))
{
    return __quoted_output_proxy<_CharT,
            typename basic_string <_CharT, _Traits, _Allocator>::const_iterator>
                    ( __s.cbegin(), __s.cend (), __delim, __escape );
}

template <class _CharT, class _Traits, class _Allocator>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
__quoted_proxy<_CharT, _Traits, _Allocator>
__quoted ( basic_string <_CharT, _Traits, _Allocator> &__s, _CharT __delim = _CharT('"'), _CharT __escape=_CharT('\\'))
{
    return __quoted_proxy<_CharT, _Traits, _Allocator>( __s, __delim, __escape );
}




template <class _CharT, class _Traits, class _Allocator>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
__quoted_output_proxy<_CharT, typename basic_string <_CharT, _Traits, _Allocator>::const_iterator>
quoted ( const basic_string <_CharT, _Traits, _Allocator> &__s, _CharT __delim = _CharT('"'), _CharT __escape=_CharT('\\'))
{
    return __quoted(__s, __delim, __escape);
}

template <class _CharT, class _Traits, class _Allocator>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
__quoted_proxy<_CharT, _Traits, _Allocator>
quoted ( basic_string <_CharT, _Traits, _Allocator> &__s, _CharT __delim = _CharT('"'), _CharT __escape=_CharT('\\'))
{
    return __quoted(__s, __delim, __escape);
}

template <class _CharT, class _Traits>
__quoted_output_proxy<_CharT, const _CharT *, _Traits>
quoted (basic_string_view <_CharT, _Traits> __sv,
             _CharT __delim = _CharT('"'), _CharT __escape=_CharT('\\'))
{
    return __quoted_output_proxy<_CharT, const _CharT *, _Traits>
         ( __sv.data(), __sv.data() + __sv.size(), __delim, __escape );
}


} }
# 253 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/filesystem" 2 3
# 261 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/filesystem" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 265 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/filesystem" 2 3



namespace std { inline namespace __1 { inline namespace __fs { namespace filesystem {

#pragma clang attribute push(__attribute__((availability(macosx,strict,introduced=10.15))), apply_to=any(function,record))
# 270 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/filesystem" 3
#pragma clang attribute push(__attribute__((availability(ios,strict,introduced=13.0))), apply_to=any(function,record))
# 270 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/filesystem" 3
#pragma clang attribute push(__attribute__((availability(tvos,strict,introduced=13.0))), apply_to=any(function,record))
# 270 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/filesystem" 3
#pragma clang attribute push(__attribute__((availability(watchos,strict,introduced=6.0))), apply_to=any(function,record))

typedef chrono::time_point<_FilesystemClock> file_time_type;

struct __attribute__ ((__visibility__("default"))) space_info {
  uintmax_t capacity;
  uintmax_t free;
  uintmax_t available;
};



enum class __attribute__ ((__type_visibility__("default"))) file_type : signed char {
  none = 0,
  not_found = -1,
  regular = 1,
  directory = 2,
  symlink = 3,
  block = 4,
  character = 5,
  fifo = 6,
  socket = 7,
  unknown = 8
};





enum class __attribute__ ((__type_visibility__("default"))) perms : unsigned {
  none = 0,

  owner_read = 0400,
  owner_write = 0200,
  owner_exec = 0100,
  owner_all = 0700,

  group_read = 040,
  group_write = 020,
  group_exec = 010,
  group_all = 070,

  others_read = 04,
  others_write = 02,
  others_exec = 01,
  others_all = 07,

  all = 0777,

  set_uid = 04000,
  set_gid = 02000,
  sticky_bit = 01000,
  mask = 07777,
  unknown = 0xFFFF,
};

__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
inline constexpr perms operator&(perms _LHS, perms _RHS) {
  return static_cast<perms>(static_cast<unsigned>(_LHS) &
                            static_cast<unsigned>(_RHS));
}

__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
inline constexpr perms operator|(perms _LHS, perms _RHS) {
  return static_cast<perms>(static_cast<unsigned>(_LHS) |
                            static_cast<unsigned>(_RHS));
}

__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
inline constexpr perms operator^(perms _LHS, perms _RHS) {
  return static_cast<perms>(static_cast<unsigned>(_LHS) ^
                            static_cast<unsigned>(_RHS));
}

__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
inline constexpr perms operator~(perms _LHS) {
  return static_cast<perms>(~static_cast<unsigned>(_LHS));
}

__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
inline perms& operator&=(perms& _LHS, perms _RHS) { return _LHS = _LHS & _RHS; }

__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
inline perms& operator|=(perms& _LHS, perms _RHS) { return _LHS = _LHS | _RHS; }

__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
inline perms& operator^=(perms& _LHS, perms _RHS) { return _LHS = _LHS ^ _RHS; }

enum class __attribute__ ((__type_visibility__("default"))) perm_options : unsigned char {
  replace = 1,
  add = 2,
  remove = 4,
  nofollow = 8
};

__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
inline constexpr perm_options operator&(perm_options _LHS, perm_options _RHS) {
  return static_cast<perm_options>(static_cast<unsigned>(_LHS) &
                                   static_cast<unsigned>(_RHS));
}

__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
inline constexpr perm_options operator|(perm_options _LHS, perm_options _RHS) {
  return static_cast<perm_options>(static_cast<unsigned>(_LHS) |
                                   static_cast<unsigned>(_RHS));
}

__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
inline constexpr perm_options operator^(perm_options _LHS, perm_options _RHS) {
  return static_cast<perm_options>(static_cast<unsigned>(_LHS) ^
                                   static_cast<unsigned>(_RHS));
}

__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
inline constexpr perm_options operator~(perm_options _LHS) {
  return static_cast<perm_options>(~static_cast<unsigned>(_LHS));
}

__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
inline perm_options& operator&=(perm_options& _LHS, perm_options _RHS) {
  return _LHS = _LHS & _RHS;
}

__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
inline perm_options& operator|=(perm_options& _LHS, perm_options _RHS) {
  return _LHS = _LHS | _RHS;
}

__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
inline perm_options& operator^=(perm_options& _LHS, perm_options _RHS) {
  return _LHS = _LHS ^ _RHS;
}

enum class __attribute__ ((__type_visibility__("default"))) copy_options : unsigned short {
  none = 0,
  skip_existing = 1,
  overwrite_existing = 2,
  update_existing = 4,
  recursive = 8,
  copy_symlinks = 16,
  skip_symlinks = 32,
  directories_only = 64,
  create_symlinks = 128,
  create_hard_links = 256,
  __in_recursive_copy = 512,
};

__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
inline constexpr copy_options operator&(copy_options _LHS, copy_options _RHS) {
  return static_cast<copy_options>(static_cast<unsigned short>(_LHS) &
                                   static_cast<unsigned short>(_RHS));
}

__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
inline constexpr copy_options operator|(copy_options _LHS, copy_options _RHS) {
  return static_cast<copy_options>(static_cast<unsigned short>(_LHS) |
                                   static_cast<unsigned short>(_RHS));
}

__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
inline constexpr copy_options operator^(copy_options _LHS, copy_options _RHS) {
  return static_cast<copy_options>(static_cast<unsigned short>(_LHS) ^
                                   static_cast<unsigned short>(_RHS));
}

__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
inline constexpr copy_options operator~(copy_options _LHS) {
  return static_cast<copy_options>(~static_cast<unsigned short>(_LHS));
}

__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
inline copy_options& operator&=(copy_options& _LHS, copy_options _RHS) {
  return _LHS = _LHS & _RHS;
}

__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
inline copy_options& operator|=(copy_options& _LHS, copy_options _RHS) {
  return _LHS = _LHS | _RHS;
}

__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
inline copy_options& operator^=(copy_options& _LHS, copy_options _RHS) {
  return _LHS = _LHS ^ _RHS;
}

enum class __attribute__ ((__type_visibility__("default"))) directory_options : unsigned char {
  none = 0,
  follow_directory_symlink = 1,
  skip_permission_denied = 2
};

__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
inline constexpr directory_options operator&(directory_options _LHS,
                                             directory_options _RHS) {
  return static_cast<directory_options>(static_cast<unsigned char>(_LHS) &
                                        static_cast<unsigned char>(_RHS));
}

__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
inline constexpr directory_options operator|(directory_options _LHS,
                                             directory_options _RHS) {
  return static_cast<directory_options>(static_cast<unsigned char>(_LHS) |
                                        static_cast<unsigned char>(_RHS));
}

__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
inline constexpr directory_options operator^(directory_options _LHS,
                                             directory_options _RHS) {
  return static_cast<directory_options>(static_cast<unsigned char>(_LHS) ^
                                        static_cast<unsigned char>(_RHS));
}

__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
inline constexpr directory_options operator~(directory_options _LHS) {
  return static_cast<directory_options>(~static_cast<unsigned char>(_LHS));
}

__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
inline directory_options& operator&=(directory_options& _LHS,
                                     directory_options _RHS) {
  return _LHS = _LHS & _RHS;
}

__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
inline directory_options& operator|=(directory_options& _LHS,
                                     directory_options _RHS) {
  return _LHS = _LHS | _RHS;
}

__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
inline directory_options& operator^=(directory_options& _LHS,
                                     directory_options _RHS) {
  return _LHS = _LHS ^ _RHS;
}

class __attribute__ ((__visibility__("default"))) file_status {
public:

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  file_status() noexcept : file_status(file_type::none) {}
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  explicit file_status(file_type __ft, perms __prms = perms::unknown) noexcept
      : __ft_(__ft),
        __prms_(__prms) {}

  file_status(const file_status&) noexcept = default;
  file_status(file_status&&) noexcept = default;

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  ~file_status() {}

  file_status& operator=(const file_status&) noexcept = default;
  file_status& operator=(file_status&&) noexcept = default;


  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  file_type type() const noexcept { return __ft_; }

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  perms permissions() const noexcept { return __prms_; }


  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  void type(file_type __ft) noexcept { __ft_ = __ft; }

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  void permissions(perms __p) noexcept { __prms_ = __p; }

private:
  file_type __ft_;
  perms __prms_;
};

class __attribute__ ((__visibility__("default"))) directory_entry;

template <class _Tp>
struct __can_convert_char {
  static const bool value = false;
};
template <class _Tp>
struct __can_convert_char<const _Tp> : public __can_convert_char<_Tp> {};
template <>
struct __can_convert_char<char> {
  static const bool value = true;
  using __char_type = char;
};
template <>
struct __can_convert_char<wchar_t> {
  static const bool value = true;
  using __char_type = wchar_t;
};







template <>
struct __can_convert_char<char16_t> {
  static const bool value = true;
  using __char_type = char16_t;
};
template <>
struct __can_convert_char<char32_t> {
  static const bool value = true;
  using __char_type = char32_t;
};

template <class _ECharT>
typename enable_if<__can_convert_char<_ECharT>::value, bool>::type
__is_separator(_ECharT __e) {



  return __e == _ECharT('/');

}




typedef string __u8_string;


struct _NullSentinel {};

template <class _Tp>
using _Void = void;

template <class _Tp, class = void>
struct __is_pathable_string : public false_type {};

template <class _ECharT, class _Traits, class _Alloc>
struct __is_pathable_string<
    basic_string<_ECharT, _Traits, _Alloc>,
    _Void<typename __can_convert_char<_ECharT>::__char_type> >
    : public __can_convert_char<_ECharT> {
  using _Str = basic_string<_ECharT, _Traits, _Alloc>;
  using _Base = __can_convert_char<_ECharT>;
  static _ECharT const* __range_begin(_Str const& __s) { return __s.data(); }
  static _ECharT const* __range_end(_Str const& __s) {
    return __s.data() + __s.length();
  }
  static _ECharT __first_or_null(_Str const& __s) {
    return __s.empty() ? _ECharT{} : __s[0];
  }
};

template <class _ECharT, class _Traits>
struct __is_pathable_string<
    basic_string_view<_ECharT, _Traits>,
    _Void<typename __can_convert_char<_ECharT>::__char_type> >
    : public __can_convert_char<_ECharT> {
  using _Str = basic_string_view<_ECharT, _Traits>;
  using _Base = __can_convert_char<_ECharT>;
  static _ECharT const* __range_begin(_Str const& __s) { return __s.data(); }
  static _ECharT const* __range_end(_Str const& __s) {
    return __s.data() + __s.length();
  }
  static _ECharT __first_or_null(_Str const& __s) {
    return __s.empty() ? _ECharT{} : __s[0];
  }
};

template <class _Source, class _DS = typename decay<_Source>::type,
          class _UnqualPtrType =
              typename remove_const<typename remove_pointer<_DS>::type>::type,
          bool _IsCharPtr = is_pointer<_DS>::value&&
              __can_convert_char<_UnqualPtrType>::value>
struct __is_pathable_char_array : false_type {};

template <class _Source, class _ECharT, class _UPtr>
struct __is_pathable_char_array<_Source, _ECharT*, _UPtr, true>
    : __can_convert_char<typename remove_const<_ECharT>::type> {
  using _Base = __can_convert_char<typename remove_const<_ECharT>::type>;

  static _ECharT const* __range_begin(const _ECharT* __b) { return __b; }
  static _ECharT const* __range_end(const _ECharT* __b) {
    using _Iter = const _ECharT*;
    const _ECharT __sentinel = _ECharT{};
    _Iter __e = __b;
    for (; *__e != __sentinel; ++__e)
      ;
    return __e;
  }

  static _ECharT __first_or_null(const _ECharT* __b) { return *__b; }
};

template <class _Iter, bool _IsIt = __is_cpp17_input_iterator<_Iter>::value,
          class = void>
struct __is_pathable_iter : false_type {};

template <class _Iter>
struct __is_pathable_iter<
    _Iter, true,
    _Void<typename __can_convert_char<
        typename iterator_traits<_Iter>::value_type>::__char_type> >
    : __can_convert_char<typename iterator_traits<_Iter>::value_type> {
  using _ECharT = typename iterator_traits<_Iter>::value_type;
  using _Base = __can_convert_char<_ECharT>;

  static _Iter __range_begin(_Iter __b) { return __b; }
  static _NullSentinel __range_end(_Iter) { return _NullSentinel{}; }

  static _ECharT __first_or_null(_Iter __b) { return *__b; }
};

template <class _Tp, bool _IsStringT = __is_pathable_string<_Tp>::value,
          bool _IsCharIterT = __is_pathable_char_array<_Tp>::value,
          bool _IsIterT = !_IsCharIterT && __is_pathable_iter<_Tp>::value>
struct __is_pathable : false_type {
  static_assert(!_IsStringT && !_IsCharIterT && !_IsIterT, "Must all be false");
};

template <class _Tp>
struct __is_pathable<_Tp, true, false, false> : __is_pathable_string<_Tp> {};

template <class _Tp>
struct __is_pathable<_Tp, false, true, false> : __is_pathable_char_array<_Tp> {
};

template <class _Tp>
struct __is_pathable<_Tp, false, false, true> : __is_pathable_iter<_Tp> {};





typedef string __path_string;
typedef char __path_value;
# 711 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/filesystem" 3
template <class _ECharT>
struct _PathCVT;


template <class _ECharT>
struct _PathCVT {
  static_assert(__can_convert_char<_ECharT>::value,
                "Char type not convertible");

  typedef __narrow_to_utf8<sizeof(_ECharT) * 8> _Narrower;




  static void __append_range(__path_string& __dest, _ECharT const* __b,
                             _ECharT const* __e) {





    _Narrower()(back_inserter(__dest), __b, __e);

  }

  template <class _Iter>
  static void __append_range(__path_string& __dest, _Iter __b, _Iter __e) {
    static_assert(!is_same<_Iter, _ECharT*>::value, "Call const overload");
    if (__b == __e)
      return;
    basic_string<_ECharT> __tmp(__b, __e);






    _Narrower()(back_inserter(__dest), __tmp.data(),
                __tmp.data() + __tmp.length());

  }

  template <class _Iter>
  static void __append_range(__path_string& __dest, _Iter __b, _NullSentinel) {
    static_assert(!is_same<_Iter, _ECharT*>::value, "Call const overload");
    const _ECharT __sentinel = _ECharT{};
    if (*__b == __sentinel)
      return;
    basic_string<_ECharT> __tmp;
    for (; *__b != __sentinel; ++__b)
      __tmp.push_back(*__b);






    _Narrower()(back_inserter(__dest), __tmp.data(),
                __tmp.data() + __tmp.length());

  }

  template <class _Source>
  static void __append_source(__path_string& __dest, _Source const& __s) {
    using _Traits = __is_pathable<_Source>;
    __append_range(__dest, _Traits::__range_begin(__s),
                   _Traits::__range_end(__s));
  }
};


template <>
struct _PathCVT<__path_value> {

  template <class _Iter>
  static typename enable_if<__is_exactly_cpp17_input_iterator<_Iter>::value>::type
  __append_range(__path_string& __dest, _Iter __b, _Iter __e) {
    for (; __b != __e; ++__b)
      __dest.push_back(*__b);
  }

  template <class _Iter>
  static typename enable_if<__is_cpp17_forward_iterator<_Iter>::value>::type
  __append_range(__path_string& __dest, _Iter __b, _Iter __e) {
    __dest.append(__b, __e);
  }

  template <class _Iter>
  static void __append_range(__path_string& __dest, _Iter __b, _NullSentinel) {
    const char __sentinel = char{};
    for (; *__b != __sentinel; ++__b)
      __dest.push_back(*__b);
  }

  template <class _Source>
  static void __append_source(__path_string& __dest, _Source const& __s) {
    using _Traits = __is_pathable<_Source>;
    __append_range(__dest, _Traits::__range_begin(__s),
                   _Traits::__range_end(__s));
  }
};
# 909 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/filesystem" 3
class __attribute__ ((__visibility__("default"))) path {
  template <class _SourceOrIter, class _Tp = path&>
  using _EnableIfPathable =
      typename enable_if<__is_pathable<_SourceOrIter>::value, _Tp>::type;

  template <class _Tp>
  using _SourceChar = typename __is_pathable<_Tp>::__char_type;

  template <class _Tp>
  using _SourceCVT = _PathCVT<_SourceChar<_Tp> >;

public:




  typedef char value_type;
  static constexpr value_type preferred_separator = '/';

  typedef basic_string<value_type> string_type;
  typedef basic_string_view<value_type> __string_view;

  enum __attribute__ ((__type_visibility__("default"))) format : unsigned char {
    auto_format,
    native_format,
    generic_format
  };


  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) path() noexcept {}
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) path(const path& __p) : __pn_(__p.__pn_) {}
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) path(path&& __p) noexcept
      : __pn_(std::__1::move(__p.__pn_)) {}

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  path(string_type&& __s, format = format::auto_format) noexcept
      : __pn_(std::__1::move(__s)) {}

  template <class _Source, class = _EnableIfPathable<_Source, void> >
  path(const _Source& __src, format = format::auto_format) {
    _SourceCVT<_Source>::__append_source(__pn_, __src);
  }

  template <class _InputIt>
  path(_InputIt __first, _InputIt __last, format = format::auto_format) {
    typedef typename iterator_traits<_InputIt>::value_type _ItVal;
    _PathCVT<_ItVal>::__append_range(__pn_, __first, __last);
  }



  template <class _Source, class = _EnableIfPathable<_Source, void> >
  path(const _Source& __src, const locale& __loc, format = format::auto_format);
  template <class _InputIt>
  path(_InputIt __first, _InputIt _last, const locale& __loc,
       format = format::auto_format);


  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  ~path() = default;


  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  path& operator=(const path& __p) {
    __pn_ = __p.__pn_;
    return *this;
  }

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  path& operator=(path&& __p) noexcept {
    __pn_ = std::__1::move(__p.__pn_);
    return *this;
  }

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  path& operator=(string_type&& __s) noexcept {
    __pn_ = std::__1::move(__s);
    return *this;
  }

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  path& assign(string_type&& __s) noexcept {
    __pn_ = std::__1::move(__s);
    return *this;
  }

  template <class _Source>
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) _EnableIfPathable<_Source>
  operator=(const _Source& __src) {
    return this->assign(__src);
  }

  template <class _Source>
  _EnableIfPathable<_Source> assign(const _Source& __src) {
    __pn_.clear();
    _SourceCVT<_Source>::__append_source(__pn_, __src);
    return *this;
  }

  template <class _InputIt>
  path& assign(_InputIt __first, _InputIt __last) {
    typedef typename iterator_traits<_InputIt>::value_type _ItVal;
    __pn_.clear();
    _PathCVT<_ItVal>::__append_range(__pn_, __first, __last);
    return *this;
  }

public:
# 1054 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/filesystem" 3
  path& operator/=(const path& __p) {
    if (__p.is_absolute()) {
      __pn_ = __p.__pn_;
      return *this;
    }
    if (has_filename())
      __pn_ += preferred_separator;
    __pn_ += __p.native();
    return *this;
  }




  template <class _Source>
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) _EnableIfPathable<_Source>
  operator/=(const _Source& __src) {
    return this->append(__src);
  }

  template <class _Source>
  _EnableIfPathable<_Source> append(const _Source& __src) {
    using _Traits = __is_pathable<_Source>;
    using _CVT = _PathCVT<_SourceChar<_Source> >;
    bool __source_is_absolute = __is_separator(_Traits::__first_or_null(__src));
    if (__source_is_absolute)
      __pn_.clear();
    else if (has_filename())
      __pn_ += preferred_separator;
    _CVT::__append_source(__pn_, __src);
    return *this;
  }

  template <class _InputIt>
  path& append(_InputIt __first, _InputIt __last) {
    typedef typename iterator_traits<_InputIt>::value_type _ItVal;
    static_assert(__can_convert_char<_ItVal>::value, "Must convertible");
    using _CVT = _PathCVT<_ItVal>;
    if (__first != __last && __is_separator(*__first))
      __pn_.clear();
    else if (has_filename())
      __pn_ += preferred_separator;
    _CVT::__append_range(__pn_, __first, __last);
    return *this;
  }



  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  path& operator+=(const path& __x) {
    __pn_ += __x.__pn_;
    return *this;
  }

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  path& operator+=(const string_type& __x) {
    __pn_ += __x;
    return *this;
  }

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  path& operator+=(__string_view __x) {
    __pn_ += __x;
    return *this;
  }

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  path& operator+=(const value_type* __x) {
    __pn_ += __x;
    return *this;
  }

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  path& operator+=(value_type __x) {
    __pn_ += __x;
    return *this;
  }

  template <class _ECharT>
  typename enable_if<__can_convert_char<_ECharT>::value, path&>::type
  operator+=(_ECharT __x) {
    _PathCVT<_ECharT>::__append_source(__pn_,
                                       basic_string_view<_ECharT>(&__x, 1));
    return *this;
  }

  template <class _Source>
  _EnableIfPathable<_Source> operator+=(const _Source& __x) {
    return this->concat(__x);
  }

  template <class _Source>
  _EnableIfPathable<_Source> concat(const _Source& __x) {
    _SourceCVT<_Source>::__append_source(__pn_, __x);
    return *this;
  }

  template <class _InputIt>
  path& concat(_InputIt __first, _InputIt __last) {
    typedef typename iterator_traits<_InputIt>::value_type _ItVal;
    _PathCVT<_ItVal>::__append_range(__pn_, __first, __last);
    return *this;
  }


  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  void clear() noexcept { __pn_.clear(); }

  path& make_preferred() {



    return *this;
  }

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  path& remove_filename() {
    auto __fname = __filename();
    if (!__fname.empty())
      __pn_.erase(__fname.data() - __pn_.data());
    return *this;
  }

  path& replace_filename(const path& __replacement) {
    remove_filename();
    return (*this /= __replacement);
  }

  path& replace_extension(const path& __replacement = path());

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  void swap(path& __rhs) noexcept { __pn_.swap(__rhs.__pn_); }


  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  void __reserve(size_t __s) { __pn_.reserve(__s); }


  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  const string_type& native() const noexcept { return __pn_; }

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  const value_type* c_str() const noexcept { return __pn_.c_str(); }

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) operator string_type() const { return __pn_; }
# 1266 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/filesystem" 3
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) std::__1::string string() const { return __pn_; }



  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) std::__1::string u8string() const { return __pn_; }



  template <class _ECharT, class _Traits = char_traits<_ECharT>,
            class _Allocator = allocator<_ECharT> >
  basic_string<_ECharT, _Traits, _Allocator>
  string(const _Allocator& __a = _Allocator()) const {
    using _CVT = __widen_from_utf8<sizeof(_ECharT) * 8>;
    using _Str = basic_string<_ECharT, _Traits, _Allocator>;
    _Str __s(__a);
    __s.reserve(__pn_.size());
    _CVT()(back_inserter(__s), __pn_.data(), __pn_.data() + __pn_.size());
    return __s;
  }


  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) std::__1::wstring wstring() const {
    return string<wchar_t>();
  }

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) std::__1::u16string u16string() const {
    return string<char16_t>();
  }
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) std::__1::u32string u32string() const {
    return string<char32_t>();
  }



  std::__1::string generic_string() const { return __pn_; }



  std::__1::string generic_u8string() const { return __pn_; }



  template <class _ECharT, class _Traits = char_traits<_ECharT>,
            class _Allocator = allocator<_ECharT> >
  basic_string<_ECharT, _Traits, _Allocator>
  generic_string(const _Allocator& __a = _Allocator()) const {
    return string<_ECharT, _Traits, _Allocator>(__a);
  }


  std::__1::wstring generic_wstring() const { return string<wchar_t>(); }

  std::__1::u16string generic_u16string() const { return string<char16_t>(); }
  std::__1::u32string generic_u32string() const { return string<char32_t>(); }



private:
  int __compare(__string_view) const;
  __string_view __root_name() const;
  __string_view __root_directory() const;
  __string_view __root_path_raw() const;
  __string_view __relative_path() const;
  __string_view __parent_path() const;
  __string_view __filename() const;
  __string_view __stem() const;
  __string_view __extension() const;

public:

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) int compare(const path& __p) const noexcept {
    return __compare(__p.__pn_);
  }
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) int compare(const string_type& __s) const {
    return __compare(__s);
  }
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) int compare(__string_view __s) const {
    return __compare(__s);
  }
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) int compare(const value_type* __s) const {
    return __compare(__s);
  }


  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) path root_name() const {
    return string_type(__root_name());
  }
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) path root_directory() const {
    return string_type(__root_directory());
  }
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) path root_path() const {



    return root_name().append(string_type(__root_directory()));

  }
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) path relative_path() const {
    return string_type(__relative_path());
  }
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) path parent_path() const {
    return string_type(__parent_path());
  }
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) path filename() const {
    return string_type(__filename());
  }
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) path stem() const { return string_type(__stem()); }
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) path extension() const {
    return string_type(__extension());
  }


                                __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) bool
  empty() const noexcept {
    return __pn_.empty();
  }

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) bool has_root_name() const {
    return !__root_name().empty();
  }
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) bool has_root_directory() const {
    return !__root_directory().empty();
  }
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) bool has_root_path() const {
    return !__root_path_raw().empty();
  }
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) bool has_relative_path() const {
    return !__relative_path().empty();
  }
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) bool has_parent_path() const {
    return !__parent_path().empty();
  }
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) bool has_filename() const {
    return !__filename().empty();
  }
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) bool has_stem() const { return !__stem().empty(); }
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) bool has_extension() const {
    return !__extension().empty();
  }

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) bool is_absolute() const {
# 1427 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/filesystem" 3
    return has_root_directory();

  }
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) bool is_relative() const { return !is_absolute(); }


  path lexically_normal() const;
  path lexically_relative(const path& __base) const;

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) path lexically_proximate(const path& __base) const {
    path __result = this->lexically_relative(__base);
    if (__result.native().empty())
      return *this;
    return __result;
  }


  class __attribute__ ((__visibility__("default"))) iterator;
  typedef iterator const_iterator;

  iterator begin() const;
  iterator end() const;


  template <class _CharT, class _Traits>
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) friend
      typename enable_if<is_same<_CharT, value_type>::value &&
                             is_same<_Traits, char_traits<value_type> >::value,
                         basic_ostream<_CharT, _Traits>&>::type
      operator<<(basic_ostream<_CharT, _Traits>& __os, const path& __p) {
    __os << std::__1::__quoted(__p.native());
    return __os;
  }

  template <class _CharT, class _Traits>
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) friend
      typename enable_if<!is_same<_CharT, value_type>::value ||
                             !is_same<_Traits, char_traits<value_type> >::value,
                         basic_ostream<_CharT, _Traits>&>::type
      operator<<(basic_ostream<_CharT, _Traits>& __os, const path& __p) {
    __os << std::__1::__quoted(__p.string<_CharT, _Traits>());
    return __os;
  }

  template <class _CharT, class _Traits>
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) friend basic_istream<_CharT, _Traits>&
  operator>>(basic_istream<_CharT, _Traits>& __is, path& __p) {
    basic_string<_CharT, _Traits> __tmp;
    __is >> __quoted(__tmp);
    __p = __tmp;
    return __is;
  }


  friend __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) bool operator==(const path& __lhs, const path& __rhs) noexcept {
    return __lhs.compare(__rhs) == 0;
  }
  friend __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) bool operator!=(const path& __lhs, const path& __rhs) noexcept {
    return __lhs.compare(__rhs) != 0;
  }
  friend __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) bool operator<(const path& __lhs, const path& __rhs) noexcept {
    return __lhs.compare(__rhs) < 0;
  }
  friend __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) bool operator<=(const path& __lhs, const path& __rhs) noexcept {
    return __lhs.compare(__rhs) <= 0;
  }
  friend __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) bool operator>(const path& __lhs, const path& __rhs) noexcept {
    return __lhs.compare(__rhs) > 0;
  }
  friend __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) bool operator>=(const path& __lhs, const path& __rhs) noexcept {
    return __lhs.compare(__rhs) >= 0;
  }

  friend __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) path operator/(const path& __lhs,
                                                  const path& __rhs) {
    path __result(__lhs);
    __result /= __rhs;
    return __result;
  }
private:
  inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) path&
  __assign_view(__string_view const& __s) noexcept {
    __pn_ = string_type(__s);
    return *this;
  }
  string_type __pn_;
};

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) void swap(path& __lhs, path& __rhs) noexcept {
  __lhs.swap(__rhs);
}

__attribute__ ((__visibility__("default")))
size_t hash_value(const path& __p) noexcept;

template <class _InputIt>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    typename enable_if<__is_pathable<_InputIt>::value, path>::type
    u8path(_InputIt __f, _InputIt __l) {
  static_assert(



      is_same<typename __is_pathable<_InputIt>::__char_type, char>::value,
      "u8path(Iter, Iter) requires Iter have a value_type of type 'char'"
      " or 'char8_t'");
# 1541 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/filesystem" 3
  return path(__f, __l);

}
# 1569 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/filesystem" 3
template <class _Source>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    typename enable_if<__is_pathable<_Source>::value, path>::type
    u8path(const _Source& __s) {
  static_assert(



      is_same<typename __is_pathable<_Source>::__char_type, char>::value,
      "u8path(Source const&) requires Source have a character type of type "
      "'char' or 'char8_t'");




  return path(__s);

}

class __attribute__ ((__visibility__("default"))) path::iterator {
public:
  enum _ParserState : unsigned char {
    _Singular,
    _BeforeBegin,
    _InRootName,
    _InRootDir,
    _InFilenames,
    _InTrailingSep,
    _AtEnd
  };

public:
  typedef bidirectional_iterator_tag iterator_category;

  typedef path value_type;
  typedef ptrdiff_t difference_type;
  typedef const path* pointer;
  typedef const path& reference;

  typedef void
      __stashing_iterator_tag;

public:
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  iterator()
      : __stashed_elem_(), __path_ptr_(nullptr), __entry_(),
        __state_(_Singular) {}

  iterator(const iterator&) = default;
  ~iterator() = default;

  iterator& operator=(const iterator&) = default;

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  reference operator*() const { return __stashed_elem_; }

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  pointer operator->() const { return &__stashed_elem_; }

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  iterator& operator++() {
    ((void)0);

    ((void)0);

    return __increment();
  }

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  iterator operator++(int) {
    iterator __it(*this);
    this->operator++();
    return __it;
  }

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  iterator& operator--() {
    ((void)0);

    ((void)0);

    return __decrement();
  }

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  iterator operator--(int) {
    iterator __it(*this);
    this->operator--();
    return __it;
  }

private:
  friend class path;

  inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) friend bool operator==(const iterator&,
                                                          const iterator&);

  iterator& __increment();
  iterator& __decrement();

  path __stashed_elem_;
  const path* __path_ptr_;
  path::__string_view __entry_;
  _ParserState __state_;
};

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) bool operator==(const path::iterator& __lhs,
                                                 const path::iterator& __rhs) {
  return __lhs.__path_ptr_ == __rhs.__path_ptr_ &&
         __lhs.__entry_.data() == __rhs.__entry_.data();
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) bool operator!=(const path::iterator& __lhs,
                                                 const path::iterator& __rhs) {
  return !(__lhs == __rhs);
}



#pragma clang attribute pop
# 1688 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/filesystem" 3
#pragma clang attribute pop
# 1688 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/filesystem" 3
#pragma clang attribute pop
# 1688 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/filesystem" 3
#pragma clang attribute pop

class __attribute__((availability(macosx,strict,introduced=10.15))) __attribute__((availability(ios,strict,introduced=13.0))) __attribute__((availability(tvos,strict,introduced=13.0))) __attribute__((availability(watchos,strict,introduced=6.0))) __attribute__ ((__visibility__("default"))) filesystem_error : public system_error {
public:
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  filesystem_error(const string& __what, error_code __ec)
      : system_error(__ec, __what),
        __storage_(make_shared<_Storage>(path(), path())) {
    __create_what(0);
  }

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  filesystem_error(const string& __what, const path& __p1, error_code __ec)
      : system_error(__ec, __what),
        __storage_(make_shared<_Storage>(__p1, path())) {
    __create_what(1);
  }

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  filesystem_error(const string& __what, const path& __p1, const path& __p2,
                   error_code __ec)
      : system_error(__ec, __what),
        __storage_(make_shared<_Storage>(__p1, __p2)) {
    __create_what(2);
  }

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  const path& path1() const noexcept { return __storage_->__p1_; }

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  const path& path2() const noexcept { return __storage_->__p2_; }

  filesystem_error(const filesystem_error&) = default;
  ~filesystem_error() override;

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  const char* what() const noexcept override {
    return __storage_->__what_.c_str();
  }

  void __create_what(int __num_paths);

private:
  struct __attribute__ ((__visibility__("hidden"))) _Storage {
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    _Storage(const path& __p1, const path& __p2) : __p1_(__p1), __p2_(__p2) {}

    path __p1_;
    path __p2_;
    string __what_;
  };
  shared_ptr<_Storage> __storage_;
};

#pragma clang attribute push(__attribute__((availability(macosx,strict,introduced=10.15))), apply_to=any(function,record))
# 1742 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/filesystem" 3
#pragma clang attribute push(__attribute__((availability(ios,strict,introduced=13.0))), apply_to=any(function,record))
# 1742 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/filesystem" 3
#pragma clang attribute push(__attribute__((availability(tvos,strict,introduced=13.0))), apply_to=any(function,record))
# 1742 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/filesystem" 3
#pragma clang attribute push(__attribute__((availability(watchos,strict,introduced=6.0))), apply_to=any(function,record))

template <class... _Args>
[[noreturn]] inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))

void __throw_filesystem_error(_Args&&... __args) {
  throw filesystem_error(std::__1::forward<_Args>(__args)...);
}
# 1758 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/filesystem" 3
__attribute__ ((__visibility__("default")))
path __absolute(const path&, error_code* __ec = nullptr);
__attribute__ ((__visibility__("default")))
path __canonical(const path&, error_code* __ec = nullptr);
__attribute__ ((__visibility__("default")))
void __copy(const path& __from, const path& __to, copy_options __opt,
            error_code* __ec = nullptr);
__attribute__ ((__visibility__("default")))
bool __copy_file(const path& __from, const path& __to, copy_options __opt,
                 error_code* __ec = nullptr);
__attribute__ ((__visibility__("default")))
void __copy_symlink(const path& __existing_symlink, const path& __new_symlink,
                    error_code* __ec = nullptr);
__attribute__ ((__visibility__("default")))
bool __create_directories(const path& p, error_code* ec = nullptr);
__attribute__ ((__visibility__("default")))
bool __create_directory(const path& p, error_code* ec = nullptr);
__attribute__ ((__visibility__("default")))
bool __create_directory(const path& p, const path& attributes,
                        error_code* ec = nullptr);
__attribute__ ((__visibility__("default")))
void __create_directory_symlink(const path& __to, const path& __new_symlink,
                                error_code* __ec = nullptr);
__attribute__ ((__visibility__("default")))
void __create_hard_link(const path& __to, const path& __new_hard_link,
                        error_code* __ec = nullptr);
__attribute__ ((__visibility__("default")))
void __create_symlink(const path& __to, const path& __new_symlink,
                      error_code* __ec = nullptr);
__attribute__ ((__visibility__("default")))
path __current_path(error_code* __ec = nullptr);
__attribute__ ((__visibility__("default")))
void __current_path(const path&, error_code* __ec = nullptr);
__attribute__ ((__visibility__("default")))
bool __equivalent(const path&, const path&, error_code* __ec = nullptr);
__attribute__ ((__visibility__("default")))
uintmax_t __file_size(const path&, error_code* __ec = nullptr);
__attribute__ ((__visibility__("default")))
uintmax_t __hard_link_count(const path&, error_code* __ec = nullptr);
__attribute__ ((__visibility__("default")))
bool __fs_is_empty(const path& p, error_code* ec = nullptr);
__attribute__ ((__visibility__("default")))
file_time_type __last_write_time(const path& p, error_code* ec = nullptr);
__attribute__ ((__visibility__("default")))
void __last_write_time(const path& p, file_time_type new_time,
                       error_code* ec = nullptr);
__attribute__ ((__visibility__("default")))
void __permissions(const path&, perms, perm_options, error_code* = nullptr);
__attribute__ ((__visibility__("default")))
path __read_symlink(const path& p, error_code* ec = nullptr);
__attribute__ ((__visibility__("default")))
bool __remove(const path& p, error_code* ec = nullptr);
__attribute__ ((__visibility__("default")))
uintmax_t __remove_all(const path& p, error_code* ec = nullptr);
__attribute__ ((__visibility__("default")))
void __rename(const path& from, const path& to, error_code* ec = nullptr);
__attribute__ ((__visibility__("default")))
void __resize_file(const path& p, uintmax_t size, error_code* ec = nullptr);
__attribute__ ((__visibility__("default")))
space_info __space(const path&, error_code* __ec = nullptr);
__attribute__ ((__visibility__("default")))
file_status __status(const path&, error_code* __ec = nullptr);
__attribute__ ((__visibility__("default")))
file_status __symlink_status(const path&, error_code* __ec = nullptr);
__attribute__ ((__visibility__("default")))
path __system_complete(const path&, error_code* __ec = nullptr);
__attribute__ ((__visibility__("default")))
path __temp_directory_path(error_code* __ec = nullptr);
__attribute__ ((__visibility__("default")))
path __weakly_canonical(path const& __p, error_code* __ec = nullptr);

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) path current_path() {
  return __current_path();
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) path current_path(error_code& __ec) {
  return __current_path(&__ec);
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) void current_path(const path& __p) {
  __current_path(__p);
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) void current_path(const path& __p,
                                                   error_code& __ec) noexcept {
  __current_path(__p, &__ec);
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) path absolute(const path& __p) {
  return __absolute(__p);
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) path absolute(const path& __p,
                                               error_code& __ec) {
  return __absolute(__p, &__ec);
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) path canonical(const path& __p) {
  return __canonical(__p);
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) path canonical(const path& __p,
                                                error_code& __ec) {
  return __canonical(__p, &__ec);
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) void copy(const path& __from,
                                           const path& __to) {
  __copy(__from, __to, copy_options::none);
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) void copy(const path& __from, const path& __to,
                                           error_code& __ec) {
  __copy(__from, __to, copy_options::none, &__ec);
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) void copy(const path& __from, const path& __to,
                                           copy_options __opt) {
  __copy(__from, __to, __opt);
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) void copy(const path& __from, const path& __to,
                                           copy_options __opt,
                                           error_code& __ec) {
  __copy(__from, __to, __opt, &__ec);
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) bool copy_file(const path& __from,
                                                const path& __to) {
  return __copy_file(__from, __to, copy_options::none);
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) bool
copy_file(const path& __from, const path& __to, error_code& __ec) {
  return __copy_file(__from, __to, copy_options::none, &__ec);
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) bool
copy_file(const path& __from, const path& __to, copy_options __opt) {
  return __copy_file(__from, __to, __opt);
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) bool copy_file(const path& __from,
                                                const path& __to,
                                                copy_options __opt,
                                                error_code& __ec) {
  return __copy_file(__from, __to, __opt, &__ec);
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) void copy_symlink(const path& __existing,
                                                   const path& __new) {
  __copy_symlink(__existing, __new);
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) void
copy_symlink(const path& __ext, const path& __new, error_code& __ec) noexcept {
  __copy_symlink(__ext, __new, &__ec);
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) bool create_directories(const path& __p) {
  return __create_directories(__p);
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) bool create_directories(const path& __p,
                                                         error_code& __ec) {
  return __create_directories(__p, &__ec);
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) bool create_directory(const path& __p) {
  return __create_directory(__p);
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) bool
create_directory(const path& __p, error_code& __ec) noexcept {
  return __create_directory(__p, &__ec);
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) bool create_directory(const path& __p,
                                                       const path& __attrs) {
  return __create_directory(__p, __attrs);
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) bool
create_directory(const path& __p, const path& __attrs,
                 error_code& __ec) noexcept {
  return __create_directory(__p, __attrs, &__ec);
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) void
create_directory_symlink(const path& __to, const path& __new) {
  __create_directory_symlink(__to, __new);
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) void
create_directory_symlink(const path& __to, const path& __new,
                         error_code& __ec) noexcept {
  __create_directory_symlink(__to, __new, &__ec);
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) void create_hard_link(const path& __to,
                                                       const path& __new) {
  __create_hard_link(__to, __new);
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) void
create_hard_link(const path& __to, const path& __new,
                 error_code& __ec) noexcept {
  __create_hard_link(__to, __new, &__ec);
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) void create_symlink(const path& __to,
                                                     const path& __new) {
  __create_symlink(__to, __new);
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) void
create_symlink(const path& __to, const path& __new, error_code& __ec) noexcept {
  return __create_symlink(__to, __new, &__ec);
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) bool status_known(file_status __s) noexcept {
  return __s.type() != file_type::none;
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) bool exists(file_status __s) noexcept {
  return status_known(__s) && __s.type() != file_type::not_found;
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) bool exists(const path& __p) {
  return exists(__status(__p));
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) bool exists(const path& __p,
                                             error_code& __ec) noexcept {
  auto __s = __status(__p, &__ec);
  if (status_known(__s))
    __ec.clear();
  return exists(__s);
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) bool equivalent(const path& __p1,
                                                 const path& __p2) {
  return __equivalent(__p1, __p2);
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) bool
equivalent(const path& __p1, const path& __p2, error_code& __ec) noexcept {
  return __equivalent(__p1, __p2, &__ec);
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) uintmax_t file_size(const path& __p) {
  return __file_size(__p);
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) uintmax_t
file_size(const path& __p, error_code& __ec) noexcept {
  return __file_size(__p, &__ec);
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) uintmax_t hard_link_count(const path& __p) {
  return __hard_link_count(__p);
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) uintmax_t
hard_link_count(const path& __p, error_code& __ec) noexcept {
  return __hard_link_count(__p, &__ec);
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) bool is_block_file(file_status __s) noexcept {
  return __s.type() == file_type::block;
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) bool is_block_file(const path& __p) {
  return is_block_file(__status(__p));
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) bool is_block_file(const path& __p,
                                                    error_code& __ec) noexcept {
  return is_block_file(__status(__p, &__ec));
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) bool
is_character_file(file_status __s) noexcept {
  return __s.type() == file_type::character;
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) bool is_character_file(const path& __p) {
  return is_character_file(__status(__p));
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) bool
is_character_file(const path& __p, error_code& __ec) noexcept {
  return is_character_file(__status(__p, &__ec));
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) bool is_directory(file_status __s) noexcept {
  return __s.type() == file_type::directory;
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) bool is_directory(const path& __p) {
  return is_directory(__status(__p));
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) bool is_directory(const path& __p,
                                                   error_code& __ec) noexcept {
  return is_directory(__status(__p, &__ec));
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) bool is_empty(const path& __p) {
  return __fs_is_empty(__p);
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) bool is_empty(const path& __p,
                                               error_code& __ec) {
  return __fs_is_empty(__p, &__ec);
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) bool is_fifo(file_status __s) noexcept {
  return __s.type() == file_type::fifo;
}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) bool is_fifo(const path& __p) {
  return is_fifo(__status(__p));
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) bool is_fifo(const path& __p,
                                              error_code& __ec) noexcept {
  return is_fifo(__status(__p, &__ec));
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) bool
is_regular_file(file_status __s) noexcept {
  return __s.type() == file_type::regular;
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) bool is_regular_file(const path& __p) {
  return is_regular_file(__status(__p));
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) bool
is_regular_file(const path& __p, error_code& __ec) noexcept {
  return is_regular_file(__status(__p, &__ec));
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) bool is_socket(file_status __s) noexcept {
  return __s.type() == file_type::socket;
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) bool is_socket(const path& __p) {
  return is_socket(__status(__p));
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) bool is_socket(const path& __p,
                                                error_code& __ec) noexcept {
  return is_socket(__status(__p, &__ec));
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) bool is_symlink(file_status __s) noexcept {
  return __s.type() == file_type::symlink;
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) bool is_symlink(const path& __p) {
  return is_symlink(__symlink_status(__p));
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) bool is_symlink(const path& __p,
                                                 error_code& __ec) noexcept {
  return is_symlink(__symlink_status(__p, &__ec));
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) bool is_other(file_status __s) noexcept {
  return exists(__s) && !is_regular_file(__s) && !is_directory(__s) &&
         !is_symlink(__s);
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) bool is_other(const path& __p) {
  return is_other(__status(__p));
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) bool is_other(const path& __p,
                                               error_code& __ec) noexcept {
  return is_other(__status(__p, &__ec));
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) file_time_type
last_write_time(const path& __p) {
  return __last_write_time(__p);
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) file_time_type
last_write_time(const path& __p, error_code& __ec) noexcept {
  return __last_write_time(__p, &__ec);
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) void last_write_time(const path& __p,
                                                      file_time_type __t) {
  __last_write_time(__p, __t);
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) void
last_write_time(const path& __p, file_time_type __t,
                error_code& __ec) noexcept {
  __last_write_time(__p, __t, &__ec);
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) void
permissions(const path& __p, perms __prms,
            perm_options __opts = perm_options::replace) {
  __permissions(__p, __prms, __opts);
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) void permissions(const path& __p, perms __prms,
                                                  error_code& __ec) noexcept {
  __permissions(__p, __prms, perm_options::replace, &__ec);
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) void permissions(const path& __p, perms __prms,
                                                  perm_options __opts,
                                                  error_code& __ec) {
  __permissions(__p, __prms, __opts, &__ec);
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) path proximate(const path& __p,
                                                const path& __base,
                                                error_code& __ec) {
  path __tmp = __weakly_canonical(__p, &__ec);
  if (__ec)
    return {};
  path __tmp_base = __weakly_canonical(__base, &__ec);
  if (__ec)
    return {};
  return __tmp.lexically_proximate(__tmp_base);
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) path proximate(const path& __p,
                                                error_code& __ec) {
  return proximate(__p, current_path(), __ec);
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) path
proximate(const path& __p, const path& __base = current_path()) {
  return __weakly_canonical(__p).lexically_proximate(
      __weakly_canonical(__base));
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) path read_symlink(const path& __p) {
  return __read_symlink(__p);
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) path read_symlink(const path& __p,
                                                   error_code& __ec) {
  return __read_symlink(__p, &__ec);
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) path relative(const path& __p,
                                               const path& __base,
                                               error_code& __ec) {
  path __tmp = __weakly_canonical(__p, &__ec);
  if (__ec)
    return path();
  path __tmpbase = __weakly_canonical(__base, &__ec);
  if (__ec)
    return path();
  return __tmp.lexically_relative(__tmpbase);
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) path relative(const path& __p,
                                               error_code& __ec) {
  return relative(__p, current_path(), __ec);
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) path
relative(const path& __p, const path& __base = current_path()) {
  return __weakly_canonical(__p).lexically_relative(__weakly_canonical(__base));
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) bool remove(const path& __p) {
  return __remove(__p);
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) bool remove(const path& __p,
                                             error_code& __ec) noexcept {
  return __remove(__p, &__ec);
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) uintmax_t remove_all(const path& __p) {
  return __remove_all(__p);
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) uintmax_t remove_all(const path& __p,
                                                      error_code& __ec) {
  return __remove_all(__p, &__ec);
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) void rename(const path& __from,
                                             const path& __to) {
  return __rename(__from, __to);
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) void
rename(const path& __from, const path& __to, error_code& __ec) noexcept {
  return __rename(__from, __to, &__ec);
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) void resize_file(const path& __p,
                                                  uintmax_t __ns) {
  return __resize_file(__p, __ns);
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) void
resize_file(const path& __p, uintmax_t __ns, error_code& __ec) noexcept {
  return __resize_file(__p, __ns, &__ec);
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) space_info space(const path& __p) {
  return __space(__p);
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) space_info space(const path& __p,
                                                  error_code& __ec) noexcept {
  return __space(__p, &__ec);
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) file_status status(const path& __p) {
  return __status(__p);
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) file_status status(const path& __p,
                                                    error_code& __ec) noexcept {
  return __status(__p, &__ec);
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) file_status symlink_status(const path& __p) {
  return __symlink_status(__p);
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) file_status
symlink_status(const path& __p, error_code& __ec) noexcept {
  return __symlink_status(__p, &__ec);
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) path temp_directory_path() {
  return __temp_directory_path();
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) path temp_directory_path(error_code& __ec) {
  return __temp_directory_path(&__ec);
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) path weakly_canonical(path const& __p) {
  return __weakly_canonical(__p);
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) path weakly_canonical(path const& __p,
                                                       error_code& __ec) {
  return __weakly_canonical(__p, &__ec);
}

class directory_iterator;
class recursive_directory_iterator;
class __attribute__ ((__visibility__("hidden"))) __dir_stream;

class directory_entry {
  typedef std::__1::__fs::filesystem::path _Path;

public:

  directory_entry() noexcept = default;
  directory_entry(directory_entry const&) = default;
  directory_entry(directory_entry&&) noexcept = default;

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  explicit directory_entry(_Path const& __p) : __p_(__p) {
    error_code __ec;
    __refresh(&__ec);
  }

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  directory_entry(_Path const& __p, error_code& __ec) : __p_(__p) {
    __refresh(&__ec);
  }

  ~directory_entry() {}

  directory_entry& operator=(directory_entry const&) = default;
  directory_entry& operator=(directory_entry&&) noexcept = default;

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  void assign(_Path const& __p) {
    __p_ = __p;
    error_code __ec;
    __refresh(&__ec);
  }

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  void assign(_Path const& __p, error_code& __ec) {
    __p_ = __p;
    __refresh(&__ec);
  }

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  void replace_filename(_Path const& __p) {
    __p_.replace_filename(__p);
    error_code __ec;
    __refresh(&__ec);
  }

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  void replace_filename(_Path const& __p, error_code& __ec) {
    __p_ = __p_.parent_path() / __p;
    __refresh(&__ec);
  }

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  void refresh() { __refresh(); }

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  void refresh(error_code& __ec) noexcept { __refresh(&__ec); }

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  _Path const& path() const noexcept { return __p_; }

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  operator const _Path&() const noexcept { return __p_; }

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  bool exists() const { return std::__1::__fs::filesystem::exists(file_status{__get_ft()}); }

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  bool exists(error_code& __ec) const noexcept {
    return std::__1::__fs::filesystem::exists(file_status{__get_ft(&__ec)});
  }

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  bool is_block_file() const { return __get_ft() == file_type::block; }

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  bool is_block_file(error_code& __ec) const noexcept {
    return __get_ft(&__ec) == file_type::block;
  }

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  bool is_character_file() const { return __get_ft() == file_type::character; }

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  bool is_character_file(error_code& __ec) const noexcept {
    return __get_ft(&__ec) == file_type::character;
  }

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  bool is_directory() const { return __get_ft() == file_type::directory; }

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  bool is_directory(error_code& __ec) const noexcept {
    return __get_ft(&__ec) == file_type::directory;
  }

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  bool is_fifo() const { return __get_ft() == file_type::fifo; }

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  bool is_fifo(error_code& __ec) const noexcept {
    return __get_ft(&__ec) == file_type::fifo;
  }

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  bool is_other() const { return std::__1::__fs::filesystem::is_other(file_status{__get_ft()}); }

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  bool is_other(error_code& __ec) const noexcept {
    return std::__1::__fs::filesystem::is_other(file_status{__get_ft(&__ec)});
  }

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  bool is_regular_file() const { return __get_ft() == file_type::regular; }

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  bool is_regular_file(error_code& __ec) const noexcept {
    return __get_ft(&__ec) == file_type::regular;
  }

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  bool is_socket() const { return __get_ft() == file_type::socket; }

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  bool is_socket(error_code& __ec) const noexcept {
    return __get_ft(&__ec) == file_type::socket;
  }

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  bool is_symlink() const { return __get_sym_ft() == file_type::symlink; }

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  bool is_symlink(error_code& __ec) const noexcept {
    return __get_sym_ft(&__ec) == file_type::symlink;
  }
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  uintmax_t file_size() const { return __get_size(); }

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  uintmax_t file_size(error_code& __ec) const noexcept {
    return __get_size(&__ec);
  }

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  uintmax_t hard_link_count() const { return __get_nlink(); }

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  uintmax_t hard_link_count(error_code& __ec) const noexcept {
    return __get_nlink(&__ec);
  }

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  file_time_type last_write_time() const { return __get_write_time(); }

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  file_time_type last_write_time(error_code& __ec) const noexcept {
    return __get_write_time(&__ec);
  }

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  file_status status() const { return __get_status(); }

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  file_status status(error_code& __ec) const noexcept {
    return __get_status(&__ec);
  }

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  file_status symlink_status() const { return __get_symlink_status(); }

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  file_status symlink_status(error_code& __ec) const noexcept {
    return __get_symlink_status(&__ec);
  }

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  bool operator<(directory_entry const& __rhs) const noexcept {
    return __p_ < __rhs.__p_;
  }

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  bool operator==(directory_entry const& __rhs) const noexcept {
    return __p_ == __rhs.__p_;
  }

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  bool operator!=(directory_entry const& __rhs) const noexcept {
    return __p_ != __rhs.__p_;
  }

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  bool operator<=(directory_entry const& __rhs) const noexcept {
    return __p_ <= __rhs.__p_;
  }

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  bool operator>(directory_entry const& __rhs) const noexcept {
    return __p_ > __rhs.__p_;
  }

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  bool operator>=(directory_entry const& __rhs) const noexcept {
    return __p_ >= __rhs.__p_;
  }

private:
  friend class directory_iterator;
  friend class recursive_directory_iterator;
  friend class __dir_stream;

  enum _CacheType : unsigned char {
    _Empty,
    _IterSymlink,
    _IterNonSymlink,
    _RefreshSymlink,
    _RefreshSymlinkUnresolved,
    _RefreshNonSymlink
  };

  struct __cached_data {
    uintmax_t __size_;
    uintmax_t __nlink_;
    file_time_type __write_time_;
    perms __sym_perms_;
    perms __non_sym_perms_;
    file_type __type_;
    _CacheType __cache_type_;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __cached_data() noexcept { __reset(); }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void __reset() {
      __cache_type_ = _Empty;
      __type_ = file_type::none;
      __sym_perms_ = __non_sym_perms_ = perms::unknown;
      __size_ = __nlink_ = uintmax_t(-1);
      __write_time_ = file_time_type::min();
    }
  };

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  static __cached_data __create_iter_result(file_type __ft) {
    __cached_data __data;
    __data.__type_ = __ft;
    __data.__cache_type_ = [&]() {
      switch (__ft) {
      case file_type::none:
        return _Empty;
      case file_type::symlink:
        return _IterSymlink;
      default:
        return _IterNonSymlink;
      }
    }();
    return __data;
  }

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  void __assign_iter_entry(_Path&& __p, __cached_data __dt) {
    __p_ = std::__1::move(__p);
    __data_ = __dt;
  }

  __attribute__ ((__visibility__("default")))
  error_code __do_refresh() noexcept;

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  static bool __is_dne_error(error_code const& __ec) {
    if (!__ec)
      return true;
    switch (static_cast<errc>(__ec.value())) {
    case errc::no_such_file_or_directory:
    case errc::not_a_directory:
      return true;
    default:
      return false;
    }
  }

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  void __handle_error(const char* __msg, error_code* __dest_ec,
                      error_code const& __ec, bool __allow_dne = false) const {
    if (__dest_ec) {
      *__dest_ec = __ec;
      return;
    }
    if (__ec && (!__allow_dne || !__is_dne_error(__ec)))
      __throw_filesystem_error(__msg, __p_, __ec);
  }

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  void __refresh(error_code* __ec = nullptr) {
    __handle_error("in directory_entry::refresh", __ec, __do_refresh(),
                                 true);
  }

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  file_type __get_sym_ft(error_code* __ec = nullptr) const {
    switch (__data_.__cache_type_) {
    case _Empty:
      return __symlink_status(__p_, __ec).type();
    case _IterSymlink:
    case _RefreshSymlink:
    case _RefreshSymlinkUnresolved:
      if (__ec)
        __ec->clear();
      return file_type::symlink;
    case _IterNonSymlink:
    case _RefreshNonSymlink:
      file_status __st(__data_.__type_);
      if (__ec && !std::__1::__fs::filesystem::exists(__st))
        *__ec = make_error_code(errc::no_such_file_or_directory);
      else if (__ec)
        __ec->clear();
      return __data_.__type_;
    }
    __builtin_unreachable();
  }

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  file_type __get_ft(error_code* __ec = nullptr) const {
    switch (__data_.__cache_type_) {
    case _Empty:
    case _IterSymlink:
    case _RefreshSymlinkUnresolved:
      return __status(__p_, __ec).type();
    case _IterNonSymlink:
    case _RefreshNonSymlink:
    case _RefreshSymlink: {
      file_status __st(__data_.__type_);
      if (__ec && !std::__1::__fs::filesystem::exists(__st))
        *__ec = make_error_code(errc::no_such_file_or_directory);
      else if (__ec)
        __ec->clear();
      return __data_.__type_;
    }
    }
    __builtin_unreachable();
  }

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  file_status __get_status(error_code* __ec = nullptr) const {
    switch (__data_.__cache_type_) {
    case _Empty:
    case _IterNonSymlink:
    case _IterSymlink:
    case _RefreshSymlinkUnresolved:
      return __status(__p_, __ec);
    case _RefreshNonSymlink:
    case _RefreshSymlink:
      return file_status(__get_ft(__ec), __data_.__non_sym_perms_);
    }
    __builtin_unreachable();
  }

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  file_status __get_symlink_status(error_code* __ec = nullptr) const {
    switch (__data_.__cache_type_) {
    case _Empty:
    case _IterNonSymlink:
    case _IterSymlink:
      return __symlink_status(__p_, __ec);
    case _RefreshNonSymlink:
      return file_status(__get_sym_ft(__ec), __data_.__non_sym_perms_);
    case _RefreshSymlink:
    case _RefreshSymlinkUnresolved:
      return file_status(__get_sym_ft(__ec), __data_.__sym_perms_);
    }
    __builtin_unreachable();
  }

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  uintmax_t __get_size(error_code* __ec = nullptr) const {
    switch (__data_.__cache_type_) {
    case _Empty:
    case _IterNonSymlink:
    case _IterSymlink:
    case _RefreshSymlinkUnresolved:
      return std::__1::__fs::filesystem::__file_size(__p_, __ec);
    case _RefreshSymlink:
    case _RefreshNonSymlink: {
      error_code __m_ec;
      file_status __st(__get_ft(&__m_ec));
      __handle_error("in directory_entry::file_size", __ec, __m_ec);
      if (std::__1::__fs::filesystem::exists(__st) && !std::__1::__fs::filesystem::is_regular_file(__st)) {
        errc __err_kind = std::__1::__fs::filesystem::is_directory(__st) ? errc::is_a_directory
                                                       : errc::not_supported;
        __handle_error("in directory_entry::file_size", __ec,
                       make_error_code(__err_kind));
      }
      return __data_.__size_;
    }
    }
    __builtin_unreachable();
  }

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  uintmax_t __get_nlink(error_code* __ec = nullptr) const {
    switch (__data_.__cache_type_) {
    case _Empty:
    case _IterNonSymlink:
    case _IterSymlink:
    case _RefreshSymlinkUnresolved:
      return std::__1::__fs::filesystem::__hard_link_count(__p_, __ec);
    case _RefreshSymlink:
    case _RefreshNonSymlink: {
      error_code __m_ec;
      (void)__get_ft(&__m_ec);
      __handle_error("in directory_entry::hard_link_count", __ec, __m_ec);
      return __data_.__nlink_;
    }
    }
    __builtin_unreachable();
  }

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  file_time_type __get_write_time(error_code* __ec = nullptr) const {
    switch (__data_.__cache_type_) {
    case _Empty:
    case _IterNonSymlink:
    case _IterSymlink:
    case _RefreshSymlinkUnresolved:
      return std::__1::__fs::filesystem::__last_write_time(__p_, __ec);
    case _RefreshSymlink:
    case _RefreshNonSymlink: {
      error_code __m_ec;
      file_status __st(__get_ft(&__m_ec));
      __handle_error("in directory_entry::last_write_time", __ec, __m_ec);
      if (std::__1::__fs::filesystem::exists(__st) &&
          __data_.__write_time_ == file_time_type::min())
        __handle_error("in directory_entry::last_write_time", __ec,
                       make_error_code(errc::value_too_large));
      return __data_.__write_time_;
    }
    }
    __builtin_unreachable();
  }

private:
  _Path __p_;
  __cached_data __data_;
};

class __dir_element_proxy {
public:
  inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) directory_entry operator*() {
    return std::__1::move(__elem_);
  }

private:
  friend class directory_iterator;
  friend class recursive_directory_iterator;
  explicit __dir_element_proxy(directory_entry const& __e) : __elem_(__e) {}
  __dir_element_proxy(__dir_element_proxy&& __o)
      : __elem_(std::__1::move(__o.__elem_)) {}
  directory_entry __elem_;
};

class directory_iterator {
public:
  typedef directory_entry value_type;
  typedef ptrdiff_t difference_type;
  typedef value_type const* pointer;
  typedef value_type const& reference;
  typedef input_iterator_tag iterator_category;

public:

  directory_iterator() noexcept {}

  explicit directory_iterator(const path& __p)
      : directory_iterator(__p, nullptr) {}

  directory_iterator(const path& __p, directory_options __opts)
      : directory_iterator(__p, nullptr, __opts) {}

  directory_iterator(const path& __p, error_code& __ec)
      : directory_iterator(__p, &__ec) {}

  directory_iterator(const path& __p, directory_options __opts,
                     error_code& __ec)
      : directory_iterator(__p, &__ec, __opts) {}

  directory_iterator(const directory_iterator&) = default;
  directory_iterator(directory_iterator&&) = default;
  directory_iterator& operator=(const directory_iterator&) = default;

  directory_iterator& operator=(directory_iterator&& __o) noexcept {

    if (this != &__o) {
      __imp_ = std::__1::move(__o.__imp_);
    }
    return *this;
  }

  ~directory_iterator() = default;

  const directory_entry& operator*() const {
    ((void)0);
    return __dereference();
  }

  const directory_entry* operator->() const { return &**this; }

  directory_iterator& operator++() { return __increment(); }

  __dir_element_proxy operator++(int) {
    __dir_element_proxy __p(**this);
    __increment();
    return __p;
  }

  directory_iterator& increment(error_code& __ec) { return __increment(&__ec); }

private:
  inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) friend bool
  operator==(const directory_iterator& __lhs,
             const directory_iterator& __rhs) noexcept;


  __attribute__ ((__visibility__("default")))
  directory_iterator(const path&, error_code*,
                     directory_options = directory_options::none);

  __attribute__ ((__visibility__("default")))
  directory_iterator& __increment(error_code* __ec = nullptr);

  __attribute__ ((__visibility__("default")))
  const directory_entry& __dereference() const;

private:
  shared_ptr<__dir_stream> __imp_;
};

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) bool
operator==(const directory_iterator& __lhs,
           const directory_iterator& __rhs) noexcept {
  return __lhs.__imp_ == __rhs.__imp_;
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) bool
operator!=(const directory_iterator& __lhs,
           const directory_iterator& __rhs) noexcept {
  return !(__lhs == __rhs);
}


inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) directory_iterator
begin(directory_iterator __iter) noexcept {
  return __iter;
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) directory_iterator
end(const directory_iterator&) noexcept {
  return directory_iterator();
}

class recursive_directory_iterator {
public:
  using value_type = directory_entry;
  using difference_type = ptrdiff_t;
  using pointer = directory_entry const*;
  using reference = directory_entry const&;
  using iterator_category = input_iterator_tag;

public:

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  recursive_directory_iterator() noexcept : __rec_(false) {}

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  explicit recursive_directory_iterator(
      const path& __p, directory_options __xoptions = directory_options::none)
      : recursive_directory_iterator(__p, __xoptions, nullptr) {}

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  recursive_directory_iterator(const path& __p, directory_options __xoptions,
                               error_code& __ec)
      : recursive_directory_iterator(__p, __xoptions, &__ec) {}

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  recursive_directory_iterator(const path& __p, error_code& __ec)
      : recursive_directory_iterator(__p, directory_options::none, &__ec) {}

  recursive_directory_iterator(const recursive_directory_iterator&) = default;
  recursive_directory_iterator(recursive_directory_iterator&&) = default;

  recursive_directory_iterator&
  operator=(const recursive_directory_iterator&) = default;

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  recursive_directory_iterator&
  operator=(recursive_directory_iterator&& __o) noexcept {

    if (this != &__o) {
      __imp_ = std::__1::move(__o.__imp_);
      __rec_ = __o.__rec_;
    }
    return *this;
  }

  ~recursive_directory_iterator() = default;

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  const directory_entry& operator*() const { return __dereference(); }

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  const directory_entry* operator->() const { return &__dereference(); }

  recursive_directory_iterator& operator++() { return __increment(); }

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  __dir_element_proxy operator++(int) {
    __dir_element_proxy __p(**this);
    __increment();
    return __p;
  }

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  recursive_directory_iterator& increment(error_code& __ec) {
    return __increment(&__ec);
  }

  __attribute__ ((__visibility__("default"))) directory_options options() const;
  __attribute__ ((__visibility__("default"))) int depth() const;

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  void pop() { __pop(); }

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  void pop(error_code& __ec) { __pop(&__ec); }

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  bool recursion_pending() const { return __rec_; }

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  void disable_recursion_pending() { __rec_ = false; }

private:
  __attribute__ ((__visibility__("default")))
  recursive_directory_iterator(const path& __p, directory_options __opt,
                               error_code* __ec);

  __attribute__ ((__visibility__("default")))
  const directory_entry& __dereference() const;

  __attribute__ ((__visibility__("default")))
  bool __try_recursion(error_code* __ec);

  __attribute__ ((__visibility__("default")))
  void __advance(error_code* __ec = nullptr);

  __attribute__ ((__visibility__("default")))
  recursive_directory_iterator& __increment(error_code* __ec = nullptr);

  __attribute__ ((__visibility__("default")))
  void __pop(error_code* __ec = nullptr);

  inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) friend bool
  operator==(const recursive_directory_iterator&,
             const recursive_directory_iterator&) noexcept;

  struct __attribute__ ((__visibility__("hidden"))) __shared_imp;
  shared_ptr<__shared_imp> __imp_;
  bool __rec_;
};

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) bool
operator==(const recursive_directory_iterator& __lhs,
           const recursive_directory_iterator& __rhs) noexcept {
  return __lhs.__imp_ == __rhs.__imp_;
}

__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
inline bool operator!=(const recursive_directory_iterator& __lhs,
                       const recursive_directory_iterator& __rhs) noexcept {
  return !(__lhs == __rhs);
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) recursive_directory_iterator
begin(recursive_directory_iterator __iter) noexcept {
  return __iter;
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) recursive_directory_iterator
end(const recursive_directory_iterator&) noexcept {
  return recursive_directory_iterator();
}

#pragma clang attribute pop
# 3008 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/filesystem" 3
#pragma clang attribute pop
# 3008 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/filesystem" 3
#pragma clang attribute pop
# 3008 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/filesystem" 3
#pragma clang attribute pop

} } } }
# 193 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/fstream" 2 3
# 197 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/fstream" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 201 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/fstream" 2 3





namespace std { inline namespace __1 {

template <class _CharT, class _Traits>
class __attribute__ ((__type_visibility__("default"))) basic_filebuf
    : public basic_streambuf<_CharT, _Traits>
{
public:
    typedef _CharT char_type;
    typedef _Traits traits_type;
    typedef typename traits_type::int_type int_type;
    typedef typename traits_type::pos_type pos_type;
    typedef typename traits_type::off_type off_type;
    typedef typename traits_type::state_type state_type;


    basic_filebuf();
    basic_filebuf(basic_filebuf&& __rhs);
    virtual ~basic_filebuf();


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    basic_filebuf& operator=(basic_filebuf&& __rhs);
    void swap(basic_filebuf& __rhs);


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    bool is_open() const;

    basic_filebuf* open(const char* __s, ios_base::openmode __mode);



    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    basic_filebuf* open(const string& __s, ios_base::openmode __mode);


    __attribute__((availability(macosx,strict,introduced=10.15))) __attribute__((availability(ios,strict,introduced=13.0))) __attribute__((availability(tvos,strict,introduced=13.0))) __attribute__((availability(watchos,strict,introduced=6.0))) __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    basic_filebuf* open(const std::__1::__fs::filesystem::path& __p, ios_base::openmode __mode) {
      return open(__p.c_str(), __mode);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    basic_filebuf* __open(int __fd, ios_base::openmode __mode);

    basic_filebuf* close();

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    inline static const char*
    __make_mdstring(ios_base::openmode __mode) noexcept;

  protected:

    virtual int_type underflow();
    virtual int_type pbackfail(int_type __c = traits_type::eof());
    virtual int_type overflow (int_type __c = traits_type::eof());
    virtual basic_streambuf<char_type, traits_type>* setbuf(char_type* __s, streamsize __n);
    virtual pos_type seekoff(off_type __off, ios_base::seekdir __way,
                             ios_base::openmode __wch = ios_base::in | ios_base::out);
    virtual pos_type seekpos(pos_type __sp,
                             ios_base::openmode __wch = ios_base::in | ios_base::out);
    virtual int sync();
    virtual void imbue(const locale& __loc);

private:
  char* __extbuf_;
  const char* __extbufnext_;
  const char* __extbufend_;
  char __extbuf_min_[8];
  size_t __ebs_;
  char_type* __intbuf_;
  size_t __ibs_;
  FILE* __file_;
  const codecvt<char_type, char, state_type>* __cv_;
  state_type __st_;
  state_type __st_last_;
  ios_base::openmode __om_;
  ios_base::openmode __cm_;
  bool __owns_eb_;
  bool __owns_ib_;
  bool __always_noconv_;

  bool __read_mode();
  void __write_mode();
};

template <class _CharT, class _Traits>
basic_filebuf<_CharT, _Traits>::basic_filebuf()
    : __extbuf_(nullptr),
      __extbufnext_(nullptr),
      __extbufend_(nullptr),
      __ebs_(0),
      __intbuf_(nullptr),
      __ibs_(0),
      __file_(nullptr),
      __cv_(nullptr),
      __st_(),
      __st_last_(),
      __om_(0),
      __cm_(0),
      __owns_eb_(false),
      __owns_ib_(false),
      __always_noconv_(false)
{
    if (has_facet<codecvt<char_type, char, state_type> >(this->getloc()))
    {
        __cv_ = &use_facet<codecvt<char_type, char, state_type> >(this->getloc());
        __always_noconv_ = __cv_->always_noconv();
    }
    setbuf(nullptr, 4096);
}

template <class _CharT, class _Traits>
basic_filebuf<_CharT, _Traits>::basic_filebuf(basic_filebuf&& __rhs)
    : basic_streambuf<_CharT, _Traits>(__rhs)
{
    if (__rhs.__extbuf_ == __rhs.__extbuf_min_)
    {
        __extbuf_ = __extbuf_min_;
        __extbufnext_ = __extbuf_ + (__rhs.__extbufnext_ - __rhs.__extbuf_);
        __extbufend_ = __extbuf_ + (__rhs.__extbufend_ - __rhs.__extbuf_);
    }
    else
    {
        __extbuf_ = __rhs.__extbuf_;
        __extbufnext_ = __rhs.__extbufnext_;
        __extbufend_ = __rhs.__extbufend_;
    }
    __ebs_ = __rhs.__ebs_;
    __intbuf_ = __rhs.__intbuf_;
    __ibs_ = __rhs.__ibs_;
    __file_ = __rhs.__file_;
    __cv_ = __rhs.__cv_;
    __st_ = __rhs.__st_;
    __st_last_ = __rhs.__st_last_;
    __om_ = __rhs.__om_;
    __cm_ = __rhs.__cm_;
    __owns_eb_ = __rhs.__owns_eb_;
    __owns_ib_ = __rhs.__owns_ib_;
    __always_noconv_ = __rhs.__always_noconv_;
    if (__rhs.pbase())
    {
        if (__rhs.pbase() == __rhs.__intbuf_)
            this->setp(__intbuf_, __intbuf_ + (__rhs. epptr() - __rhs.pbase()));
        else
            this->setp((char_type*)__extbuf_,
                       (char_type*)__extbuf_ + (__rhs. epptr() - __rhs.pbase()));
        this->__pbump(__rhs. pptr() - __rhs.pbase());
    }
    else if (__rhs.eback())
    {
        if (__rhs.eback() == __rhs.__intbuf_)
            this->setg(__intbuf_, __intbuf_ + (__rhs.gptr() - __rhs.eback()),
                                  __intbuf_ + (__rhs.egptr() - __rhs.eback()));
        else
            this->setg((char_type*)__extbuf_,
                       (char_type*)__extbuf_ + (__rhs.gptr() - __rhs.eback()),
                       (char_type*)__extbuf_ + (__rhs.egptr() - __rhs.eback()));
    }
    __rhs.__extbuf_ = nullptr;
    __rhs.__extbufnext_ = nullptr;
    __rhs.__extbufend_ = nullptr;
    __rhs.__ebs_ = 0;
    __rhs.__intbuf_ = 0;
    __rhs.__ibs_ = 0;
    __rhs.__file_ = nullptr;
    __rhs.__st_ = state_type();
    __rhs.__st_last_ = state_type();
    __rhs.__om_ = 0;
    __rhs.__cm_ = 0;
    __rhs.__owns_eb_ = false;
    __rhs.__owns_ib_ = false;
    __rhs.setg(0, 0, 0);
    __rhs.setp(0, 0);
}

template <class _CharT, class _Traits>
inline
basic_filebuf<_CharT, _Traits>&
basic_filebuf<_CharT, _Traits>::operator=(basic_filebuf&& __rhs)
{
    close();
    swap(__rhs);
    return *this;
}

template <class _CharT, class _Traits>
basic_filebuf<_CharT, _Traits>::~basic_filebuf()
{

    try
    {

        close();

    }
    catch (...)
    {
    }

    if (__owns_eb_)
        delete [] __extbuf_;
    if (__owns_ib_)
        delete [] __intbuf_;
}

template <class _CharT, class _Traits>
void
basic_filebuf<_CharT, _Traits>::swap(basic_filebuf& __rhs)
{
    basic_streambuf<char_type, traits_type>::swap(__rhs);
    if (__extbuf_ != __extbuf_min_ && __rhs.__extbuf_ != __rhs.__extbuf_min_)
    {
        std::__1::swap(__extbuf_, __rhs.__extbuf_);
        std::__1::swap(__extbufnext_, __rhs.__extbufnext_);
        std::__1::swap(__extbufend_, __rhs.__extbufend_);
    }
    else
    {
        ptrdiff_t __ln = __extbufnext_ - __extbuf_;
        ptrdiff_t __le = __extbufend_ - __extbuf_;
        ptrdiff_t __rn = __rhs.__extbufnext_ - __rhs.__extbuf_;
        ptrdiff_t __re = __rhs.__extbufend_ - __rhs.__extbuf_;
        if (__extbuf_ == __extbuf_min_ && __rhs.__extbuf_ != __rhs.__extbuf_min_)
        {
            __extbuf_ = __rhs.__extbuf_;
            __rhs.__extbuf_ = __rhs.__extbuf_min_;
        }
        else if (__extbuf_ != __extbuf_min_ && __rhs.__extbuf_ == __rhs.__extbuf_min_)
        {
            __rhs.__extbuf_ = __extbuf_;
            __extbuf_ = __extbuf_min_;
        }
        __extbufnext_ = __extbuf_ + __rn;
        __extbufend_ = __extbuf_ + __re;
        __rhs.__extbufnext_ = __rhs.__extbuf_ + __ln;
        __rhs.__extbufend_ = __rhs.__extbuf_ + __le;
    }
    std::__1::swap(__ebs_, __rhs.__ebs_);
    std::__1::swap(__intbuf_, __rhs.__intbuf_);
    std::__1::swap(__ibs_, __rhs.__ibs_);
    std::__1::swap(__file_, __rhs.__file_);
    std::__1::swap(__cv_, __rhs.__cv_);
    std::__1::swap(__st_, __rhs.__st_);
    std::__1::swap(__st_last_, __rhs.__st_last_);
    std::__1::swap(__om_, __rhs.__om_);
    std::__1::swap(__cm_, __rhs.__cm_);
    std::__1::swap(__owns_eb_, __rhs.__owns_eb_);
    std::__1::swap(__owns_ib_, __rhs.__owns_ib_);
    std::__1::swap(__always_noconv_, __rhs.__always_noconv_);
    if (this->eback() == (char_type*)__rhs.__extbuf_min_)
    {
        ptrdiff_t __n = this->gptr() - this->eback();
        ptrdiff_t __e = this->egptr() - this->eback();
        this->setg((char_type*)__extbuf_min_,
                   (char_type*)__extbuf_min_ + __n,
                   (char_type*)__extbuf_min_ + __e);
    }
    else if (this->pbase() == (char_type*)__rhs.__extbuf_min_)
    {
        ptrdiff_t __n = this->pptr() - this->pbase();
        ptrdiff_t __e = this->epptr() - this->pbase();
        this->setp((char_type*)__extbuf_min_,
                   (char_type*)__extbuf_min_ + __e);
        this->__pbump(__n);
    }
    if (__rhs.eback() == (char_type*)__extbuf_min_)
    {
        ptrdiff_t __n = __rhs.gptr() - __rhs.eback();
        ptrdiff_t __e = __rhs.egptr() - __rhs.eback();
        __rhs.setg((char_type*)__rhs.__extbuf_min_,
                   (char_type*)__rhs.__extbuf_min_ + __n,
                   (char_type*)__rhs.__extbuf_min_ + __e);
    }
    else if (__rhs.pbase() == (char_type*)__extbuf_min_)
    {
        ptrdiff_t __n = __rhs.pptr() - __rhs.pbase();
        ptrdiff_t __e = __rhs.epptr() - __rhs.pbase();
        __rhs.setp((char_type*)__rhs.__extbuf_min_,
                   (char_type*)__rhs.__extbuf_min_ + __e);
        __rhs.__pbump(__n);
    }
}

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void
swap(basic_filebuf<_CharT, _Traits>& __x, basic_filebuf<_CharT, _Traits>& __y)
{
    __x.swap(__y);
}

template <class _CharT, class _Traits>
inline
bool
basic_filebuf<_CharT, _Traits>::is_open() const
{
    return __file_ != nullptr;
}

template <class _CharT, class _Traits>
const char* basic_filebuf<_CharT, _Traits>::__make_mdstring(
    ios_base::openmode __mode) noexcept {
  switch (__mode & ~ios_base::ate) {
  case ios_base::out:
  case ios_base::out | ios_base::trunc:
    return "w" ;
  case ios_base::out | ios_base::app:
  case ios_base::app:
    return "a" ;
  case ios_base::in:
    return "r" ;
  case ios_base::in | ios_base::out:
    return "r+" ;
  case ios_base::in | ios_base::out | ios_base::trunc:
    return "w+" ;
  case ios_base::in | ios_base::out | ios_base::app:
  case ios_base::in | ios_base::app:
    return "a+" ;
  case ios_base::out | ios_base::binary:
  case ios_base::out | ios_base::trunc | ios_base::binary:
    return "wb" ;
  case ios_base::out | ios_base::app | ios_base::binary:
  case ios_base::app | ios_base::binary:
    return "ab" ;
  case ios_base::in | ios_base::binary:
    return "rb" ;
  case ios_base::in | ios_base::out | ios_base::binary:
    return "r+b" ;
  case ios_base::in | ios_base::out | ios_base::trunc | ios_base::binary:
    return "w+b" ;
  case ios_base::in | ios_base::out | ios_base::app | ios_base::binary:
  case ios_base::in | ios_base::app | ios_base::binary:
    return "a+b" ;
  default:
    return nullptr;
  }
  __builtin_unreachable();
}


template <class _CharT, class _Traits>
basic_filebuf<_CharT, _Traits>*
basic_filebuf<_CharT, _Traits>::open(const char* __s, ios_base::openmode __mode)
{
    basic_filebuf<_CharT, _Traits>* __rt = nullptr;
    if (__file_ == nullptr)
    {
      if (const char* __mdstr = __make_mdstring(__mode)) {
        __rt = this;
        __file_ = fopen(__s, __mdstr);
        if (__file_) {
          __om_ = __mode;
          if (__mode & ios_base::ate) {
            if (fseek(__file_, 0, 2)) {
              fclose(__file_);
              __file_ = nullptr;
              __rt = nullptr;
            }
          }
        } else
          __rt = nullptr;
      }
    }
    return __rt;
}

template <class _CharT, class _Traits>
inline
basic_filebuf<_CharT, _Traits>*
basic_filebuf<_CharT, _Traits>::__open(int __fd, ios_base::openmode __mode) {
  basic_filebuf<_CharT, _Traits>* __rt = nullptr;
  if (__file_ == nullptr) {
    if (const char* __mdstr = __make_mdstring(__mode)) {
      __rt = this;
      __file_ = fdopen(__fd, __mdstr);
      if (__file_) {
        __om_ = __mode;
        if (__mode & ios_base::ate) {
          if (fseek(__file_, 0, 2)) {
            fclose(__file_);
            __file_ = nullptr;
            __rt = nullptr;
          }
        }
      } else
        __rt = nullptr;
    }
  }
  return __rt;
}
# 681 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/fstream" 3
template <class _CharT, class _Traits>
inline
basic_filebuf<_CharT, _Traits>*
basic_filebuf<_CharT, _Traits>::open(const string& __s, ios_base::openmode __mode)
{
    return open(__s.c_str(), __mode);
}


template <class _CharT, class _Traits>
basic_filebuf<_CharT, _Traits>*
basic_filebuf<_CharT, _Traits>::close()
{
    basic_filebuf<_CharT, _Traits>* __rt = nullptr;
    if (__file_)
    {
        __rt = this;
        unique_ptr<FILE, int(*)(FILE*)> __h(__file_, fclose);
        if (sync())
            __rt = nullptr;
        if (fclose(__h.release()))
            __rt = nullptr;
        __file_ = nullptr;
        setbuf(0, 0);
    }
    return __rt;
}

template <class _CharT, class _Traits>
typename basic_filebuf<_CharT, _Traits>::int_type
basic_filebuf<_CharT, _Traits>::underflow()
{
    if (__file_ == nullptr)
        return traits_type::eof();
    bool __initial = __read_mode();
    char_type __1buf;
    if (this->gptr() == nullptr)
        this->setg(&__1buf, &__1buf+1, &__1buf+1);
    const size_t __unget_sz = __initial ? 0 : min<size_t>((this->egptr() - this->eback()) / 2, 4);
    int_type __c = traits_type::eof();
    if (this->gptr() == this->egptr())
    {
        std::__1::memmove(this->eback(), this->egptr() - __unget_sz, __unget_sz * sizeof(char_type));
        if (__always_noconv_)
        {
            size_t __nmemb = static_cast<size_t>(this->egptr() - this->eback() - __unget_sz);
            __nmemb = fread(this->eback() + __unget_sz, 1, __nmemb, __file_);
            if (__nmemb != 0)
            {
                this->setg(this->eback(),
                           this->eback() + __unget_sz,
                           this->eback() + __unget_sz + __nmemb);
                __c = traits_type::to_int_type(*this->gptr());
            }
        }
        else
        {
            ((void)0);
            if (__extbufend_ != __extbufnext_)
                std::__1::memmove(__extbuf_, __extbufnext_, __extbufend_ - __extbufnext_);
            __extbufnext_ = __extbuf_ + (__extbufend_ - __extbufnext_);
            __extbufend_ = __extbuf_ + (__extbuf_ == __extbuf_min_ ? sizeof(__extbuf_min_) : __ebs_);
            size_t __nmemb = std::__1::min(static_cast<size_t>(__ibs_ - __unget_sz),
                                 static_cast<size_t>(__extbufend_ - __extbufnext_));
            codecvt_base::result __r;
            __st_last_ = __st_;
            size_t __nr = fread((void*) const_cast<char *>(__extbufnext_), 1, __nmemb, __file_);
            if (__nr != 0)
            {
                if (!__cv_)
                    __throw_bad_cast();

                __extbufend_ = __extbufnext_ + __nr;
                char_type* __inext;
                __r = __cv_->in(__st_, __extbuf_, __extbufend_, __extbufnext_,
                                       this->eback() + __unget_sz,
                                       this->eback() + __ibs_, __inext);
                if (__r == codecvt_base::noconv)
                {
                    this->setg((char_type*)__extbuf_, (char_type*)__extbuf_,
                                          (char_type*)const_cast<char *>(__extbufend_));
                    __c = traits_type::to_int_type(*this->gptr());
                }
                else if (__inext != this->eback() + __unget_sz)
                {
                    this->setg(this->eback(), this->eback() + __unget_sz, __inext);
                    __c = traits_type::to_int_type(*this->gptr());
                }
            }
        }
    }
    else
        __c = traits_type::to_int_type(*this->gptr());
    if (this->eback() == &__1buf)
        this->setg(nullptr, nullptr, nullptr);
    return __c;
}

template <class _CharT, class _Traits>
typename basic_filebuf<_CharT, _Traits>::int_type
basic_filebuf<_CharT, _Traits>::pbackfail(int_type __c)
{
    if (__file_ && this->eback() < this->gptr())
    {
        if (traits_type::eq_int_type(__c, traits_type::eof()))
        {
            this->gbump(-1);
            return traits_type::not_eof(__c);
        }
        if ((__om_ & ios_base::out) ||
            traits_type::eq(traits_type::to_char_type(__c), this->gptr()[-1]))
        {
            this->gbump(-1);
            *this->gptr() = traits_type::to_char_type(__c);
            return __c;
        }
    }
    return traits_type::eof();
}

template <class _CharT, class _Traits>
typename basic_filebuf<_CharT, _Traits>::int_type
basic_filebuf<_CharT, _Traits>::overflow(int_type __c)
{
    if (__file_ == nullptr)
        return traits_type::eof();
    __write_mode();
    char_type __1buf;
    char_type* __pb_save = this->pbase();
    char_type* __epb_save = this->epptr();
    if (!traits_type::eq_int_type(__c, traits_type::eof()))
    {
        if (this->pptr() == nullptr)
            this->setp(&__1buf, &__1buf+1);
        *this->pptr() = traits_type::to_char_type(__c);
        this->pbump(1);
    }
    if (this->pptr() != this->pbase())
    {
        if (__always_noconv_)
        {
            size_t __nmemb = static_cast<size_t>(this->pptr() - this->pbase());
            if (fwrite(this->pbase(), sizeof(char_type), __nmemb, __file_) != __nmemb)
                return traits_type::eof();
        }
        else
        {
            char* __extbe = __extbuf_;
            codecvt_base::result __r;
            do
            {
                if (!__cv_)
                    __throw_bad_cast();

                const char_type* __e;
                __r = __cv_->out(__st_, this->pbase(), this->pptr(), __e,
                                        __extbuf_, __extbuf_ + __ebs_, __extbe);
                if (__e == this->pbase())
                    return traits_type::eof();
                if (__r == codecvt_base::noconv)
                {
                    size_t __nmemb = static_cast<size_t>(this->pptr() - this->pbase());
                    if (fwrite(this->pbase(), 1, __nmemb, __file_) != __nmemb)
                        return traits_type::eof();
                }
                else if (__r == codecvt_base::ok || __r == codecvt_base::partial)
                {
                    size_t __nmemb = static_cast<size_t>(__extbe - __extbuf_);
                    if (fwrite(__extbuf_, 1, __nmemb, __file_) != __nmemb)
                        return traits_type::eof();
                    if (__r == codecvt_base::partial)
                    {
                        this->setp(const_cast<char_type*>(__e), this->pptr());
                        this->__pbump(this->epptr() - this->pbase());
                    }
                }
                else
                    return traits_type::eof();
            } while (__r == codecvt_base::partial);
        }
        this->setp(__pb_save, __epb_save);
    }
    return traits_type::not_eof(__c);
}

template <class _CharT, class _Traits>
basic_streambuf<_CharT, _Traits>*
basic_filebuf<_CharT, _Traits>::setbuf(char_type* __s, streamsize __n)
{
    this->setg(nullptr, nullptr, nullptr);
    this->setp(nullptr, nullptr);
    if (__owns_eb_)
        delete [] __extbuf_;
    if (__owns_ib_)
        delete [] __intbuf_;
    __ebs_ = __n;
    if (__ebs_ > sizeof(__extbuf_min_))
    {
        if (__always_noconv_ && __s)
        {
            __extbuf_ = (char*)__s;
            __owns_eb_ = false;
        }
        else
        {
            __extbuf_ = new char[__ebs_];
            __owns_eb_ = true;
        }
    }
    else
    {
        __extbuf_ = __extbuf_min_;
        __ebs_ = sizeof(__extbuf_min_);
        __owns_eb_ = false;
    }
    if (!__always_noconv_)
    {
        __ibs_ = max<streamsize>(__n, sizeof(__extbuf_min_));
        if (__s && __ibs_ >= sizeof(__extbuf_min_))
        {
            __intbuf_ = __s;
            __owns_ib_ = false;
        }
        else
        {
            __intbuf_ = new char_type[__ibs_];
            __owns_ib_ = true;
        }
    }
    else
    {
        __ibs_ = 0;
        __intbuf_ = nullptr;
        __owns_ib_ = false;
    }
    return this;
}

template <class _CharT, class _Traits>
typename basic_filebuf<_CharT, _Traits>::pos_type
basic_filebuf<_CharT, _Traits>::seekoff(off_type __off, ios_base::seekdir __way,
                                        ios_base::openmode)
{
    if (!__cv_)
        __throw_bad_cast();

    int __width = __cv_->encoding();
    if (__file_ == nullptr || (__width <= 0 && __off != 0) || sync())
        return pos_type(off_type(-1));

    int __whence;
    switch (__way)
    {
    case ios_base::beg:
        __whence = 0;
        break;
    case ios_base::cur:
        __whence = 1;
        break;
    case ios_base::end:
        __whence = 2;
        break;
    default:
        return pos_type(off_type(-1));
    }





    if (fseeko(__file_, __width > 0 ? __width * __off : 0, __whence))
        return pos_type(off_type(-1));
    pos_type __r = ftello(__file_);

    __r.state(__st_);
    return __r;
}

template <class _CharT, class _Traits>
typename basic_filebuf<_CharT, _Traits>::pos_type
basic_filebuf<_CharT, _Traits>::seekpos(pos_type __sp, ios_base::openmode)
{
    if (__file_ == nullptr || sync())
        return pos_type(off_type(-1));




    if (fseeko(__file_, __sp, 0))
        return pos_type(off_type(-1));

    __st_ = __sp.state();
    return __sp;
}

template <class _CharT, class _Traits>
int
basic_filebuf<_CharT, _Traits>::sync()
{
    if (__file_ == nullptr)
        return 0;
    if (!__cv_)
        __throw_bad_cast();

    if (__cm_ & ios_base::out)
    {
        if (this->pptr() != this->pbase())
            if (overflow() == traits_type::eof())
                return -1;
        codecvt_base::result __r;
        do
        {
            char* __extbe;
            __r = __cv_->unshift(__st_, __extbuf_, __extbuf_ + __ebs_, __extbe);
            size_t __nmemb = static_cast<size_t>(__extbe - __extbuf_);
            if (fwrite(__extbuf_, 1, __nmemb, __file_) != __nmemb)
                return -1;
        } while (__r == codecvt_base::partial);
        if (__r == codecvt_base::error)
            return -1;
        if (fflush(__file_))
            return -1;
    }
    else if (__cm_ & ios_base::in)
    {
        off_type __c;
        state_type __state = __st_last_;
        bool __update_st = false;
        if (__always_noconv_)
            __c = this->egptr() - this->gptr();
        else
        {
            int __width = __cv_->encoding();
            __c = __extbufend_ - __extbufnext_;
            if (__width > 0)
                __c += __width * (this->egptr() - this->gptr());
            else
            {
                if (this->gptr() != this->egptr())
                {
                    const int __off = __cv_->length(__state, __extbuf_,
                                                     __extbufnext_,
                                                     this->gptr() - this->eback());
                    __c += __extbufnext_ - __extbuf_ - __off;
                    __update_st = true;
                }
            }
        }




        if (fseeko(__file_, -__c, 1))
            return -1;

        if (__update_st)
            __st_ = __state;
        __extbufnext_ = __extbufend_ = __extbuf_;
        this->setg(nullptr, nullptr, nullptr);
        __cm_ = 0;
    }
    return 0;
}

template <class _CharT, class _Traits>
void
basic_filebuf<_CharT, _Traits>::imbue(const locale& __loc)
{
    sync();
    __cv_ = &use_facet<codecvt<char_type, char, state_type> >(__loc);
    bool __old_anc = __always_noconv_;
    __always_noconv_ = __cv_->always_noconv();
    if (__old_anc != __always_noconv_)
    {
        this->setg(nullptr, nullptr, nullptr);
        this->setp(nullptr, nullptr);

        if (__always_noconv_)
        {
            if (__owns_eb_)
                delete [] __extbuf_;
            __owns_eb_ = __owns_ib_;
            __ebs_ = __ibs_;
            __extbuf_ = (char*)__intbuf_;
            __ibs_ = 0;
            __intbuf_ = nullptr;
            __owns_ib_ = false;
        }
        else
        {
            if (!__owns_eb_ && __extbuf_ != __extbuf_min_)
            {
                __ibs_ = __ebs_;
                __intbuf_ = (char_type*)__extbuf_;
                __owns_ib_ = false;
                __extbuf_ = new char[__ebs_];
                __owns_eb_ = true;
            }
            else
            {
                __ibs_ = __ebs_;
                __intbuf_ = new char_type[__ibs_];
                __owns_ib_ = true;
            }
        }
    }
}

template <class _CharT, class _Traits>
bool
basic_filebuf<_CharT, _Traits>::__read_mode()
{
    if (!(__cm_ & ios_base::in))
    {
        this->setp(nullptr, nullptr);
        if (__always_noconv_)
            this->setg((char_type*)__extbuf_,
                       (char_type*)__extbuf_ + __ebs_,
                       (char_type*)__extbuf_ + __ebs_);
        else
            this->setg(__intbuf_, __intbuf_ + __ibs_, __intbuf_ + __ibs_);
        __cm_ = ios_base::in;
        return true;
    }
    return false;
}

template <class _CharT, class _Traits>
void
basic_filebuf<_CharT, _Traits>::__write_mode()
{
    if (!(__cm_ & ios_base::out))
    {
        this->setg(nullptr, nullptr, nullptr);
        if (__ebs_ > sizeof(__extbuf_min_))
        {
            if (__always_noconv_)
                this->setp((char_type*)__extbuf_,
                           (char_type*)__extbuf_ + (__ebs_ - 1));
            else
                this->setp(__intbuf_, __intbuf_ + (__ibs_ - 1));
        }
        else
            this->setp(nullptr, nullptr);
        __cm_ = ios_base::out;
    }
}



template <class _CharT, class _Traits>
class __attribute__ ((__type_visibility__("default"))) basic_ifstream
    : public basic_istream<_CharT, _Traits>
{
public:
    typedef _CharT char_type;
    typedef _Traits traits_type;
    typedef typename traits_type::int_type int_type;
    typedef typename traits_type::pos_type pos_type;
    typedef typename traits_type::off_type off_type;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    basic_ifstream();

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit basic_ifstream(const char* __s, ios_base::openmode __mode = ios_base::in);




    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit basic_ifstream(const string& __s, ios_base::openmode __mode = ios_base::in);

    __attribute__((availability(macosx,strict,introduced=10.15))) __attribute__((availability(ios,strict,introduced=13.0))) __attribute__((availability(tvos,strict,introduced=13.0))) __attribute__((availability(watchos,strict,introduced=6.0))) __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit basic_ifstream(const filesystem::path& __p, ios_base::openmode __mode = ios_base::in)
      : basic_ifstream(__p.c_str(), __mode) {}


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    basic_ifstream(basic_ifstream&& __rhs);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    basic_ifstream& operator=(basic_ifstream&& __rhs);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void swap(basic_ifstream& __rhs);

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    basic_filebuf<char_type, traits_type>* rdbuf() const;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    bool is_open() const;

    void open(const char* __s, ios_base::openmode __mode = ios_base::in);



    void open(const string& __s, ios_base::openmode __mode = ios_base::in);

    __attribute__((availability(macosx,strict,introduced=10.15))) __attribute__((availability(ios,strict,introduced=13.0))) __attribute__((availability(tvos,strict,introduced=13.0))) __attribute__((availability(watchos,strict,introduced=6.0))) __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void open(const filesystem::path& __p,
              ios_base::openmode __mode = ios_base::in) {
      return open(__p.c_str(), __mode);
    }


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void __open(int __fd, ios_base::openmode __mode);

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void close();

private:
    basic_filebuf<char_type, traits_type> __sb_;
};

template <class _CharT, class _Traits>
inline
basic_ifstream<_CharT, _Traits>::basic_ifstream()
    : basic_istream<char_type, traits_type>(&__sb_)
{
}


template <class _CharT, class _Traits>
inline
basic_ifstream<_CharT, _Traits>::basic_ifstream(const char* __s, ios_base::openmode __mode)
    : basic_istream<char_type, traits_type>(&__sb_)
{
    if (__sb_.open(__s, __mode | ios_base::in) == nullptr)
        this->setstate(ios_base::failbit);
}
# 1222 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/fstream" 3
template <class _CharT, class _Traits>
inline
basic_ifstream<_CharT, _Traits>::basic_ifstream(const string& __s, ios_base::openmode __mode)
    : basic_istream<char_type, traits_type>(&__sb_)
{
    if (__sb_.open(__s, __mode | ios_base::in) == nullptr)
        this->setstate(ios_base::failbit);
}


template <class _CharT, class _Traits>
inline
basic_ifstream<_CharT, _Traits>::basic_ifstream(basic_ifstream&& __rhs)
    : basic_istream<char_type, traits_type>(std::__1::move(__rhs)),
      __sb_(std::__1::move(__rhs.__sb_))
{
    this->set_rdbuf(&__sb_);
}

template <class _CharT, class _Traits>
inline
basic_ifstream<_CharT, _Traits>&
basic_ifstream<_CharT, _Traits>::operator=(basic_ifstream&& __rhs)
{
    basic_istream<char_type, traits_type>::operator=(std::__1::move(__rhs));
    __sb_ = std::__1::move(__rhs.__sb_);
    return *this;
}

template <class _CharT, class _Traits>
inline
void
basic_ifstream<_CharT, _Traits>::swap(basic_ifstream& __rhs)
{
    basic_istream<char_type, traits_type>::swap(__rhs);
    __sb_.swap(__rhs.__sb_);
}

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void
swap(basic_ifstream<_CharT, _Traits>& __x, basic_ifstream<_CharT, _Traits>& __y)
{
    __x.swap(__y);
}

template <class _CharT, class _Traits>
inline
basic_filebuf<_CharT, _Traits>*
basic_ifstream<_CharT, _Traits>::rdbuf() const
{
    return const_cast<basic_filebuf<char_type, traits_type>*>(&__sb_);
}

template <class _CharT, class _Traits>
inline
bool
basic_ifstream<_CharT, _Traits>::is_open() const
{
    return __sb_.is_open();
}


template <class _CharT, class _Traits>
void
basic_ifstream<_CharT, _Traits>::open(const char* __s, ios_base::openmode __mode)
{
    if (__sb_.open(__s, __mode | ios_base::in))
        this->clear();
    else
        this->setstate(ios_base::failbit);
}
# 1307 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/fstream" 3
template <class _CharT, class _Traits>
void
basic_ifstream<_CharT, _Traits>::open(const string& __s, ios_base::openmode __mode)
{
    if (__sb_.open(__s, __mode | ios_base::in))
        this->clear();
    else
        this->setstate(ios_base::failbit);
}

template <class _CharT, class _Traits>
inline
void basic_ifstream<_CharT, _Traits>::__open(int __fd,
                                             ios_base::openmode __mode) {
  if (__sb_.__open(__fd, __mode | ios_base::in))
    this->clear();
  else
    this->setstate(ios_base::failbit);
}


template <class _CharT, class _Traits>
inline
void
basic_ifstream<_CharT, _Traits>::close()
{
    if (__sb_.close() == 0)
        this->setstate(ios_base::failbit);
}



template <class _CharT, class _Traits>
class __attribute__ ((__type_visibility__("default"))) basic_ofstream
    : public basic_ostream<_CharT, _Traits>
{
public:
    typedef _CharT char_type;
    typedef _Traits traits_type;
    typedef typename traits_type::int_type int_type;
    typedef typename traits_type::pos_type pos_type;
    typedef typename traits_type::off_type off_type;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    basic_ofstream();
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit basic_ofstream(const char* __s, ios_base::openmode __mode = ios_base::out);




    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit basic_ofstream(const string& __s, ios_base::openmode __mode = ios_base::out);


    __attribute__((availability(macosx,strict,introduced=10.15))) __attribute__((availability(ios,strict,introduced=13.0))) __attribute__((availability(tvos,strict,introduced=13.0))) __attribute__((availability(watchos,strict,introduced=6.0))) __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit basic_ofstream(const filesystem::path& __p, ios_base::openmode __mode = ios_base::out)
      : basic_ofstream(__p.c_str(), __mode) {}


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    basic_ofstream(basic_ofstream&& __rhs);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    basic_ofstream& operator=(basic_ofstream&& __rhs);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void swap(basic_ofstream& __rhs);

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    basic_filebuf<char_type, traits_type>* rdbuf() const;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    bool is_open() const;

    void open(const char* __s, ios_base::openmode __mode = ios_base::out);



    void open(const string& __s, ios_base::openmode __mode = ios_base::out);


    __attribute__((availability(macosx,strict,introduced=10.15))) __attribute__((availability(ios,strict,introduced=13.0))) __attribute__((availability(tvos,strict,introduced=13.0))) __attribute__((availability(watchos,strict,introduced=6.0))) __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void open(const filesystem::path& __p, ios_base::openmode __mode = ios_base::out)
    { return open(__p.c_str(), __mode); }


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void __open(int __fd, ios_base::openmode __mode);

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void close();

private:
    basic_filebuf<char_type, traits_type> __sb_;
};

template <class _CharT, class _Traits>
inline
basic_ofstream<_CharT, _Traits>::basic_ofstream()
    : basic_ostream<char_type, traits_type>(&__sb_)
{
}


template <class _CharT, class _Traits>
inline
basic_ofstream<_CharT, _Traits>::basic_ofstream(const char* __s, ios_base::openmode __mode)
    : basic_ostream<char_type, traits_type>(&__sb_)
{
    if (__sb_.open(__s, __mode | ios_base::out) == nullptr)
        this->setstate(ios_base::failbit);
}
# 1429 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/fstream" 3
template <class _CharT, class _Traits>
inline
basic_ofstream<_CharT, _Traits>::basic_ofstream(const string& __s, ios_base::openmode __mode)
    : basic_ostream<char_type, traits_type>(&__sb_)
{
    if (__sb_.open(__s, __mode | ios_base::out) == nullptr)
        this->setstate(ios_base::failbit);
}


template <class _CharT, class _Traits>
inline
basic_ofstream<_CharT, _Traits>::basic_ofstream(basic_ofstream&& __rhs)
    : basic_ostream<char_type, traits_type>(std::__1::move(__rhs)),
      __sb_(std::__1::move(__rhs.__sb_))
{
    this->set_rdbuf(&__sb_);
}

template <class _CharT, class _Traits>
inline
basic_ofstream<_CharT, _Traits>&
basic_ofstream<_CharT, _Traits>::operator=(basic_ofstream&& __rhs)
{
    basic_ostream<char_type, traits_type>::operator=(std::__1::move(__rhs));
    __sb_ = std::__1::move(__rhs.__sb_);
    return *this;
}

template <class _CharT, class _Traits>
inline
void
basic_ofstream<_CharT, _Traits>::swap(basic_ofstream& __rhs)
{
    basic_ostream<char_type, traits_type>::swap(__rhs);
    __sb_.swap(__rhs.__sb_);
}

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void
swap(basic_ofstream<_CharT, _Traits>& __x, basic_ofstream<_CharT, _Traits>& __y)
{
    __x.swap(__y);
}

template <class _CharT, class _Traits>
inline
basic_filebuf<_CharT, _Traits>*
basic_ofstream<_CharT, _Traits>::rdbuf() const
{
    return const_cast<basic_filebuf<char_type, traits_type>*>(&__sb_);
}

template <class _CharT, class _Traits>
inline
bool
basic_ofstream<_CharT, _Traits>::is_open() const
{
    return __sb_.is_open();
}


template <class _CharT, class _Traits>
void
basic_ofstream<_CharT, _Traits>::open(const char* __s, ios_base::openmode __mode)
{
    if (__sb_.open(__s, __mode | ios_base::out))
        this->clear();
    else
        this->setstate(ios_base::failbit);
}
# 1514 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/fstream" 3
template <class _CharT, class _Traits>
void
basic_ofstream<_CharT, _Traits>::open(const string& __s, ios_base::openmode __mode)
{
    if (__sb_.open(__s, __mode | ios_base::out))
        this->clear();
    else
        this->setstate(ios_base::failbit);
}

template <class _CharT, class _Traits>
inline
void basic_ofstream<_CharT, _Traits>::__open(int __fd,
                                             ios_base::openmode __mode) {
  if (__sb_.__open(__fd, __mode | ios_base::out))
    this->clear();
  else
    this->setstate(ios_base::failbit);
}


template <class _CharT, class _Traits>
inline
void
basic_ofstream<_CharT, _Traits>::close()
{
    if (__sb_.close() == nullptr)
        this->setstate(ios_base::failbit);
}



template <class _CharT, class _Traits>
class __attribute__ ((__type_visibility__("default"))) basic_fstream
    : public basic_iostream<_CharT, _Traits>
{
public:
    typedef _CharT char_type;
    typedef _Traits traits_type;
    typedef typename traits_type::int_type int_type;
    typedef typename traits_type::pos_type pos_type;
    typedef typename traits_type::off_type off_type;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    basic_fstream();

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit basic_fstream(const char* __s, ios_base::openmode __mode = ios_base::in | ios_base::out);




    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit basic_fstream(const string& __s, ios_base::openmode __mode = ios_base::in | ios_base::out);


    __attribute__((availability(macosx,strict,introduced=10.15))) __attribute__((availability(ios,strict,introduced=13.0))) __attribute__((availability(tvos,strict,introduced=13.0))) __attribute__((availability(watchos,strict,introduced=6.0))) __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit basic_fstream(const filesystem::path& __p, ios_base::openmode __mode = ios_base::in | ios_base::out)
      : basic_fstream(__p.c_str(), __mode) {}



    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    basic_fstream(basic_fstream&& __rhs);

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    basic_fstream& operator=(basic_fstream&& __rhs);

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void swap(basic_fstream& __rhs);

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    basic_filebuf<char_type, traits_type>* rdbuf() const;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    bool is_open() const;

    void open(const char* __s, ios_base::openmode __mode = ios_base::in | ios_base::out);



    void open(const string& __s, ios_base::openmode __mode = ios_base::in | ios_base::out);


    __attribute__((availability(macosx,strict,introduced=10.15))) __attribute__((availability(ios,strict,introduced=13.0))) __attribute__((availability(tvos,strict,introduced=13.0))) __attribute__((availability(watchos,strict,introduced=6.0))) __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void open(const filesystem::path& __p, ios_base::openmode __mode = ios_base::in|ios_base::out)
    { return open(__p.c_str(), __mode); }



    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void close();

private:
    basic_filebuf<char_type, traits_type> __sb_;
};

template <class _CharT, class _Traits>
inline
basic_fstream<_CharT, _Traits>::basic_fstream()
    : basic_iostream<char_type, traits_type>(&__sb_)
{
}


template <class _CharT, class _Traits>
inline
basic_fstream<_CharT, _Traits>::basic_fstream(const char* __s, ios_base::openmode __mode)
    : basic_iostream<char_type, traits_type>(&__sb_)
{
    if (__sb_.open(__s, __mode) == nullptr)
        this->setstate(ios_base::failbit);
}
# 1638 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/fstream" 3
template <class _CharT, class _Traits>
inline
basic_fstream<_CharT, _Traits>::basic_fstream(const string& __s, ios_base::openmode __mode)
    : basic_iostream<char_type, traits_type>(&__sb_)
{
    if (__sb_.open(__s, __mode) == nullptr)
        this->setstate(ios_base::failbit);
}


template <class _CharT, class _Traits>
inline
basic_fstream<_CharT, _Traits>::basic_fstream(basic_fstream&& __rhs)
    : basic_iostream<char_type, traits_type>(std::__1::move(__rhs)),
      __sb_(std::__1::move(__rhs.__sb_))
{
    this->set_rdbuf(&__sb_);
}

template <class _CharT, class _Traits>
inline
basic_fstream<_CharT, _Traits>&
basic_fstream<_CharT, _Traits>::operator=(basic_fstream&& __rhs)
{
    basic_iostream<char_type, traits_type>::operator=(std::__1::move(__rhs));
    __sb_ = std::__1::move(__rhs.__sb_);
    return *this;
}

template <class _CharT, class _Traits>
inline
void
basic_fstream<_CharT, _Traits>::swap(basic_fstream& __rhs)
{
    basic_iostream<char_type, traits_type>::swap(__rhs);
    __sb_.swap(__rhs.__sb_);
}

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void
swap(basic_fstream<_CharT, _Traits>& __x, basic_fstream<_CharT, _Traits>& __y)
{
    __x.swap(__y);
}

template <class _CharT, class _Traits>
inline
basic_filebuf<_CharT, _Traits>*
basic_fstream<_CharT, _Traits>::rdbuf() const
{
    return const_cast<basic_filebuf<char_type, traits_type>*>(&__sb_);
}

template <class _CharT, class _Traits>
inline
bool
basic_fstream<_CharT, _Traits>::is_open() const
{
    return __sb_.is_open();
}


template <class _CharT, class _Traits>
void
basic_fstream<_CharT, _Traits>::open(const char* __s, ios_base::openmode __mode)
{
    if (__sb_.open(__s, __mode))
        this->clear();
    else
        this->setstate(ios_base::failbit);
}
# 1723 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/fstream" 3
template <class _CharT, class _Traits>
void
basic_fstream<_CharT, _Traits>::open(const string& __s, ios_base::openmode __mode)
{
    if (__sb_.open(__s, __mode))
        this->clear();
    else
        this->setstate(ios_base::failbit);
}


template <class _CharT, class _Traits>
inline
void
basic_fstream<_CharT, _Traits>::close()
{
    if (__sb_.close() == nullptr)
        this->setstate(ios_base::failbit);
}


extern template class __attribute__ ((__visibility__("default"))) basic_ifstream<char>;
extern template class __attribute__ ((__visibility__("default"))) basic_ofstream<char>;
extern template class __attribute__ ((__visibility__("default"))) basic_filebuf<char>;


} }
# 134 "/usr/local/include/bits/stdc++.h" 2
# 148 "/usr/local/include/bits/stdc++.h"
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/iostream" 1 3
# 44 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/iostream" 3


namespace std { inline namespace __1 {


extern __attribute__ ((__visibility__("default"))) istream cin;

extern __attribute__ ((__visibility__("default"))) wistream wcin;



extern __attribute__ ((__visibility__("default"))) ostream cout;

extern __attribute__ ((__visibility__("default"))) wostream wcout;


extern __attribute__ ((__visibility__("default"))) ostream cerr;

extern __attribute__ ((__visibility__("default"))) wostream wcerr;

extern __attribute__ ((__visibility__("default"))) ostream clog;

extern __attribute__ ((__visibility__("default"))) wostream wclog;


} }
# 149 "/usr/local/include/bits/stdc++.h" 2
# 160 "/usr/local/include/bits/stdc++.h"
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/list" 1 3
# 190 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/list" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/memory" 1 3
# 974 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/memory" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 1 3
# 20 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/assert.h" 1 3 4
# 44 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/assert.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/stdlib.h" 1 3 4
# 45 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/assert.h" 2 3 4
# 81 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/assert.h" 3 4
extern "C" {
void __assert_rtn(const char *, const char *, int, const char *) __attribute__((__noreturn__)) __attribute__((__cold__)) __attribute__((__disable_tail_calls__));



}
# 21 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 2 3
# 24 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 3
# 975 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/memory" 2 3
# 191 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/list" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 1 3
# 192 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/list" 2 3
# 196 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/list" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 200 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/list" 2 3


namespace std { inline namespace __1 {

template <class _Tp, class _VoidPtr> struct __list_node;
template <class _Tp, class _VoidPtr> struct __list_node_base;

template <class _Tp, class _VoidPtr>
struct __list_node_pointer_traits {
  typedef typename __rebind_pointer<_VoidPtr, __list_node<_Tp, _VoidPtr> >::type
        __node_pointer;
  typedef typename __rebind_pointer<_VoidPtr, __list_node_base<_Tp, _VoidPtr> >::type
        __base_pointer;




  typedef typename conditional<
          is_pointer<_VoidPtr>::value,
          __base_pointer,
          __node_pointer
  >::type __link_pointer;


  typedef typename conditional<
          is_same<__link_pointer, __node_pointer>::value,
          __base_pointer,
          __node_pointer
  >::type __non_link_pointer;

  static __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  __link_pointer __unsafe_link_pointer_cast(__link_pointer __p) {
      return __p;
  }

  static __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  __link_pointer __unsafe_link_pointer_cast(__non_link_pointer __p) {
      return static_cast<__link_pointer>(static_cast<_VoidPtr>(__p));
  }

};

template <class _Tp, class _VoidPtr>
struct __list_node_base
{
    typedef __list_node_pointer_traits<_Tp, _VoidPtr> _NodeTraits;
    typedef typename _NodeTraits::__node_pointer __node_pointer;
    typedef typename _NodeTraits::__base_pointer __base_pointer;
    typedef typename _NodeTraits::__link_pointer __link_pointer;

    __link_pointer __prev_;
    __link_pointer __next_;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __list_node_base() : __prev_(_NodeTraits::__unsafe_link_pointer_cast(__self())),
                         __next_(_NodeTraits::__unsafe_link_pointer_cast(__self())) {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __base_pointer __self() {
        return pointer_traits<__base_pointer>::pointer_to(*this);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __node_pointer __as_node() {
        return static_cast<__node_pointer>(__self());
    }
};

template <class _Tp, class _VoidPtr>
struct __attribute__((__standalone_debug__)) __list_node
    : public __list_node_base<_Tp, _VoidPtr>
{
    _Tp __value_;

    typedef __list_node_base<_Tp, _VoidPtr> __base;
    typedef typename __base::__link_pointer __link_pointer;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __link_pointer __as_link() {
        return static_cast<__link_pointer>(__base::__self());
    }
};

template <class _Tp, class _Alloc = allocator<_Tp> > class __attribute__ ((__type_visibility__("default"))) list;
template <class _Tp, class _Alloc> class __list_imp;
template <class _Tp, class _VoidPtr> class __attribute__ ((__type_visibility__("default"))) __list_const_iterator;

template <class _Tp, class _VoidPtr>
class __attribute__ ((__type_visibility__("default"))) __list_iterator
{
    typedef __list_node_pointer_traits<_Tp, _VoidPtr> _NodeTraits;
    typedef typename _NodeTraits::__link_pointer __link_pointer;

    __link_pointer __ptr_;
# 303 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/list" 3
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit __list_iterator(__link_pointer __p) noexcept : __ptr_(__p) {}




    template<class, class> friend class list;
    template<class, class> friend class __list_imp;
    template<class, class> friend class __list_const_iterator;
public:
    typedef bidirectional_iterator_tag iterator_category;
    typedef _Tp value_type;
    typedef value_type& reference;
    typedef typename __rebind_pointer<_VoidPtr, value_type>::type pointer;
    typedef typename pointer_traits<pointer>::difference_type difference_type;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __list_iterator() noexcept : __ptr_(nullptr)
    {



    }
# 355 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/list" 3
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    reference operator*() const
    {




        return __ptr_->__as_node()->__value_;
    }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    pointer operator->() const
    {




        return pointer_traits<pointer>::pointer_to(__ptr_->__as_node()->__value_);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __list_iterator& operator++()
    {




        __ptr_ = __ptr_->__next_;
        return *this;
    }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __list_iterator operator++(int) {__list_iterator __t(*this); ++(*this); return __t;}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __list_iterator& operator--()
    {




        __ptr_ = __ptr_->__prev_;
        return *this;
    }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __list_iterator operator--(int) {__list_iterator __t(*this); --(*this); return __t;}

    friend __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    bool operator==(const __list_iterator& __x, const __list_iterator& __y)
    {
        return __x.__ptr_ == __y.__ptr_;
    }
    friend __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
     bool operator!=(const __list_iterator& __x, const __list_iterator& __y)
        {return !(__x == __y);}
};

template <class _Tp, class _VoidPtr>
class __attribute__ ((__type_visibility__("default"))) __list_const_iterator
{
    typedef __list_node_pointer_traits<_Tp, _VoidPtr> _NodeTraits;
    typedef typename _NodeTraits::__link_pointer __link_pointer;

    __link_pointer __ptr_;
# 426 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/list" 3
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit __list_const_iterator(__link_pointer __p) noexcept : __ptr_(__p) {}


    template<class, class> friend class list;
    template<class, class> friend class __list_imp;
public:
    typedef bidirectional_iterator_tag iterator_category;
    typedef _Tp value_type;
    typedef const value_type& reference;
    typedef typename __rebind_pointer<_VoidPtr, const value_type>::type pointer;
    typedef typename pointer_traits<pointer>::difference_type difference_type;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __list_const_iterator() noexcept : __ptr_(nullptr)
    {



    }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __list_const_iterator(const __list_iterator<_Tp, _VoidPtr>& __p) noexcept
        : __ptr_(__p.__ptr_)
    {



    }
# 482 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/list" 3
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    reference operator*() const
    {




        return __ptr_->__as_node()->__value_;
    }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    pointer operator->() const
    {




        return pointer_traits<pointer>::pointer_to(__ptr_->__as_node()->__value_);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __list_const_iterator& operator++()
    {




        __ptr_ = __ptr_->__next_;
        return *this;
    }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __list_const_iterator operator++(int) {__list_const_iterator __t(*this); ++(*this); return __t;}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __list_const_iterator& operator--()
    {




        __ptr_ = __ptr_->__prev_;
        return *this;
    }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __list_const_iterator operator--(int) {__list_const_iterator __t(*this); --(*this); return __t;}

    friend __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    bool operator==(const __list_const_iterator& __x, const __list_const_iterator& __y)
    {
        return __x.__ptr_ == __y.__ptr_;
    }
    friend __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    bool operator!=(const __list_const_iterator& __x, const __list_const_iterator& __y)
        {return !(__x == __y);}
};

template <class _Tp, class _Alloc>
class __list_imp
{
    __list_imp(const __list_imp&);
    __list_imp& operator=(const __list_imp&);
public:
    typedef _Alloc allocator_type;
    typedef allocator_traits<allocator_type> __alloc_traits;
    typedef typename __alloc_traits::size_type size_type;
protected:
    typedef _Tp value_type;
    typedef typename __alloc_traits::void_pointer __void_pointer;
    typedef __list_iterator<value_type, __void_pointer> iterator;
    typedef __list_const_iterator<value_type, __void_pointer> const_iterator;
    typedef __list_node_base<value_type, __void_pointer> __node_base;
    typedef __list_node<value_type, __void_pointer> __node;
    typedef typename __rebind_alloc_helper<__alloc_traits, __node>::type __node_allocator;
    typedef allocator_traits<__node_allocator> __node_alloc_traits;
    typedef typename __node_alloc_traits::pointer __node_pointer;
    typedef typename __node_alloc_traits::pointer __node_const_pointer;
    typedef __list_node_pointer_traits<value_type, __void_pointer> __node_pointer_traits;
    typedef typename __node_pointer_traits::__link_pointer __link_pointer;
    typedef __link_pointer __link_const_pointer;
    typedef typename __alloc_traits::pointer pointer;
    typedef typename __alloc_traits::const_pointer const_pointer;
    typedef typename __alloc_traits::difference_type difference_type;

    typedef typename __rebind_alloc_helper<__alloc_traits, __node_base>::type __node_base_allocator;
    typedef typename allocator_traits<__node_base_allocator>::pointer __node_base_pointer;
    static_assert((!is_same<allocator_type, __node_allocator>::value),
                  "internal allocator type must differ from user-specified "
                  "type; otherwise overload resolution breaks");

    __node_base __end_;
    __compressed_pair<size_type, __node_allocator> __size_alloc_;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __link_pointer __end_as_link() const noexcept {
        return __node_pointer_traits::__unsafe_link_pointer_cast(
                const_cast<__node_base&>(__end_).__self());
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
          size_type& __sz() noexcept {return __size_alloc_.first();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const size_type& __sz() const noexcept
        {return __size_alloc_.first();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
          __node_allocator& __node_alloc() noexcept
          {return __size_alloc_.second();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const __node_allocator& __node_alloc() const noexcept
        {return __size_alloc_.second();}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_type __node_alloc_max_size() const noexcept {
        return __node_alloc_traits::max_size(__node_alloc());
    }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    static void __unlink_nodes(__link_pointer __f, __link_pointer __l) noexcept;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __list_imp()
        noexcept(is_nothrow_default_constructible<__node_allocator>::value);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __list_imp(const allocator_type& __a);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __list_imp(const __node_allocator& __a);

    __list_imp(__node_allocator&& __a) noexcept;

    ~__list_imp();
    void clear() noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    bool empty() const noexcept {return __sz() == 0;}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iterator begin() noexcept
    {



        return iterator(__end_.__next_);

    }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_iterator begin() const noexcept
    {



        return const_iterator(__end_.__next_);

    }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iterator end() noexcept
    {



        return iterator(__end_as_link());

    }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_iterator end() const noexcept
    {



        return const_iterator(__end_as_link());

    }

    void swap(__list_imp& __c)

        noexcept;





    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void __copy_assign_alloc(const __list_imp& __c)
        {__copy_assign_alloc(__c, integral_constant<bool,
                      __node_alloc_traits::propagate_on_container_copy_assignment::value>());}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void __move_assign_alloc(__list_imp& __c)
        noexcept(!__node_alloc_traits::propagate_on_container_move_assignment::value || is_nothrow_move_assignable<__node_allocator>::value)


        {__move_assign_alloc(__c, integral_constant<bool,
                      __node_alloc_traits::propagate_on_container_move_assignment::value>());}

private:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void __copy_assign_alloc(const __list_imp& __c, true_type)
        {
            if (__node_alloc() != __c.__node_alloc())
                clear();
            __node_alloc() = __c.__node_alloc();
        }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void __copy_assign_alloc(const __list_imp&, false_type)
        {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void __move_assign_alloc(__list_imp& __c, true_type)
        noexcept(is_nothrow_move_assignable<__node_allocator>::value)
        {
            __node_alloc() = std::__1::move(__c.__node_alloc());
        }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void __move_assign_alloc(__list_imp&, false_type)
        noexcept
        {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void __invalidate_all_iterators() {



    }
};


template <class _Tp, class _Alloc>
inline
void
__list_imp<_Tp, _Alloc>::__unlink_nodes(__link_pointer __f, __link_pointer __l)
    noexcept
{
    __f->__prev_->__next_ = __l->__next_;
    __l->__next_->__prev_ = __f->__prev_;
}

template <class _Tp, class _Alloc>
inline
__list_imp<_Tp, _Alloc>::__list_imp()
        noexcept(is_nothrow_default_constructible<__node_allocator>::value)
    : __size_alloc_(0, __default_init_tag())
{
}

template <class _Tp, class _Alloc>
inline
__list_imp<_Tp, _Alloc>::__list_imp(const allocator_type& __a)
    : __size_alloc_(0, __node_allocator(__a))
{
}

template <class _Tp, class _Alloc>
inline __list_imp<_Tp, _Alloc>::__list_imp(const __node_allocator& __a)
    : __size_alloc_(0, __a) {}


template <class _Tp, class _Alloc>
inline __list_imp<_Tp, _Alloc>::__list_imp(__node_allocator&& __a) noexcept
    : __size_alloc_(0, std::__1::move(__a)) {}


template <class _Tp, class _Alloc>
__list_imp<_Tp, _Alloc>::~__list_imp() {
  clear();



}

template <class _Tp, class _Alloc>
void
__list_imp<_Tp, _Alloc>::clear() noexcept
{
    if (!empty())
    {
        __node_allocator& __na = __node_alloc();
        __link_pointer __f = __end_.__next_;
        __link_pointer __l = __end_as_link();
        __unlink_nodes(__f, __l->__prev_);
        __sz() = 0;
        while (__f != __l)
        {
            __node_pointer __np = __f->__as_node();
            __f = __f->__next_;
            __node_alloc_traits::destroy(__na, std::__1::addressof(__np->__value_));
            __node_alloc_traits::deallocate(__na, __np, 1);
        }
        __invalidate_all_iterators();
    }
}

template <class _Tp, class _Alloc>
void
__list_imp<_Tp, _Alloc>::swap(__list_imp& __c)

        noexcept




{
    ((void)0);



    using std::__1::swap;
    std::__1::__swap_allocator(__node_alloc(), __c.__node_alloc());
    swap(__sz(), __c.__sz());
    swap(__end_, __c.__end_);
    if (__sz() == 0)
        __end_.__next_ = __end_.__prev_ = __end_as_link();
    else
        __end_.__prev_->__next_ = __end_.__next_->__prev_ = __end_as_link();
    if (__c.__sz() == 0)
        __c.__end_.__next_ = __c.__end_.__prev_ = __c.__end_as_link();
    else
        __c.__end_.__prev_->__next_ = __c.__end_.__next_->__prev_ = __c.__end_as_link();
# 832 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/list" 3
}

template <class _Tp, class _Alloc >
class __attribute__ ((__type_visibility__("default"))) list
    : private __list_imp<_Tp, _Alloc>
{
    typedef __list_imp<_Tp, _Alloc> base;
    typedef typename base::__node __node;
    typedef typename base::__node_allocator __node_allocator;
    typedef typename base::__node_pointer __node_pointer;
    typedef typename base::__node_alloc_traits __node_alloc_traits;
    typedef typename base::__node_base __node_base;
    typedef typename base::__node_base_pointer __node_base_pointer;
    typedef typename base::__link_pointer __link_pointer;

public:
    typedef _Tp value_type;
    typedef _Alloc allocator_type;
    static_assert((is_same<value_type, typename allocator_type::value_type>::value),
                  "Invalid allocator::value_type");
    typedef value_type& reference;
    typedef const value_type& const_reference;
    typedef typename base::pointer pointer;
    typedef typename base::const_pointer const_pointer;
    typedef typename base::size_type size_type;
    typedef typename base::difference_type difference_type;
    typedef typename base::iterator iterator;
    typedef typename base::const_iterator const_iterator;
    typedef std::__1::reverse_iterator<iterator> reverse_iterator;
    typedef std::__1::reverse_iterator<const_iterator> const_reverse_iterator;



    typedef void __remove_return_type;


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    list()
        noexcept(is_nothrow_default_constructible<__node_allocator>::value)
    {



    }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit list(const allocator_type& __a) : base(__a)
    {



    }
    explicit list(size_type __n);

    explicit list(size_type __n, const allocator_type& __a);

    list(size_type __n, const value_type& __x);
    list(size_type __n, const value_type& __x, const allocator_type& __a);
    template <class _InpIter>
        list(_InpIter __f, _InpIter __l,
             typename enable_if<__is_cpp17_input_iterator<_InpIter>::value>::type* = 0);
    template <class _InpIter>
        list(_InpIter __f, _InpIter __l, const allocator_type& __a,
             typename enable_if<__is_cpp17_input_iterator<_InpIter>::value>::type* = 0);

    list(const list& __c);
    list(const list& __c, const __identity_t<allocator_type>& __a);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    list& operator=(const list& __c);

    list(initializer_list<value_type> __il);
    list(initializer_list<value_type> __il, const allocator_type& __a);

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    list(list&& __c)
        noexcept(is_nothrow_move_constructible<__node_allocator>::value);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    list(list&& __c, const __identity_t<allocator_type>& __a);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    list& operator=(list&& __c)
        noexcept(__node_alloc_traits::propagate_on_container_move_assignment::value && is_nothrow_move_assignable<__node_allocator>::value);



    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    list& operator=(initializer_list<value_type> __il)
        {assign(__il.begin(), __il.end()); return *this;}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void assign(initializer_list<value_type> __il)
        {assign(__il.begin(), __il.end());}


    template <class _InpIter>
        void assign(_InpIter __f, _InpIter __l,
             typename enable_if<__is_cpp17_input_iterator<_InpIter>::value>::type* = 0);
    void assign(size_type __n, const value_type& __x);

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    allocator_type get_allocator() const noexcept;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_type size() const noexcept {return base::__sz();}
                                  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    bool empty() const noexcept {return base::empty();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_type max_size() const noexcept
        {
            return std::__1::min<size_type>(
                base::__node_alloc_max_size(),
                numeric_limits<difference_type >::max());
        }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
          iterator begin() noexcept {return base::begin();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_iterator begin() const noexcept {return base::begin();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
          iterator end() noexcept {return base::end();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_iterator end() const noexcept {return base::end();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_iterator cbegin() const noexcept {return base::begin();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_iterator cend() const noexcept {return base::end();}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
          reverse_iterator rbegin() noexcept
            {return reverse_iterator(end());}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_reverse_iterator rbegin() const noexcept
        {return const_reverse_iterator(end());}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
          reverse_iterator rend() noexcept
            {return reverse_iterator(begin());}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_reverse_iterator rend() const noexcept
        {return const_reverse_iterator(begin());}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_reverse_iterator crbegin() const noexcept
        {return const_reverse_iterator(end());}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_reverse_iterator crend() const noexcept
        {return const_reverse_iterator(begin());}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    reference front()
    {
        ((void)0);
        return base::__end_.__next_->__as_node()->__value_;
    }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_reference front() const
    {
        ((void)0);
        return base::__end_.__next_->__as_node()->__value_;
    }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    reference back()
    {
        ((void)0);
        return base::__end_.__prev_->__as_node()->__value_;
    }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_reference back() const
    {
        ((void)0);
        return base::__end_.__prev_->__as_node()->__value_;
    }


    void push_front(value_type&& __x);
    void push_back(value_type&& __x);

    template <class... _Args>

       reference emplace_front(_Args&&... __args);



    template <class... _Args>

        reference emplace_back(_Args&&... __args);



    template <class... _Args>
        iterator emplace(const_iterator __p, _Args&&... __args);

    iterator insert(const_iterator __p, value_type&& __x);

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iterator insert(const_iterator __p, initializer_list<value_type> __il)
        {return insert(__p, __il.begin(), __il.end());}


    void push_front(const value_type& __x);
    void push_back(const value_type& __x);


    template <class _Arg>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void __emplace_back(_Arg&& __arg) { emplace_back(std::__1::forward<_Arg>(__arg)); }





    iterator insert(const_iterator __p, const value_type& __x);
    iterator insert(const_iterator __p, size_type __n, const value_type& __x);
    template <class _InpIter>
        iterator insert(const_iterator __p, _InpIter __f, _InpIter __l,
             typename enable_if<__is_cpp17_input_iterator<_InpIter>::value>::type* = 0);

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void swap(list& __c)

        noexcept




        {base::swap(__c);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void clear() noexcept {base::clear();}

    void pop_front();
    void pop_back();

    iterator erase(const_iterator __p);
    iterator erase(const_iterator __f, const_iterator __l);

    void resize(size_type __n);
    void resize(size_type __n, const value_type& __x);

    void splice(const_iterator __p, list& __c);

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void splice(const_iterator __p, list&& __c) {splice(__p, __c);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void splice(const_iterator __p, list&& __c, const_iterator __i)
        {splice(__p, __c, __i);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void splice(const_iterator __p, list&& __c, const_iterator __f, const_iterator __l)
        {splice(__p, __c, __f, __l);}

    void splice(const_iterator __p, list& __c, const_iterator __i);
    void splice(const_iterator __p, list& __c, const_iterator __f, const_iterator __l);

    __remove_return_type remove(const value_type& __x);
    template <class _Pred> __remove_return_type remove_if(_Pred __pred);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __remove_return_type unique() { return unique(__equal_to<value_type>()); }
    template <class _BinaryPred>
        __remove_return_type unique(_BinaryPred __binary_pred);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void merge(list& __c);

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void merge(list&& __c) {merge(__c);}

    template <class _Comp>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        void merge(list&& __c, _Comp __comp) {merge(__c, __comp);}

    template <class _Comp>
        void merge(list& __c, _Comp __comp);

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void sort();
    template <class _Comp>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        void sort(_Comp __comp);

    void reverse() noexcept;

    bool __invariants() const;

    typedef __allocator_destructor<__node_allocator> __node_destructor;
    typedef unique_ptr<__node, __node_destructor> __hold_pointer;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __hold_pointer __allocate_node(__node_allocator& __na) {
      __node_pointer __p = __node_alloc_traits::allocate(__na, 1);
      __p->__prev_ = nullptr;
      return __hold_pointer(__p, __node_destructor(__na, 1));
    }
# 1128 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/list" 3
private:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    static void __link_nodes (__link_pointer __p, __link_pointer __f, __link_pointer __l);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void __link_nodes_at_front(__link_pointer __f, __link_pointer __l);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void __link_nodes_at_back (__link_pointer __f, __link_pointer __l);
    iterator __iterator(size_type __n);
    template <class _Comp>
        static iterator __sort(iterator __f1, iterator __e2, size_type __n, _Comp& __comp);

    void __move_assign(list& __c, true_type)
        noexcept(is_nothrow_move_assignable<__node_allocator>::value);
    void __move_assign(list& __c, false_type);
};


template<class _InputIterator,
         class _Alloc = allocator<__iter_value_type<_InputIterator>>,
         class = _EnableIf<__is_allocator<_Alloc>::value>
         >
list(_InputIterator, _InputIterator)
  -> list<__iter_value_type<_InputIterator>, _Alloc>;

template<class _InputIterator,
         class _Alloc,
         class = _EnableIf<__is_allocator<_Alloc>::value>
         >
list(_InputIterator, _InputIterator, _Alloc)
  -> list<__iter_value_type<_InputIterator>, _Alloc>;



template <class _Tp, class _Alloc>
inline
void
list<_Tp, _Alloc>::__link_nodes(__link_pointer __p, __link_pointer __f, __link_pointer __l)
{
    __p->__prev_->__next_ = __f;
    __f->__prev_ = __p->__prev_;
    __p->__prev_ = __l;
    __l->__next_ = __p;
}


template <class _Tp, class _Alloc>
inline
void
list<_Tp, _Alloc>::__link_nodes_at_front(__link_pointer __f, __link_pointer __l)
{
    __f->__prev_ = base::__end_as_link();
    __l->__next_ = base::__end_.__next_;
    __l->__next_->__prev_ = __l;
    base::__end_.__next_ = __f;
}


template <class _Tp, class _Alloc>
inline
void
list<_Tp, _Alloc>::__link_nodes_at_back(__link_pointer __f, __link_pointer __l)
{
    __l->__next_ = base::__end_as_link();
    __f->__prev_ = base::__end_.__prev_;
    __f->__prev_->__next_ = __f;
    base::__end_.__prev_ = __l;
}


template <class _Tp, class _Alloc>
inline
typename list<_Tp, _Alloc>::iterator
list<_Tp, _Alloc>::__iterator(size_type __n)
{
    return __n <= base::__sz() / 2 ? std::__1::next(begin(), __n)
                                   : std::__1::prev(end(), base::__sz() - __n);
}

template <class _Tp, class _Alloc>
list<_Tp, _Alloc>::list(size_type __n)
{



    for (; __n > 0; --__n)

        emplace_back();



}


template <class _Tp, class _Alloc>
list<_Tp, _Alloc>::list(size_type __n, const allocator_type& __a) : base(__a)
{



    for (; __n > 0; --__n)
        emplace_back();
}


template <class _Tp, class _Alloc>
list<_Tp, _Alloc>::list(size_type __n, const value_type& __x)
{



    for (; __n > 0; --__n)
        push_back(__x);
}

template <class _Tp, class _Alloc>
list<_Tp, _Alloc>::list(size_type __n, const value_type& __x, const allocator_type& __a)
    : base(__a)
{



    for (; __n > 0; --__n)
        push_back(__x);
}

template <class _Tp, class _Alloc>
template <class _InpIter>
list<_Tp, _Alloc>::list(_InpIter __f, _InpIter __l,
                        typename enable_if<__is_cpp17_input_iterator<_InpIter>::value>::type*)
{



    for (; __f != __l; ++__f)
        __emplace_back(*__f);
}

template <class _Tp, class _Alloc>
template <class _InpIter>
list<_Tp, _Alloc>::list(_InpIter __f, _InpIter __l, const allocator_type& __a,
                        typename enable_if<__is_cpp17_input_iterator<_InpIter>::value>::type*)
    : base(__a)
{



    for (; __f != __l; ++__f)
        __emplace_back(*__f);
}

template <class _Tp, class _Alloc>
list<_Tp, _Alloc>::list(const list& __c)
    : base(__node_alloc_traits::select_on_container_copy_construction(
          __c.__node_alloc())) {



    for (const_iterator __i = __c.begin(), __e = __c.end(); __i != __e; ++__i)
        push_back(*__i);
}

template <class _Tp, class _Alloc>
list<_Tp, _Alloc>::list(const list& __c, const __identity_t<allocator_type>& __a)
    : base(__a)
{



    for (const_iterator __i = __c.begin(), __e = __c.end(); __i != __e; ++__i)
        push_back(*__i);
}



template <class _Tp, class _Alloc>
list<_Tp, _Alloc>::list(initializer_list<value_type> __il, const allocator_type& __a)
    : base(__a)
{



    for (typename initializer_list<value_type>::const_iterator __i = __il.begin(),
            __e = __il.end(); __i != __e; ++__i)
        push_back(*__i);
}

template <class _Tp, class _Alloc>
list<_Tp, _Alloc>::list(initializer_list<value_type> __il)
{



    for (typename initializer_list<value_type>::const_iterator __i = __il.begin(),
            __e = __il.end(); __i != __e; ++__i)
        push_back(*__i);
}

template <class _Tp, class _Alloc>
inline list<_Tp, _Alloc>::list(list&& __c)
    noexcept(is_nothrow_move_constructible<__node_allocator>::value)
    : base(std::__1::move(__c.__node_alloc())) {



    splice(end(), __c);
}

template <class _Tp, class _Alloc>
inline
list<_Tp, _Alloc>::list(list&& __c, const __identity_t<allocator_type>& __a)
    : base(__a)
{



    if (__a == __c.get_allocator())
        splice(end(), __c);
    else
    {
        typedef move_iterator<iterator> _Ip;
        assign(_Ip(__c.begin()), _Ip(__c.end()));
    }
}

template <class _Tp, class _Alloc>
inline
list<_Tp, _Alloc>&
list<_Tp, _Alloc>::operator=(list&& __c)
        noexcept(__node_alloc_traits::propagate_on_container_move_assignment::value && is_nothrow_move_assignable<__node_allocator>::value)


{
    __move_assign(__c, integral_constant<bool,
          __node_alloc_traits::propagate_on_container_move_assignment::value>());
    return *this;
}

template <class _Tp, class _Alloc>
void
list<_Tp, _Alloc>::__move_assign(list& __c, false_type)
{
    if (base::__node_alloc() != __c.__node_alloc())
    {
        typedef move_iterator<iterator> _Ip;
        assign(_Ip(__c.begin()), _Ip(__c.end()));
    }
    else
        __move_assign(__c, true_type());
}

template <class _Tp, class _Alloc>
void
list<_Tp, _Alloc>::__move_assign(list& __c, true_type)
        noexcept(is_nothrow_move_assignable<__node_allocator>::value)
{
    clear();
    base::__move_assign_alloc(__c);
    splice(end(), __c);
}



template <class _Tp, class _Alloc>
inline
list<_Tp, _Alloc>&
list<_Tp, _Alloc>::operator=(const list& __c)
{
    if (this != &__c)
    {
        base::__copy_assign_alloc(__c);
        assign(__c.begin(), __c.end());
    }
    return *this;
}

template <class _Tp, class _Alloc>
template <class _InpIter>
void
list<_Tp, _Alloc>::assign(_InpIter __f, _InpIter __l,
                          typename enable_if<__is_cpp17_input_iterator<_InpIter>::value>::type*)
{
    iterator __i = begin();
    iterator __e = end();
    for (; __f != __l && __i != __e; ++__f, ++__i)
        *__i = *__f;
    if (__i == __e)
        insert(__e, __f, __l);
    else
        erase(__i, __e);



}

template <class _Tp, class _Alloc>
void
list<_Tp, _Alloc>::assign(size_type __n, const value_type& __x)
{
    iterator __i = begin();
    iterator __e = end();
    for (; __n > 0 && __i != __e; --__n, ++__i)
        *__i = __x;
    if (__i == __e)
        insert(__e, __n, __x);
    else
        erase(__i, __e);



}

template <class _Tp, class _Alloc>
inline
_Alloc
list<_Tp, _Alloc>::get_allocator() const noexcept
{
    return allocator_type(base::__node_alloc());
}

template <class _Tp, class _Alloc>
typename list<_Tp, _Alloc>::iterator
list<_Tp, _Alloc>::insert(const_iterator __p, const value_type& __x)
{





    __node_allocator& __na = base::__node_alloc();
    __hold_pointer __hold = __allocate_node(__na);
    __node_alloc_traits::construct(__na, std::__1::addressof(__hold->__value_), __x);
    __link_nodes(__p.__ptr_, __hold->__as_link(), __hold->__as_link());
    ++base::__sz();



    return iterator(__hold.release()->__as_link());

}

template <class _Tp, class _Alloc>
typename list<_Tp, _Alloc>::iterator
list<_Tp, _Alloc>::insert(const_iterator __p, size_type __n, const value_type& __x)
{






    iterator __r(__p.__ptr_);

    if (__n > 0)
    {
        size_type __ds = 0;
        __node_allocator& __na = base::__node_alloc();
        __hold_pointer __hold = __allocate_node(__na);
        __node_alloc_traits::construct(__na, std::__1::addressof(__hold->__value_), __x);
        ++__ds;



        __r = iterator(__hold->__as_link());

        __hold.release();
        iterator __e = __r;

        try
        {

            for (--__n; __n != 0; --__n, ++__e, ++__ds)
            {
                __hold.reset(__node_alloc_traits::allocate(__na, 1));
                __node_alloc_traits::construct(__na, std::__1::addressof(__hold->__value_), __x);
                __e.__ptr_->__next_ = __hold->__as_link();
                __hold->__prev_ = __e.__ptr_;
                __hold.release();
            }

        }
        catch (...)
        {
            while (true)
            {
                __node_alloc_traits::destroy(__na, std::__1::addressof(*__e));
                __link_pointer __prev = __e.__ptr_->__prev_;
                __node_alloc_traits::deallocate(__na, __e.__ptr_->__as_node(), 1);
                if (__prev == 0)
                    break;



                __e = iterator(__prev);

            }
            throw;
        }

        __link_nodes(__p.__ptr_, __r.__ptr_, __e.__ptr_);
        base::__sz() += __ds;
    }
    return __r;
}

template <class _Tp, class _Alloc>
template <class _InpIter>
typename list<_Tp, _Alloc>::iterator
list<_Tp, _Alloc>::insert(const_iterator __p, _InpIter __f, _InpIter __l,
             typename enable_if<__is_cpp17_input_iterator<_InpIter>::value>::type*)
{






    iterator __r(__p.__ptr_);

    if (__f != __l)
    {
        size_type __ds = 0;
        __node_allocator& __na = base::__node_alloc();
        __hold_pointer __hold = __allocate_node(__na);
        __node_alloc_traits::construct(__na, std::__1::addressof(__hold->__value_), *__f);
        ++__ds;



        __r = iterator(__hold.get()->__as_link());

        __hold.release();
        iterator __e = __r;

        try
        {

            for (++__f; __f != __l; ++__f, (void) ++__e, (void) ++__ds)
            {
                __hold.reset(__node_alloc_traits::allocate(__na, 1));
                __node_alloc_traits::construct(__na, std::__1::addressof(__hold->__value_), *__f);
                __e.__ptr_->__next_ = __hold.get()->__as_link();
                __hold->__prev_ = __e.__ptr_;
                __hold.release();
            }

        }
        catch (...)
        {
            while (true)
            {
                __node_alloc_traits::destroy(__na, std::__1::addressof(*__e));
                __link_pointer __prev = __e.__ptr_->__prev_;
                __node_alloc_traits::deallocate(__na, __e.__ptr_->__as_node(), 1);
                if (__prev == 0)
                    break;



                __e = iterator(__prev);

            }
            throw;
        }

        __link_nodes(__p.__ptr_, __r.__ptr_, __e.__ptr_);
        base::__sz() += __ds;
    }
    return __r;
}

template <class _Tp, class _Alloc>
void
list<_Tp, _Alloc>::push_front(const value_type& __x)
{
    __node_allocator& __na = base::__node_alloc();
    __hold_pointer __hold = __allocate_node(__na);
    __node_alloc_traits::construct(__na, std::__1::addressof(__hold->__value_), __x);
    __link_pointer __nl = __hold->__as_link();
    __link_nodes_at_front(__nl, __nl);
    ++base::__sz();
    __hold.release();
}

template <class _Tp, class _Alloc>
void
list<_Tp, _Alloc>::push_back(const value_type& __x)
{
    __node_allocator& __na = base::__node_alloc();
    __hold_pointer __hold = __allocate_node(__na);
    __node_alloc_traits::construct(__na, std::__1::addressof(__hold->__value_), __x);
    __link_nodes_at_back(__hold.get()->__as_link(), __hold.get()->__as_link());
    ++base::__sz();
    __hold.release();
}



template <class _Tp, class _Alloc>
void
list<_Tp, _Alloc>::push_front(value_type&& __x)
{
    __node_allocator& __na = base::__node_alloc();
    __hold_pointer __hold = __allocate_node(__na);
    __node_alloc_traits::construct(__na, std::__1::addressof(__hold->__value_), std::__1::move(__x));
    __link_nodes_at_front(__hold.get()->__as_link(), __hold.get()->__as_link());
    ++base::__sz();
    __hold.release();
}

template <class _Tp, class _Alloc>
void
list<_Tp, _Alloc>::push_back(value_type&& __x)
{
    __node_allocator& __na = base::__node_alloc();
    __hold_pointer __hold = __allocate_node(__na);
    __node_alloc_traits::construct(__na, std::__1::addressof(__hold->__value_), std::__1::move(__x));
    __link_nodes_at_back(__hold.get()->__as_link(), __hold.get()->__as_link());
    ++base::__sz();
    __hold.release();
}

template <class _Tp, class _Alloc>
template <class... _Args>

typename list<_Tp, _Alloc>::reference



list<_Tp, _Alloc>::emplace_front(_Args&&... __args)
{
    __node_allocator& __na = base::__node_alloc();
    __hold_pointer __hold = __allocate_node(__na);
    __node_alloc_traits::construct(__na, std::__1::addressof(__hold->__value_), std::__1::forward<_Args>(__args)...);
    __link_nodes_at_front(__hold.get()->__as_link(), __hold.get()->__as_link());
    ++base::__sz();

    return __hold.release()->__value_;



}

template <class _Tp, class _Alloc>
template <class... _Args>

typename list<_Tp, _Alloc>::reference



list<_Tp, _Alloc>::emplace_back(_Args&&... __args)
{
    __node_allocator& __na = base::__node_alloc();
    __hold_pointer __hold = __allocate_node(__na);
    __node_alloc_traits::construct(__na, std::__1::addressof(__hold->__value_), std::__1::forward<_Args>(__args)...);
    __link_pointer __nl = __hold->__as_link();
    __link_nodes_at_back(__nl, __nl);
    ++base::__sz();

    return __hold.release()->__value_;



}

template <class _Tp, class _Alloc>
template <class... _Args>
typename list<_Tp, _Alloc>::iterator
list<_Tp, _Alloc>::emplace(const_iterator __p, _Args&&... __args)
{





    __node_allocator& __na = base::__node_alloc();
    __hold_pointer __hold = __allocate_node(__na);
    __node_alloc_traits::construct(__na, std::__1::addressof(__hold->__value_), std::__1::forward<_Args>(__args)...);
    __link_pointer __nl = __hold.get()->__as_link();
    __link_nodes(__p.__ptr_, __nl, __nl);
    ++base::__sz();
    __hold.release();



    return iterator(__nl);

}

template <class _Tp, class _Alloc>
typename list<_Tp, _Alloc>::iterator
list<_Tp, _Alloc>::insert(const_iterator __p, value_type&& __x)
{





    __node_allocator& __na = base::__node_alloc();
    __hold_pointer __hold = __allocate_node(__na);
    __node_alloc_traits::construct(__na, std::__1::addressof(__hold->__value_), std::__1::move(__x));
    __link_pointer __nl = __hold->__as_link();
    __link_nodes(__p.__ptr_, __nl, __nl);
    ++base::__sz();
    __hold.release();



    return iterator(__nl);

}



template <class _Tp, class _Alloc>
void
list<_Tp, _Alloc>::pop_front()
{
    ((void)0);
    __node_allocator& __na = base::__node_alloc();
    __link_pointer __n = base::__end_.__next_;
    base::__unlink_nodes(__n, __n);
    --base::__sz();
# 1765 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/list" 3
    __node_pointer __np = __n->__as_node();
    __node_alloc_traits::destroy(__na, std::__1::addressof(__np->__value_));
    __node_alloc_traits::deallocate(__na, __np, 1);
}

template <class _Tp, class _Alloc>
void
list<_Tp, _Alloc>::pop_back()
{
    ((void)0);
    __node_allocator& __na = base::__node_alloc();
    __link_pointer __n = base::__end_.__prev_;
    base::__unlink_nodes(__n, __n);
    --base::__sz();
# 1794 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/list" 3
    __node_pointer __np = __n->__as_node();
    __node_alloc_traits::destroy(__na, std::__1::addressof(__np->__value_));
    __node_alloc_traits::deallocate(__na, __np, 1);
}

template <class _Tp, class _Alloc>
typename list<_Tp, _Alloc>::iterator
list<_Tp, _Alloc>::erase(const_iterator __p)
{





    ((void)0);

    __node_allocator& __na = base::__node_alloc();
    __link_pointer __n = __p.__ptr_;
    __link_pointer __r = __n->__next_;
    base::__unlink_nodes(__n, __n);
    --base::__sz();
# 1830 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/list" 3
    __node_pointer __np = __n->__as_node();
    __node_alloc_traits::destroy(__na, std::__1::addressof(__np->__value_));
    __node_alloc_traits::deallocate(__na, __np, 1);



    return iterator(__r);

}

template <class _Tp, class _Alloc>
typename list<_Tp, _Alloc>::iterator
list<_Tp, _Alloc>::erase(const_iterator __f, const_iterator __l)
{
# 1852 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/list" 3
    if (__f != __l)
    {
        __node_allocator& __na = base::__node_alloc();
        base::__unlink_nodes(__f.__ptr_, __l.__ptr_->__prev_);
        while (__f != __l)
        {
            __link_pointer __n = __f.__ptr_;
            ++__f;
            --base::__sz();
# 1876 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/list" 3
            __node_pointer __np = __n->__as_node();
            __node_alloc_traits::destroy(__na, std::__1::addressof(__np->__value_));
            __node_alloc_traits::deallocate(__na, __np, 1);
        }
    }



    return iterator(__l.__ptr_);

}

template <class _Tp, class _Alloc>
void
list<_Tp, _Alloc>::resize(size_type __n)
{
    if (__n < base::__sz())
        erase(__iterator(__n), end());
    else if (__n > base::__sz())
    {
        __n -= base::__sz();
        size_type __ds = 0;
        __node_allocator& __na = base::__node_alloc();
        __hold_pointer __hold = __allocate_node(__na);
        __node_alloc_traits::construct(__na, std::__1::addressof(__hold->__value_));
        ++__ds;



        iterator __r = iterator(__hold.release()->__as_link());

        iterator __e = __r;

        try
        {

            for (--__n; __n != 0; --__n, ++__e, ++__ds)
            {
                __hold.reset(__node_alloc_traits::allocate(__na, 1));
                __node_alloc_traits::construct(__na, std::__1::addressof(__hold->__value_));
                __e.__ptr_->__next_ = __hold.get()->__as_link();
                __hold->__prev_ = __e.__ptr_;
                __hold.release();
            }

        }
        catch (...)
        {
            while (true)
            {
                __node_alloc_traits::destroy(__na, std::__1::addressof(*__e));
                __link_pointer __prev = __e.__ptr_->__prev_;
                __node_alloc_traits::deallocate(__na, __e.__ptr_->__as_node(), 1);
                if (__prev == 0)
                    break;



                __e = iterator(__prev);

            }
            throw;
        }

        __link_nodes_at_back(__r.__ptr_, __e.__ptr_);
        base::__sz() += __ds;
    }
}

template <class _Tp, class _Alloc>
void
list<_Tp, _Alloc>::resize(size_type __n, const value_type& __x)
{
    if (__n < base::__sz())
        erase(__iterator(__n), end());
    else if (__n > base::__sz())
    {
        __n -= base::__sz();
        size_type __ds = 0;
        __node_allocator& __na = base::__node_alloc();
        __hold_pointer __hold = __allocate_node(__na);
        __node_alloc_traits::construct(__na, std::__1::addressof(__hold->__value_), __x);
        ++__ds;
        __link_pointer __nl = __hold.release()->__as_link();



        iterator __r = iterator(__nl);

        iterator __e = __r;

        try
        {

            for (--__n; __n != 0; --__n, ++__e, ++__ds)
            {
                __hold.reset(__node_alloc_traits::allocate(__na, 1));
                __node_alloc_traits::construct(__na, std::__1::addressof(__hold->__value_), __x);
                __e.__ptr_->__next_ = __hold.get()->__as_link();
                __hold->__prev_ = __e.__ptr_;
                __hold.release();
            }

        }
        catch (...)
        {
            while (true)
            {
                __node_alloc_traits::destroy(__na, std::__1::addressof(*__e));
                __link_pointer __prev = __e.__ptr_->__prev_;
                __node_alloc_traits::deallocate(__na, __e.__ptr_->__as_node(), 1);
                if (__prev == 0)
                    break;



                __e = iterator(__prev);

            }
            throw;
        }

        __link_nodes(base::__end_as_link(), __r.__ptr_, __e.__ptr_);
        base::__sz() += __ds;
    }
}

template <class _Tp, class _Alloc>
void
list<_Tp, _Alloc>::splice(const_iterator __p, list& __c)
{
    ((void)0);






    if (!__c.empty())
    {
        __link_pointer __f = __c.__end_.__next_;
        __link_pointer __l = __c.__end_.__prev_;
        base::__unlink_nodes(__f, __l);
        __link_nodes(__p.__ptr_, __f, __l);
        base::__sz() += __c.__sz();
        __c.__sz() = 0;
# 2042 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/list" 3
    }
}

template <class _Tp, class _Alloc>
void
list<_Tp, _Alloc>::splice(const_iterator __p, list& __c, const_iterator __i)
{
# 2060 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/list" 3
    if (__p.__ptr_ != __i.__ptr_ && __p.__ptr_ != __i.__ptr_->__next_)
    {
        __link_pointer __f = __i.__ptr_;
        base::__unlink_nodes(__f, __f);
        __link_nodes(__p.__ptr_, __f, __f);
        --__c.__sz();
        ++base::__sz();
# 2087 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/list" 3
    }
}

template <class _Tp, class _Alloc>
void
list<_Tp, _Alloc>::splice(const_iterator __p, list& __c, const_iterator __f, const_iterator __l)
{
# 2113 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/list" 3
    if (__f != __l)
    {
        __link_pointer __first = __f.__ptr_;
        --__l;
        __link_pointer __last = __l.__ptr_;
        if (this != &__c)
        {
            size_type __s = std::__1::distance(__f, __l) + 1;
            __c.__sz() -= __s;
            base::__sz() += __s;
        }
        base::__unlink_nodes(__first, __last);
        __link_nodes(__p.__ptr_, __first, __last);
# 2150 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/list" 3
    }
}

template <class _Tp, class _Alloc>
typename list<_Tp, _Alloc>::__remove_return_type
list<_Tp, _Alloc>::remove(const value_type& __x)
{
    list<_Tp, _Alloc> __deleted_nodes(get_allocator());
    for (const_iterator __i = begin(), __e = end(); __i != __e;)
    {
        if (*__i == __x)
        {
            const_iterator __j = std::__1::next(__i);
            for (; __j != __e && *__j == __x; ++__j)
                ;
            __deleted_nodes.splice(__deleted_nodes.end(), *this, __i, __j);
            __i = __j;
            if (__i != __e)
                ++__i;
        }
        else
            ++__i;
    }

    return (__remove_return_type) __deleted_nodes.size();
}

template <class _Tp, class _Alloc>
template <class _Pred>
typename list<_Tp, _Alloc>::__remove_return_type
list<_Tp, _Alloc>::remove_if(_Pred __pred)
{
    list<_Tp, _Alloc> __deleted_nodes(get_allocator());
    for (iterator __i = begin(), __e = end(); __i != __e;)
    {
        if (__pred(*__i))
        {
            iterator __j = std::__1::next(__i);
            for (; __j != __e && __pred(*__j); ++__j)
                ;
            __deleted_nodes.splice(__deleted_nodes.end(), *this, __i, __j);
            __i = __j;
            if (__i != __e)
                ++__i;
        }
        else
            ++__i;
    }

    return (__remove_return_type) __deleted_nodes.size();
}

template <class _Tp, class _Alloc>
template <class _BinaryPred>
typename list<_Tp, _Alloc>::__remove_return_type
list<_Tp, _Alloc>::unique(_BinaryPred __binary_pred)
{
    list<_Tp, _Alloc> __deleted_nodes(get_allocator());
    for (iterator __i = begin(), __e = end(); __i != __e;)
    {
        iterator __j = std::__1::next(__i);
        for (; __j != __e && __binary_pred(*__i, *__j); ++__j)
            ;
        if (++__i != __j) {
            __deleted_nodes.splice(__deleted_nodes.end(), *this, __i, __j);
            __i = __j;
            }
    }

    return (__remove_return_type) __deleted_nodes.size();
}

template <class _Tp, class _Alloc>
inline
void
list<_Tp, _Alloc>::merge(list& __c)
{
    merge(__c, __less<value_type>());
}

template <class _Tp, class _Alloc>
template <class _Comp>
void
list<_Tp, _Alloc>::merge(list& __c, _Comp __comp)
{
    if (this != std::__1::addressof(__c))
    {
        iterator __f1 = begin();
        iterator __e1 = end();
        iterator __f2 = __c.begin();
        iterator __e2 = __c.end();
        while (__f1 != __e1 && __f2 != __e2)
        {
            if (__comp(*__f2, *__f1))
            {
                size_type __ds = 1;
                iterator __m2 = std::__1::next(__f2);
                for (; __m2 != __e2 && __comp(*__m2, *__f1); ++__m2, ++__ds)
                    ;
                base::__sz() += __ds;
                __c.__sz() -= __ds;
                __link_pointer __f = __f2.__ptr_;
                __link_pointer __l = __m2.__ptr_->__prev_;
                __f2 = __m2;
                base::__unlink_nodes(__f, __l);
                __m2 = std::__1::next(__f1);
                __link_nodes(__f1.__ptr_, __f, __l);
                __f1 = __m2;
            }
            else
                ++__f1;
        }
        splice(__e1, __c);
# 2281 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/list" 3
    }
}

template <class _Tp, class _Alloc>
inline
void
list<_Tp, _Alloc>::sort()
{
    sort(__less<value_type>());
}

template <class _Tp, class _Alloc>
template <class _Comp>
inline
void
list<_Tp, _Alloc>::sort(_Comp __comp)
{
    __sort(begin(), end(), base::__sz(), __comp);
}

template <class _Tp, class _Alloc>
template <class _Comp>
typename list<_Tp, _Alloc>::iterator
list<_Tp, _Alloc>::__sort(iterator __f1, iterator __e2, size_type __n, _Comp& __comp)
{
    switch (__n)
    {
    case 0:
    case 1:
        return __f1;
    case 2:
        if (__comp(*--__e2, *__f1))
        {
            __link_pointer __f = __e2.__ptr_;
            base::__unlink_nodes(__f, __f);
            __link_nodes(__f1.__ptr_, __f, __f);
            return __e2;
        }
        return __f1;
    }
    size_type __n2 = __n / 2;
    iterator __e1 = std::__1::next(__f1, __n2);
    iterator __r = __f1 = __sort(__f1, __e1, __n2, __comp);
    iterator __f2 = __e1 = __sort(__e1, __e2, __n - __n2, __comp);
    if (__comp(*__f2, *__f1))
    {
        iterator __m2 = std::__1::next(__f2);
        for (; __m2 != __e2 && __comp(*__m2, *__f1); ++__m2)
            ;
        __link_pointer __f = __f2.__ptr_;
        __link_pointer __l = __m2.__ptr_->__prev_;
        __r = __f2;
        __e1 = __f2 = __m2;
        base::__unlink_nodes(__f, __l);
        __m2 = std::__1::next(__f1);
        __link_nodes(__f1.__ptr_, __f, __l);
        __f1 = __m2;
    }
    else
        ++__f1;
    while (__f1 != __e1 && __f2 != __e2)
    {
        if (__comp(*__f2, *__f1))
        {
            iterator __m2 = std::__1::next(__f2);
            for (; __m2 != __e2 && __comp(*__m2, *__f1); ++__m2)
                ;
            __link_pointer __f = __f2.__ptr_;
            __link_pointer __l = __m2.__ptr_->__prev_;
            if (__e1 == __f2)
                __e1 = __m2;
            __f2 = __m2;
            base::__unlink_nodes(__f, __l);
            __m2 = std::__1::next(__f1);
            __link_nodes(__f1.__ptr_, __f, __l);
            __f1 = __m2;
        }
        else
            ++__f1;
    }
    return __r;
}

template <class _Tp, class _Alloc>
void
list<_Tp, _Alloc>::reverse() noexcept
{
    if (base::__sz() > 1)
    {
        iterator __e = end();
        for (iterator __i = begin(); __i.__ptr_ != __e.__ptr_;)
        {
            std::__1::swap(__i.__ptr_->__prev_, __i.__ptr_->__next_);
            __i.__ptr_ = __i.__ptr_->__prev_;
        }
        std::__1::swap(__e.__ptr_->__prev_, __e.__ptr_->__next_);
    }
}

template <class _Tp, class _Alloc>
bool
list<_Tp, _Alloc>::__invariants() const
{
    return size() == std::__1::distance(begin(), end());
}
# 2419 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/list" 3
template <class _Tp, class _Alloc>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator==(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
{
    return __x.size() == __y.size() && std::__1::equal(__x.begin(), __x.end(), __y.begin());
}

template <class _Tp, class _Alloc>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator< (const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
{
    return std::__1::lexicographical_compare(__x.begin(), __x.end(), __y.begin(), __y.end());
}

template <class _Tp, class _Alloc>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator!=(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
{
    return !(__x == __y);
}

template <class _Tp, class _Alloc>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator> (const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
{
    return __y < __x;
}

template <class _Tp, class _Alloc>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator>=(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
{
    return !(__x < __y);
}

template <class _Tp, class _Alloc>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator<=(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
{
    return !(__y < __x);
}

template <class _Tp, class _Alloc>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void
swap(list<_Tp, _Alloc>& __x, list<_Tp, _Alloc>& __y)
    noexcept(noexcept(__x.swap(__y)))
{
    __x.swap(__y);
}
# 2490 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/list" 3
} }
# 161 "/usr/local/include/bits/stdc++.h" 2





# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/map" 1 3
# 494 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/map" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/is_transparent.h" 1 3
# 14 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/is_transparent.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 1 3
# 15 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/is_transparent.h" 2 3
# 18 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/is_transparent.h" 3


namespace std { inline namespace __1 {



template <class _Tp, class, class = void>
struct __is_transparent : false_type {};

template <class _Tp, class _Up>
struct __is_transparent<_Tp, _Up,
                        typename __void_t<typename _Tp::is_transparent>::type>
   : true_type {};



} }
# 495 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/map" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__node_handle" 1 3
# 15 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__node_handle" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/memory" 1 3
# 974 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/memory" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 1 3
# 20 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/assert.h" 1 3 4
# 44 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/assert.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/stdlib.h" 1 3 4
# 45 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/assert.h" 2 3 4
# 81 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/assert.h" 3 4
extern "C" {
void __assert_rtn(const char *, const char *, int, const char *) __attribute__((__noreturn__)) __attribute__((__cold__)) __attribute__((__disable_tail_calls__));



}
# 21 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 2 3
# 24 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 3
# 975 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/memory" 2 3
# 16 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__node_handle" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/optional" 1 3
# 158 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/optional" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 1 3
# 159 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/optional" 2 3
# 164 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/optional" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 168 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/optional" 2 3


namespace std
{

class __attribute__ ((__visibility__("default"))) __attribute__((availability(macosx,strict,introduced=10.13))) __attribute__((availability(ios,strict,introduced=11.0))) __attribute__((availability(tvos,strict,introduced=11.0))) __attribute__((availability(watchos,strict,introduced=4.0))) bad_optional_access
    : public exception
{
public:

    virtual ~bad_optional_access() noexcept;
    virtual const char* what() const noexcept;
};

}



namespace std { inline namespace __1 {

[[noreturn]]
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
__attribute__((availability(macosx,strict,introduced=10.13))) __attribute__((availability(ios,strict,introduced=11.0))) __attribute__((availability(tvos,strict,introduced=11.0))) __attribute__((availability(watchos,strict,introduced=4.0)))
void __throw_bad_optional_access() {

        throw bad_optional_access();



}

struct nullopt_t
{
    struct __secret_tag { __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) explicit __secret_tag() = default; };
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr explicit nullopt_t(__secret_tag, __secret_tag) noexcept {}
};

inline constexpr nullopt_t nullopt{nullopt_t::__secret_tag{}, nullopt_t::__secret_tag{}};

template <class _Tp, bool = is_trivially_destructible<_Tp>::value>
struct __optional_destruct_base;

template <class _Tp>
struct __optional_destruct_base<_Tp, false>
{
    typedef _Tp value_type;
    static_assert(is_object_v<value_type>,
        "instantiation of optional with a non-object type is undefined behavior");
    union
    {
        char __null_state_;
        value_type __val_;
    };
    bool __engaged_;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
                                  ~__optional_destruct_base()
    {
        if (__engaged_)
            __val_.~value_type();
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    constexpr __optional_destruct_base() noexcept
        : __null_state_(),
           __engaged_(false) {}

    template <class... _Args>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    constexpr explicit __optional_destruct_base(in_place_t, _Args&&... __args)
        : __val_(std::__1::forward<_Args>(__args)...),
           __engaged_(true) {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
                                  void reset() noexcept
    {
        if (__engaged_)
        {
            __val_.~value_type();
            __engaged_ = false;
        }
    }
};

template <class _Tp>
struct __optional_destruct_base<_Tp, true>
{
    typedef _Tp value_type;
    static_assert(is_object_v<value_type>,
        "instantiation of optional with a non-object type is undefined behavior");
    union
    {
        char __null_state_;
        value_type __val_;
    };
    bool __engaged_;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    constexpr __optional_destruct_base() noexcept
        : __null_state_(),
           __engaged_(false) {}

    template <class... _Args>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    constexpr explicit __optional_destruct_base(in_place_t, _Args&&... __args)
        : __val_(std::__1::forward<_Args>(__args)...),
           __engaged_(true) {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
                                  void reset() noexcept
    {
        if (__engaged_)
        {
            __engaged_ = false;
        }
    }
};

template <class _Tp, bool = is_reference<_Tp>::value>
struct __optional_storage_base : __optional_destruct_base<_Tp>
{
    using __base = __optional_destruct_base<_Tp>;
    using value_type = _Tp;
    using __base::__base;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    constexpr bool has_value() const noexcept
    {
        return this->__engaged_;
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    constexpr value_type& __get() & noexcept
    {
        return this->__val_;
    }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    constexpr const value_type& __get() const& noexcept
    {
        return this->__val_;
    }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    constexpr value_type&& __get() && noexcept
    {
        return std::__1::move(this->__val_);
    }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    constexpr const value_type&& __get() const&& noexcept
    {
        return std::__1::move(this->__val_);
    }

    template <class... _Args>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
                                  void __construct(_Args&&... __args)
    {
        ((void)0);



        ::new ((void*)std::__1::addressof(this->__val_)) value_type(std::__1::forward<_Args>(__args)...);

        this->__engaged_ = true;
    }

    template <class _That>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
                                  void __construct_from(_That&& __opt)
    {
        if (__opt.has_value())
            __construct(std::__1::forward<_That>(__opt).__get());
    }

    template <class _That>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
                                  void __assign_from(_That&& __opt)
    {
        if (this->__engaged_ == __opt.has_value())
        {
            if (this->__engaged_)
                this->__val_ = std::__1::forward<_That>(__opt).__get();
        }
        else
        {
            if (this->__engaged_)
                this->reset();
            else
                __construct(std::__1::forward<_That>(__opt).__get());
        }
    }
};




template <class _Tp>
struct __optional_storage_base<_Tp, true>
{
    using value_type = _Tp;
    using __raw_type = remove_reference_t<_Tp>;
    __raw_type* __value_;

    template <class _Up>
    static constexpr bool __can_bind_reference() {
        using _RawUp = typename remove_reference<_Up>::type;
        using _UpPtr = _RawUp*;
        using _RawTp = typename remove_reference<_Tp>::type;
        using _TpPtr = _RawTp*;
        using _CheckLValueArg = integral_constant<bool,
            (is_lvalue_reference<_Up>::value && is_convertible<_UpPtr, _TpPtr>::value)
        || is_same<_RawUp, reference_wrapper<_RawTp>>::value
        || is_same<_RawUp, reference_wrapper<typename remove_const<_RawTp>::type>>::value
        >;
        return (is_lvalue_reference<_Tp>::value && _CheckLValueArg::value)
            || (is_rvalue_reference<_Tp>::value && !is_lvalue_reference<_Up>::value &&
                is_convertible<_UpPtr, _TpPtr>::value);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    constexpr __optional_storage_base() noexcept
        : __value_(nullptr) {}

    template <class _UArg>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    constexpr explicit __optional_storage_base(in_place_t, _UArg&& __uarg)
        : __value_(std::__1::addressof(__uarg))
    {
      static_assert(__can_bind_reference<_UArg>(),
        "Attempted to construct a reference element in tuple from a "
        "possible temporary");
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
                                  void reset() noexcept { __value_ = nullptr; }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    constexpr bool has_value() const noexcept
      { return __value_ != nullptr; }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    constexpr value_type& __get() const& noexcept
      { return *__value_; }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    constexpr value_type&& __get() const&& noexcept
      { return std::__1::forward<value_type>(*__value_); }

    template <class _UArg>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
                                  void __construct(_UArg&& __val)
    {
        ((void)0);
        static_assert(__can_bind_reference<_UArg>(),
            "Attempted to construct a reference element in tuple from a "
            "possible temporary");
        __value_ = std::__1::addressof(__val);
    }

    template <class _That>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
                                  void __construct_from(_That&& __opt)
    {
        if (__opt.has_value())
            __construct(std::__1::forward<_That>(__opt).__get());
    }

    template <class _That>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
                                  void __assign_from(_That&& __opt)
    {
        if (has_value() == __opt.has_value())
        {
            if (has_value())
                *__value_ = std::__1::forward<_That>(__opt).__get();
        }
        else
        {
            if (has_value())
                reset();
            else
                __construct(std::__1::forward<_That>(__opt).__get());
        }
    }
};

template <class _Tp, bool = is_trivially_copy_constructible<_Tp>::value>
struct __optional_copy_base : __optional_storage_base<_Tp>
{
    using __optional_storage_base<_Tp>::__optional_storage_base;
};

template <class _Tp>
struct __optional_copy_base<_Tp, false> : __optional_storage_base<_Tp>
{
    using __optional_storage_base<_Tp>::__optional_storage_base;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __optional_copy_base() = default;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
                                  __optional_copy_base(const __optional_copy_base& __opt)
    {
        this->__construct_from(__opt);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __optional_copy_base(__optional_copy_base&&) = default;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __optional_copy_base& operator=(const __optional_copy_base&) = default;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __optional_copy_base& operator=(__optional_copy_base&&) = default;
};

template <class _Tp, bool = is_trivially_move_constructible<_Tp>::value>
struct __optional_move_base : __optional_copy_base<_Tp>
{
    using __optional_copy_base<_Tp>::__optional_copy_base;
};

template <class _Tp>
struct __optional_move_base<_Tp, false> : __optional_copy_base<_Tp>
{
    using value_type = _Tp;
    using __optional_copy_base<_Tp>::__optional_copy_base;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __optional_move_base() = default;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __optional_move_base(const __optional_move_base&) = default;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
                                  __optional_move_base(__optional_move_base&& __opt)
        noexcept(is_nothrow_move_constructible_v<value_type>)
    {
        this->__construct_from(std::__1::move(__opt));
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __optional_move_base& operator=(const __optional_move_base&) = default;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __optional_move_base& operator=(__optional_move_base&&) = default;
};

template <class _Tp, bool =
    is_trivially_destructible<_Tp>::value &&
    is_trivially_copy_constructible<_Tp>::value &&
    is_trivially_copy_assignable<_Tp>::value>
struct __optional_copy_assign_base : __optional_move_base<_Tp>
{
    using __optional_move_base<_Tp>::__optional_move_base;
};

template <class _Tp>
struct __optional_copy_assign_base<_Tp, false> : __optional_move_base<_Tp>
{
    using __optional_move_base<_Tp>::__optional_move_base;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __optional_copy_assign_base() = default;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __optional_copy_assign_base(const __optional_copy_assign_base&) = default;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __optional_copy_assign_base(__optional_copy_assign_base&&) = default;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
                                  __optional_copy_assign_base& operator=(const __optional_copy_assign_base& __opt)
    {
        this->__assign_from(__opt);
        return *this;
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __optional_copy_assign_base& operator=(__optional_copy_assign_base&&) = default;
};

template <class _Tp, bool =
    is_trivially_destructible<_Tp>::value &&
    is_trivially_move_constructible<_Tp>::value &&
    is_trivially_move_assignable<_Tp>::value>
struct __optional_move_assign_base : __optional_copy_assign_base<_Tp>
{
    using __optional_copy_assign_base<_Tp>::__optional_copy_assign_base;
};

template <class _Tp>
struct __optional_move_assign_base<_Tp, false> : __optional_copy_assign_base<_Tp>
{
    using value_type = _Tp;
    using __optional_copy_assign_base<_Tp>::__optional_copy_assign_base;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __optional_move_assign_base() = default;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __optional_move_assign_base(const __optional_move_assign_base& __opt) = default;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __optional_move_assign_base(__optional_move_assign_base&&) = default;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __optional_move_assign_base& operator=(const __optional_move_assign_base&) = default;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
                                  __optional_move_assign_base& operator=(__optional_move_assign_base&& __opt)
        noexcept(is_nothrow_move_assignable_v<value_type> &&
                 is_nothrow_move_constructible_v<value_type>)
    {
        this->__assign_from(std::__1::move(__opt));
        return *this;
    }
};

template <class _Tp>
using __optional_sfinae_ctor_base_t = __sfinae_ctor_base<
    is_copy_constructible<_Tp>::value,
    is_move_constructible<_Tp>::value
>;

template <class _Tp>
using __optional_sfinae_assign_base_t = __sfinae_assign_base<
    (is_copy_constructible<_Tp>::value && is_copy_assignable<_Tp>::value),
    (is_move_constructible<_Tp>::value && is_move_assignable<_Tp>::value)
>;

template <class _Tp>
class optional
    : private __optional_move_assign_base<_Tp>
    , private __optional_sfinae_ctor_base_t<_Tp>
    , private __optional_sfinae_assign_base_t<_Tp>
{
    using __base = __optional_move_assign_base<_Tp>;
public:
    using value_type = _Tp;

private:

    static_assert(!is_same_v<__uncvref_t<value_type>, in_place_t>,
        "instantiation of optional with in_place_t is ill-formed");
    static_assert(!is_same_v<__uncvref_t<value_type>, nullopt_t>,
        "instantiation of optional with nullopt_t is ill-formed");
    static_assert(!is_reference_v<value_type>,
        "instantiation of optional with a reference type is ill-formed");
    static_assert(is_destructible_v<value_type>,
        "instantiation of optional with a non-destructible type is ill-formed");
    static_assert(!is_array_v<value_type>,
        "instantiation of optional with an array type is ill-formed");


    struct _CheckOptionalArgsConstructor {
      template <class _Up>
      static constexpr bool __enable_implicit() {
          return is_constructible_v<_Tp, _Up&&> &&
                 is_convertible_v<_Up&&, _Tp>;
      }

      template <class _Up>
      static constexpr bool __enable_explicit() {
          return is_constructible_v<_Tp, _Up&&> &&
                 !is_convertible_v<_Up&&, _Tp>;
      }
    };
    template <class _Up>
    using _CheckOptionalArgsCtor = _If<
        _IsNotSame<__uncvref_t<_Up>, in_place_t>::value &&
        _IsNotSame<__uncvref_t<_Up>, optional>::value,
        _CheckOptionalArgsConstructor,
        __check_tuple_constructor_fail
    >;
    template <class _QualUp>
    struct _CheckOptionalLikeConstructor {
      template <class _Up, class _Opt = optional<_Up>>
      using __check_constructible_from_opt = _Or<
          is_constructible<_Tp, _Opt&>,
          is_constructible<_Tp, _Opt const&>,
          is_constructible<_Tp, _Opt&&>,
          is_constructible<_Tp, _Opt const&&>,
          is_convertible<_Opt&, _Tp>,
          is_convertible<_Opt const&, _Tp>,
          is_convertible<_Opt&&, _Tp>,
          is_convertible<_Opt const&&, _Tp>
      >;
      template <class _Up, class _Opt = optional<_Up>>
      using __check_assignable_from_opt = _Or<
          is_assignable<_Tp&, _Opt&>,
          is_assignable<_Tp&, _Opt const&>,
          is_assignable<_Tp&, _Opt&&>,
          is_assignable<_Tp&, _Opt const&&>
      >;
      template <class _Up, class _QUp = _QualUp>
      static constexpr bool __enable_implicit() {
          return is_convertible<_QUp, _Tp>::value &&
              !__check_constructible_from_opt<_Up>::value;
      }
      template <class _Up, class _QUp = _QualUp>
      static constexpr bool __enable_explicit() {
          return !is_convertible<_QUp, _Tp>::value &&
              !__check_constructible_from_opt<_Up>::value;
      }
      template <class _Up, class _QUp = _QualUp>
      static constexpr bool __enable_assign() {


          return !__check_constructible_from_opt<_Up>::value &&
              !__check_assignable_from_opt<_Up>::value;
      }
    };

    template <class _Up, class _QualUp>
    using _CheckOptionalLikeCtor = _If<
      _And<
         _IsNotSame<_Up, _Tp>,
          is_constructible<_Tp, _QualUp>
      >::value,
      _CheckOptionalLikeConstructor<_QualUp>,
      __check_tuple_constructor_fail
    >;
    template <class _Up, class _QualUp>
    using _CheckOptionalLikeAssign = _If<
      _And<
          _IsNotSame<_Up, _Tp>,
          is_constructible<_Tp, _QualUp>,
          is_assignable<_Tp&, _QualUp>
      >::value,
      _CheckOptionalLikeConstructor<_QualUp>,
      __check_tuple_constructor_fail
    >;
public:

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr optional() noexcept {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr optional(const optional&) = default;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr optional(optional&&) = default;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr optional(nullopt_t) noexcept {}

    template <class _InPlaceT, class... _Args, class = _EnableIf<
          _And<
              _IsSame<_InPlaceT, in_place_t>,
              is_constructible<value_type, _Args...>
            >::value
        >
    >
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    constexpr explicit optional(_InPlaceT, _Args&&... __args)
        : __base(in_place, std::__1::forward<_Args>(__args)...) {}

    template <class _Up, class... _Args, class = _EnableIf<
        is_constructible_v<value_type, initializer_list<_Up>&, _Args...>>
    >
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    constexpr explicit optional(in_place_t, initializer_list<_Up> __il, _Args&&... __args)
        : __base(in_place, __il, std::__1::forward<_Args>(__args)...) {}

    template <class _Up = value_type, _EnableIf<
        _CheckOptionalArgsCtor<_Up>::template __enable_implicit<_Up>()
    , int> = 0>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    constexpr optional(_Up&& __v)
        : __base(in_place, std::__1::forward<_Up>(__v)) {}

    template <class _Up, _EnableIf<
        _CheckOptionalArgsCtor<_Up>::template __enable_explicit<_Up>()
    , int> = 0>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    constexpr explicit optional(_Up&& __v)
        : __base(in_place, std::__1::forward<_Up>(__v)) {}


    template <class _Up, _EnableIf<
        _CheckOptionalLikeCtor<_Up, _Up const&>::template __enable_implicit<_Up>()
    , int> = 0>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
                                  optional(const optional<_Up>& __v)
    {
        this->__construct_from(__v);
    }
    template <class _Up, _EnableIf<
        _CheckOptionalLikeCtor<_Up, _Up const&>::template __enable_explicit<_Up>()
    , int> = 0>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
                                  explicit optional(const optional<_Up>& __v)
    {
        this->__construct_from(__v);
    }


    template <class _Up, _EnableIf<
        _CheckOptionalLikeCtor<_Up, _Up &&>::template __enable_implicit<_Up>()
    , int> = 0>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
                                  optional(optional<_Up>&& __v)
    {
        this->__construct_from(std::__1::move(__v));
    }
    template <class _Up, _EnableIf<
        _CheckOptionalLikeCtor<_Up, _Up &&>::template __enable_explicit<_Up>()
    , int> = 0>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
                                  explicit optional(optional<_Up>&& __v)
    {
        this->__construct_from(std::__1::move(__v));
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
                                  optional& operator=(nullopt_t) noexcept
    {
        reset();
        return *this;
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) optional& operator=(const optional&) = default;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) optional& operator=(optional&&) = default;


    template <class _Up = value_type,
              class = _EnableIf<
                      _And<
                          _IsNotSame<__uncvref_t<_Up>, optional>,
                          _Or<
                              _IsNotSame<__uncvref_t<_Up>, value_type>,
                              _Not<is_scalar<value_type>>
                          >,
                          is_constructible<value_type, _Up>,
                          is_assignable<value_type&, _Up>
                      >::value>
             >
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
                                  optional&
    operator=(_Up&& __v)
    {
        if (this->has_value())
            this->__get() = std::__1::forward<_Up>(__v);
        else
            this->__construct(std::__1::forward<_Up>(__v));
        return *this;
    }


    template <class _Up, _EnableIf<
        _CheckOptionalLikeAssign<_Up, _Up const&>::template __enable_assign<_Up>()
    , int> = 0>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
                                  optional&
    operator=(const optional<_Up>& __v)
    {
        this->__assign_from(__v);
        return *this;
    }


    template <class _Up, _EnableIf<
        _CheckOptionalLikeCtor<_Up, _Up &&>::template __enable_assign<_Up>()
    , int> = 0>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
                                  optional&
    operator=(optional<_Up>&& __v)
    {
        this->__assign_from(std::__1::move(__v));
        return *this;
    }

    template <class... _Args,
              class = _EnableIf
                      <
                          is_constructible_v<value_type, _Args...>
                      >
             >
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
                                  _Tp &
    emplace(_Args&&... __args)
    {
        reset();
        this->__construct(std::__1::forward<_Args>(__args)...);
        return this->__get();
    }

    template <class _Up, class... _Args,
              class = _EnableIf
                      <
                          is_constructible_v<value_type, initializer_list<_Up>&, _Args...>
                      >
             >
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
                                  _Tp &
    emplace(initializer_list<_Up> __il, _Args&&... __args)
    {
        reset();
        this->__construct(__il, std::__1::forward<_Args>(__args)...);
        return this->__get();
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
                                  void swap(optional& __opt)
        noexcept(is_nothrow_move_constructible_v<value_type> &&
                 is_nothrow_swappable_v<value_type>)
    {
        if (this->has_value() == __opt.has_value())
        {
            using std::__1::swap;
            if (this->has_value())
                swap(this->__get(), __opt.__get());
        }
        else
        {
            if (this->has_value())
            {
                __opt.__construct(std::__1::move(this->__get()));
                reset();
            }
            else
            {
                this->__construct(std::__1::move(__opt.__get()));
                __opt.reset();
            }
        }
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    constexpr
    add_pointer_t<value_type const>
    operator->() const
    {
        ((void)0);

        return std::__1::addressof(this->__get());



    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    constexpr
    add_pointer_t<value_type>
    operator->()
    {
        ((void)0);

        return std::__1::addressof(this->__get());



    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    constexpr
    const value_type&
    operator*() const& noexcept
    {
        ((void)0);
        return this->__get();
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    constexpr
    value_type&
    operator*() & noexcept
    {
        ((void)0);
        return this->__get();
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    constexpr
    value_type&&
    operator*() && noexcept
    {
        ((void)0);
        return std::__1::move(this->__get());
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    constexpr
    const value_type&&
    operator*() const&& noexcept
    {
        ((void)0);
        return std::__1::move(this->__get());
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    constexpr explicit operator bool() const noexcept { return has_value(); }

    using __base::has_value;
    using __base::__get;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __attribute__((availability(macosx,strict,introduced=10.13))) __attribute__((availability(ios,strict,introduced=11.0))) __attribute__((availability(tvos,strict,introduced=11.0))) __attribute__((availability(watchos,strict,introduced=4.0)))
    constexpr value_type const& value() const&
    {
        if (!this->has_value())
            __throw_bad_optional_access();
        return this->__get();
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __attribute__((availability(macosx,strict,introduced=10.13))) __attribute__((availability(ios,strict,introduced=11.0))) __attribute__((availability(tvos,strict,introduced=11.0))) __attribute__((availability(watchos,strict,introduced=4.0)))
    constexpr value_type& value() &
    {
        if (!this->has_value())
            __throw_bad_optional_access();
        return this->__get();
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __attribute__((availability(macosx,strict,introduced=10.13))) __attribute__((availability(ios,strict,introduced=11.0))) __attribute__((availability(tvos,strict,introduced=11.0))) __attribute__((availability(watchos,strict,introduced=4.0)))
    constexpr value_type&& value() &&
    {
        if (!this->has_value())
            __throw_bad_optional_access();
        return std::__1::move(this->__get());
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __attribute__((availability(macosx,strict,introduced=10.13))) __attribute__((availability(ios,strict,introduced=11.0))) __attribute__((availability(tvos,strict,introduced=11.0))) __attribute__((availability(watchos,strict,introduced=4.0)))
    constexpr value_type const&& value() const&&
    {
        if (!this->has_value())
            __throw_bad_optional_access();
        return std::__1::move(this->__get());
    }

    template <class _Up>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    constexpr value_type value_or(_Up&& __v) const&
    {
        static_assert(is_copy_constructible_v<value_type>,
                      "optional<T>::value_or: T must be copy constructible");
        static_assert(is_convertible_v<_Up, value_type>,
                      "optional<T>::value_or: U must be convertible to T");
        return this->has_value() ? this->__get() :
                                  static_cast<value_type>(std::__1::forward<_Up>(__v));
    }

    template <class _Up>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    constexpr value_type value_or(_Up&& __v) &&
    {
        static_assert(is_move_constructible_v<value_type>,
                      "optional<T>::value_or: T must be move constructible");
        static_assert(is_convertible_v<_Up, value_type>,
                      "optional<T>::value_or: U must be convertible to T");
        return this->has_value() ? std::__1::move(this->__get()) :
                                  static_cast<value_type>(std::__1::forward<_Up>(__v));
    }

    using __base::reset;

private:
    template <class _Up>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    static _Up*
    __operator_arrow(true_type, _Up& __x)
    {
        return std::__1::addressof(__x);
    }

    template <class _Up>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    static constexpr _Up*
    __operator_arrow(false_type, _Up& __x)
    {
        return &__x;
    }
};


template<class T>
    optional(T) -> optional<T>;



template <class _Tp, class _Up>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
_EnableIf<
    is_convertible_v<decltype(declval<const _Tp&>() ==
        declval<const _Up&>()), bool>,
    bool
>
operator==(const optional<_Tp>& __x, const optional<_Up>& __y)
{
    if (static_cast<bool>(__x) != static_cast<bool>(__y))
        return false;
    if (!static_cast<bool>(__x))
        return true;
    return *__x == *__y;
}

template <class _Tp, class _Up>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
_EnableIf<
    is_convertible_v<decltype(declval<const _Tp&>() !=
        declval<const _Up&>()), bool>,
    bool
>
operator!=(const optional<_Tp>& __x, const optional<_Up>& __y)
{
    if (static_cast<bool>(__x) != static_cast<bool>(__y))
        return true;
    if (!static_cast<bool>(__x))
        return false;
    return *__x != *__y;
}

template <class _Tp, class _Up>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
_EnableIf<
    is_convertible_v<decltype(declval<const _Tp&>() <
        declval<const _Up&>()), bool>,
    bool
>
operator<(const optional<_Tp>& __x, const optional<_Up>& __y)
{
    if (!static_cast<bool>(__y))
        return false;
    if (!static_cast<bool>(__x))
        return true;
    return *__x < *__y;
}

template <class _Tp, class _Up>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
_EnableIf<
    is_convertible_v<decltype(declval<const _Tp&>() >
        declval<const _Up&>()), bool>,
    bool
>
operator>(const optional<_Tp>& __x, const optional<_Up>& __y)
{
    if (!static_cast<bool>(__x))
        return false;
    if (!static_cast<bool>(__y))
        return true;
    return *__x > *__y;
}

template <class _Tp, class _Up>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
_EnableIf<
    is_convertible_v<decltype(declval<const _Tp&>() <=
        declval<const _Up&>()), bool>,
    bool
>
operator<=(const optional<_Tp>& __x, const optional<_Up>& __y)
{
    if (!static_cast<bool>(__x))
        return true;
    if (!static_cast<bool>(__y))
        return false;
    return *__x <= *__y;
}

template <class _Tp, class _Up>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
_EnableIf<
    is_convertible_v<decltype(declval<const _Tp&>() >=
        declval<const _Up&>()), bool>,
    bool
>
operator>=(const optional<_Tp>& __x, const optional<_Up>& __y)
{
    if (!static_cast<bool>(__y))
        return true;
    if (!static_cast<bool>(__x))
        return false;
    return *__x >= *__y;
}


template <class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
bool
operator==(const optional<_Tp>& __x, nullopt_t) noexcept
{
    return !static_cast<bool>(__x);
}

template <class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
bool
operator==(nullopt_t, const optional<_Tp>& __x) noexcept
{
    return !static_cast<bool>(__x);
}

template <class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
bool
operator!=(const optional<_Tp>& __x, nullopt_t) noexcept
{
    return static_cast<bool>(__x);
}

template <class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
bool
operator!=(nullopt_t, const optional<_Tp>& __x) noexcept
{
    return static_cast<bool>(__x);
}

template <class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
bool
operator<(const optional<_Tp>&, nullopt_t) noexcept
{
    return false;
}

template <class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
bool
operator<(nullopt_t, const optional<_Tp>& __x) noexcept
{
    return static_cast<bool>(__x);
}

template <class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
bool
operator<=(const optional<_Tp>& __x, nullopt_t) noexcept
{
    return !static_cast<bool>(__x);
}

template <class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
bool
operator<=(nullopt_t, const optional<_Tp>&) noexcept
{
    return true;
}

template <class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
bool
operator>(const optional<_Tp>& __x, nullopt_t) noexcept
{
    return static_cast<bool>(__x);
}

template <class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
bool
operator>(nullopt_t, const optional<_Tp>&) noexcept
{
    return false;
}

template <class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
bool
operator>=(const optional<_Tp>&, nullopt_t) noexcept
{
    return true;
}

template <class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
bool
operator>=(nullopt_t, const optional<_Tp>& __x) noexcept
{
    return !static_cast<bool>(__x);
}


template <class _Tp, class _Up>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
_EnableIf<
    is_convertible_v<decltype(declval<const _Tp&>() ==
        declval<const _Up&>()), bool>,
    bool
>
operator==(const optional<_Tp>& __x, const _Up& __v)
{
    return static_cast<bool>(__x) ? *__x == __v : false;
}

template <class _Tp, class _Up>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
_EnableIf<
    is_convertible_v<decltype(declval<const _Tp&>() ==
        declval<const _Up&>()), bool>,
    bool
>
operator==(const _Tp& __v, const optional<_Up>& __x)
{
    return static_cast<bool>(__x) ? __v == *__x : false;
}

template <class _Tp, class _Up>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
_EnableIf<
    is_convertible_v<decltype(declval<const _Tp&>() !=
        declval<const _Up&>()), bool>,
    bool
>
operator!=(const optional<_Tp>& __x, const _Up& __v)
{
    return static_cast<bool>(__x) ? *__x != __v : true;
}

template <class _Tp, class _Up>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
_EnableIf<
    is_convertible_v<decltype(declval<const _Tp&>() !=
        declval<const _Up&>()), bool>,
    bool
>
operator!=(const _Tp& __v, const optional<_Up>& __x)
{
    return static_cast<bool>(__x) ? __v != *__x : true;
}

template <class _Tp, class _Up>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
_EnableIf<
    is_convertible_v<decltype(declval<const _Tp&>() <
        declval<const _Up&>()), bool>,
    bool
>
operator<(const optional<_Tp>& __x, const _Up& __v)
{
    return static_cast<bool>(__x) ? *__x < __v : true;
}

template <class _Tp, class _Up>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
_EnableIf<
    is_convertible_v<decltype(declval<const _Tp&>() <
        declval<const _Up&>()), bool>,
    bool
>
operator<(const _Tp& __v, const optional<_Up>& __x)
{
    return static_cast<bool>(__x) ? __v < *__x : false;
}

template <class _Tp, class _Up>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
_EnableIf<
    is_convertible_v<decltype(declval<const _Tp&>() <=
        declval<const _Up&>()), bool>,
    bool
>
operator<=(const optional<_Tp>& __x, const _Up& __v)
{
    return static_cast<bool>(__x) ? *__x <= __v : true;
}

template <class _Tp, class _Up>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
_EnableIf<
    is_convertible_v<decltype(declval<const _Tp&>() <=
        declval<const _Up&>()), bool>,
    bool
>
operator<=(const _Tp& __v, const optional<_Up>& __x)
{
    return static_cast<bool>(__x) ? __v <= *__x : false;
}

template <class _Tp, class _Up>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
_EnableIf<
    is_convertible_v<decltype(declval<const _Tp&>() >
        declval<const _Up&>()), bool>,
    bool
>
operator>(const optional<_Tp>& __x, const _Up& __v)
{
    return static_cast<bool>(__x) ? *__x > __v : false;
}

template <class _Tp, class _Up>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
_EnableIf<
    is_convertible_v<decltype(declval<const _Tp&>() >
        declval<const _Up&>()), bool>,
    bool
>
operator>(const _Tp& __v, const optional<_Up>& __x)
{
    return static_cast<bool>(__x) ? __v > *__x : true;
}

template <class _Tp, class _Up>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
_EnableIf<
    is_convertible_v<decltype(declval<const _Tp&>() >=
        declval<const _Up&>()), bool>,
    bool
>
operator>=(const optional<_Tp>& __x, const _Up& __v)
{
    return static_cast<bool>(__x) ? *__x >= __v : false;
}

template <class _Tp, class _Up>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
_EnableIf<
    is_convertible_v<decltype(declval<const _Tp&>() >=
        declval<const _Up&>()), bool>,
    bool
>
operator>=(const _Tp& __v, const optional<_Up>& __x)
{
    return static_cast<bool>(__x) ? __v >= *__x : true;
}


template <class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
_EnableIf<
    is_move_constructible_v<_Tp> && is_swappable_v<_Tp>,
    void
>
swap(optional<_Tp>& __x, optional<_Tp>& __y) noexcept(noexcept(__x.swap(__y)))
{
    __x.swap(__y);
}

template <class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
optional<decay_t<_Tp>> make_optional(_Tp&& __v)
{
    return optional<decay_t<_Tp>>(std::__1::forward<_Tp>(__v));
}

template <class _Tp, class... _Args>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
optional<_Tp> make_optional(_Args&&... __args)
{
    return optional<_Tp>(in_place, std::__1::forward<_Args>(__args)...);
}

template <class _Tp, class _Up, class... _Args>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
optional<_Tp> make_optional(initializer_list<_Up> __il, _Args&&... __args)
{
    return optional<_Tp>(in_place, __il, std::__1::forward<_Args>(__args)...);
}

template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) hash<
    __enable_hash_helper<optional<_Tp>, remove_const_t<_Tp>>
>
{

    __attribute__ ((deprecated)) typedef optional<_Tp> argument_type;
    __attribute__ ((deprecated)) typedef size_t result_type;


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_t operator()(const optional<_Tp>& __opt) const
    {
        return static_cast<bool>(__opt) ? hash<remove_const_t<_Tp>>()(*__opt) : 0;
    }
};

} }
# 17 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__node_handle" 2 3
# 20 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__node_handle" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 24 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__node_handle" 2 3

namespace std { inline namespace __1 {




template <class _NodeType, class _Alloc>
struct __generic_container_node_destructor;

template <class _NodeType, class _Alloc,
          template <class, class> class _MapOrSetSpecifics>
class __attribute__ ((__type_visibility__("default"))) __basic_node_handle
    : public _MapOrSetSpecifics<
          _NodeType,
          __basic_node_handle<_NodeType, _Alloc, _MapOrSetSpecifics>>
{
    template <class _Tp, class _Compare, class _Allocator>
        friend class __tree;
    template <class _Tp, class _Hash, class _Equal, class _Allocator>
        friend class __hash_table;
    friend struct _MapOrSetSpecifics<
        _NodeType, __basic_node_handle<_NodeType, _Alloc, _MapOrSetSpecifics>>;

    typedef allocator_traits<_Alloc> __alloc_traits;
    typedef typename __rebind_pointer<typename __alloc_traits::void_pointer,
                                      _NodeType>::type
        __node_pointer_type;

public:
    typedef _Alloc allocator_type;

private:
    __node_pointer_type __ptr_ = nullptr;
    optional<allocator_type> __alloc_;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void __release_ptr()
    {
        __ptr_ = nullptr;
        __alloc_ = std::__1::nullopt;
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void __destroy_node_pointer()
    {
        if (__ptr_ != nullptr)
        {
            typedef typename __allocator_traits_rebind<
                allocator_type, _NodeType>::type __node_alloc_type;
            __node_alloc_type __alloc(*__alloc_);
            __generic_container_node_destructor<_NodeType, __node_alloc_type>(
                __alloc, true)(__ptr_);
            __ptr_ = nullptr;
        }
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __basic_node_handle(__node_pointer_type __ptr,
                        allocator_type const& __alloc)
            : __ptr_(__ptr), __alloc_(__alloc)
    {
    }

public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __basic_node_handle() = default;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __basic_node_handle(__basic_node_handle&& __other) noexcept
            : __ptr_(__other.__ptr_),
              __alloc_(std::__1::move(__other.__alloc_))
    {
        __other.__ptr_ = nullptr;
        __other.__alloc_ = std::__1::nullopt;
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __basic_node_handle& operator=(__basic_node_handle&& __other)
    {
        ((void)0);






        __destroy_node_pointer();
        __ptr_ = __other.__ptr_;

        if (__alloc_traits::propagate_on_container_move_assignment::value ||
            __alloc_ == std::__1::nullopt)
            __alloc_ = std::__1::move(__other.__alloc_);

        __other.__ptr_ = nullptr;
        __other.__alloc_ = std::__1::nullopt;

        return *this;
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    allocator_type get_allocator() const { return *__alloc_; }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit operator bool() const { return __ptr_ != nullptr; }

                                  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    bool empty() const { return __ptr_ == nullptr; }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void swap(__basic_node_handle& __other) noexcept(
        __alloc_traits::propagate_on_container_swap::value ||
        __alloc_traits::is_always_equal::value)
    {
        using std::__1::swap;
        swap(__ptr_, __other.__ptr_);
        if (__alloc_traits::propagate_on_container_swap::value ||
            __alloc_ == std::__1::nullopt || __other.__alloc_ == std::__1::nullopt)
            swap(__alloc_, __other.__alloc_);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    friend void swap(__basic_node_handle& __a, __basic_node_handle& __b)
        noexcept(noexcept(__a.swap(__b))) { __a.swap(__b); }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    ~__basic_node_handle()
    {
        __destroy_node_pointer();
    }
};

template <class _NodeType, class _Derived>
struct __set_node_handle_specifics
{
    typedef typename _NodeType::__node_value_type value_type;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    value_type& value() const
    {
        return static_cast<_Derived const*>(this)->__ptr_->__value_;
    }
};

template <class _NodeType, class _Derived>
struct __map_node_handle_specifics
{
    typedef typename _NodeType::__node_value_type::key_type key_type;
    typedef typename _NodeType::__node_value_type::mapped_type mapped_type;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    key_type& key() const
    {
        return static_cast<_Derived const*>(this)->
            __ptr_->__value_.__ref().first;
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    mapped_type& mapped() const
    {
        return static_cast<_Derived const*>(this)->
            __ptr_->__value_.__ref().second;
    }
};

template <class _NodeType, class _Alloc>
using __set_node_handle =
    __basic_node_handle< _NodeType, _Alloc, __set_node_handle_specifics>;

template <class _NodeType, class _Alloc>
using __map_node_handle =
    __basic_node_handle< _NodeType, _Alloc, __map_node_handle_specifics>;

template <class _Iterator, class _NodeType>
struct __attribute__ ((__type_visibility__("default"))) __insert_return_type
{
    _Iterator position;
    bool inserted;
    _NodeType node;
};



} }
# 496 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/map" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__tree" 1 3
# 18 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__tree" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/memory" 1 3
# 974 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/memory" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 1 3
# 20 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/assert.h" 1 3 4
# 44 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/assert.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/stdlib.h" 1 3 4
# 45 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/assert.h" 2 3 4
# 81 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/assert.h" 3 4
extern "C" {
void __assert_rtn(const char *, const char *, int, const char *) __attribute__((__noreturn__)) __attribute__((__cold__)) __attribute__((__disable_tail_calls__));



}
# 21 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 2 3
# 24 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 3
# 975 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/memory" 2 3
# 19 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__tree" 2 3
# 23 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__tree" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 27 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__tree" 2 3


namespace std { inline namespace __1 {
# 38 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__tree" 3
template <class _Tp, class _Compare, class _Allocator> class __tree;
template <class _Tp, class _NodePtr, class _DiffType>
    class __attribute__ ((__type_visibility__("default"))) __tree_iterator;
template <class _Tp, class _ConstNodePtr, class _DiffType>
    class __attribute__ ((__type_visibility__("default"))) __tree_const_iterator;

template <class _Pointer> class __tree_end_node;
template <class _VoidPtr> class __tree_node_base;
template <class _Tp, class _VoidPtr> class __tree_node;

template <class _Key, class _Value>
struct __value_type;

template <class _Allocator> class __map_node_destructor;
template <class _TreeIterator> class __attribute__ ((__type_visibility__("default"))) __map_iterator;
template <class _TreeIterator> class __attribute__ ((__type_visibility__("default"))) __map_const_iterator;
# 78 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__tree" 3
template <class _NodePtr>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
__tree_is_left_child(_NodePtr __x) noexcept
{
    return __x == __x->__parent_->__left_;
}




template <class _NodePtr>
unsigned
__tree_sub_invariant(_NodePtr __x)
{
    if (__x == nullptr)
        return 1;


    if (__x->__left_ != nullptr && __x->__left_->__parent_ != __x)
        return 0;

    if (__x->__right_ != nullptr && __x->__right_->__parent_ != __x)
        return 0;

    if (__x->__left_ == __x->__right_ && __x->__left_ != nullptr)
        return 0;

    if (!__x->__is_black_)
    {
        if (__x->__left_ && !__x->__left_->__is_black_)
            return 0;
        if (__x->__right_ && !__x->__right_->__is_black_)
            return 0;
    }
    unsigned __h = std::__1::__tree_sub_invariant(__x->__left_);
    if (__h == 0)
        return 0;
    if (__h != std::__1::__tree_sub_invariant(__x->__right_))
        return 0;
    return __h + __x->__is_black_;
}




template <class _NodePtr>
bool
__tree_invariant(_NodePtr __root)
{
    if (__root == nullptr)
        return true;

    if (__root->__parent_ == nullptr)
        return false;
    if (!std::__1::__tree_is_left_child(__root))
        return false;

    if (!__root->__is_black_)
        return false;

    return std::__1::__tree_sub_invariant(__root) != 0;
}



template <class _NodePtr>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
_NodePtr
__tree_min(_NodePtr __x) noexcept
{
    while (__x->__left_ != nullptr)
        __x = __x->__left_;
    return __x;
}



template <class _NodePtr>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
_NodePtr
__tree_max(_NodePtr __x) noexcept
{
    while (__x->__right_ != nullptr)
        __x = __x->__right_;
    return __x;
}



template <class _NodePtr>
_NodePtr
__tree_next(_NodePtr __x) noexcept
{
    if (__x->__right_ != nullptr)
        return std::__1::__tree_min(__x->__right_);
    while (!std::__1::__tree_is_left_child(__x))
        __x = __x->__parent_unsafe();
    return __x->__parent_unsafe();
}

template <class _EndNodePtr, class _NodePtr>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
_EndNodePtr
__tree_next_iter(_NodePtr __x) noexcept
{
    if (__x->__right_ != nullptr)
        return static_cast<_EndNodePtr>(std::__1::__tree_min(__x->__right_));
    while (!std::__1::__tree_is_left_child(__x))
        __x = __x->__parent_unsafe();
    return static_cast<_EndNodePtr>(__x->__parent_);
}




template <class _NodePtr, class _EndNodePtr>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
_NodePtr
__tree_prev_iter(_EndNodePtr __x) noexcept
{
    if (__x->__left_ != nullptr)
        return std::__1::__tree_max(__x->__left_);
    _NodePtr __xx = static_cast<_NodePtr>(__x);
    while (std::__1::__tree_is_left_child(__xx))
        __xx = __xx->__parent_unsafe();
    return __xx->__parent_unsafe();
}



template <class _NodePtr>
_NodePtr
__tree_leaf(_NodePtr __x) noexcept
{
    while (true)
    {
        if (__x->__left_ != nullptr)
        {
            __x = __x->__left_;
            continue;
        }
        if (__x->__right_ != nullptr)
        {
            __x = __x->__right_;
            continue;
        }
        break;
    }
    return __x;
}




template <class _NodePtr>
void
__tree_left_rotate(_NodePtr __x) noexcept
{
    _NodePtr __y = __x->__right_;
    __x->__right_ = __y->__left_;
    if (__x->__right_ != nullptr)
        __x->__right_->__set_parent(__x);
    __y->__parent_ = __x->__parent_;
    if (std::__1::__tree_is_left_child(__x))
        __x->__parent_->__left_ = __y;
    else
        __x->__parent_unsafe()->__right_ = __y;
    __y->__left_ = __x;
    __x->__set_parent(__y);
}




template <class _NodePtr>
void
__tree_right_rotate(_NodePtr __x) noexcept
{
    _NodePtr __y = __x->__left_;
    __x->__left_ = __y->__right_;
    if (__x->__left_ != nullptr)
        __x->__left_->__set_parent(__x);
    __y->__parent_ = __x->__parent_;
    if (std::__1::__tree_is_left_child(__x))
        __x->__parent_->__left_ = __y;
    else
        __x->__parent_unsafe()->__right_ = __y;
    __y->__right_ = __x;
    __x->__set_parent(__y);
}
# 278 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__tree" 3
template <class _NodePtr>
void
__tree_balance_after_insert(_NodePtr __root, _NodePtr __x) noexcept
{
    __x->__is_black_ = __x == __root;
    while (__x != __root && !__x->__parent_unsafe()->__is_black_)
    {

        if (std::__1::__tree_is_left_child(__x->__parent_unsafe()))
        {
            _NodePtr __y = __x->__parent_unsafe()->__parent_unsafe()->__right_;
            if (__y != nullptr && !__y->__is_black_)
            {
                __x = __x->__parent_unsafe();
                __x->__is_black_ = true;
                __x = __x->__parent_unsafe();
                __x->__is_black_ = __x == __root;
                __y->__is_black_ = true;
            }
            else
            {
                if (!std::__1::__tree_is_left_child(__x))
                {
                    __x = __x->__parent_unsafe();
                    std::__1::__tree_left_rotate(__x);
                }
                __x = __x->__parent_unsafe();
                __x->__is_black_ = true;
                __x = __x->__parent_unsafe();
                __x->__is_black_ = false;
                std::__1::__tree_right_rotate(__x);
                break;
            }
        }
        else
        {
            _NodePtr __y = __x->__parent_unsafe()->__parent_->__left_;
            if (__y != nullptr && !__y->__is_black_)
            {
                __x = __x->__parent_unsafe();
                __x->__is_black_ = true;
                __x = __x->__parent_unsafe();
                __x->__is_black_ = __x == __root;
                __y->__is_black_ = true;
            }
            else
            {
                if (std::__1::__tree_is_left_child(__x))
                {
                    __x = __x->__parent_unsafe();
                    std::__1::__tree_right_rotate(__x);
                }
                __x = __x->__parent_unsafe();
                __x->__is_black_ = true;
                __x = __x->__parent_unsafe();
                __x->__is_black_ = false;
                std::__1::__tree_left_rotate(__x);
                break;
            }
        }
    }
}
# 348 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__tree" 3
template <class _NodePtr>
void
__tree_remove(_NodePtr __root, _NodePtr __z) noexcept
{




    _NodePtr __y = (__z->__left_ == nullptr || __z->__right_ == nullptr) ?
                    __z : std::__1::__tree_next(__z);

    _NodePtr __x = __y->__left_ != nullptr ? __y->__left_ : __y->__right_;

    _NodePtr __w = nullptr;

    if (__x != nullptr)
        __x->__parent_ = __y->__parent_;
    if (std::__1::__tree_is_left_child(__y))
    {
        __y->__parent_->__left_ = __x;
        if (__y != __root)
            __w = __y->__parent_unsafe()->__right_;
        else
            __root = __x;
    }
    else
    {
        __y->__parent_unsafe()->__right_ = __x;

        __w = __y->__parent_->__left_;
    }
    bool __removed_black = __y->__is_black_;


    if (__y != __z)
    {

        __y->__parent_ = __z->__parent_;
        if (std::__1::__tree_is_left_child(__z))
            __y->__parent_->__left_ = __y;
        else
            __y->__parent_unsafe()->__right_ = __y;
        __y->__left_ = __z->__left_;
        __y->__left_->__set_parent(__y);
        __y->__right_ = __z->__right_;
        if (__y->__right_ != nullptr)
            __y->__right_->__set_parent(__y);
        __y->__is_black_ = __z->__is_black_;
        if (__root == __z)
            __root = __y;
    }


    if (__removed_black && __root != nullptr)
    {
# 415 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__tree" 3
        if (__x != nullptr)
            __x->__is_black_ = true;
        else
        {





            while (true)
            {
                if (!std::__1::__tree_is_left_child(__w))
                {
                    if (!__w->__is_black_)
                    {
                        __w->__is_black_ = true;
                        __w->__parent_unsafe()->__is_black_ = false;
                        std::__1::__tree_left_rotate(__w->__parent_unsafe());


                        if (__root == __w->__left_)
                            __root = __w;

                        __w = __w->__left_->__right_;
                    }

                    if ((__w->__left_ == nullptr || __w->__left_->__is_black_) &&
                        (__w->__right_ == nullptr || __w->__right_->__is_black_))
                    {
                        __w->__is_black_ = false;
                        __x = __w->__parent_unsafe();

                        if (__x == __root || !__x->__is_black_)
                        {
                            __x->__is_black_ = true;
                            break;
                        }

                        __w = std::__1::__tree_is_left_child(__x) ?
                                    __x->__parent_unsafe()->__right_ :
                                    __x->__parent_->__left_;

                    }
                    else
                    {
                        if (__w->__right_ == nullptr || __w->__right_->__is_black_)
                        {

                            __w->__left_->__is_black_ = true;
                            __w->__is_black_ = false;
                            std::__1::__tree_right_rotate(__w);


                            __w = __w->__parent_unsafe();
                        }

                        __w->__is_black_ = __w->__parent_unsafe()->__is_black_;
                        __w->__parent_unsafe()->__is_black_ = true;
                        __w->__right_->__is_black_ = true;
                        std::__1::__tree_left_rotate(__w->__parent_unsafe());
                        break;
                    }
                }
                else
                {
                    if (!__w->__is_black_)
                    {
                        __w->__is_black_ = true;
                        __w->__parent_unsafe()->__is_black_ = false;
                        std::__1::__tree_right_rotate(__w->__parent_unsafe());


                        if (__root == __w->__right_)
                            __root = __w;

                        __w = __w->__right_->__left_;
                    }

                    if ((__w->__left_ == nullptr || __w->__left_->__is_black_) &&
                        (__w->__right_ == nullptr || __w->__right_->__is_black_))
                    {
                        __w->__is_black_ = false;
                        __x = __w->__parent_unsafe();

                        if (!__x->__is_black_ || __x == __root)
                        {
                            __x->__is_black_ = true;
                            break;
                        }

                        __w = std::__1::__tree_is_left_child(__x) ?
                                    __x->__parent_unsafe()->__right_ :
                                    __x->__parent_->__left_;

                    }
                    else
                    {
                        if (__w->__left_ == nullptr || __w->__left_->__is_black_)
                        {

                            __w->__right_->__is_black_ = true;
                            __w->__is_black_ = false;
                            std::__1::__tree_left_rotate(__w);


                            __w = __w->__parent_unsafe();
                        }

                        __w->__is_black_ = __w->__parent_unsafe()->__is_black_;
                        __w->__parent_unsafe()->__is_black_ = true;
                        __w->__left_->__is_black_ = true;
                        std::__1::__tree_right_rotate(__w->__parent_unsafe());
                        break;
                    }
                }
            }
        }
    }
}




template <class _Tp>
struct __is_tree_value_type_imp : false_type {};

template <class _Key, class _Value>
struct __is_tree_value_type_imp<__value_type<_Key, _Value> > : true_type {};

template <class ..._Args>
struct __is_tree_value_type : false_type {};

template <class _One>
struct __is_tree_value_type<_One> : __is_tree_value_type_imp<typename __uncvref<_One>::type> {};

template <class _Tp>
struct __tree_key_value_types {
  typedef _Tp key_type;
  typedef _Tp __node_value_type;
  typedef _Tp __container_value_type;
  static const bool __is_map = false;

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  static key_type const& __get_key(_Tp const& __v) {
    return __v;
  }
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  static __container_value_type const& __get_value(__node_value_type const& __v) {
    return __v;
  }
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  static __container_value_type* __get_ptr(__node_value_type& __n) {
    return std::__1::addressof(__n);
  }
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  static __container_value_type&& __move(__node_value_type& __v) {
    return std::__1::move(__v);
  }
};

template <class _Key, class _Tp>
struct __tree_key_value_types<__value_type<_Key, _Tp> > {
  typedef _Key key_type;
  typedef _Tp mapped_type;
  typedef __value_type<_Key, _Tp> __node_value_type;
  typedef pair<const _Key, _Tp> __container_value_type;
  typedef __container_value_type __map_value_type;
  static const bool __is_map = true;

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  static key_type const&
  __get_key(__node_value_type const& __t) {
    return __t.__get_value().first;
  }

  template <class _Up>
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  static typename enable_if<__is_same_uncvref<_Up, __container_value_type>::value,
      key_type const&>::type
  __get_key(_Up& __t) {
    return __t.first;
  }

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  static __container_value_type const&
  __get_value(__node_value_type const& __t) {
    return __t.__get_value();
  }

  template <class _Up>
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  static typename enable_if<__is_same_uncvref<_Up, __container_value_type>::value,
      __container_value_type const&>::type
  __get_value(_Up& __t) {
    return __t;
  }

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  static __container_value_type* __get_ptr(__node_value_type& __n) {
    return std::__1::addressof(__n.__get_value());
  }

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  static pair<key_type&&, mapped_type&&> __move(__node_value_type& __v) {
    return __v.__move();
  }
};

template <class _VoidPtr>
struct __tree_node_base_types {
  typedef _VoidPtr __void_pointer;

  typedef __tree_node_base<__void_pointer> __node_base_type;
  typedef typename __rebind_pointer<_VoidPtr, __node_base_type>::type
                                                             __node_base_pointer;

  typedef __tree_end_node<__node_base_pointer> __end_node_type;
  typedef typename __rebind_pointer<_VoidPtr, __end_node_type>::type
                                                             __end_node_pointer;



  typedef typename conditional<
      is_pointer<__end_node_pointer>::value,
        __end_node_pointer,
        __node_base_pointer>::type __parent_pointer;


private:
  static_assert((is_same<typename pointer_traits<_VoidPtr>::element_type, void>::value),
                  "_VoidPtr does not point to unqualified void type");
};

template <class _Tp, class _AllocPtr, class _KVTypes = __tree_key_value_types<_Tp>,
         bool = _KVTypes::__is_map>
struct __tree_map_pointer_types {};

template <class _Tp, class _AllocPtr, class _KVTypes>
struct __tree_map_pointer_types<_Tp, _AllocPtr, _KVTypes, true> {
  typedef typename _KVTypes::__map_value_type _Mv;
  typedef typename __rebind_pointer<_AllocPtr, _Mv>::type
                                                       __map_value_type_pointer;
  typedef typename __rebind_pointer<_AllocPtr, const _Mv>::type
                                                 __const_map_value_type_pointer;
};

template <class _NodePtr, class _NodeT = typename pointer_traits<_NodePtr>::element_type>
struct __tree_node_types;

template <class _NodePtr, class _Tp, class _VoidPtr>
struct __tree_node_types<_NodePtr, __tree_node<_Tp, _VoidPtr> >
    : public __tree_node_base_types<_VoidPtr>,
             __tree_key_value_types<_Tp>,
             __tree_map_pointer_types<_Tp, _VoidPtr>
{
  typedef __tree_node_base_types<_VoidPtr> __base;
  typedef __tree_key_value_types<_Tp> __key_base;
  typedef __tree_map_pointer_types<_Tp, _VoidPtr> __map_pointer_base;
public:

  typedef typename pointer_traits<_NodePtr>::element_type __node_type;
  typedef _NodePtr __node_pointer;

  typedef _Tp __node_value_type;
  typedef typename __rebind_pointer<_VoidPtr, __node_value_type>::type
                                                      __node_value_type_pointer;
  typedef typename __rebind_pointer<_VoidPtr, const __node_value_type>::type
                                                __const_node_value_type_pointer;



  typedef typename conditional<
      is_pointer<__node_pointer>::value,
        typename __base::__end_node_pointer,
        __node_pointer>::type __iter_pointer;

private:
    static_assert(!is_const<__node_type>::value,
                "_NodePtr should never be a pointer to const");
    static_assert((is_same<typename __rebind_pointer<_VoidPtr, __node_type>::type,
                          _NodePtr>::value), "_VoidPtr does not rebind to _NodePtr.");
};

template <class _ValueTp, class _VoidPtr>
struct __make_tree_node_types {
  typedef typename __rebind_pointer<_VoidPtr, __tree_node<_ValueTp, _VoidPtr> >::type
                                                                        _NodePtr;
  typedef __tree_node_types<_NodePtr> type;
};



template <class _Pointer>
class __tree_end_node
{
public:
    typedef _Pointer pointer;
    pointer __left_;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __tree_end_node() noexcept : __left_() {}
};

template <class _VoidPtr>
class __attribute__((__standalone_debug__)) __tree_node_base
    : public __tree_node_base_types<_VoidPtr>::__end_node_type
{
    typedef __tree_node_base_types<_VoidPtr> _NodeBaseTypes;

public:
    typedef typename _NodeBaseTypes::__node_base_pointer pointer;
    typedef typename _NodeBaseTypes::__parent_pointer __parent_pointer;

    pointer __right_;
    __parent_pointer __parent_;
    bool __is_black_;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    pointer __parent_unsafe() const { return static_cast<pointer>(__parent_);}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void __set_parent(pointer __p) {
        __parent_ = static_cast<__parent_pointer>(__p);
    }

private:
  ~__tree_node_base() = delete;
  __tree_node_base(__tree_node_base const&) = delete;
  __tree_node_base& operator=(__tree_node_base const&) = delete;
};

template <class _Tp, class _VoidPtr>
class __attribute__((__standalone_debug__)) __tree_node
    : public __tree_node_base<_VoidPtr>
{
public:
    typedef _Tp __node_value_type;

    __node_value_type __value_;

private:
  ~__tree_node() = delete;
  __tree_node(__tree_node const&) = delete;
  __tree_node& operator=(__tree_node const&) = delete;
};


template <class _Allocator>
class __tree_node_destructor
{
    typedef _Allocator allocator_type;
    typedef allocator_traits<allocator_type> __alloc_traits;

public:
    typedef typename __alloc_traits::pointer pointer;
private:
    typedef __tree_node_types<pointer> _NodeTypes;
    allocator_type& __na_;


public:
    bool __value_constructed;


    __tree_node_destructor(const __tree_node_destructor &) = default;
    __tree_node_destructor& operator=(const __tree_node_destructor&) = delete;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit __tree_node_destructor(allocator_type& __na, bool __val = false) noexcept
        : __na_(__na),
          __value_constructed(__val)
        {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void operator()(pointer __p) noexcept
    {
        if (__value_constructed)
            __alloc_traits::destroy(__na_, _NodeTypes::__get_ptr(__p->__value_));
        if (__p)
            __alloc_traits::deallocate(__na_, __p, 1);
    }

    template <class> friend class __map_node_destructor;
};


template <class _NodeType, class _Alloc>
struct __generic_container_node_destructor;
template <class _Tp, class _VoidPtr, class _Alloc>
struct __generic_container_node_destructor<__tree_node<_Tp, _VoidPtr>, _Alloc>
    : __tree_node_destructor<_Alloc>
{
    using __tree_node_destructor<_Alloc>::__tree_node_destructor;
};


template <class _Tp, class _NodePtr, class _DiffType>
class __attribute__ ((__type_visibility__("default"))) __tree_iterator
{
    typedef __tree_node_types<_NodePtr> _NodeTypes;
    typedef _NodePtr __node_pointer;
    typedef typename _NodeTypes::__node_base_pointer __node_base_pointer;
    typedef typename _NodeTypes::__end_node_pointer __end_node_pointer;
    typedef typename _NodeTypes::__iter_pointer __iter_pointer;
    typedef pointer_traits<__node_pointer> __pointer_traits;

    __iter_pointer __ptr_;

public:
    typedef bidirectional_iterator_tag iterator_category;
    typedef _Tp value_type;
    typedef _DiffType difference_type;
    typedef value_type& reference;
    typedef typename _NodeTypes::__node_value_type_pointer pointer;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) __tree_iterator() noexcept

    : __ptr_(nullptr)

    {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) reference operator*() const
        {return __get_np()->__value_;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) pointer operator->() const
        {return pointer_traits<pointer>::pointer_to(__get_np()->__value_);}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __tree_iterator& operator++() {
      __ptr_ = static_cast<__iter_pointer>(
          std::__1::__tree_next_iter<__end_node_pointer>(static_cast<__node_base_pointer>(__ptr_)));
      return *this;
    }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __tree_iterator operator++(int)
        {__tree_iterator __t(*this); ++(*this); return __t;}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __tree_iterator& operator--() {
      __ptr_ = static_cast<__iter_pointer>(std::__1::__tree_prev_iter<__node_base_pointer>(
          static_cast<__end_node_pointer>(__ptr_)));
      return *this;
    }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __tree_iterator operator--(int)
        {__tree_iterator __t(*this); --(*this); return __t;}

    friend __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        bool operator==(const __tree_iterator& __x, const __tree_iterator& __y)
        {return __x.__ptr_ == __y.__ptr_;}
    friend __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        bool operator!=(const __tree_iterator& __x, const __tree_iterator& __y)
        {return !(__x == __y);}

private:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit __tree_iterator(__node_pointer __p) noexcept : __ptr_(__p) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit __tree_iterator(__end_node_pointer __p) noexcept : __ptr_(__p) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __node_pointer __get_np() const { return static_cast<__node_pointer>(__ptr_); }
    template <class, class, class> friend class __tree;
    template <class, class, class> friend class __attribute__ ((__type_visibility__("default"))) __tree_const_iterator;
    template <class> friend class __attribute__ ((__type_visibility__("default"))) __map_iterator;
    template <class, class, class, class> friend class __attribute__ ((__type_visibility__("default"))) map;
    template <class, class, class, class> friend class __attribute__ ((__type_visibility__("default"))) multimap;
    template <class, class, class> friend class __attribute__ ((__type_visibility__("default"))) set;
    template <class, class, class> friend class __attribute__ ((__type_visibility__("default"))) multiset;
};

template <class _Tp, class _NodePtr, class _DiffType>
class __attribute__ ((__type_visibility__("default"))) __tree_const_iterator
{
    typedef __tree_node_types<_NodePtr> _NodeTypes;
    typedef typename _NodeTypes::__node_pointer __node_pointer;
    typedef typename _NodeTypes::__node_base_pointer __node_base_pointer;
    typedef typename _NodeTypes::__end_node_pointer __end_node_pointer;
    typedef typename _NodeTypes::__iter_pointer __iter_pointer;
    typedef pointer_traits<__node_pointer> __pointer_traits;

    __iter_pointer __ptr_;

public:
    typedef bidirectional_iterator_tag iterator_category;
    typedef _Tp value_type;
    typedef _DiffType difference_type;
    typedef const value_type& reference;
    typedef typename _NodeTypes::__const_node_value_type_pointer pointer;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) __tree_const_iterator() noexcept

    : __ptr_(nullptr)

    {}

private:
    typedef __tree_iterator<value_type, __node_pointer, difference_type>
                                                           __non_const_iterator;
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __tree_const_iterator(__non_const_iterator __p) noexcept
        : __ptr_(__p.__ptr_) {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) reference operator*() const
        {return __get_np()->__value_;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) pointer operator->() const
        {return pointer_traits<pointer>::pointer_to(__get_np()->__value_);}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __tree_const_iterator& operator++() {
      __ptr_ = static_cast<__iter_pointer>(
          std::__1::__tree_next_iter<__end_node_pointer>(static_cast<__node_base_pointer>(__ptr_)));
      return *this;
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __tree_const_iterator operator++(int)
        {__tree_const_iterator __t(*this); ++(*this); return __t;}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __tree_const_iterator& operator--() {
      __ptr_ = static_cast<__iter_pointer>(std::__1::__tree_prev_iter<__node_base_pointer>(
          static_cast<__end_node_pointer>(__ptr_)));
      return *this;
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __tree_const_iterator operator--(int)
        {__tree_const_iterator __t(*this); --(*this); return __t;}

    friend __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        bool operator==(const __tree_const_iterator& __x, const __tree_const_iterator& __y)
        {return __x.__ptr_ == __y.__ptr_;}
    friend __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        bool operator!=(const __tree_const_iterator& __x, const __tree_const_iterator& __y)
        {return !(__x == __y);}

private:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit __tree_const_iterator(__node_pointer __p) noexcept
        : __ptr_(__p) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit __tree_const_iterator(__end_node_pointer __p) noexcept
        : __ptr_(__p) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __node_pointer __get_np() const { return static_cast<__node_pointer>(__ptr_); }

    template <class, class, class> friend class __tree;
    template <class, class, class, class> friend class __attribute__ ((__type_visibility__("default"))) map;
    template <class, class, class, class> friend class __attribute__ ((__type_visibility__("default"))) multimap;
    template <class, class, class> friend class __attribute__ ((__type_visibility__("default"))) set;
    template <class, class, class> friend class __attribute__ ((__type_visibility__("default"))) multiset;
    template <class> friend class __attribute__ ((__type_visibility__("default"))) __map_const_iterator;

};

template<class _Tp, class _Compare>

    __attribute__((diagnose_if(!__invokable<_Compare const&, _Tp const&, _Tp const&>::value, "the specified comparator type does not provide a viable const call operator", "warning")))


int __diagnose_non_const_comparator();

template <class _Tp, class _Compare, class _Allocator>
class __tree
{
public:
    typedef _Tp value_type;
    typedef _Compare value_compare;
    typedef _Allocator allocator_type;

private:
    typedef allocator_traits<allocator_type> __alloc_traits;
    typedef typename __make_tree_node_types<value_type,
        typename __alloc_traits::void_pointer>::type
                                                    _NodeTypes;
    typedef typename _NodeTypes::key_type key_type;
public:
    typedef typename _NodeTypes::__node_value_type __node_value_type;
    typedef typename _NodeTypes::__container_value_type __container_value_type;

    typedef typename __alloc_traits::pointer pointer;
    typedef typename __alloc_traits::const_pointer const_pointer;
    typedef typename __alloc_traits::size_type size_type;
    typedef typename __alloc_traits::difference_type difference_type;

public:
    typedef typename _NodeTypes::__void_pointer __void_pointer;

    typedef typename _NodeTypes::__node_type __node;
    typedef typename _NodeTypes::__node_pointer __node_pointer;

    typedef typename _NodeTypes::__node_base_type __node_base;
    typedef typename _NodeTypes::__node_base_pointer __node_base_pointer;

    typedef typename _NodeTypes::__end_node_type __end_node_t;
    typedef typename _NodeTypes::__end_node_pointer __end_node_ptr;

    typedef typename _NodeTypes::__parent_pointer __parent_pointer;
    typedef typename _NodeTypes::__iter_pointer __iter_pointer;

    typedef typename __rebind_alloc_helper<__alloc_traits, __node>::type __node_allocator;
    typedef allocator_traits<__node_allocator> __node_traits;

private:



    static_assert((is_same<__node_pointer, typename __node_traits::pointer>::value),
                  "Allocator does not rebind pointers in a sane manner.");
    typedef typename __rebind_alloc_helper<__node_traits, __node_base>::type
        __node_base_allocator;
    typedef allocator_traits<__node_base_allocator> __node_base_traits;
    static_assert((is_same<__node_base_pointer, typename __node_base_traits::pointer>::value),
                 "Allocator does not rebind pointers in a sane manner.");

private:
    __iter_pointer __begin_node_;
    __compressed_pair<__end_node_t, __node_allocator> __pair1_;
    __compressed_pair<size_type, value_compare> __pair3_;

public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __iter_pointer __end_node() noexcept
    {
        return static_cast<__iter_pointer>(
                pointer_traits<__end_node_ptr>::pointer_to(__pair1_.first())
        );
    }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __iter_pointer __end_node() const noexcept
    {
        return static_cast<__iter_pointer>(
            pointer_traits<__end_node_ptr>::pointer_to(
                const_cast<__end_node_t&>(__pair1_.first())
            )
        );
    }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
          __node_allocator& __node_alloc() noexcept {return __pair1_.second();}
private:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const __node_allocator& __node_alloc() const noexcept
        {return __pair1_.second();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
          __iter_pointer& __begin_node() noexcept {return __begin_node_;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const __iter_pointer& __begin_node() const noexcept {return __begin_node_;}
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    allocator_type __alloc() const noexcept
        {return allocator_type(__node_alloc());}
private:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
          size_type& size() noexcept {return __pair3_.first();}
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const size_type& size() const noexcept {return __pair3_.first();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
          value_compare& value_comp() noexcept {return __pair3_.second();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const value_compare& value_comp() const noexcept
        {return __pair3_.second();}
public:

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __node_pointer __root() const noexcept
        {return static_cast<__node_pointer>(__end_node()->__left_);}

    __node_base_pointer* __root_ptr() const noexcept {
        return std::__1::addressof(__end_node()->__left_);
    }

    typedef __tree_iterator<value_type, __node_pointer, difference_type> iterator;
    typedef __tree_const_iterator<value_type, __node_pointer, difference_type> const_iterator;

    explicit __tree(const value_compare& __comp)
        noexcept(is_nothrow_default_constructible<__node_allocator>::value && is_nothrow_copy_constructible<value_compare>::value);


    explicit __tree(const allocator_type& __a);
    __tree(const value_compare& __comp, const allocator_type& __a);
    __tree(const __tree& __t);
    __tree& operator=(const __tree& __t);
    template <class _ForwardIterator>
        void __assign_unique(_ForwardIterator __first, _ForwardIterator __last);
    template <class _InputIterator>
        void __assign_multi(_InputIterator __first, _InputIterator __last);
    __tree(__tree&& __t)
        noexcept(is_nothrow_move_constructible<__node_allocator>::value && is_nothrow_move_constructible<value_compare>::value);


    __tree(__tree&& __t, const allocator_type& __a);
    __tree& operator=(__tree&& __t)
        noexcept(__node_traits::propagate_on_container_move_assignment::value && is_nothrow_move_assignable<value_compare>::value && is_nothrow_move_assignable<__node_allocator>::value);



    ~__tree();

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
          iterator begin() noexcept {return iterator(__begin_node());}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_iterator begin() const noexcept {return const_iterator(__begin_node());}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
          iterator end() noexcept {return iterator(__end_node());}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_iterator end() const noexcept {return const_iterator(__end_node());}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_type max_size() const noexcept
        {return std::__1::min<size_type>(
                __node_traits::max_size(__node_alloc()),
                numeric_limits<difference_type >::max());}

    void clear() noexcept;

    void swap(__tree& __t)







        noexcept(__is_nothrow_swappable<value_compare>::value);


    template <class _Key, class ..._Args>
    pair<iterator, bool>
    __emplace_unique_key_args(_Key const&, _Args&&... __args);
    template <class _Key, class ..._Args>
    pair<iterator, bool>
    __emplace_hint_unique_key_args(const_iterator, _Key const&, _Args&&...);

    template <class... _Args>
    pair<iterator, bool> __emplace_unique_impl(_Args&&... __args);

    template <class... _Args>
    iterator __emplace_hint_unique_impl(const_iterator __p, _Args&&... __args);

    template <class... _Args>
    iterator __emplace_multi(_Args&&... __args);

    template <class... _Args>
    iterator __emplace_hint_multi(const_iterator __p, _Args&&... __args);

    template <class _Pp>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    pair<iterator, bool> __emplace_unique(_Pp&& __x) {
        return __emplace_unique_extract_key(std::__1::forward<_Pp>(__x),
                                            __can_extract_key<_Pp, key_type>());
    }

    template <class _First, class _Second>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    typename enable_if<
        __can_extract_map_key<_First, key_type, __container_value_type>::value,
        pair<iterator, bool>
    >::type __emplace_unique(_First&& __f, _Second&& __s) {
        return __emplace_unique_key_args(__f, std::__1::forward<_First>(__f),
                                              std::__1::forward<_Second>(__s));
    }

    template <class... _Args>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    pair<iterator, bool> __emplace_unique(_Args&&... __args) {
        return __emplace_unique_impl(std::__1::forward<_Args>(__args)...);
    }

    template <class _Pp>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    pair<iterator, bool>
    __emplace_unique_extract_key(_Pp&& __x, __extract_key_fail_tag) {
      return __emplace_unique_impl(std::__1::forward<_Pp>(__x));
    }

    template <class _Pp>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    pair<iterator, bool>
    __emplace_unique_extract_key(_Pp&& __x, __extract_key_self_tag) {
      return __emplace_unique_key_args(__x, std::__1::forward<_Pp>(__x));
    }

    template <class _Pp>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    pair<iterator, bool>
    __emplace_unique_extract_key(_Pp&& __x, __extract_key_first_tag) {
      return __emplace_unique_key_args(__x.first, std::__1::forward<_Pp>(__x));
    }

    template <class _Pp>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iterator __emplace_hint_unique(const_iterator __p, _Pp&& __x) {
        return __emplace_hint_unique_extract_key(__p, std::__1::forward<_Pp>(__x),
                                            __can_extract_key<_Pp, key_type>());
    }

    template <class _First, class _Second>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    typename enable_if<
        __can_extract_map_key<_First, key_type, __container_value_type>::value,
        iterator
    >::type __emplace_hint_unique(const_iterator __p, _First&& __f, _Second&& __s) {
        return __emplace_hint_unique_key_args(__p, __f,
                                              std::__1::forward<_First>(__f),
                                              std::__1::forward<_Second>(__s)).first;
    }

    template <class... _Args>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iterator __emplace_hint_unique(const_iterator __p, _Args&&... __args) {
        return __emplace_hint_unique_impl(__p, std::__1::forward<_Args>(__args)...);
    }

    template <class _Pp>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iterator
    __emplace_hint_unique_extract_key(const_iterator __p, _Pp&& __x, __extract_key_fail_tag) {
      return __emplace_hint_unique_impl(__p, std::__1::forward<_Pp>(__x));
    }

    template <class _Pp>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iterator
    __emplace_hint_unique_extract_key(const_iterator __p, _Pp&& __x, __extract_key_self_tag) {
      return __emplace_hint_unique_key_args(__p, __x, std::__1::forward<_Pp>(__x)).first;
    }

    template <class _Pp>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iterator
    __emplace_hint_unique_extract_key(const_iterator __p, _Pp&& __x, __extract_key_first_tag) {
      return __emplace_hint_unique_key_args(__p, __x.first, std::__1::forward<_Pp>(__x)).first;
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    pair<iterator, bool> __insert_unique(const __container_value_type& __v) {
        return __emplace_unique_key_args(_NodeTypes::__get_key(__v), __v);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iterator __insert_unique(const_iterator __p, const __container_value_type& __v) {
        return __emplace_hint_unique_key_args(__p, _NodeTypes::__get_key(__v), __v).first;
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    pair<iterator, bool> __insert_unique(__container_value_type&& __v) {
        return __emplace_unique_key_args(_NodeTypes::__get_key(__v), std::__1::move(__v));
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iterator __insert_unique(const_iterator __p, __container_value_type&& __v) {
        return __emplace_hint_unique_key_args(__p, _NodeTypes::__get_key(__v), std::__1::move(__v)).first;
    }

    template <class _Vp, class = typename enable_if<
            !is_same<typename __unconstref<_Vp>::type,
                     __container_value_type
            >::value
        >::type>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    pair<iterator, bool> __insert_unique(_Vp&& __v) {
        return __emplace_unique(std::__1::forward<_Vp>(__v));
    }

    template <class _Vp, class = typename enable_if<
            !is_same<typename __unconstref<_Vp>::type,
                     __container_value_type
            >::value
        >::type>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iterator __insert_unique(const_iterator __p, _Vp&& __v) {
        return __emplace_hint_unique(__p, std::__1::forward<_Vp>(__v));
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iterator __insert_multi(__container_value_type&& __v) {
        return __emplace_multi(std::__1::move(__v));
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iterator __insert_multi(const_iterator __p, __container_value_type&& __v) {
        return __emplace_hint_multi(__p, std::__1::move(__v));
    }

    template <class _Vp>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iterator __insert_multi(_Vp&& __v) {
        return __emplace_multi(std::__1::forward<_Vp>(__v));
    }

    template <class _Vp>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iterator __insert_multi(const_iterator __p, _Vp&& __v) {
        return __emplace_hint_multi(__p, std::__1::forward<_Vp>(__v));
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    pair<iterator, bool> __node_assign_unique(const __container_value_type& __v, __node_pointer __dest);

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iterator __node_insert_multi(__node_pointer __nd);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iterator __node_insert_multi(const_iterator __p, __node_pointer __nd);


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) iterator
    __remove_node_pointer(__node_pointer) noexcept;


    template <class _NodeHandle, class _InsertReturnType>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    _InsertReturnType __node_handle_insert_unique(_NodeHandle&&);
    template <class _NodeHandle>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iterator __node_handle_insert_unique(const_iterator, _NodeHandle&&);
    template <class _Tree>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void __node_handle_merge_unique(_Tree& __source);

    template <class _NodeHandle>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iterator __node_handle_insert_multi(_NodeHandle&&);
    template <class _NodeHandle>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iterator __node_handle_insert_multi(const_iterator, _NodeHandle&&);
    template <class _Tree>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void __node_handle_merge_multi(_Tree& __source);


    template <class _NodeHandle>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    _NodeHandle __node_handle_extract(key_type const&);
    template <class _NodeHandle>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    _NodeHandle __node_handle_extract(const_iterator);


    iterator erase(const_iterator __p);
    iterator erase(const_iterator __f, const_iterator __l);
    template <class _Key>
        size_type __erase_unique(const _Key& __k);
    template <class _Key>
        size_type __erase_multi(const _Key& __k);

    void __insert_node_at(__parent_pointer __parent,
                          __node_base_pointer& __child,
                          __node_base_pointer __new_node) noexcept;

    template <class _Key>
        iterator find(const _Key& __v);
    template <class _Key>
        const_iterator find(const _Key& __v) const;

    template <class _Key>
        size_type __count_unique(const _Key& __k) const;
    template <class _Key>
        size_type __count_multi(const _Key& __k) const;

    template <class _Key>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        iterator lower_bound(const _Key& __v)
            {return __lower_bound(__v, __root(), __end_node());}
    template <class _Key>
        iterator __lower_bound(const _Key& __v,
                               __node_pointer __root,
                               __iter_pointer __result);
    template <class _Key>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        const_iterator lower_bound(const _Key& __v) const
            {return __lower_bound(__v, __root(), __end_node());}
    template <class _Key>
        const_iterator __lower_bound(const _Key& __v,
                                     __node_pointer __root,
                                     __iter_pointer __result) const;
    template <class _Key>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        iterator upper_bound(const _Key& __v)
            {return __upper_bound(__v, __root(), __end_node());}
    template <class _Key>
        iterator __upper_bound(const _Key& __v,
                               __node_pointer __root,
                               __iter_pointer __result);
    template <class _Key>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        const_iterator upper_bound(const _Key& __v) const
            {return __upper_bound(__v, __root(), __end_node());}
    template <class _Key>
        const_iterator __upper_bound(const _Key& __v,
                                     __node_pointer __root,
                                     __iter_pointer __result) const;
    template <class _Key>
        pair<iterator, iterator>
        __equal_range_unique(const _Key& __k);
    template <class _Key>
        pair<const_iterator, const_iterator>
        __equal_range_unique(const _Key& __k) const;

    template <class _Key>
        pair<iterator, iterator>
        __equal_range_multi(const _Key& __k);
    template <class _Key>
        pair<const_iterator, const_iterator>
        __equal_range_multi(const _Key& __k) const;

    typedef __tree_node_destructor<__node_allocator> _Dp;
    typedef unique_ptr<__node, _Dp> __node_holder;

    __node_holder remove(const_iterator __p) noexcept;
private:
    __node_base_pointer&
        __find_leaf_low(__parent_pointer& __parent, const key_type& __v);
    __node_base_pointer&
        __find_leaf_high(__parent_pointer& __parent, const key_type& __v);
    __node_base_pointer&
        __find_leaf(const_iterator __hint,
                    __parent_pointer& __parent, const key_type& __v);


    template <class _Key>
    __node_base_pointer&
        __find_equal(__parent_pointer& __parent, const _Key& __v);
    template <class _Key>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) __node_base_pointer&
    __find_equal(__parent_pointer& __parent, const _Key& __v) const {
      return const_cast<__tree*>(this)->__find_equal(__parent, __v);
    }
    template <class _Key>
    __node_base_pointer&
        __find_equal(const_iterator __hint, __parent_pointer& __parent,
                     __node_base_pointer& __dummy,
                     const _Key& __v);

    template <class ..._Args>
    __node_holder __construct_node(_Args&& ...__args);

    void destroy(__node_pointer __nd) noexcept;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void __copy_assign_alloc(const __tree& __t)
        {__copy_assign_alloc(__t, integral_constant<bool,
             __node_traits::propagate_on_container_copy_assignment::value>());}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void __copy_assign_alloc(const __tree& __t, true_type)
        {
        if (__node_alloc() != __t.__node_alloc())
            clear();
        __node_alloc() = __t.__node_alloc();
        }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void __copy_assign_alloc(const __tree&, false_type) {}

    void __move_assign(__tree& __t, false_type);
    void __move_assign(__tree& __t, true_type)
        noexcept(is_nothrow_move_assignable<value_compare>::value && is_nothrow_move_assignable<__node_allocator>::value);


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void __move_assign_alloc(__tree& __t)
        noexcept(!__node_traits::propagate_on_container_move_assignment::value || is_nothrow_move_assignable<__node_allocator>::value)


        {__move_assign_alloc(__t, integral_constant<bool,
             __node_traits::propagate_on_container_move_assignment::value>());}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void __move_assign_alloc(__tree& __t, true_type)
        noexcept(is_nothrow_move_assignable<__node_allocator>::value)
        {__node_alloc() = std::__1::move(__t.__node_alloc());}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void __move_assign_alloc(__tree&, false_type) noexcept {}

    struct _DetachedTreeCache {
      __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
      explicit _DetachedTreeCache(__tree *__t) noexcept : __t_(__t),
        __cache_root_(__detach_from_tree(__t)) {
          __advance();
        }

      __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
      __node_pointer __get() const noexcept {
        return __cache_elem_;
      }

      __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
      void __advance() noexcept {
        __cache_elem_ = __cache_root_;
        if (__cache_root_) {
          __cache_root_ = __detach_next(__cache_root_);
        }
      }

      __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
      ~_DetachedTreeCache() {
        __t_->destroy(__cache_elem_);
        if (__cache_root_) {
          while (__cache_root_->__parent_ != nullptr)
            __cache_root_ = static_cast<__node_pointer>(__cache_root_->__parent_);
          __t_->destroy(__cache_root_);
        }
      }

       _DetachedTreeCache(_DetachedTreeCache const&) = delete;
       _DetachedTreeCache& operator=(_DetachedTreeCache const&) = delete;

    private:
      __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
      static __node_pointer __detach_from_tree(__tree *__t) noexcept;
      __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
      static __node_pointer __detach_next(__node_pointer) noexcept;

      __tree *__t_;
      __node_pointer __cache_root_;
      __node_pointer __cache_elem_;
    };


    template <class, class, class, class> friend class __attribute__ ((__type_visibility__("default"))) map;
    template <class, class, class, class> friend class __attribute__ ((__type_visibility__("default"))) multimap;
};

template <class _Tp, class _Compare, class _Allocator>
__tree<_Tp, _Compare, _Allocator>::__tree(const value_compare& __comp)
        noexcept(is_nothrow_default_constructible<__node_allocator>::value && is_nothrow_copy_constructible<value_compare>::value)


    : __pair3_(0, __comp)
{
    __begin_node() = __end_node();
}

template <class _Tp, class _Compare, class _Allocator>
__tree<_Tp, _Compare, _Allocator>::__tree(const allocator_type& __a)
    : __begin_node_(__iter_pointer()),
      __pair1_(__default_init_tag(), __node_allocator(__a)),
      __pair3_(0, __default_init_tag())
{
    __begin_node() = __end_node();
}

template <class _Tp, class _Compare, class _Allocator>
__tree<_Tp, _Compare, _Allocator>::__tree(const value_compare& __comp,
                                           const allocator_type& __a)
    : __begin_node_(__iter_pointer()),
      __pair1_(__default_init_tag(), __node_allocator(__a)),
      __pair3_(0, __comp)
{
    __begin_node() = __end_node();
}


template <class _Tp, class _Compare, class _Allocator>
typename __tree<_Tp, _Compare, _Allocator>::__node_pointer
__tree<_Tp, _Compare, _Allocator>::_DetachedTreeCache::__detach_from_tree(__tree *__t) noexcept
{
    __node_pointer __cache = static_cast<__node_pointer>(__t->__begin_node());
    __t->__begin_node() = __t->__end_node();
    __t->__end_node()->__left_->__parent_ = nullptr;
    __t->__end_node()->__left_ = nullptr;
    __t->size() = 0;

    if (__cache->__right_ != nullptr)
        __cache = static_cast<__node_pointer>(__cache->__right_);


    return __cache;
}





template <class _Tp, class _Compare, class _Allocator>
typename __tree<_Tp, _Compare, _Allocator>::__node_pointer
__tree<_Tp, _Compare, _Allocator>::_DetachedTreeCache::__detach_next(__node_pointer __cache) noexcept
{
    if (__cache->__parent_ == nullptr)
        return nullptr;
    if (std::__1::__tree_is_left_child(static_cast<__node_base_pointer>(__cache)))
    {
        __cache->__parent_->__left_ = nullptr;
        __cache = static_cast<__node_pointer>(__cache->__parent_);
        if (__cache->__right_ == nullptr)
            return __cache;
        return static_cast<__node_pointer>(std::__1::__tree_leaf(__cache->__right_));
    }

    __cache->__parent_unsafe()->__right_ = nullptr;
    __cache = static_cast<__node_pointer>(__cache->__parent_);
    if (__cache->__left_ == nullptr)
        return __cache;
    return static_cast<__node_pointer>(std::__1::__tree_leaf(__cache->__left_));
}

template <class _Tp, class _Compare, class _Allocator>
__tree<_Tp, _Compare, _Allocator>&
__tree<_Tp, _Compare, _Allocator>::operator=(const __tree& __t)
{
    if (this != &__t)
    {
        value_comp() = __t.value_comp();
        __copy_assign_alloc(__t);
        __assign_multi(__t.begin(), __t.end());
    }
    return *this;
}

template <class _Tp, class _Compare, class _Allocator>
template <class _ForwardIterator>
void
__tree<_Tp, _Compare, _Allocator>::__assign_unique(_ForwardIterator __first, _ForwardIterator __last)
{
    typedef iterator_traits<_ForwardIterator> _ITraits;
    typedef typename _ITraits::value_type _ItValueType;
    static_assert((is_same<_ItValueType, __container_value_type>::value),
                  "__assign_unique may only be called with the containers value type");
    static_assert(__is_cpp17_forward_iterator<_ForwardIterator>::value,
                  "__assign_unique requires a forward iterator");
    if (size() != 0)
    {
        _DetachedTreeCache __cache(this);
          for (; __cache.__get() != nullptr && __first != __last; ++__first) {
              if (__node_assign_unique(*__first, __cache.__get()).second)
                  __cache.__advance();
            }
    }
    for (; __first != __last; ++__first)
        __insert_unique(*__first);
}

template <class _Tp, class _Compare, class _Allocator>
template <class _InputIterator>
void
__tree<_Tp, _Compare, _Allocator>::__assign_multi(_InputIterator __first, _InputIterator __last)
{
    typedef iterator_traits<_InputIterator> _ITraits;
    typedef typename _ITraits::value_type _ItValueType;
    static_assert((is_same<_ItValueType, __container_value_type>::value ||
                  is_same<_ItValueType, __node_value_type>::value),
                  "__assign_multi may only be called with the containers value type"
                  " or the nodes value type");
    if (size() != 0)
    {
        _DetachedTreeCache __cache(this);
        for (; __cache.__get() && __first != __last; ++__first) {
            __cache.__get()->__value_ = *__first;
            __node_insert_multi(__cache.__get());
            __cache.__advance();
        }
    }
    for (; __first != __last; ++__first)
        __insert_multi(_NodeTypes::__get_value(*__first));
}

template <class _Tp, class _Compare, class _Allocator>
__tree<_Tp, _Compare, _Allocator>::__tree(const __tree& __t)
    : __begin_node_(__iter_pointer()),
      __pair1_(__default_init_tag(), __node_traits::select_on_container_copy_construction(__t.__node_alloc())),
      __pair3_(0, __t.value_comp())
{
    __begin_node() = __end_node();
}

template <class _Tp, class _Compare, class _Allocator>
__tree<_Tp, _Compare, _Allocator>::__tree(__tree&& __t)
    noexcept(is_nothrow_move_constructible<__node_allocator>::value && is_nothrow_move_constructible<value_compare>::value)


    : __begin_node_(std::__1::move(__t.__begin_node_)),
      __pair1_(std::__1::move(__t.__pair1_)),
      __pair3_(std::__1::move(__t.__pair3_))
{
    if (size() == 0)
        __begin_node() = __end_node();
    else
    {
        __end_node()->__left_->__parent_ = static_cast<__parent_pointer>(__end_node());
        __t.__begin_node() = __t.__end_node();
        __t.__end_node()->__left_ = nullptr;
        __t.size() = 0;
    }
}

template <class _Tp, class _Compare, class _Allocator>
__tree<_Tp, _Compare, _Allocator>::__tree(__tree&& __t, const allocator_type& __a)
    : __pair1_(__default_init_tag(), __node_allocator(__a)),
      __pair3_(0, std::__1::move(__t.value_comp()))
{
    if (__a == __t.__alloc())
    {
        if (__t.size() == 0)
            __begin_node() = __end_node();
        else
        {
            __begin_node() = __t.__begin_node();
            __end_node()->__left_ = __t.__end_node()->__left_;
            __end_node()->__left_->__parent_ = static_cast<__parent_pointer>(__end_node());
            size() = __t.size();
            __t.__begin_node() = __t.__end_node();
            __t.__end_node()->__left_ = nullptr;
            __t.size() = 0;
        }
    }
    else
    {
        __begin_node() = __end_node();
    }
}

template <class _Tp, class _Compare, class _Allocator>
void
__tree<_Tp, _Compare, _Allocator>::__move_assign(__tree& __t, true_type)
    noexcept(is_nothrow_move_assignable<value_compare>::value && is_nothrow_move_assignable<__node_allocator>::value)

{
    destroy(static_cast<__node_pointer>(__end_node()->__left_));
    __begin_node_ = __t.__begin_node_;
    __pair1_.first() = __t.__pair1_.first();
    __move_assign_alloc(__t);
    __pair3_ = std::__1::move(__t.__pair3_);
    if (size() == 0)
        __begin_node() = __end_node();
    else
    {
        __end_node()->__left_->__parent_ = static_cast<__parent_pointer>(__end_node());
        __t.__begin_node() = __t.__end_node();
        __t.__end_node()->__left_ = nullptr;
        __t.size() = 0;
    }
}

template <class _Tp, class _Compare, class _Allocator>
void
__tree<_Tp, _Compare, _Allocator>::__move_assign(__tree& __t, false_type)
{
    if (__node_alloc() == __t.__node_alloc())
        __move_assign(__t, true_type());
    else
    {
        value_comp() = std::__1::move(__t.value_comp());
        const_iterator __e = end();
        if (size() != 0)
        {
            _DetachedTreeCache __cache(this);
            while (__cache.__get() != nullptr && __t.size() != 0) {
              __cache.__get()->__value_ = std::__1::move(__t.remove(__t.begin())->__value_);
              __node_insert_multi(__cache.__get());
              __cache.__advance();
            }
        }
        while (__t.size() != 0)
            __insert_multi(__e, _NodeTypes::__move(__t.remove(__t.begin())->__value_));
    }
}

template <class _Tp, class _Compare, class _Allocator>
__tree<_Tp, _Compare, _Allocator>&
__tree<_Tp, _Compare, _Allocator>::operator=(__tree&& __t)
    noexcept(__node_traits::propagate_on_container_move_assignment::value && is_nothrow_move_assignable<value_compare>::value && is_nothrow_move_assignable<__node_allocator>::value)




{
    __move_assign(__t, integral_constant<bool,
                  __node_traits::propagate_on_container_move_assignment::value>());
    return *this;
}

template <class _Tp, class _Compare, class _Allocator>
__tree<_Tp, _Compare, _Allocator>::~__tree()
{
    static_assert((is_copy_constructible<value_compare>::value),
                 "Comparator must be copy-constructible.");
  destroy(__root());
}

template <class _Tp, class _Compare, class _Allocator>
void
__tree<_Tp, _Compare, _Allocator>::destroy(__node_pointer __nd) noexcept
{
    if (__nd != nullptr)
    {
        destroy(static_cast<__node_pointer>(__nd->__left_));
        destroy(static_cast<__node_pointer>(__nd->__right_));
        __node_allocator& __na = __node_alloc();
        __node_traits::destroy(__na, _NodeTypes::__get_ptr(__nd->__value_));
        __node_traits::deallocate(__na, __nd, 1);
    }
}

template <class _Tp, class _Compare, class _Allocator>
void
__tree<_Tp, _Compare, _Allocator>::swap(__tree& __t)







        noexcept(__is_nothrow_swappable<value_compare>::value)

{
    using std::__1::swap;
    swap(__begin_node_, __t.__begin_node_);
    swap(__pair1_.first(), __t.__pair1_.first());
    std::__1::__swap_allocator(__node_alloc(), __t.__node_alloc());
    __pair3_.swap(__t.__pair3_);
    if (size() == 0)
        __begin_node() = __end_node();
    else
        __end_node()->__left_->__parent_ = static_cast<__parent_pointer>(__end_node());
    if (__t.size() == 0)
        __t.__begin_node() = __t.__end_node();
    else
        __t.__end_node()->__left_->__parent_ = static_cast<__parent_pointer>(__t.__end_node());
}

template <class _Tp, class _Compare, class _Allocator>
void
__tree<_Tp, _Compare, _Allocator>::clear() noexcept
{
    destroy(__root());
    size() = 0;
    __begin_node() = __end_node();
    __end_node()->__left_ = nullptr;
}




template <class _Tp, class _Compare, class _Allocator>
typename __tree<_Tp, _Compare, _Allocator>::__node_base_pointer&
__tree<_Tp, _Compare, _Allocator>::__find_leaf_low(__parent_pointer& __parent,
                                                   const key_type& __v)
{
    __node_pointer __nd = __root();
    if (__nd != nullptr)
    {
        while (true)
        {
            if (value_comp()(__nd->__value_, __v))
            {
                if (__nd->__right_ != nullptr)
                    __nd = static_cast<__node_pointer>(__nd->__right_);
                else
                {
                    __parent = static_cast<__parent_pointer>(__nd);
                    return __nd->__right_;
                }
            }
            else
            {
                if (__nd->__left_ != nullptr)
                    __nd = static_cast<__node_pointer>(__nd->__left_);
                else
                {
                    __parent = static_cast<__parent_pointer>(__nd);
                    return __parent->__left_;
                }
            }
        }
    }
    __parent = static_cast<__parent_pointer>(__end_node());
    return __parent->__left_;
}




template <class _Tp, class _Compare, class _Allocator>
typename __tree<_Tp, _Compare, _Allocator>::__node_base_pointer&
__tree<_Tp, _Compare, _Allocator>::__find_leaf_high(__parent_pointer& __parent,
                                                    const key_type& __v)
{
    __node_pointer __nd = __root();
    if (__nd != nullptr)
    {
        while (true)
        {
            if (value_comp()(__v, __nd->__value_))
            {
                if (__nd->__left_ != nullptr)
                    __nd = static_cast<__node_pointer>(__nd->__left_);
                else
                {
                    __parent = static_cast<__parent_pointer>(__nd);
                    return __parent->__left_;
                }
            }
            else
            {
                if (__nd->__right_ != nullptr)
                    __nd = static_cast<__node_pointer>(__nd->__right_);
                else
                {
                    __parent = static_cast<__parent_pointer>(__nd);
                    return __nd->__right_;
                }
            }
        }
    }
    __parent = static_cast<__parent_pointer>(__end_node());
    return __parent->__left_;
}







template <class _Tp, class _Compare, class _Allocator>
typename __tree<_Tp, _Compare, _Allocator>::__node_base_pointer&
__tree<_Tp, _Compare, _Allocator>::__find_leaf(const_iterator __hint,
                                               __parent_pointer& __parent,
                                               const key_type& __v)
{
    if (__hint == end() || !value_comp()(*__hint, __v))
    {

        const_iterator __prior = __hint;
        if (__prior == begin() || !value_comp()(__v, *--__prior))
        {

            if (__hint.__ptr_->__left_ == nullptr)
            {
                __parent = static_cast<__parent_pointer>(__hint.__ptr_);
                return __parent->__left_;
            }
            else
            {
                __parent = static_cast<__parent_pointer>(__prior.__ptr_);
                return static_cast<__node_base_pointer>(__prior.__ptr_)->__right_;
            }
        }

        return __find_leaf_high(__parent, __v);
    }

    return __find_leaf_low(__parent, __v);
}





template <class _Tp, class _Compare, class _Allocator>
template <class _Key>
typename __tree<_Tp, _Compare, _Allocator>::__node_base_pointer&
__tree<_Tp, _Compare, _Allocator>::__find_equal(__parent_pointer& __parent,
                                                const _Key& __v)
{
    __node_pointer __nd = __root();
    __node_base_pointer* __nd_ptr = __root_ptr();
    if (__nd != nullptr)
    {
        while (true)
        {
            if (value_comp()(__v, __nd->__value_))
            {
                if (__nd->__left_ != nullptr) {
                    __nd_ptr = std::__1::addressof(__nd->__left_);
                    __nd = static_cast<__node_pointer>(__nd->__left_);
                } else {
                    __parent = static_cast<__parent_pointer>(__nd);
                    return __parent->__left_;
                }
            }
            else if (value_comp()(__nd->__value_, __v))
            {
                if (__nd->__right_ != nullptr) {
                    __nd_ptr = std::__1::addressof(__nd->__right_);
                    __nd = static_cast<__node_pointer>(__nd->__right_);
                } else {
                    __parent = static_cast<__parent_pointer>(__nd);
                    return __nd->__right_;
                }
            }
            else
            {
                __parent = static_cast<__parent_pointer>(__nd);
                return *__nd_ptr;
            }
        }
    }
    __parent = static_cast<__parent_pointer>(__end_node());
    return __parent->__left_;
}
# 2015 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__tree" 3
template <class _Tp, class _Compare, class _Allocator>
template <class _Key>
typename __tree<_Tp, _Compare, _Allocator>::__node_base_pointer&
__tree<_Tp, _Compare, _Allocator>::__find_equal(const_iterator __hint,
                                                __parent_pointer& __parent,
                                                __node_base_pointer& __dummy,
                                                const _Key& __v)
{
    if (__hint == end() || value_comp()(__v, *__hint))
    {

        const_iterator __prior = __hint;
        if (__prior == begin() || value_comp()(*--__prior, __v))
        {

            if (__hint.__ptr_->__left_ == nullptr)
            {
                __parent = static_cast<__parent_pointer>(__hint.__ptr_);
                return __parent->__left_;
            }
            else
            {
                __parent = static_cast<__parent_pointer>(__prior.__ptr_);
                return static_cast<__node_base_pointer>(__prior.__ptr_)->__right_;
            }
        }

        return __find_equal(__parent, __v);
    }
    else if (value_comp()(*__hint, __v))
    {

        const_iterator __next = std::__1::next(__hint);
        if (__next == end() || value_comp()(__v, *__next))
        {

            if (__hint.__get_np()->__right_ == nullptr)
            {
                __parent = static_cast<__parent_pointer>(__hint.__ptr_);
                return static_cast<__node_base_pointer>(__hint.__ptr_)->__right_;
            }
            else
            {
                __parent = static_cast<__parent_pointer>(__next.__ptr_);
                return __parent->__left_;
            }
        }

        return __find_equal(__parent, __v);
    }

    __parent = static_cast<__parent_pointer>(__hint.__ptr_);
    __dummy = static_cast<__node_base_pointer>(__hint.__ptr_);
    return __dummy;
}

template <class _Tp, class _Compare, class _Allocator>
void __tree<_Tp, _Compare, _Allocator>::__insert_node_at(
    __parent_pointer __parent, __node_base_pointer& __child,
    __node_base_pointer __new_node) noexcept
{
    __new_node->__left_ = nullptr;
    __new_node->__right_ = nullptr;
    __new_node->__parent_ = __parent;

    __child = __new_node;
    if (__begin_node()->__left_ != nullptr)
        __begin_node() = static_cast<__iter_pointer>(__begin_node()->__left_);
    std::__1::__tree_balance_after_insert(__end_node()->__left_, __child);
    ++size();
}

template <class _Tp, class _Compare, class _Allocator>
template <class _Key, class... _Args>
pair<typename __tree<_Tp, _Compare, _Allocator>::iterator, bool>
__tree<_Tp, _Compare, _Allocator>::__emplace_unique_key_args(_Key const& __k, _Args&&... __args)
{
    __parent_pointer __parent;
    __node_base_pointer& __child = __find_equal(__parent, __k);
    __node_pointer __r = static_cast<__node_pointer>(__child);
    bool __inserted = false;
    if (__child == nullptr)
    {
        __node_holder __h = __construct_node(std::__1::forward<_Args>(__args)...);
        __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__h.get()));
        __r = __h.release();
        __inserted = true;
    }
    return pair<iterator, bool>(iterator(__r), __inserted);
}

template <class _Tp, class _Compare, class _Allocator>
template <class _Key, class... _Args>
pair<typename __tree<_Tp, _Compare, _Allocator>::iterator, bool>
__tree<_Tp, _Compare, _Allocator>::__emplace_hint_unique_key_args(
    const_iterator __p, _Key const& __k, _Args&&... __args)
{
    __parent_pointer __parent;
    __node_base_pointer __dummy;
    __node_base_pointer& __child = __find_equal(__p, __parent, __dummy, __k);
    __node_pointer __r = static_cast<__node_pointer>(__child);
    bool __inserted = false;
    if (__child == nullptr)
    {
        __node_holder __h = __construct_node(std::__1::forward<_Args>(__args)...);
        __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__h.get()));
        __r = __h.release();
        __inserted = true;
    }
    return pair<iterator, bool>(iterator(__r), __inserted);
}

template <class _Tp, class _Compare, class _Allocator>
template <class ..._Args>
typename __tree<_Tp, _Compare, _Allocator>::__node_holder
__tree<_Tp, _Compare, _Allocator>::__construct_node(_Args&& ...__args)
{
    static_assert(!__is_tree_value_type<_Args...>::value,
                  "Cannot construct from __value_type");
    __node_allocator& __na = __node_alloc();
    __node_holder __h(__node_traits::allocate(__na, 1), _Dp(__na));
    __node_traits::construct(__na, _NodeTypes::__get_ptr(__h->__value_), std::__1::forward<_Args>(__args)...);
    __h.get_deleter().__value_constructed = true;
    return __h;
}


template <class _Tp, class _Compare, class _Allocator>
template <class... _Args>
pair<typename __tree<_Tp, _Compare, _Allocator>::iterator, bool>
__tree<_Tp, _Compare, _Allocator>::__emplace_unique_impl(_Args&&... __args)
{
    __node_holder __h = __construct_node(std::__1::forward<_Args>(__args)...);
    __parent_pointer __parent;
    __node_base_pointer& __child = __find_equal(__parent, __h->__value_);
    __node_pointer __r = static_cast<__node_pointer>(__child);
    bool __inserted = false;
    if (__child == nullptr)
    {
        __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__h.get()));
        __r = __h.release();
        __inserted = true;
    }
    return pair<iterator, bool>(iterator(__r), __inserted);
}

template <class _Tp, class _Compare, class _Allocator>
template <class... _Args>
typename __tree<_Tp, _Compare, _Allocator>::iterator
__tree<_Tp, _Compare, _Allocator>::__emplace_hint_unique_impl(const_iterator __p, _Args&&... __args)
{
    __node_holder __h = __construct_node(std::__1::forward<_Args>(__args)...);
    __parent_pointer __parent;
    __node_base_pointer __dummy;
    __node_base_pointer& __child = __find_equal(__p, __parent, __dummy, __h->__value_);
    __node_pointer __r = static_cast<__node_pointer>(__child);
    if (__child == nullptr)
    {
        __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__h.get()));
        __r = __h.release();
    }
    return iterator(__r);
}

template <class _Tp, class _Compare, class _Allocator>
template <class... _Args>
typename __tree<_Tp, _Compare, _Allocator>::iterator
__tree<_Tp, _Compare, _Allocator>::__emplace_multi(_Args&&... __args)
{
    __node_holder __h = __construct_node(std::__1::forward<_Args>(__args)...);
    __parent_pointer __parent;
    __node_base_pointer& __child = __find_leaf_high(__parent, _NodeTypes::__get_key(__h->__value_));
    __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__h.get()));
    return iterator(static_cast<__node_pointer>(__h.release()));
}

template <class _Tp, class _Compare, class _Allocator>
template <class... _Args>
typename __tree<_Tp, _Compare, _Allocator>::iterator
__tree<_Tp, _Compare, _Allocator>::__emplace_hint_multi(const_iterator __p,
                                                        _Args&&... __args)
{
    __node_holder __h = __construct_node(std::__1::forward<_Args>(__args)...);
    __parent_pointer __parent;
    __node_base_pointer& __child = __find_leaf(__p, __parent, _NodeTypes::__get_key(__h->__value_));
    __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__h.get()));
    return iterator(static_cast<__node_pointer>(__h.release()));
}

template <class _Tp, class _Compare, class _Allocator>
pair<typename __tree<_Tp, _Compare, _Allocator>::iterator, bool>
__tree<_Tp, _Compare, _Allocator>::__node_assign_unique(const __container_value_type& __v, __node_pointer __nd)
{
    __parent_pointer __parent;
    __node_base_pointer& __child = __find_equal(__parent, _NodeTypes::__get_key(__v));
    __node_pointer __r = static_cast<__node_pointer>(__child);
    bool __inserted = false;
    if (__child == nullptr)
    {
        __nd->__value_ = __v;
        __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__nd));
        __r = __nd;
        __inserted = true;
    }
    return pair<iterator, bool>(iterator(__r), __inserted);
}


template <class _Tp, class _Compare, class _Allocator>
typename __tree<_Tp, _Compare, _Allocator>::iterator
__tree<_Tp, _Compare, _Allocator>::__node_insert_multi(__node_pointer __nd)
{
    __parent_pointer __parent;
    __node_base_pointer& __child = __find_leaf_high(__parent, _NodeTypes::__get_key(__nd->__value_));
    __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__nd));
    return iterator(__nd);
}

template <class _Tp, class _Compare, class _Allocator>
typename __tree<_Tp, _Compare, _Allocator>::iterator
__tree<_Tp, _Compare, _Allocator>::__node_insert_multi(const_iterator __p,
                                                       __node_pointer __nd)
{
    __parent_pointer __parent;
    __node_base_pointer& __child = __find_leaf(__p, __parent, _NodeTypes::__get_key(__nd->__value_));
    __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__nd));
    return iterator(__nd);
}

template <class _Tp, class _Compare, class _Allocator>
typename __tree<_Tp, _Compare, _Allocator>::iterator
__tree<_Tp, _Compare, _Allocator>::__remove_node_pointer(__node_pointer __ptr) noexcept
{
    iterator __r(__ptr);
    ++__r;
    if (__begin_node() == __ptr)
        __begin_node() = __r.__ptr_;
    --size();
    std::__1::__tree_remove(__end_node()->__left_,
                         static_cast<__node_base_pointer>(__ptr));
    return __r;
}


template <class _Tp, class _Compare, class _Allocator>
template <class _NodeHandle, class _InsertReturnType>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
_InsertReturnType
__tree<_Tp, _Compare, _Allocator>::__node_handle_insert_unique(
    _NodeHandle&& __nh)
{
    if (__nh.empty())
        return _InsertReturnType{end(), false, _NodeHandle()};

    __node_pointer __ptr = __nh.__ptr_;
    __parent_pointer __parent;
    __node_base_pointer& __child = __find_equal(__parent,
                                                __ptr->__value_);
    if (__child != nullptr)
        return _InsertReturnType{
            iterator(static_cast<__node_pointer>(__child)),
            false, std::__1::move(__nh)};

    __insert_node_at(__parent, __child,
                     static_cast<__node_base_pointer>(__ptr));
    __nh.__release_ptr();
    return _InsertReturnType{iterator(__ptr), true, _NodeHandle()};
}

template <class _Tp, class _Compare, class _Allocator>
template <class _NodeHandle>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename __tree<_Tp, _Compare, _Allocator>::iterator
__tree<_Tp, _Compare, _Allocator>::__node_handle_insert_unique(
    const_iterator __hint, _NodeHandle&& __nh)
{
    if (__nh.empty())
        return end();

    __node_pointer __ptr = __nh.__ptr_;
    __parent_pointer __parent;
    __node_base_pointer __dummy;
    __node_base_pointer& __child = __find_equal(__hint, __parent, __dummy,
                                                __ptr->__value_);
    __node_pointer __r = static_cast<__node_pointer>(__child);
    if (__child == nullptr)
    {
        __insert_node_at(__parent, __child,
                         static_cast<__node_base_pointer>(__ptr));
        __r = __ptr;
        __nh.__release_ptr();
    }
    return iterator(__r);
}

template <class _Tp, class _Compare, class _Allocator>
template <class _NodeHandle>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
_NodeHandle
__tree<_Tp, _Compare, _Allocator>::__node_handle_extract(key_type const& __key)
{
    iterator __it = find(__key);
    if (__it == end())
        return _NodeHandle();
    return __node_handle_extract<_NodeHandle>(__it);
}

template <class _Tp, class _Compare, class _Allocator>
template <class _NodeHandle>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
_NodeHandle
__tree<_Tp, _Compare, _Allocator>::__node_handle_extract(const_iterator __p)
{
    __node_pointer __np = __p.__get_np();
    __remove_node_pointer(__np);
    return _NodeHandle(__np, __alloc());
}

template <class _Tp, class _Compare, class _Allocator>
template <class _Tree>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void
__tree<_Tp, _Compare, _Allocator>::__node_handle_merge_unique(_Tree& __source)
{
    static_assert(is_same<typename _Tree::__node_pointer, __node_pointer>::value, "");

    for (typename _Tree::iterator __i = __source.begin();
         __i != __source.end();)
    {
        __node_pointer __src_ptr = __i.__get_np();
        __parent_pointer __parent;
        __node_base_pointer& __child =
            __find_equal(__parent, _NodeTypes::__get_key(__src_ptr->__value_));
        ++__i;
        if (__child != nullptr)
            continue;
        __source.__remove_node_pointer(__src_ptr);
        __insert_node_at(__parent, __child,
                         static_cast<__node_base_pointer>(__src_ptr));
    }
}

template <class _Tp, class _Compare, class _Allocator>
template <class _NodeHandle>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename __tree<_Tp, _Compare, _Allocator>::iterator
__tree<_Tp, _Compare, _Allocator>::__node_handle_insert_multi(_NodeHandle&& __nh)
{
    if (__nh.empty())
        return end();
    __node_pointer __ptr = __nh.__ptr_;
    __parent_pointer __parent;
    __node_base_pointer& __child = __find_leaf_high(
        __parent, _NodeTypes::__get_key(__ptr->__value_));
    __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__ptr));
    __nh.__release_ptr();
    return iterator(__ptr);
}

template <class _Tp, class _Compare, class _Allocator>
template <class _NodeHandle>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename __tree<_Tp, _Compare, _Allocator>::iterator
__tree<_Tp, _Compare, _Allocator>::__node_handle_insert_multi(
    const_iterator __hint, _NodeHandle&& __nh)
{
    if (__nh.empty())
        return end();

    __node_pointer __ptr = __nh.__ptr_;
    __parent_pointer __parent;
    __node_base_pointer& __child = __find_leaf(__hint, __parent,
                                               _NodeTypes::__get_key(__ptr->__value_));
    __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__ptr));
    __nh.__release_ptr();
    return iterator(__ptr);
}

template <class _Tp, class _Compare, class _Allocator>
template <class _Tree>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void
__tree<_Tp, _Compare, _Allocator>::__node_handle_merge_multi(_Tree& __source)
{
    static_assert(is_same<typename _Tree::__node_pointer, __node_pointer>::value, "");

    for (typename _Tree::iterator __i = __source.begin();
         __i != __source.end();)
    {
        __node_pointer __src_ptr = __i.__get_np();
        __parent_pointer __parent;
        __node_base_pointer& __child = __find_leaf_high(
            __parent, _NodeTypes::__get_key(__src_ptr->__value_));
        ++__i;
        __source.__remove_node_pointer(__src_ptr);
        __insert_node_at(__parent, __child,
                         static_cast<__node_base_pointer>(__src_ptr));
    }
}



template <class _Tp, class _Compare, class _Allocator>
typename __tree<_Tp, _Compare, _Allocator>::iterator
__tree<_Tp, _Compare, _Allocator>::erase(const_iterator __p)
{
    __node_pointer __np = __p.__get_np();
    iterator __r = __remove_node_pointer(__np);
    __node_allocator& __na = __node_alloc();
    __node_traits::destroy(__na, _NodeTypes::__get_ptr(
        const_cast<__node_value_type&>(*__p)));
    __node_traits::deallocate(__na, __np, 1);
    return __r;
}

template <class _Tp, class _Compare, class _Allocator>
typename __tree<_Tp, _Compare, _Allocator>::iterator
__tree<_Tp, _Compare, _Allocator>::erase(const_iterator __f, const_iterator __l)
{
    while (__f != __l)
        __f = erase(__f);
    return iterator(__l.__ptr_);
}

template <class _Tp, class _Compare, class _Allocator>
template <class _Key>
typename __tree<_Tp, _Compare, _Allocator>::size_type
__tree<_Tp, _Compare, _Allocator>::__erase_unique(const _Key& __k)
{
    iterator __i = find(__k);
    if (__i == end())
        return 0;
    erase(__i);
    return 1;
}

template <class _Tp, class _Compare, class _Allocator>
template <class _Key>
typename __tree<_Tp, _Compare, _Allocator>::size_type
__tree<_Tp, _Compare, _Allocator>::__erase_multi(const _Key& __k)
{
    pair<iterator, iterator> __p = __equal_range_multi(__k);
    size_type __r = 0;
    for (; __p.first != __p.second; ++__r)
        __p.first = erase(__p.first);
    return __r;
}

template <class _Tp, class _Compare, class _Allocator>
template <class _Key>
typename __tree<_Tp, _Compare, _Allocator>::iterator
__tree<_Tp, _Compare, _Allocator>::find(const _Key& __v)
{
    iterator __p = __lower_bound(__v, __root(), __end_node());
    if (__p != end() && !value_comp()(__v, *__p))
        return __p;
    return end();
}

template <class _Tp, class _Compare, class _Allocator>
template <class _Key>
typename __tree<_Tp, _Compare, _Allocator>::const_iterator
__tree<_Tp, _Compare, _Allocator>::find(const _Key& __v) const
{
    const_iterator __p = __lower_bound(__v, __root(), __end_node());
    if (__p != end() && !value_comp()(__v, *__p))
        return __p;
    return end();
}

template <class _Tp, class _Compare, class _Allocator>
template <class _Key>
typename __tree<_Tp, _Compare, _Allocator>::size_type
__tree<_Tp, _Compare, _Allocator>::__count_unique(const _Key& __k) const
{
    __node_pointer __rt = __root();
    while (__rt != nullptr)
    {
        if (value_comp()(__k, __rt->__value_))
        {
            __rt = static_cast<__node_pointer>(__rt->__left_);
        }
        else if (value_comp()(__rt->__value_, __k))
            __rt = static_cast<__node_pointer>(__rt->__right_);
        else
            return 1;
    }
    return 0;
}

template <class _Tp, class _Compare, class _Allocator>
template <class _Key>
typename __tree<_Tp, _Compare, _Allocator>::size_type
__tree<_Tp, _Compare, _Allocator>::__count_multi(const _Key& __k) const
{
    __iter_pointer __result = __end_node();
    __node_pointer __rt = __root();
    while (__rt != nullptr)
    {
        if (value_comp()(__k, __rt->__value_))
        {
            __result = static_cast<__iter_pointer>(__rt);
            __rt = static_cast<__node_pointer>(__rt->__left_);
        }
        else if (value_comp()(__rt->__value_, __k))
            __rt = static_cast<__node_pointer>(__rt->__right_);
        else
            return std::__1::distance(
                __lower_bound(__k, static_cast<__node_pointer>(__rt->__left_), static_cast<__iter_pointer>(__rt)),
                __upper_bound(__k, static_cast<__node_pointer>(__rt->__right_), __result)
            );
    }
    return 0;
}

template <class _Tp, class _Compare, class _Allocator>
template <class _Key>
typename __tree<_Tp, _Compare, _Allocator>::iterator
__tree<_Tp, _Compare, _Allocator>::__lower_bound(const _Key& __v,
                                                 __node_pointer __root,
                                                 __iter_pointer __result)
{
    while (__root != nullptr)
    {
        if (!value_comp()(__root->__value_, __v))
        {
            __result = static_cast<__iter_pointer>(__root);
            __root = static_cast<__node_pointer>(__root->__left_);
        }
        else
            __root = static_cast<__node_pointer>(__root->__right_);
    }
    return iterator(__result);
}

template <class _Tp, class _Compare, class _Allocator>
template <class _Key>
typename __tree<_Tp, _Compare, _Allocator>::const_iterator
__tree<_Tp, _Compare, _Allocator>::__lower_bound(const _Key& __v,
                                                 __node_pointer __root,
                                                 __iter_pointer __result) const
{
    while (__root != nullptr)
    {
        if (!value_comp()(__root->__value_, __v))
        {
            __result = static_cast<__iter_pointer>(__root);
            __root = static_cast<__node_pointer>(__root->__left_);
        }
        else
            __root = static_cast<__node_pointer>(__root->__right_);
    }
    return const_iterator(__result);
}

template <class _Tp, class _Compare, class _Allocator>
template <class _Key>
typename __tree<_Tp, _Compare, _Allocator>::iterator
__tree<_Tp, _Compare, _Allocator>::__upper_bound(const _Key& __v,
                                                 __node_pointer __root,
                                                 __iter_pointer __result)
{
    while (__root != nullptr)
    {
        if (value_comp()(__v, __root->__value_))
        {
            __result = static_cast<__iter_pointer>(__root);
            __root = static_cast<__node_pointer>(__root->__left_);
        }
        else
            __root = static_cast<__node_pointer>(__root->__right_);
    }
    return iterator(__result);
}

template <class _Tp, class _Compare, class _Allocator>
template <class _Key>
typename __tree<_Tp, _Compare, _Allocator>::const_iterator
__tree<_Tp, _Compare, _Allocator>::__upper_bound(const _Key& __v,
                                                 __node_pointer __root,
                                                 __iter_pointer __result) const
{
    while (__root != nullptr)
    {
        if (value_comp()(__v, __root->__value_))
        {
            __result = static_cast<__iter_pointer>(__root);
            __root = static_cast<__node_pointer>(__root->__left_);
        }
        else
            __root = static_cast<__node_pointer>(__root->__right_);
    }
    return const_iterator(__result);
}

template <class _Tp, class _Compare, class _Allocator>
template <class _Key>
pair<typename __tree<_Tp, _Compare, _Allocator>::iterator,
     typename __tree<_Tp, _Compare, _Allocator>::iterator>
__tree<_Tp, _Compare, _Allocator>::__equal_range_unique(const _Key& __k)
{
    typedef pair<iterator, iterator> _Pp;
    __iter_pointer __result = __end_node();
    __node_pointer __rt = __root();
    while (__rt != nullptr)
    {
        if (value_comp()(__k, __rt->__value_))
        {
            __result = static_cast<__iter_pointer>(__rt);
            __rt = static_cast<__node_pointer>(__rt->__left_);
        }
        else if (value_comp()(__rt->__value_, __k))
            __rt = static_cast<__node_pointer>(__rt->__right_);
        else
            return _Pp(iterator(__rt),
                      iterator(
                          __rt->__right_ != nullptr ?
                              static_cast<__iter_pointer>(std::__1::__tree_min(__rt->__right_))
                            : __result));
    }
    return _Pp(iterator(__result), iterator(__result));
}

template <class _Tp, class _Compare, class _Allocator>
template <class _Key>
pair<typename __tree<_Tp, _Compare, _Allocator>::const_iterator,
     typename __tree<_Tp, _Compare, _Allocator>::const_iterator>
__tree<_Tp, _Compare, _Allocator>::__equal_range_unique(const _Key& __k) const
{
    typedef pair<const_iterator, const_iterator> _Pp;
    __iter_pointer __result = __end_node();
    __node_pointer __rt = __root();
    while (__rt != nullptr)
    {
        if (value_comp()(__k, __rt->__value_))
        {
            __result = static_cast<__iter_pointer>(__rt);
            __rt = static_cast<__node_pointer>(__rt->__left_);
        }
        else if (value_comp()(__rt->__value_, __k))
            __rt = static_cast<__node_pointer>(__rt->__right_);
        else
            return _Pp(const_iterator(__rt),
                      const_iterator(
                          __rt->__right_ != nullptr ?
                              static_cast<__iter_pointer>(std::__1::__tree_min(__rt->__right_))
                            : __result));
    }
    return _Pp(const_iterator(__result), const_iterator(__result));
}

template <class _Tp, class _Compare, class _Allocator>
template <class _Key>
pair<typename __tree<_Tp, _Compare, _Allocator>::iterator,
     typename __tree<_Tp, _Compare, _Allocator>::iterator>
__tree<_Tp, _Compare, _Allocator>::__equal_range_multi(const _Key& __k)
{
    typedef pair<iterator, iterator> _Pp;
    __iter_pointer __result = __end_node();
    __node_pointer __rt = __root();
    while (__rt != nullptr)
    {
        if (value_comp()(__k, __rt->__value_))
        {
            __result = static_cast<__iter_pointer>(__rt);
            __rt = static_cast<__node_pointer>(__rt->__left_);
        }
        else if (value_comp()(__rt->__value_, __k))
            __rt = static_cast<__node_pointer>(__rt->__right_);
        else
            return _Pp(__lower_bound(__k, static_cast<__node_pointer>(__rt->__left_), static_cast<__iter_pointer>(__rt)),
                      __upper_bound(__k, static_cast<__node_pointer>(__rt->__right_), __result));
    }
    return _Pp(iterator(__result), iterator(__result));
}

template <class _Tp, class _Compare, class _Allocator>
template <class _Key>
pair<typename __tree<_Tp, _Compare, _Allocator>::const_iterator,
     typename __tree<_Tp, _Compare, _Allocator>::const_iterator>
__tree<_Tp, _Compare, _Allocator>::__equal_range_multi(const _Key& __k) const
{
    typedef pair<const_iterator, const_iterator> _Pp;
    __iter_pointer __result = __end_node();
    __node_pointer __rt = __root();
    while (__rt != nullptr)
    {
        if (value_comp()(__k, __rt->__value_))
        {
            __result = static_cast<__iter_pointer>(__rt);
            __rt = static_cast<__node_pointer>(__rt->__left_);
        }
        else if (value_comp()(__rt->__value_, __k))
            __rt = static_cast<__node_pointer>(__rt->__right_);
        else
            return _Pp(__lower_bound(__k, static_cast<__node_pointer>(__rt->__left_), static_cast<__iter_pointer>(__rt)),
                      __upper_bound(__k, static_cast<__node_pointer>(__rt->__right_), __result));
    }
    return _Pp(const_iterator(__result), const_iterator(__result));
}

template <class _Tp, class _Compare, class _Allocator>
typename __tree<_Tp, _Compare, _Allocator>::__node_holder
__tree<_Tp, _Compare, _Allocator>::remove(const_iterator __p) noexcept
{
    __node_pointer __np = __p.__get_np();
    if (__begin_node() == __p.__ptr_)
    {
        if (__np->__right_ != nullptr)
            __begin_node() = static_cast<__iter_pointer>(__np->__right_);
        else
            __begin_node() = static_cast<__iter_pointer>(__np->__parent_);
    }
    --size();
    std::__1::__tree_remove(__end_node()->__left_,
                         static_cast<__node_base_pointer>(__np));
    return __node_holder(__np, _Dp(__node_alloc(), true));
}

template <class _Tp, class _Compare, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void
swap(__tree<_Tp, _Compare, _Allocator>& __x,
     __tree<_Tp, _Compare, _Allocator>& __y)
    noexcept(noexcept(__x.swap(__y)))
{
    __x.swap(__y);
}

} }
# 497 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/map" 2 3





# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/memory" 1 3
# 974 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/memory" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 1 3
# 20 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/assert.h" 1 3 4
# 44 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/assert.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/stdlib.h" 1 3 4
# 45 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/assert.h" 2 3 4
# 81 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/assert.h" 3 4
extern "C" {
void __assert_rtn(const char *, const char *, int, const char *) __attribute__((__noreturn__)) __attribute__((__cold__)) __attribute__((__disable_tail_calls__));



}
# 21 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 2 3
# 24 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 3
# 975 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/memory" 2 3
# 503 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/map" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 1 3
# 504 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/map" 2 3
# 509 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/map" 3


namespace std { inline namespace __1 {

template <class _Key, class _CP, class _Compare,
          bool = is_empty<_Compare>::value && !__libcpp_is_final<_Compare>::value>
class __map_value_compare
    : private _Compare
{
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __map_value_compare()
        noexcept(is_nothrow_default_constructible<_Compare>::value)
        : _Compare() {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __map_value_compare(_Compare c)
        noexcept(is_nothrow_copy_constructible<_Compare>::value)
        : _Compare(c) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const _Compare& key_comp() const noexcept {return *this;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    bool operator()(const _CP& __x, const _CP& __y) const
        {return static_cast<const _Compare&>(*this)(__x.__get_value().first, __y.__get_value().first);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    bool operator()(const _CP& __x, const _Key& __y) const
        {return static_cast<const _Compare&>(*this)(__x.__get_value().first, __y);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    bool operator()(const _Key& __x, const _CP& __y) const
        {return static_cast<const _Compare&>(*this)(__x, __y.__get_value().first);}
    void swap(__map_value_compare&__y)
        noexcept(__is_nothrow_swappable<_Compare>::value)
    {
      using std::__1::swap;
      swap(static_cast<_Compare&>(*this), static_cast<_Compare&>(__y));
    }


    template <typename _K2>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    typename enable_if<__is_transparent<_Compare, _K2>::value, bool>::type
    operator () ( const _K2& __x, const _CP& __y ) const
        {return static_cast<const _Compare&>(*this) (__x, __y.__get_value().first);}

    template <typename _K2>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    typename enable_if<__is_transparent<_Compare, _K2>::value, bool>::type
    operator () (const _CP& __x, const _K2& __y) const
        {return static_cast<const _Compare&>(*this) (__x.__get_value().first, __y);}

};

template <class _Key, class _CP, class _Compare>
class __map_value_compare<_Key, _CP, _Compare, false>
{
    _Compare comp;

public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __map_value_compare()
        noexcept(is_nothrow_default_constructible<_Compare>::value)
        : comp() {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __map_value_compare(_Compare c)
        noexcept(is_nothrow_copy_constructible<_Compare>::value)
        : comp(c) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const _Compare& key_comp() const noexcept {return comp;}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    bool operator()(const _CP& __x, const _CP& __y) const
        {return comp(__x.__get_value().first, __y.__get_value().first);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    bool operator()(const _CP& __x, const _Key& __y) const
        {return comp(__x.__get_value().first, __y);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    bool operator()(const _Key& __x, const _CP& __y) const
        {return comp(__x, __y.__get_value().first);}
    void swap(__map_value_compare&__y)
        noexcept(__is_nothrow_swappable<_Compare>::value)
    {
        using std::__1::swap;
        swap(comp, __y.comp);
    }


    template <typename _K2>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    typename enable_if<__is_transparent<_Compare, _K2>::value, bool>::type
    operator () ( const _K2& __x, const _CP& __y ) const
        {return comp (__x, __y.__get_value().first);}

    template <typename _K2>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    typename enable_if<__is_transparent<_Compare, _K2>::value, bool>::type
    operator () (const _CP& __x, const _K2& __y) const
        {return comp (__x.__get_value().first, __y);}

};

template <class _Key, class _CP, class _Compare, bool __b>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void
swap(__map_value_compare<_Key, _CP, _Compare, __b>& __x,
     __map_value_compare<_Key, _CP, _Compare, __b>& __y)
    noexcept(noexcept(__x.swap(__y)))
{
    __x.swap(__y);
}

template <class _Allocator>
class __map_node_destructor
{
    typedef _Allocator allocator_type;
    typedef allocator_traits<allocator_type> __alloc_traits;

public:
    typedef typename __alloc_traits::pointer pointer;

private:
    allocator_type& __na_;

    __map_node_destructor& operator=(const __map_node_destructor&);

public:
    bool __first_constructed;
    bool __second_constructed;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit __map_node_destructor(allocator_type& __na) noexcept
        : __na_(__na),
          __first_constructed(false),
          __second_constructed(false)
        {}


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __map_node_destructor(__tree_node_destructor<allocator_type>&& __x) noexcept
        : __na_(__x.__na_),
          __first_constructed(__x.__value_constructed),
          __second_constructed(__x.__value_constructed)
        {
            __x.__value_constructed = false;
        }


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void operator()(pointer __p) noexcept
    {
        if (__second_constructed)
            __alloc_traits::destroy(__na_, std::__1::addressof(__p->__value_.__get_value().second));
        if (__first_constructed)
            __alloc_traits::destroy(__na_, std::__1::addressof(__p->__value_.__get_value().first));
        if (__p)
            __alloc_traits::deallocate(__na_, __p, 1);
    }
};

template <class _Key, class _Tp, class _Compare, class _Allocator>
    class map;
template <class _Key, class _Tp, class _Compare, class _Allocator>
    class multimap;
template <class _TreeIterator> class __map_const_iterator;



template <class _Key, class _Tp>
struct __attribute__((__standalone_debug__)) __value_type
{
    typedef _Key key_type;
    typedef _Tp mapped_type;
    typedef pair<const key_type, mapped_type> value_type;
    typedef pair<key_type&, mapped_type&> __nc_ref_pair_type;
    typedef pair<key_type&&, mapped_type&&> __nc_rref_pair_type;

private:
    value_type __cc;

public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    value_type& __get_value()
    {

        return *std::__1::launder(std::__1::addressof(__cc));



    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const value_type& __get_value() const
    {

        return *std::__1::launder(std::__1::addressof(__cc));



    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __nc_ref_pair_type __ref()
    {
        value_type& __v = __get_value();
        return __nc_ref_pair_type(const_cast<key_type&>(__v.first), __v.second);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __nc_rref_pair_type __move()
    {
        value_type& __v = __get_value();
        return __nc_rref_pair_type(
            std::__1::move(const_cast<key_type&>(__v.first)),
            std::__1::move(__v.second));
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __value_type& operator=(const __value_type& __v)
    {
        __ref() = __v.__get_value();
        return *this;
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __value_type& operator=(__value_type&& __v)
    {
        __ref() = __v.__move();
        return *this;
    }

    template <class _ValueTp,
              class = typename enable_if<
                    __is_same_uncvref<_ValueTp, value_type>::value
                 >::type
             >
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __value_type& operator=(_ValueTp&& __v)
    {
        __ref() = std::__1::forward<_ValueTp>(__v);
        return *this;
    }

private:
    __value_type() = delete;
    ~__value_type() = delete;
    __value_type(const __value_type& __v) = delete;
    __value_type(__value_type&& __v) = delete;
};
# 783 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/map" 3
template <class _Tp>
struct __extract_key_value_types;

template <class _Key, class _Tp>
struct __extract_key_value_types<__value_type<_Key, _Tp> >
{
  typedef _Key const __key_type;
  typedef _Tp __mapped_type;
};

template <class _TreeIterator>
class __attribute__ ((__type_visibility__("default"))) __map_iterator
{
    typedef typename _TreeIterator::_NodeTypes _NodeTypes;
    typedef typename _TreeIterator::__pointer_traits __pointer_traits;

    _TreeIterator __i_;

public:
    typedef bidirectional_iterator_tag iterator_category;
    typedef typename _NodeTypes::__map_value_type value_type;
    typedef typename _TreeIterator::difference_type difference_type;
    typedef value_type& reference;
    typedef typename _NodeTypes::__map_value_type_pointer pointer;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __map_iterator() noexcept {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __map_iterator(_TreeIterator __i) noexcept : __i_(__i) {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    reference operator*() const {return __i_->__get_value();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    pointer operator->() const {return pointer_traits<pointer>::pointer_to(__i_->__get_value());}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __map_iterator& operator++() {++__i_; return *this;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __map_iterator operator++(int)
    {
        __map_iterator __t(*this);
        ++(*this);
        return __t;
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __map_iterator& operator--() {--__i_; return *this;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __map_iterator operator--(int)
    {
        __map_iterator __t(*this);
        --(*this);
        return __t;
    }

    friend __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    bool operator==(const __map_iterator& __x, const __map_iterator& __y)
        {return __x.__i_ == __y.__i_;}
    friend
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    bool operator!=(const __map_iterator& __x, const __map_iterator& __y)
        {return __x.__i_ != __y.__i_;}

    template <class, class, class, class> friend class __attribute__ ((__type_visibility__("default"))) map;
    template <class, class, class, class> friend class __attribute__ ((__type_visibility__("default"))) multimap;
    template <class> friend class __attribute__ ((__type_visibility__("default"))) __map_const_iterator;
};

template <class _TreeIterator>
class __attribute__ ((__type_visibility__("default"))) __map_const_iterator
{
    typedef typename _TreeIterator::_NodeTypes _NodeTypes;
    typedef typename _TreeIterator::__pointer_traits __pointer_traits;

    _TreeIterator __i_;

public:
    typedef bidirectional_iterator_tag iterator_category;
    typedef typename _NodeTypes::__map_value_type value_type;
    typedef typename _TreeIterator::difference_type difference_type;
    typedef const value_type& reference;
    typedef typename _NodeTypes::__const_map_value_type_pointer pointer;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __map_const_iterator() noexcept {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __map_const_iterator(_TreeIterator __i) noexcept : __i_(__i) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __map_const_iterator(__map_iterator<
        typename _TreeIterator::__non_const_iterator> __i) noexcept
        : __i_(__i.__i_) {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    reference operator*() const {return __i_->__get_value();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    pointer operator->() const {return pointer_traits<pointer>::pointer_to(__i_->__get_value());}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __map_const_iterator& operator++() {++__i_; return *this;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __map_const_iterator operator++(int)
    {
        __map_const_iterator __t(*this);
        ++(*this);
        return __t;
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __map_const_iterator& operator--() {--__i_; return *this;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __map_const_iterator operator--(int)
    {
        __map_const_iterator __t(*this);
        --(*this);
        return __t;
    }

    friend __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    bool operator==(const __map_const_iterator& __x, const __map_const_iterator& __y)
        {return __x.__i_ == __y.__i_;}
    friend __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    bool operator!=(const __map_const_iterator& __x, const __map_const_iterator& __y)
        {return __x.__i_ != __y.__i_;}

    template <class, class, class, class> friend class __attribute__ ((__type_visibility__("default"))) map;
    template <class, class, class, class> friend class __attribute__ ((__type_visibility__("default"))) multimap;
    template <class, class, class> friend class __attribute__ ((__type_visibility__("default"))) __tree_const_iterator;
};

template <class _Key, class _Tp, class _Compare = less<_Key>,
          class _Allocator = allocator<pair<const _Key, _Tp> > >
class __attribute__ ((__type_visibility__("default"))) map
{
public:

    typedef _Key key_type;
    typedef _Tp mapped_type;
    typedef pair<const key_type, mapped_type> value_type;
    typedef __identity_t<_Compare> key_compare;
    typedef __identity_t<_Allocator> allocator_type;
    typedef value_type& reference;
    typedef const value_type& const_reference;

    static_assert((is_same<typename allocator_type::value_type, value_type>::value),
                  "Allocator::value_type must be same type as value_type");

#pragma GCC diagnostic push
# 931 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/map" 3
#pragma GCC diagnostic ignored "-Wdeprecated"
# 931 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/map" 3
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
    class __attribute__ ((__type_visibility__("default"))) value_compare



    {
#pragma GCC diagnostic pop
        friend class map;
    protected:
        key_compare comp;

        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) value_compare(key_compare c) : comp(c) {}
    public:

        __attribute__ ((deprecated)) typedef bool result_type;
        __attribute__ ((deprecated)) typedef value_type first_argument_type;
        __attribute__ ((deprecated)) typedef value_type second_argument_type;

        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        bool operator()(const value_type& __x, const value_type& __y) const
            {return comp(__x.first, __y.first);}
    };

private:

    typedef std::__1::__value_type<key_type, mapped_type> __value_type;
    typedef __map_value_compare<key_type, __value_type, key_compare> __vc;
    typedef typename __rebind_alloc_helper<allocator_traits<allocator_type>,
                                                 __value_type>::type __allocator_type;
    typedef __tree<__value_type, __vc, __allocator_type> __base;
    typedef typename __base::__node_traits __node_traits;
    typedef allocator_traits<allocator_type> __alloc_traits;

    __base __tree_;

public:
    typedef typename __alloc_traits::pointer pointer;
    typedef typename __alloc_traits::const_pointer const_pointer;
    typedef typename __alloc_traits::size_type size_type;
    typedef typename __alloc_traits::difference_type difference_type;
    typedef __map_iterator<typename __base::iterator> iterator;
    typedef __map_const_iterator<typename __base::const_iterator> const_iterator;
    typedef std::__1::reverse_iterator<iterator> reverse_iterator;
    typedef std::__1::reverse_iterator<const_iterator> const_reverse_iterator;


    typedef __map_node_handle<typename __base::__node, allocator_type> node_type;
    typedef __insert_return_type<iterator, node_type> insert_return_type;


    template <class _Key2, class _Value2, class _Comp2, class _Alloc2>
        friend class __attribute__ ((__type_visibility__("default"))) map;
    template <class _Key2, class _Value2, class _Comp2, class _Alloc2>
        friend class __attribute__ ((__type_visibility__("default"))) multimap;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    map()
        noexcept(is_nothrow_default_constructible<allocator_type>::value && is_nothrow_default_constructible<key_compare>::value && is_nothrow_copy_constructible<key_compare>::value)



        : __tree_(__vc(key_compare())) {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit map(const key_compare& __comp)
        noexcept(is_nothrow_default_constructible<allocator_type>::value && is_nothrow_copy_constructible<key_compare>::value)


        : __tree_(__vc(__comp)) {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit map(const key_compare& __comp, const allocator_type& __a)
        : __tree_(__vc(__comp), typename __base::allocator_type(__a)) {}

    template <class _InputIterator>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        map(_InputIterator __f, _InputIterator __l,
            const key_compare& __comp = key_compare())
        : __tree_(__vc(__comp))
        {
            insert(__f, __l);
        }

    template <class _InputIterator>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        map(_InputIterator __f, _InputIterator __l,
            const key_compare& __comp, const allocator_type& __a)
        : __tree_(__vc(__comp), typename __base::allocator_type(__a))
        {
            insert(__f, __l);
        }


    template <class _InputIterator>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    map(_InputIterator __f, _InputIterator __l, const allocator_type& __a)
        : map(__f, __l, key_compare(), __a) {}


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    map(const map& __m)
        : __tree_(__m.__tree_)
        {
            insert(__m.begin(), __m.end());
        }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    map& operator=(const map& __m)
        {

            __tree_ = __m.__tree_;
# 1050 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/map" 3
            return *this;
        }



    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    map(map&& __m)
        noexcept(is_nothrow_move_constructible<__base>::value)
        : __tree_(std::__1::move(__m.__tree_))
        {
        }

    map(map&& __m, const allocator_type& __a);

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    map& operator=(map&& __m)
        noexcept(is_nothrow_move_assignable<__base>::value)
        {
            __tree_ = std::__1::move(__m.__tree_);
            return *this;
        }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    map(initializer_list<value_type> __il, const key_compare& __comp = key_compare())
        : __tree_(__vc(__comp))
        {
            insert(__il.begin(), __il.end());
        }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    map(initializer_list<value_type> __il, const key_compare& __comp, const allocator_type& __a)
        : __tree_(__vc(__comp), typename __base::allocator_type(__a))
        {
            insert(__il.begin(), __il.end());
        }


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    map(initializer_list<value_type> __il, const allocator_type& __a)
        : map(__il, key_compare(), __a) {}


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    map& operator=(initializer_list<value_type> __il)
        {
            __tree_.__assign_unique(__il.begin(), __il.end());
            return *this;
        }



    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit map(const allocator_type& __a)
        : __tree_(typename __base::allocator_type(__a))
        {
        }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    map(const map& __m, const allocator_type& __a)
        : __tree_(__m.__tree_.value_comp(), typename __base::allocator_type(__a))
        {
            insert(__m.begin(), __m.end());
        }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    ~map() {
        static_assert(sizeof(__diagnose_non_const_comparator<_Key, _Compare>()), "");
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
          iterator begin() noexcept {return __tree_.begin();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_iterator begin() const noexcept {return __tree_.begin();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
          iterator end() noexcept {return __tree_.end();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_iterator end() const noexcept {return __tree_.end();}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
          reverse_iterator rbegin() noexcept {return reverse_iterator(end());}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_reverse_iterator rbegin() const noexcept
        {return const_reverse_iterator(end());}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
          reverse_iterator rend() noexcept
            {return reverse_iterator(begin());}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_reverse_iterator rend() const noexcept
        {return const_reverse_iterator(begin());}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_iterator cbegin() const noexcept {return begin();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_iterator cend() const noexcept {return end();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_reverse_iterator crbegin() const noexcept {return rbegin();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_reverse_iterator crend() const noexcept {return rend();}

                                  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    bool empty() const noexcept {return __tree_.size() == 0;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_type size() const noexcept {return __tree_.size();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_type max_size() const noexcept {return __tree_.max_size();}

    mapped_type& operator[](const key_type& __k);

    mapped_type& operator[](key_type&& __k);


          mapped_type& at(const key_type& __k);
    const mapped_type& at(const key_type& __k) const;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    allocator_type get_allocator() const noexcept {return allocator_type(__tree_.__alloc());}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    key_compare key_comp() const {return __tree_.value_comp().key_comp();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    value_compare value_comp() const {return value_compare(__tree_.value_comp().key_comp());}


    template <class ..._Args>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    pair<iterator, bool> emplace(_Args&& ...__args) {
        return __tree_.__emplace_unique(std::__1::forward<_Args>(__args)...);
    }

    template <class ..._Args>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iterator emplace_hint(const_iterator __p, _Args&& ...__args) {
        return __tree_.__emplace_hint_unique(__p.__i_, std::__1::forward<_Args>(__args)...);
    }

    template <class _Pp,
              class = typename enable_if<is_constructible<value_type, _Pp>::value>::type>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        pair<iterator, bool> insert(_Pp&& __p)
            {return __tree_.__insert_unique(std::__1::forward<_Pp>(__p));}

    template <class _Pp,
              class = typename enable_if<is_constructible<value_type, _Pp>::value>::type>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        iterator insert(const_iterator __pos, _Pp&& __p)
            {return __tree_.__insert_unique(__pos.__i_, std::__1::forward<_Pp>(__p));}



    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    pair<iterator, bool>
        insert(const value_type& __v) {return __tree_.__insert_unique(__v);}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iterator
        insert(const_iterator __p, const value_type& __v)
            {return __tree_.__insert_unique(__p.__i_, __v);}


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    pair<iterator, bool>
    insert(value_type&& __v) {return __tree_.__insert_unique(std::__1::move(__v));}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iterator insert(const_iterator __p, value_type&& __v)
    {return __tree_.__insert_unique(__p.__i_, std::__1::move(__v));}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void insert(initializer_list<value_type> __il)
        {insert(__il.begin(), __il.end());}


    template <class _InputIterator>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        void insert(_InputIterator __f, _InputIterator __l)
        {
            for (const_iterator __e = cend(); __f != __l; ++__f)
                insert(__e.__i_, *__f);
        }



    template <class... _Args>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        pair<iterator, bool> try_emplace(const key_type& __k, _Args&&... __args)
    {
        return __tree_.__emplace_unique_key_args(__k,
            std::__1::piecewise_construct,
            std::__1::forward_as_tuple(__k),
            std::__1::forward_as_tuple(std::__1::forward<_Args>(__args)...));
    }

    template <class... _Args>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        pair<iterator, bool> try_emplace(key_type&& __k, _Args&&... __args)
    {
        return __tree_.__emplace_unique_key_args(__k,
            std::__1::piecewise_construct,
            std::__1::forward_as_tuple(std::__1::move(__k)),
            std::__1::forward_as_tuple(std::__1::forward<_Args>(__args)...));
    }

    template <class... _Args>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        iterator try_emplace(const_iterator __h, const key_type& __k, _Args&&... __args)
    {
        return __tree_.__emplace_hint_unique_key_args(__h.__i_, __k,
            std::__1::piecewise_construct,
            std::__1::forward_as_tuple(__k),
            std::__1::forward_as_tuple(std::__1::forward<_Args>(__args)...)).first;
    }

    template <class... _Args>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        iterator try_emplace(const_iterator __h, key_type&& __k, _Args&&... __args)
    {
        return __tree_.__emplace_hint_unique_key_args(__h.__i_, __k,
            std::__1::piecewise_construct,
            std::__1::forward_as_tuple(std::__1::move(__k)),
            std::__1::forward_as_tuple(std::__1::forward<_Args>(__args)...)).first;
    }

    template <class _Vp>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        pair<iterator, bool> insert_or_assign(const key_type& __k, _Vp&& __v)
    {
        iterator __p = lower_bound(__k);
        if ( __p != end() && !key_comp()(__k, __p->first))
        {
            __p->second = std::__1::forward<_Vp>(__v);
            return std::__1::make_pair(__p, false);
        }
        return std::__1::make_pair(emplace_hint(__p, __k, std::__1::forward<_Vp>(__v)), true);
    }

    template <class _Vp>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        pair<iterator, bool> insert_or_assign(key_type&& __k, _Vp&& __v)
    {
        iterator __p = lower_bound(__k);
        if ( __p != end() && !key_comp()(__k, __p->first))
        {
            __p->second = std::__1::forward<_Vp>(__v);
            return std::__1::make_pair(__p, false);
        }
        return std::__1::make_pair(emplace_hint(__p, std::__1::move(__k), std::__1::forward<_Vp>(__v)), true);
    }

    template <class _Vp>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) iterator insert_or_assign(const_iterator __h,
                                                        const key_type& __k,
                                                        _Vp&& __v) {
      auto [__r, __inserted] = __tree_.__emplace_hint_unique_key_args(
          __h.__i_, __k, __k, std::__1::forward<_Vp>(__v));

      if (!__inserted)
        __r->__get_value().second = std::__1::forward<_Vp>(__v);

      return __r;
    }

    template <class _Vp>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) iterator insert_or_assign(const_iterator __h,
                                                        key_type&& __k,
                                                        _Vp&& __v) {
      auto [__r, __inserted] = __tree_.__emplace_hint_unique_key_args(
          __h.__i_, __k, std::__1::move(__k), std::__1::forward<_Vp>(__v));

      if (!__inserted)
        __r->__get_value().second = std::__1::forward<_Vp>(__v);

      return __r;
    }



    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iterator erase(const_iterator __p) {return __tree_.erase(__p.__i_);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iterator erase(iterator __p) {return __tree_.erase(__p.__i_);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_type erase(const key_type& __k)
        {return __tree_.__erase_unique(__k);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iterator erase(const_iterator __f, const_iterator __l)
        {return __tree_.erase(__f.__i_, __l.__i_);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void clear() noexcept {__tree_.clear();}


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    insert_return_type insert(node_type&& __nh)
    {
        ((void)0);

        return __tree_.template __node_handle_insert_unique<
            node_type, insert_return_type>(std::__1::move(__nh));
    }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iterator insert(const_iterator __hint, node_type&& __nh)
    {
        ((void)0);

        return __tree_.template __node_handle_insert_unique<node_type>(
            __hint.__i_, std::__1::move(__nh));
    }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    node_type extract(key_type const& __key)
    {
        return __tree_.template __node_handle_extract<node_type>(__key);
    }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    node_type extract(const_iterator __it)
    {
        return __tree_.template __node_handle_extract<node_type>(__it.__i_);
    }
    template <class _Compare2>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void merge(map<key_type, mapped_type, _Compare2, allocator_type>& __source)
    {
        ((void)0);

        __tree_.__node_handle_merge_unique(__source.__tree_);
    }
    template <class _Compare2>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void merge(map<key_type, mapped_type, _Compare2, allocator_type>&& __source)
    {
        ((void)0);

        __tree_.__node_handle_merge_unique(__source.__tree_);
    }
    template <class _Compare2>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void merge(multimap<key_type, mapped_type, _Compare2, allocator_type>& __source)
    {
        ((void)0);

        __tree_.__node_handle_merge_unique(__source.__tree_);
    }
    template <class _Compare2>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void merge(multimap<key_type, mapped_type, _Compare2, allocator_type>&& __source)
    {
        ((void)0);

        __tree_.__node_handle_merge_unique(__source.__tree_);
    }


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void swap(map& __m)
        noexcept(__is_nothrow_swappable<__base>::value)
        {__tree_.swap(__m.__tree_);}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iterator find(const key_type& __k) {return __tree_.find(__k);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_iterator find(const key_type& __k) const {return __tree_.find(__k);}

    template <typename _K2>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    typename enable_if<__is_transparent<_Compare, _K2>::value,iterator>::type
    find(const _K2& __k) {return __tree_.find(__k);}
    template <typename _K2>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    typename enable_if<__is_transparent<_Compare, _K2>::value,const_iterator>::type
    find(const _K2& __k) const {return __tree_.find(__k);}


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_type count(const key_type& __k) const
        {return __tree_.__count_unique(__k);}

    template <typename _K2>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    typename enable_if<__is_transparent<_Compare, _K2>::value,size_type>::type
    count(const _K2& __k) const {return __tree_.__count_multi(__k);}
# 1438 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/map" 3
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iterator lower_bound(const key_type& __k)
        {return __tree_.lower_bound(__k);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_iterator lower_bound(const key_type& __k) const
        {return __tree_.lower_bound(__k);}

    template <typename _K2>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    typename enable_if<__is_transparent<_Compare, _K2>::value,iterator>::type
    lower_bound(const _K2& __k) {return __tree_.lower_bound(__k);}

    template <typename _K2>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    typename enable_if<__is_transparent<_Compare, _K2>::value,const_iterator>::type
    lower_bound(const _K2& __k) const {return __tree_.lower_bound(__k);}


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iterator upper_bound(const key_type& __k)
        {return __tree_.upper_bound(__k);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_iterator upper_bound(const key_type& __k) const
        {return __tree_.upper_bound(__k);}

    template <typename _K2>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    typename enable_if<__is_transparent<_Compare, _K2>::value,iterator>::type
    upper_bound(const _K2& __k) {return __tree_.upper_bound(__k);}
    template <typename _K2>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    typename enable_if<__is_transparent<_Compare, _K2>::value,const_iterator>::type
    upper_bound(const _K2& __k) const {return __tree_.upper_bound(__k);}


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    pair<iterator,iterator> equal_range(const key_type& __k)
        {return __tree_.__equal_range_unique(__k);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    pair<const_iterator,const_iterator> equal_range(const key_type& __k) const
        {return __tree_.__equal_range_unique(__k);}

    template <typename _K2>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    typename enable_if<__is_transparent<_Compare, _K2>::value,pair<iterator,iterator>>::type
    equal_range(const _K2& __k) {return __tree_.__equal_range_multi(__k);}
    template <typename _K2>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    typename enable_if<__is_transparent<_Compare, _K2>::value,pair<const_iterator,const_iterator>>::type
    equal_range(const _K2& __k) const {return __tree_.__equal_range_multi(__k);}


private:
    typedef typename __base::__node __node;
    typedef typename __base::__node_allocator __node_allocator;
    typedef typename __base::__node_pointer __node_pointer;
    typedef typename __base::__node_base_pointer __node_base_pointer;
    typedef typename __base::__parent_pointer __parent_pointer;

    typedef __map_node_destructor<__node_allocator> _Dp;
    typedef unique_ptr<__node, _Dp> __node_holder;




};


template<class _InputIterator, class _Compare = less<__iter_key_type<_InputIterator>>,
         class _Allocator = allocator<__iter_to_alloc_type<_InputIterator>>,
         class = _EnableIf<!__is_allocator<_Compare>::value, void>,
         class = _EnableIf<__is_allocator<_Allocator>::value, void>>
map(_InputIterator, _InputIterator, _Compare = _Compare(), _Allocator = _Allocator())
  -> map<__iter_key_type<_InputIterator>, __iter_mapped_type<_InputIterator>, _Compare, _Allocator>;

template<class _Key, class _Tp, class _Compare = less<remove_const_t<_Key>>,
         class _Allocator = allocator<pair<const _Key, _Tp>>,
         class = _EnableIf<!__is_allocator<_Compare>::value, void>,
         class = _EnableIf<__is_allocator<_Allocator>::value, void>>
map(initializer_list<pair<_Key, _Tp>>, _Compare = _Compare(), _Allocator = _Allocator())
  -> map<remove_const_t<_Key>, _Tp, _Compare, _Allocator>;

template<class _InputIterator, class _Allocator,
         class = _EnableIf<__is_allocator<_Allocator>::value, void>>
map(_InputIterator, _InputIterator, _Allocator)
  -> map<__iter_key_type<_InputIterator>, __iter_mapped_type<_InputIterator>,
         less<__iter_key_type<_InputIterator>>, _Allocator>;

template<class _Key, class _Tp, class _Allocator,
         class = _EnableIf<__is_allocator<_Allocator>::value, void>>
map(initializer_list<pair<_Key, _Tp>>, _Allocator)
  -> map<remove_const_t<_Key>, _Tp, less<remove_const_t<_Key>>, _Allocator>;



template <class _Key, class _Tp, class _Compare, class _Allocator>
map<_Key, _Tp, _Compare, _Allocator>::map(map&& __m, const allocator_type& __a)
    : __tree_(std::__1::move(__m.__tree_), typename __base::allocator_type(__a))
{
    if (__a != __m.get_allocator())
    {
        const_iterator __e = cend();
        while (!__m.empty())
            __tree_.__insert_unique(__e.__i_,
                    __m.__tree_.remove(__m.begin().__i_)->__value_.__move());
    }
}

template <class _Key, class _Tp, class _Compare, class _Allocator>
_Tp&
map<_Key, _Tp, _Compare, _Allocator>::operator[](const key_type& __k)
{
    return __tree_.__emplace_unique_key_args(__k,
        std::__1::piecewise_construct,
        std::__1::forward_as_tuple(__k),
        std::__1::forward_as_tuple()).first->__get_value().second;
}

template <class _Key, class _Tp, class _Compare, class _Allocator>
_Tp&
map<_Key, _Tp, _Compare, _Allocator>::operator[](key_type&& __k)
{
    return __tree_.__emplace_unique_key_args(__k,
        std::__1::piecewise_construct,
        std::__1::forward_as_tuple(std::__1::move(__k)),
        std::__1::forward_as_tuple()).first->__get_value().second;
}
# 1599 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/map" 3
template <class _Key, class _Tp, class _Compare, class _Allocator>
_Tp&
map<_Key, _Tp, _Compare, _Allocator>::at(const key_type& __k)
{
    __parent_pointer __parent;
    __node_base_pointer& __child = __tree_.__find_equal(__parent, __k);
    if (__child == nullptr)
        __throw_out_of_range("map::at:  key not found");
    return static_cast<__node_pointer>(__child)->__value_.__get_value().second;
}

template <class _Key, class _Tp, class _Compare, class _Allocator>
const _Tp&
map<_Key, _Tp, _Compare, _Allocator>::at(const key_type& __k) const
{
    __parent_pointer __parent;
    __node_base_pointer __child = __tree_.__find_equal(__parent, __k);
    if (__child == nullptr)
        __throw_out_of_range("map::at:  key not found");
    return static_cast<__node_pointer>(__child)->__value_.__get_value().second;
}


template <class _Key, class _Tp, class _Compare, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator==(const map<_Key, _Tp, _Compare, _Allocator>& __x,
           const map<_Key, _Tp, _Compare, _Allocator>& __y)
{
    return __x.size() == __y.size() && std::__1::equal(__x.begin(), __x.end(), __y.begin());
}

template <class _Key, class _Tp, class _Compare, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator< (const map<_Key, _Tp, _Compare, _Allocator>& __x,
           const map<_Key, _Tp, _Compare, _Allocator>& __y)
{
    return std::__1::lexicographical_compare(__x.begin(), __x.end(), __y.begin(), __y.end());
}

template <class _Key, class _Tp, class _Compare, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator!=(const map<_Key, _Tp, _Compare, _Allocator>& __x,
           const map<_Key, _Tp, _Compare, _Allocator>& __y)
{
    return !(__x == __y);
}

template <class _Key, class _Tp, class _Compare, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator> (const map<_Key, _Tp, _Compare, _Allocator>& __x,
           const map<_Key, _Tp, _Compare, _Allocator>& __y)
{
    return __y < __x;
}

template <class _Key, class _Tp, class _Compare, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator>=(const map<_Key, _Tp, _Compare, _Allocator>& __x,
           const map<_Key, _Tp, _Compare, _Allocator>& __y)
{
    return !(__x < __y);
}

template <class _Key, class _Tp, class _Compare, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator<=(const map<_Key, _Tp, _Compare, _Allocator>& __x,
           const map<_Key, _Tp, _Compare, _Allocator>& __y)
{
    return !(__y < __x);
}

template <class _Key, class _Tp, class _Compare, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void
swap(map<_Key, _Tp, _Compare, _Allocator>& __x,
     map<_Key, _Tp, _Compare, _Allocator>& __y)
    noexcept(noexcept(__x.swap(__y)))
{
    __x.swap(__y);
}
# 1697 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/map" 3
template <class _Key, class _Tp, class _Compare = less<_Key>,
          class _Allocator = allocator<pair<const _Key, _Tp> > >
class __attribute__ ((__type_visibility__("default"))) multimap
{
public:

    typedef _Key key_type;
    typedef _Tp mapped_type;
    typedef pair<const key_type, mapped_type> value_type;
    typedef __identity_t<_Compare> key_compare;
    typedef __identity_t<_Allocator> allocator_type;
    typedef value_type& reference;
    typedef const value_type& const_reference;

    static_assert((is_same<typename allocator_type::value_type, value_type>::value),
                  "Allocator::value_type must be same type as value_type");

#pragma GCC diagnostic push
# 1714 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/map" 3
#pragma GCC diagnostic ignored "-Wdeprecated"
# 1714 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/map" 3
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
    class __attribute__ ((__type_visibility__("default"))) value_compare



    {
#pragma GCC diagnostic pop
        friend class multimap;
    protected:
        key_compare comp;

        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        value_compare(key_compare c) : comp(c) {}
    public:

        __attribute__ ((deprecated)) typedef bool result_type;
        __attribute__ ((deprecated)) typedef value_type first_argument_type;
        __attribute__ ((deprecated)) typedef value_type second_argument_type;

        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        bool operator()(const value_type& __x, const value_type& __y) const
            {return comp(__x.first, __y.first);}
    };

private:

    typedef std::__1::__value_type<key_type, mapped_type> __value_type;
    typedef __map_value_compare<key_type, __value_type, key_compare> __vc;
    typedef typename __rebind_alloc_helper<allocator_traits<allocator_type>,
                                                 __value_type>::type __allocator_type;
    typedef __tree<__value_type, __vc, __allocator_type> __base;
    typedef typename __base::__node_traits __node_traits;
    typedef allocator_traits<allocator_type> __alloc_traits;

    __base __tree_;

public:
    typedef typename __alloc_traits::pointer pointer;
    typedef typename __alloc_traits::const_pointer const_pointer;
    typedef typename __alloc_traits::size_type size_type;
    typedef typename __alloc_traits::difference_type difference_type;
    typedef __map_iterator<typename __base::iterator> iterator;
    typedef __map_const_iterator<typename __base::const_iterator> const_iterator;
    typedef std::__1::reverse_iterator<iterator> reverse_iterator;
    typedef std::__1::reverse_iterator<const_iterator> const_reverse_iterator;


    typedef __map_node_handle<typename __base::__node, allocator_type> node_type;


    template <class _Key2, class _Value2, class _Comp2, class _Alloc2>
        friend class __attribute__ ((__type_visibility__("default"))) map;
    template <class _Key2, class _Value2, class _Comp2, class _Alloc2>
        friend class __attribute__ ((__type_visibility__("default"))) multimap;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    multimap()
        noexcept(is_nothrow_default_constructible<allocator_type>::value && is_nothrow_default_constructible<key_compare>::value && is_nothrow_copy_constructible<key_compare>::value)



        : __tree_(__vc(key_compare())) {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit multimap(const key_compare& __comp)
        noexcept(is_nothrow_default_constructible<allocator_type>::value && is_nothrow_copy_constructible<key_compare>::value)


        : __tree_(__vc(__comp)) {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit multimap(const key_compare& __comp, const allocator_type& __a)
        : __tree_(__vc(__comp), typename __base::allocator_type(__a)) {}

    template <class _InputIterator>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        multimap(_InputIterator __f, _InputIterator __l,
            const key_compare& __comp = key_compare())
        : __tree_(__vc(__comp))
        {
            insert(__f, __l);
        }

    template <class _InputIterator>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        multimap(_InputIterator __f, _InputIterator __l,
            const key_compare& __comp, const allocator_type& __a)
        : __tree_(__vc(__comp), typename __base::allocator_type(__a))
        {
            insert(__f, __l);
        }


    template <class _InputIterator>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    multimap(_InputIterator __f, _InputIterator __l, const allocator_type& __a)
        : multimap(__f, __l, key_compare(), __a) {}


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    multimap(const multimap& __m)
        : __tree_(__m.__tree_.value_comp(),
          __alloc_traits::select_on_container_copy_construction(__m.__tree_.__alloc()))
        {
            insert(__m.begin(), __m.end());
        }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    multimap& operator=(const multimap& __m)
        {

            __tree_ = __m.__tree_;
# 1834 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/map" 3
            return *this;
        }



    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    multimap(multimap&& __m)
        noexcept(is_nothrow_move_constructible<__base>::value)
        : __tree_(std::__1::move(__m.__tree_))
        {
        }

    multimap(multimap&& __m, const allocator_type& __a);

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    multimap& operator=(multimap&& __m)
        noexcept(is_nothrow_move_assignable<__base>::value)
        {
            __tree_ = std::__1::move(__m.__tree_);
            return *this;
        }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    multimap(initializer_list<value_type> __il, const key_compare& __comp = key_compare())
        : __tree_(__vc(__comp))
        {
            insert(__il.begin(), __il.end());
        }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    multimap(initializer_list<value_type> __il, const key_compare& __comp, const allocator_type& __a)
        : __tree_(__vc(__comp), typename __base::allocator_type(__a))
        {
            insert(__il.begin(), __il.end());
        }


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    multimap(initializer_list<value_type> __il, const allocator_type& __a)
        : multimap(__il, key_compare(), __a) {}


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    multimap& operator=(initializer_list<value_type> __il)
        {
            __tree_.__assign_multi(__il.begin(), __il.end());
            return *this;
        }



    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit multimap(const allocator_type& __a)
        : __tree_(typename __base::allocator_type(__a))
        {
        }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    multimap(const multimap& __m, const allocator_type& __a)
        : __tree_(__m.__tree_.value_comp(), typename __base::allocator_type(__a))
        {
            insert(__m.begin(), __m.end());
        }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    ~multimap() {
        static_assert(sizeof(__diagnose_non_const_comparator<_Key, _Compare>()), "");
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
          iterator begin() noexcept {return __tree_.begin();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_iterator begin() const noexcept {return __tree_.begin();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
          iterator end() noexcept {return __tree_.end();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_iterator end() const noexcept {return __tree_.end();}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
          reverse_iterator rbegin() noexcept {return reverse_iterator(end());}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_reverse_iterator rbegin() const noexcept
        {return const_reverse_iterator(end());}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
          reverse_iterator rend() noexcept {return reverse_iterator(begin());}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_reverse_iterator rend() const noexcept
        {return const_reverse_iterator(begin());}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_iterator cbegin() const noexcept {return begin();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_iterator cend() const noexcept {return end();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_reverse_iterator crbegin() const noexcept {return rbegin();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_reverse_iterator crend() const noexcept {return rend();}

                                  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    bool empty() const noexcept {return __tree_.size() == 0;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_type size() const noexcept {return __tree_.size();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_type max_size() const noexcept {return __tree_.max_size();}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    allocator_type get_allocator() const noexcept {return allocator_type(__tree_.__alloc());}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    key_compare key_comp() const {return __tree_.value_comp().key_comp();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    value_compare value_comp() const
        {return value_compare(__tree_.value_comp().key_comp());}



    template <class ..._Args>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iterator emplace(_Args&& ...__args) {
        return __tree_.__emplace_multi(std::__1::forward<_Args>(__args)...);
    }

    template <class ..._Args>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iterator emplace_hint(const_iterator __p, _Args&& ...__args) {
        return __tree_.__emplace_hint_multi(__p.__i_, std::__1::forward<_Args>(__args)...);
    }

    template <class _Pp,
              class = typename enable_if<is_constructible<value_type, _Pp>::value>::type>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        iterator insert(_Pp&& __p)
            {return __tree_.__insert_multi(std::__1::forward<_Pp>(__p));}

    template <class _Pp,
              class = typename enable_if<is_constructible<value_type, _Pp>::value>::type>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        iterator insert(const_iterator __pos, _Pp&& __p)
            {return __tree_.__insert_multi(__pos.__i_, std::__1::forward<_Pp>(__p));}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iterator insert(value_type&& __v)
        {return __tree_.__insert_multi(std::__1::move(__v));}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iterator insert(const_iterator __p, value_type&& __v)
        {return __tree_.__insert_multi(__p.__i_, std::__1::move(__v));}


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void insert(initializer_list<value_type> __il)
        {insert(__il.begin(), __il.end());}



    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iterator insert(const value_type& __v) {return __tree_.__insert_multi(__v);}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iterator insert(const_iterator __p, const value_type& __v)
            {return __tree_.__insert_multi(__p.__i_, __v);}

    template <class _InputIterator>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        void insert(_InputIterator __f, _InputIterator __l)
        {
            for (const_iterator __e = cend(); __f != __l; ++__f)
                __tree_.__insert_multi(__e.__i_, *__f);
        }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iterator erase(const_iterator __p) {return __tree_.erase(__p.__i_);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iterator erase(iterator __p) {return __tree_.erase(__p.__i_);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_type erase(const key_type& __k) {return __tree_.__erase_multi(__k);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iterator erase(const_iterator __f, const_iterator __l)
        {return __tree_.erase(__f.__i_, __l.__i_);}


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iterator insert(node_type&& __nh)
    {
        ((void)0);

        return __tree_.template __node_handle_insert_multi<node_type>(
            std::__1::move(__nh));
    }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iterator insert(const_iterator __hint, node_type&& __nh)
    {
        ((void)0);

        return __tree_.template __node_handle_insert_multi<node_type>(
            __hint.__i_, std::__1::move(__nh));
    }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    node_type extract(key_type const& __key)
    {
        return __tree_.template __node_handle_extract<node_type>(__key);
    }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    node_type extract(const_iterator __it)
    {
        return __tree_.template __node_handle_extract<node_type>(
            __it.__i_);
    }
    template <class _Compare2>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void merge(multimap<key_type, mapped_type, _Compare2, allocator_type>& __source)
    {
        ((void)0);

        return __tree_.__node_handle_merge_multi(__source.__tree_);
    }
    template <class _Compare2>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void merge(multimap<key_type, mapped_type, _Compare2, allocator_type>&& __source)
    {
        ((void)0);

        return __tree_.__node_handle_merge_multi(__source.__tree_);
    }
    template <class _Compare2>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void merge(map<key_type, mapped_type, _Compare2, allocator_type>& __source)
    {
        ((void)0);

        return __tree_.__node_handle_merge_multi(__source.__tree_);
    }
    template <class _Compare2>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void merge(map<key_type, mapped_type, _Compare2, allocator_type>&& __source)
    {
        ((void)0);

        return __tree_.__node_handle_merge_multi(__source.__tree_);
    }


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void clear() noexcept {__tree_.clear();}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void swap(multimap& __m)
        noexcept(__is_nothrow_swappable<__base>::value)
        {__tree_.swap(__m.__tree_);}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iterator find(const key_type& __k) {return __tree_.find(__k);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_iterator find(const key_type& __k) const {return __tree_.find(__k);}

    template <typename _K2>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    typename enable_if<__is_transparent<_Compare, _K2>::value,iterator>::type
    find(const _K2& __k) {return __tree_.find(__k);}
    template <typename _K2>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    typename enable_if<__is_transparent<_Compare, _K2>::value,const_iterator>::type
    find(const _K2& __k) const {return __tree_.find(__k);}


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_type count(const key_type& __k) const
        {return __tree_.__count_multi(__k);}

    template <typename _K2>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    typename enable_if<__is_transparent<_Compare, _K2>::value,size_type>::type
    count(const _K2& __k) const {return __tree_.__count_multi(__k);}
# 2117 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/map" 3
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iterator lower_bound(const key_type& __k)
        {return __tree_.lower_bound(__k);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_iterator lower_bound(const key_type& __k) const
            {return __tree_.lower_bound(__k);}

    template <typename _K2>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    typename enable_if<__is_transparent<_Compare, _K2>::value,iterator>::type
    lower_bound(const _K2& __k) {return __tree_.lower_bound(__k);}

    template <typename _K2>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    typename enable_if<__is_transparent<_Compare, _K2>::value,const_iterator>::type
    lower_bound(const _K2& __k) const {return __tree_.lower_bound(__k);}


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iterator upper_bound(const key_type& __k)
            {return __tree_.upper_bound(__k);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_iterator upper_bound(const key_type& __k) const
            {return __tree_.upper_bound(__k);}

    template <typename _K2>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    typename enable_if<__is_transparent<_Compare, _K2>::value,iterator>::type
    upper_bound(const _K2& __k) {return __tree_.upper_bound(__k);}
    template <typename _K2>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    typename enable_if<__is_transparent<_Compare, _K2>::value,const_iterator>::type
    upper_bound(const _K2& __k) const {return __tree_.upper_bound(__k);}


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    pair<iterator,iterator> equal_range(const key_type& __k)
            {return __tree_.__equal_range_multi(__k);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    pair<const_iterator,const_iterator> equal_range(const key_type& __k) const
            {return __tree_.__equal_range_multi(__k);}

    template <typename _K2>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    typename enable_if<__is_transparent<_Compare, _K2>::value,pair<iterator,iterator>>::type
    equal_range(const _K2& __k) {return __tree_.__equal_range_multi(__k);}
    template <typename _K2>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    typename enable_if<__is_transparent<_Compare, _K2>::value,pair<const_iterator,const_iterator>>::type
    equal_range(const _K2& __k) const {return __tree_.__equal_range_multi(__k);}


private:
    typedef typename __base::__node __node;
    typedef typename __base::__node_allocator __node_allocator;
    typedef typename __base::__node_pointer __node_pointer;

    typedef __map_node_destructor<__node_allocator> _Dp;
    typedef unique_ptr<__node, _Dp> __node_holder;
};


template<class _InputIterator, class _Compare = less<__iter_key_type<_InputIterator>>,
         class _Allocator = allocator<__iter_to_alloc_type<_InputIterator>>,
         class = _EnableIf<!__is_allocator<_Compare>::value, void>,
         class = _EnableIf<__is_allocator<_Allocator>::value, void>>
multimap(_InputIterator, _InputIterator, _Compare = _Compare(), _Allocator = _Allocator())
  -> multimap<__iter_key_type<_InputIterator>, __iter_mapped_type<_InputIterator>, _Compare, _Allocator>;

template<class _Key, class _Tp, class _Compare = less<remove_const_t<_Key>>,
         class _Allocator = allocator<pair<const _Key, _Tp>>,
         class = _EnableIf<!__is_allocator<_Compare>::value, void>,
         class = _EnableIf<__is_allocator<_Allocator>::value, void>>
multimap(initializer_list<pair<_Key, _Tp>>, _Compare = _Compare(), _Allocator = _Allocator())
  -> multimap<remove_const_t<_Key>, _Tp, _Compare, _Allocator>;

template<class _InputIterator, class _Allocator,
         class = _EnableIf<__is_allocator<_Allocator>::value, void>>
multimap(_InputIterator, _InputIterator, _Allocator)
  -> multimap<__iter_key_type<_InputIterator>, __iter_mapped_type<_InputIterator>,
         less<__iter_key_type<_InputIterator>>, _Allocator>;

template<class _Key, class _Tp, class _Allocator,
         class = _EnableIf<__is_allocator<_Allocator>::value, void>>
multimap(initializer_list<pair<_Key, _Tp>>, _Allocator)
  -> multimap<remove_const_t<_Key>, _Tp, less<remove_const_t<_Key>>, _Allocator>;



template <class _Key, class _Tp, class _Compare, class _Allocator>
multimap<_Key, _Tp, _Compare, _Allocator>::multimap(multimap&& __m, const allocator_type& __a)
    : __tree_(std::__1::move(__m.__tree_), typename __base::allocator_type(__a))
{
    if (__a != __m.get_allocator())
    {
        const_iterator __e = cend();
        while (!__m.empty())
            __tree_.__insert_multi(__e.__i_,
                    std::__1::move(__m.__tree_.remove(__m.begin().__i_)->__value_.__move()));
    }
}


template <class _Key, class _Tp, class _Compare, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator==(const multimap<_Key, _Tp, _Compare, _Allocator>& __x,
           const multimap<_Key, _Tp, _Compare, _Allocator>& __y)
{
    return __x.size() == __y.size() && std::__1::equal(__x.begin(), __x.end(), __y.begin());
}

template <class _Key, class _Tp, class _Compare, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator< (const multimap<_Key, _Tp, _Compare, _Allocator>& __x,
           const multimap<_Key, _Tp, _Compare, _Allocator>& __y)
{
    return std::__1::lexicographical_compare(__x.begin(), __x.end(), __y.begin(), __y.end());
}

template <class _Key, class _Tp, class _Compare, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator!=(const multimap<_Key, _Tp, _Compare, _Allocator>& __x,
           const multimap<_Key, _Tp, _Compare, _Allocator>& __y)
{
    return !(__x == __y);
}

template <class _Key, class _Tp, class _Compare, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator> (const multimap<_Key, _Tp, _Compare, _Allocator>& __x,
           const multimap<_Key, _Tp, _Compare, _Allocator>& __y)
{
    return __y < __x;
}

template <class _Key, class _Tp, class _Compare, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator>=(const multimap<_Key, _Tp, _Compare, _Allocator>& __x,
           const multimap<_Key, _Tp, _Compare, _Allocator>& __y)
{
    return !(__x < __y);
}

template <class _Key, class _Tp, class _Compare, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator<=(const multimap<_Key, _Tp, _Compare, _Allocator>& __x,
           const multimap<_Key, _Tp, _Compare, _Allocator>& __y)
{
    return !(__y < __x);
}

template <class _Key, class _Tp, class _Compare, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void
swap(multimap<_Key, _Tp, _Compare, _Allocator>& __x,
     multimap<_Key, _Tp, _Compare, _Allocator>& __y)
    noexcept(noexcept(__x.swap(__y)))
{
    __x.swap(__y);
}
# 2295 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/map" 3
} }
# 167 "/usr/local/include/bits/stdc++.h" 2


# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/memory" 1 3
# 974 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/memory" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 1 3
# 20 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/assert.h" 1 3 4
# 44 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/assert.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/stdlib.h" 1 3 4
# 45 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/assert.h" 2 3 4
# 81 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/assert.h" 3 4
extern "C" {
void __assert_rtn(const char *, const char *, int, const char *) __attribute__((__noreturn__)) __attribute__((__cold__)) __attribute__((__disable_tail_calls__));



}
# 21 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 2 3
# 24 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 3
# 975 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/memory" 2 3
# 170 "/usr/local/include/bits/stdc++.h" 2





# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/numeric" 1 3
# 157 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/numeric" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 161 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/numeric" 2 3

namespace std { inline namespace __1 {

template <class _InputIterator, class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
_Tp
accumulate(_InputIterator __first, _InputIterator __last, _Tp __init)
{
    for (; __first != __last; ++__first)



        __init = __init + *__first;

    return __init;
}

template <class _InputIterator, class _Tp, class _BinaryOperation>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
_Tp
accumulate(_InputIterator __first, _InputIterator __last, _Tp __init, _BinaryOperation __binary_op)
{
    for (; __first != __last; ++__first)



        __init = __binary_op(__init, *__first);

    return __init;
}


template <class _InputIterator, class _Tp, class _BinaryOp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
_Tp
reduce(_InputIterator __first, _InputIterator __last, _Tp __init, _BinaryOp __b)
{
    for (; __first != __last; ++__first)
        __init = __b(__init, *__first);
    return __init;
}

template <class _InputIterator, class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
_Tp
reduce(_InputIterator __first, _InputIterator __last, _Tp __init)
{
    return std::__1::reduce(__first, __last, __init, std::__1::plus<>());
}

template <class _InputIterator>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename iterator_traits<_InputIterator>::value_type
reduce(_InputIterator __first, _InputIterator __last)
{
    return std::__1::reduce(__first, __last,
       typename iterator_traits<_InputIterator>::value_type{});
}


template <class _InputIterator1, class _InputIterator2, class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
_Tp
inner_product(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _Tp __init)
{
    for (; __first1 != __last1; ++__first1, (void) ++__first2)



        __init = __init + *__first1 * *__first2;

    return __init;
}

template <class _InputIterator1, class _InputIterator2, class _Tp, class _BinaryOperation1, class _BinaryOperation2>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
_Tp
inner_product(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2,
              _Tp __init, _BinaryOperation1 __binary_op1, _BinaryOperation2 __binary_op2)
{
    for (; __first1 != __last1; ++__first1, (void) ++__first2)



        __init = __binary_op1(__init, __binary_op2(*__first1, *__first2));

    return __init;
}


template <class _InputIterator, class _Tp, class _BinaryOp, class _UnaryOp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
_Tp
transform_reduce(_InputIterator __first, _InputIterator __last,
           _Tp __init, _BinaryOp __b, _UnaryOp __u)
{
    for (; __first != __last; ++__first)
        __init = __b(__init, __u(*__first));
    return __init;
}

template <class _InputIterator1, class _InputIterator2,
          class _Tp, class _BinaryOp1, class _BinaryOp2>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
_Tp
transform_reduce(_InputIterator1 __first1, _InputIterator1 __last1,
                 _InputIterator2 __first2, _Tp __init, _BinaryOp1 __b1, _BinaryOp2 __b2)
{
    for (; __first1 != __last1; ++__first1, (void) ++__first2)
        __init = __b1(__init, __b2(*__first1, *__first2));
    return __init;
}

template <class _InputIterator1, class _InputIterator2, class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
_Tp
transform_reduce(_InputIterator1 __first1, _InputIterator1 __last1,
                 _InputIterator2 __first2, _Tp __init)
{
    return std::__1::transform_reduce(__first1, __last1, __first2, std::__1::move(__init),
                                   std::__1::plus<>(), std::__1::multiplies<>());
}


template <class _InputIterator, class _OutputIterator>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
_OutputIterator
partial_sum(_InputIterator __first, _InputIterator __last, _OutputIterator __result)
{
    if (__first != __last)
    {
        typename iterator_traits<_InputIterator>::value_type __t(*__first);
        *__result = __t;
        for (++__first, (void) ++__result; __first != __last; ++__first, (void) ++__result)
        {



            __t = __t + *__first;

            *__result = __t;
        }
    }
    return __result;
}

template <class _InputIterator, class _OutputIterator, class _BinaryOperation>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
_OutputIterator
partial_sum(_InputIterator __first, _InputIterator __last, _OutputIterator __result,
              _BinaryOperation __binary_op)
{
    if (__first != __last)
    {
        typename iterator_traits<_InputIterator>::value_type __t(*__first);
        *__result = __t;
        for (++__first, (void) ++__result; __first != __last; ++__first, (void) ++__result)
        {



            __t = __binary_op(__t, *__first);

            *__result = __t;
        }
    }
    return __result;
}


template <class _InputIterator, class _OutputIterator, class _Tp, class _BinaryOp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
_OutputIterator
exclusive_scan(_InputIterator __first, _InputIterator __last,
               _OutputIterator __result, _Tp __init, _BinaryOp __b)
{
    if (__first != __last)
    {
        _Tp __tmp(__b(__init, *__first));
        while (true)
        {
            *__result = std::__1::move(__init);
            ++__result;
            ++__first;
            if (__first == __last)
                break;
            __init = std::__1::move(__tmp);
            __tmp = __b(__init, *__first);
        }
    }
    return __result;
}

template <class _InputIterator, class _OutputIterator, class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
_OutputIterator
exclusive_scan(_InputIterator __first, _InputIterator __last,
               _OutputIterator __result, _Tp __init)
{
    return std::__1::exclusive_scan(__first, __last, __result, __init, std::__1::plus<>());
}

template <class _InputIterator, class _OutputIterator, class _Tp, class _BinaryOp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
_OutputIterator inclusive_scan(_InputIterator __first, _InputIterator __last,
                               _OutputIterator __result, _BinaryOp __b, _Tp __init)
{
    for (; __first != __last; ++__first, (void) ++__result) {
        __init = __b(__init, *__first);
        *__result = __init;
    }
    return __result;
}

template <class _InputIterator, class _OutputIterator, class _BinaryOp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
_OutputIterator inclusive_scan(_InputIterator __first, _InputIterator __last,
                               _OutputIterator __result, _BinaryOp __b)
{
    if (__first != __last) {
        typename iterator_traits<_InputIterator>::value_type __init = *__first;
        *__result++ = __init;
        if (++__first != __last)
            return std::__1::inclusive_scan(__first, __last, __result, __b, __init);
    }

    return __result;
}

template <class _InputIterator, class _OutputIterator>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
_OutputIterator inclusive_scan(_InputIterator __first, _InputIterator __last,
                               _OutputIterator __result)
{
    return std::__1::inclusive_scan(__first, __last, __result, std::__1::plus<>());
}

template <class _InputIterator, class _OutputIterator, class _Tp,
          class _BinaryOp, class _UnaryOp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
_OutputIterator
transform_exclusive_scan(_InputIterator __first, _InputIterator __last,
                           _OutputIterator __result, _Tp __init,
                           _BinaryOp __b, _UnaryOp __u)
{
    if (__first != __last)
    {
        _Tp __saved = __init;
        do
        {
            __init = __b(__init, __u(*__first));
            *__result = __saved;
            __saved = __init;
            ++__result;
        } while (++__first != __last);
    }
    return __result;
}

template <class _InputIterator, class _OutputIterator, class _Tp, class _BinaryOp, class _UnaryOp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
_OutputIterator
transform_inclusive_scan(_InputIterator __first, _InputIterator __last,
                           _OutputIterator __result, _BinaryOp __b, _UnaryOp __u, _Tp __init)
{
    for (; __first != __last; ++__first, (void) ++__result) {
        __init = __b(__init, __u(*__first));
        *__result = __init;
        }

    return __result;
}

template <class _InputIterator, class _OutputIterator, class _BinaryOp, class _UnaryOp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
_OutputIterator
transform_inclusive_scan(_InputIterator __first, _InputIterator __last,
                               _OutputIterator __result, _BinaryOp __b, _UnaryOp __u)
{
    if (__first != __last) {
        typename iterator_traits<_InputIterator>::value_type __init = __u(*__first);
        *__result++ = __init;
        if (++__first != __last)
            return std::__1::transform_inclusive_scan(__first, __last, __result, __b, __u, __init);
    }

    return __result;
}


template <class _InputIterator, class _OutputIterator>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
_OutputIterator
adjacent_difference(_InputIterator __first, _InputIterator __last, _OutputIterator __result)
{
    if (__first != __last)
    {
        typename iterator_traits<_InputIterator>::value_type __acc(*__first);
        *__result = __acc;
        for (++__first, (void) ++__result; __first != __last; ++__first, (void) ++__result)
        {
            typename iterator_traits<_InputIterator>::value_type __val(*__first);



            *__result = __val - __acc;

            __acc = std::__1::move(__val);
        }
    }
    return __result;
}

template <class _InputIterator, class _OutputIterator, class _BinaryOperation>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
_OutputIterator
adjacent_difference(_InputIterator __first, _InputIterator __last, _OutputIterator __result,
                      _BinaryOperation __binary_op)
{
    if (__first != __last)
    {
        typename iterator_traits<_InputIterator>::value_type __acc(*__first);
        *__result = __acc;
        for (++__first, (void) ++__result; __first != __last; ++__first, (void) ++__result)
        {
            typename iterator_traits<_InputIterator>::value_type __val(*__first);



            *__result = __binary_op(__val, __acc);

            __acc = std::__1::move(__val);
        }
    }
    return __result;
}

template <class _ForwardIterator, class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void
iota(_ForwardIterator __first, _ForwardIterator __last, _Tp __value_)
{
    for (; __first != __last; ++__first, (void) ++__value_)
        *__first = __value_;
}



template <typename _Result, typename _Source, bool _IsSigned = is_signed<_Source>::value> struct __ct_abs;

template <typename _Result, typename _Source>
struct __ct_abs<_Result, _Source, true> {
    constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    _Result operator()(_Source __t) const noexcept
    {
        if (__t >= 0) return __t;
        if (__t == numeric_limits<_Source>::min()) return -static_cast<_Result>(__t);
        return -__t;
    }
};

template <typename _Result, typename _Source>
struct __ct_abs<_Result, _Source, false> {
    constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    _Result operator()(_Source __t) const noexcept { return __t; }
};


template<class _Tp>
constexpr __attribute__ ((__visibility__("hidden")))
_Tp __gcd(_Tp __m, _Tp __n)
{
    static_assert((!is_signed<_Tp>::value), "");
    return __n == 0 ? __m : std::__1::__gcd<_Tp>(__n, __m % __n);
}


template<class _Tp, class _Up>
constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
common_type_t<_Tp,_Up>
gcd(_Tp __m, _Up __n)
{
    static_assert((is_integral<_Tp>::value && is_integral<_Up>::value), "Arguments to gcd must be integer types");
    static_assert((!is_same<typename remove_cv<_Tp>::type, bool>::value), "First argument to gcd cannot be bool" );
    static_assert((!is_same<typename remove_cv<_Up>::type, bool>::value), "Second argument to gcd cannot be bool" );
    using _Rp = common_type_t<_Tp,_Up>;
    using _Wp = make_unsigned_t<_Rp>;
    return static_cast<_Rp>(std::__1::__gcd(
        static_cast<_Wp>(__ct_abs<_Rp, _Tp>()(__m)),
        static_cast<_Wp>(__ct_abs<_Rp, _Up>()(__n))));
}

template<class _Tp, class _Up>
constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
common_type_t<_Tp,_Up>
lcm(_Tp __m, _Up __n)
{
    static_assert((is_integral<_Tp>::value && is_integral<_Up>::value), "Arguments to lcm must be integer types");
    static_assert((!is_same<typename remove_cv<_Tp>::type, bool>::value), "First argument to lcm cannot be bool" );
    static_assert((!is_same<typename remove_cv<_Up>::type, bool>::value), "Second argument to lcm cannot be bool" );
    if (__m == 0 || __n == 0)
        return 0;

    using _Rp = common_type_t<_Tp,_Up>;
    _Rp __val1 = __ct_abs<_Rp, _Tp>()(__m) / std::__1::gcd(__m, __n);
    _Rp __val2 = __ct_abs<_Rp, _Up>()(__n);
    ((void)0);
    return __val1 * __val2;
}
# 628 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/numeric" 3
} }
# 176 "/usr/local/include/bits/stdc++.h" 2





# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/queue" 1 3
# 188 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/queue" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/vector" 1 3
# 289 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/vector" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/memory" 1 3
# 974 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/memory" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 1 3
# 20 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/assert.h" 1 3 4
# 44 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/assert.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/stdlib.h" 1 3 4
# 45 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/assert.h" 2 3 4
# 81 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/assert.h" 3 4
extern "C" {
void __assert_rtn(const char *, const char *, int, const char *) __attribute__((__noreturn__)) __attribute__((__cold__)) __attribute__((__disable_tail_calls__));



}
# 21 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 2 3
# 24 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 3
# 975 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/memory" 2 3
# 290 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/vector" 2 3

# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 1 3
# 292 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/vector" 2 3
# 296 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/vector" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 300 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/vector" 2 3


namespace std { inline namespace __1 {

template <bool>
class __attribute__ ((__type_visibility__("default"))) __vector_base_common
{
protected:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) __vector_base_common() {}
    [[noreturn]] void __throw_length_error() const;
    [[noreturn]] void __throw_out_of_range() const;
};

template <bool __b>
void
__vector_base_common<__b>::__throw_length_error() const
{
    std::__1::__throw_length_error("vector");
}

template <bool __b>
void
__vector_base_common<__b>::__throw_out_of_range() const
{
    std::__1::__throw_out_of_range("vector");
}

extern template class __attribute__ ((__visibility__("default"))) __vector_base_common<true>;

template <class _Tp, class _Allocator>
class __vector_base
    : protected __vector_base_common<true>
{
public:
    typedef _Allocator allocator_type;
    typedef allocator_traits<allocator_type> __alloc_traits;
    typedef typename __alloc_traits::size_type size_type;
protected:
    typedef _Tp value_type;
    typedef value_type& reference;
    typedef const value_type& const_reference;
    typedef typename __alloc_traits::difference_type difference_type;
    typedef typename __alloc_traits::pointer pointer;
    typedef typename __alloc_traits::const_pointer const_pointer;
    typedef pointer iterator;
    typedef const_pointer const_iterator;

    pointer __begin_;
    pointer __end_;
    __compressed_pair<pointer, allocator_type> __end_cap_;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    allocator_type& __alloc() noexcept
        {return __end_cap_.second();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const allocator_type& __alloc() const noexcept
        {return __end_cap_.second();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    pointer& __end_cap() noexcept
        {return __end_cap_.first();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const pointer& __end_cap() const noexcept
        {return __end_cap_.first();}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __vector_base()
        noexcept(is_nothrow_default_constructible<allocator_type>::value);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) __vector_base(const allocator_type& __a);

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) __vector_base(allocator_type&& __a) noexcept;

    ~__vector_base();

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void clear() noexcept {__destruct_at_end(__begin_);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_type capacity() const noexcept
        {return static_cast<size_type>(__end_cap() - __begin_);}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void __destruct_at_end(pointer __new_last) noexcept;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void __copy_assign_alloc(const __vector_base& __c)
        {__copy_assign_alloc(__c, integral_constant<bool,
                      __alloc_traits::propagate_on_container_copy_assignment::value>());}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void __move_assign_alloc(__vector_base& __c)
        noexcept(!__alloc_traits::propagate_on_container_move_assignment::value || is_nothrow_move_assignable<allocator_type>::value)


        {__move_assign_alloc(__c, integral_constant<bool,
                      __alloc_traits::propagate_on_container_move_assignment::value>());}

    [[noreturn]] __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void __throw_length_error() const {

        __vector_base_common<true>::__throw_length_error();



    }

    [[noreturn]] __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void __throw_out_of_range() const {

        __vector_base_common<true>::__throw_out_of_range();



    }

private:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void __copy_assign_alloc(const __vector_base& __c, true_type)
        {
            if (__alloc() != __c.__alloc())
            {
                clear();
                __alloc_traits::deallocate(__alloc(), __begin_, capacity());
                __begin_ = __end_ = __end_cap() = nullptr;
            }
            __alloc() = __c.__alloc();
        }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void __copy_assign_alloc(const __vector_base&, false_type)
        {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void __move_assign_alloc(__vector_base& __c, true_type)
        noexcept(is_nothrow_move_assignable<allocator_type>::value)
        {
            __alloc() = std::__1::move(__c.__alloc());
        }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void __move_assign_alloc(__vector_base&, false_type)
        noexcept
        {}
};

template <class _Tp, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void
__vector_base<_Tp, _Allocator>::__destruct_at_end(pointer __new_last) noexcept
{
    pointer __soon_to_be_end = __end_;
    while (__new_last != __soon_to_be_end)
        __alloc_traits::destroy(__alloc(), std::__1::__to_address(--__soon_to_be_end));
    __end_ = __new_last;
}

template <class _Tp, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
__vector_base<_Tp, _Allocator>::__vector_base()
        noexcept(is_nothrow_default_constructible<allocator_type>::value)
    : __begin_(nullptr),
      __end_(nullptr),
      __end_cap_(nullptr, __default_init_tag())
{
}

template <class _Tp, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
__vector_base<_Tp, _Allocator>::__vector_base(const allocator_type& __a)
    : __begin_(nullptr),
      __end_(nullptr),
      __end_cap_(nullptr, __a)
{
}


template <class _Tp, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
__vector_base<_Tp, _Allocator>::__vector_base(allocator_type&& __a) noexcept
    : __begin_(nullptr),
      __end_(nullptr),
      __end_cap_(nullptr, std::__1::move(__a)) {}


template <class _Tp, class _Allocator>
__vector_base<_Tp, _Allocator>::~__vector_base()
{
    if (__begin_ != nullptr)
    {
        clear();
        __alloc_traits::deallocate(__alloc(), __begin_, capacity());
    }
}

template <class _Tp, class _Allocator >
class __attribute__ ((__type_visibility__("default"))) vector
    : private __vector_base<_Tp, _Allocator>
{
private:
    typedef __vector_base<_Tp, _Allocator> __base;
    typedef allocator<_Tp> __default_allocator_type;
public:
    typedef vector __self;
    typedef _Tp value_type;
    typedef _Allocator allocator_type;
    typedef typename __base::__alloc_traits __alloc_traits;
    typedef typename __base::reference reference;
    typedef typename __base::const_reference const_reference;
    typedef typename __base::size_type size_type;
    typedef typename __base::difference_type difference_type;
    typedef typename __base::pointer pointer;
    typedef typename __base::const_pointer const_pointer;
    typedef __wrap_iter<pointer> iterator;
    typedef __wrap_iter<const_pointer> const_iterator;
    typedef std::__1::reverse_iterator<iterator> reverse_iterator;
    typedef std::__1::reverse_iterator<const_iterator> const_reverse_iterator;

    static_assert((is_same<typename allocator_type::value_type, value_type>::value),
                  "Allocator::value_type must be same type as value_type");

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    vector() noexcept(is_nothrow_default_constructible<allocator_type>::value)
        {



        }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) explicit vector(const allocator_type& __a)



        noexcept

        : __base(__a)
    {



    }
    explicit vector(size_type __n);

    explicit vector(size_type __n, const allocator_type& __a);

    vector(size_type __n, const value_type& __x);
    vector(size_type __n, const value_type& __x, const allocator_type& __a);
    template <class _InputIterator>
        vector(_InputIterator __first,
               typename enable_if<__is_cpp17_input_iterator <_InputIterator>::value &&
                                 !__is_cpp17_forward_iterator<_InputIterator>::value &&
                                 is_constructible<
                                    value_type,
                                    typename iterator_traits<_InputIterator>::reference>::value,
                                 _InputIterator>::type __last);
    template <class _InputIterator>
        vector(_InputIterator __first, _InputIterator __last, const allocator_type& __a,
               typename enable_if<__is_cpp17_input_iterator <_InputIterator>::value &&
                                 !__is_cpp17_forward_iterator<_InputIterator>::value &&
                                 is_constructible<
                                    value_type,
                                    typename iterator_traits<_InputIterator>::reference>::value>::type* = 0);
    template <class _ForwardIterator>
        vector(_ForwardIterator __first,
               typename enable_if<__is_cpp17_forward_iterator<_ForwardIterator>::value &&
                                 is_constructible<
                                    value_type,
                                    typename iterator_traits<_ForwardIterator>::reference>::value,
                                 _ForwardIterator>::type __last);
    template <class _ForwardIterator>
        vector(_ForwardIterator __first, _ForwardIterator __last, const allocator_type& __a,
               typename enable_if<__is_cpp17_forward_iterator<_ForwardIterator>::value &&
                                 is_constructible<
                                    value_type,
                                    typename iterator_traits<_ForwardIterator>::reference>::value>::type* = 0);

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    ~vector()
    {
        __annotate_delete();



    }

    vector(const vector& __x);
    vector(const vector& __x, const __identity_t<allocator_type>& __a);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    vector& operator=(const vector& __x);


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    vector(initializer_list<value_type> __il);

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    vector(initializer_list<value_type> __il, const allocator_type& __a);

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    vector(vector&& __x)

        noexcept;




    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    vector(vector&& __x, const __identity_t<allocator_type>& __a);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    vector& operator=(vector&& __x)
        noexcept((__noexcept_move_assign_container<_Allocator, __alloc_traits>::value));

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    vector& operator=(initializer_list<value_type> __il)
        {assign(__il.begin(), __il.end()); return *this;}



    template <class _InputIterator>
        typename enable_if
        <
             __is_cpp17_input_iterator <_InputIterator>::value &&
            !__is_cpp17_forward_iterator<_InputIterator>::value &&
            is_constructible<
                 value_type,
                 typename iterator_traits<_InputIterator>::reference>::value,
            void
        >::type
        assign(_InputIterator __first, _InputIterator __last);
    template <class _ForwardIterator>
        typename enable_if
        <
            __is_cpp17_forward_iterator<_ForwardIterator>::value &&
            is_constructible<
                 value_type,
                 typename iterator_traits<_ForwardIterator>::reference>::value,
            void
        >::type
        assign(_ForwardIterator __first, _ForwardIterator __last);

    void assign(size_type __n, const_reference __u);


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void assign(initializer_list<value_type> __il)
        {assign(__il.begin(), __il.end());}


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    allocator_type get_allocator() const noexcept
        {return this->__alloc();}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) iterator begin() noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) const_iterator begin() const noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) iterator end() noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) const_iterator end() const noexcept;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    reverse_iterator rbegin() noexcept
        {return reverse_iterator(end());}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_reverse_iterator rbegin() const noexcept
        {return const_reverse_iterator(end());}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    reverse_iterator rend() noexcept
        {return reverse_iterator(begin());}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_reverse_iterator rend() const noexcept
        {return const_reverse_iterator(begin());}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_iterator cbegin() const noexcept
        {return begin();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_iterator cend() const noexcept
        {return end();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_reverse_iterator crbegin() const noexcept
        {return rbegin();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_reverse_iterator crend() const noexcept
        {return rend();}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_type size() const noexcept
        {return static_cast<size_type>(this->__end_ - this->__begin_);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_type capacity() const noexcept
        {return __base::capacity();}
                                  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    bool empty() const noexcept
        {return this->__begin_ == this->__end_;}
    size_type max_size() const noexcept;
    void reserve(size_type __n);
    void shrink_to_fit() noexcept;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) reference operator[](size_type __n) noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) const_reference operator[](size_type __n) const noexcept;
    reference at(size_type __n);
    const_reference at(size_type __n) const;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) reference front() noexcept
    {
        ((void)0);
        return *this->__begin_;
    }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) const_reference front() const noexcept
    {
        ((void)0);
        return *this->__begin_;
    }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) reference back() noexcept
    {
        ((void)0);
        return *(this->__end_ - 1);
    }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) const_reference back() const noexcept
    {
        ((void)0);
        return *(this->__end_ - 1);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    value_type* data() noexcept
        {return std::__1::__to_address(this->__begin_);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const value_type* data() const noexcept
        {return std::__1::__to_address(this->__begin_);}





    template <class _Arg>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void __emplace_back(_Arg&& __arg) {
      emplace_back(std::__1::forward<_Arg>(__arg));
    }


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) void push_back(const_reference __x);


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) void push_back(value_type&& __x);

    template <class... _Args>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))

        reference emplace_back(_Args&&... __args);





    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void pop_back();

    iterator insert(const_iterator __position, const_reference __x);


    iterator insert(const_iterator __position, value_type&& __x);
    template <class... _Args>
        iterator emplace(const_iterator __position, _Args&&... __args);


    iterator insert(const_iterator __position, size_type __n, const_reference __x);
    template <class _InputIterator>
        typename enable_if
        <
             __is_cpp17_input_iterator <_InputIterator>::value &&
            !__is_cpp17_forward_iterator<_InputIterator>::value &&
            is_constructible<
                 value_type,
                 typename iterator_traits<_InputIterator>::reference>::value,
            iterator
        >::type
        insert(const_iterator __position, _InputIterator __first, _InputIterator __last);
    template <class _ForwardIterator>
        typename enable_if
        <
            __is_cpp17_forward_iterator<_ForwardIterator>::value &&
            is_constructible<
                 value_type,
                 typename iterator_traits<_ForwardIterator>::reference>::value,
            iterator
        >::type
        insert(const_iterator __position, _ForwardIterator __first, _ForwardIterator __last);


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iterator insert(const_iterator __position, initializer_list<value_type> __il)
        {return insert(__position, __il.begin(), __il.end());}


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) iterator erase(const_iterator __position);
    iterator erase(const_iterator __first, const_iterator __last);

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void clear() noexcept
    {
        size_type __old_size = size();
        __base::clear();
        __annotate_shrink(__old_size);
        __invalidate_all_iterators();
    }

    void resize(size_type __sz);
    void resize(size_type __sz, const_reference __x);

    void swap(vector&)

        noexcept;





    bool __invariants() const;
# 823 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/vector" 3
private:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) void __invalidate_all_iterators();
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) void __invalidate_iterators_past(pointer __new_last);
    void __vallocate(size_type __n);
    void __vdeallocate() noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) size_type __recommend(size_type __new_size) const;
    void __construct_at_end(size_type __n);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void __construct_at_end(size_type __n, const_reference __x);
    template <class _ForwardIterator>
        typename enable_if
        <
            __is_cpp17_forward_iterator<_ForwardIterator>::value,
            void
        >::type
        __construct_at_end(_ForwardIterator __first, _ForwardIterator __last, size_type __n);
    void __append(size_type __n);
    void __append(size_type __n, const_reference __x);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iterator __make_iter(pointer __p) noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_iterator __make_iter(const_pointer __p) const noexcept;
    void __swap_out_circular_buffer(__split_buffer<value_type, allocator_type&>& __v);
    pointer __swap_out_circular_buffer(__split_buffer<value_type, allocator_type&>& __v, pointer __p);
    void __move_range(pointer __from_s, pointer __from_e, pointer __to);
    void __move_assign(vector& __c, true_type)
        noexcept(is_nothrow_move_assignable<allocator_type>::value);
    void __move_assign(vector& __c, false_type)
        noexcept(__alloc_traits::is_always_equal::value);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void __destruct_at_end(pointer __new_last) noexcept
    {
        __invalidate_iterators_past(__new_last);
        size_type __old_size = size();
        __base::__destruct_at_end(__new_last);
        __annotate_shrink(__old_size);
    }


    template <class _Up>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    inline void __push_back_slow_path(_Up&& __x);

    template <class... _Args>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    inline void __emplace_back_slow_path(_Args&&... __args);
# 880 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/vector" 3
    void __annotate_contiguous_container(const void *__beg, const void *__end,
                                         const void *__old_mid,
                                         const void *__new_mid) const
    {

      if (__beg && is_same<allocator_type, __default_allocator_type>::value)
        __sanitizer_annotate_contiguous_container(__beg, __end, __old_mid, __new_mid);
    }





    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void __annotate_new(size_type __current_size) const noexcept {
      __annotate_contiguous_container(data(), data() + capacity(),
                                      data() + capacity(), data() + __current_size);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void __annotate_delete() const noexcept {
      __annotate_contiguous_container(data(), data() + capacity(),
                                      data() + size(), data() + capacity());
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void __annotate_increase(size_type __n) const noexcept
    {
      __annotate_contiguous_container(data(), data() + capacity(),
                                      data() + size(), data() + size() + __n);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void __annotate_shrink(size_type __old_size) const noexcept
    {
      __annotate_contiguous_container(data(), data() + capacity(),
                                      data() + __old_size, data() + size());
    }

  struct _ConstructTransaction {
    explicit _ConstructTransaction(vector &__v, size_type __n)
      : __v_(__v), __pos_(__v.__end_), __new_end_(__v.__end_ + __n) {

      __v_.__annotate_increase(__n);

    }
    ~_ConstructTransaction() {
      __v_.__end_ = __pos_;

      if (__pos_ != __new_end_) {
        __v_.__annotate_shrink(__new_end_ - __v_.__begin_);
      }

    }

    vector &__v_;
    pointer __pos_;
    const_pointer const __new_end_;

  private:
    _ConstructTransaction(_ConstructTransaction const&) = delete;
    _ConstructTransaction& operator=(_ConstructTransaction const&) = delete;
  };

  template <class ..._Args>
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  void __construct_one_at_end(_Args&& ...__args) {
    _ConstructTransaction __tx(*this, 1);
    __alloc_traits::construct(this->__alloc(), std::__1::__to_address(__tx.__pos_),
        std::__1::forward<_Args>(__args)...);
    ++__tx.__pos_;
  }
};


template<class _InputIterator,
         class _Alloc = allocator<__iter_value_type<_InputIterator>>,
         class = _EnableIf<__is_allocator<_Alloc>::value>
         >
vector(_InputIterator, _InputIterator)
  -> vector<__iter_value_type<_InputIterator>, _Alloc>;

template<class _InputIterator,
         class _Alloc,
         class = _EnableIf<__is_allocator<_Alloc>::value>
         >
vector(_InputIterator, _InputIterator, _Alloc)
  -> vector<__iter_value_type<_InputIterator>, _Alloc>;


template <class _Tp, class _Allocator>
void
vector<_Tp, _Allocator>::__swap_out_circular_buffer(__split_buffer<value_type, allocator_type&>& __v)
{

    __annotate_delete();
    std::__1::__construct_backward_with_exception_guarantees(this->__alloc(), this->__begin_, this->__end_, __v.__begin_);
    std::__1::swap(this->__begin_, __v.__begin_);
    std::__1::swap(this->__end_, __v.__end_);
    std::__1::swap(this->__end_cap(), __v.__end_cap());
    __v.__first_ = __v.__begin_;
    __annotate_new(size());
    __invalidate_all_iterators();
}

template <class _Tp, class _Allocator>
typename vector<_Tp, _Allocator>::pointer
vector<_Tp, _Allocator>::__swap_out_circular_buffer(__split_buffer<value_type, allocator_type&>& __v, pointer __p)
{
    __annotate_delete();
    pointer __r = __v.__begin_;
    std::__1::__construct_backward_with_exception_guarantees(this->__alloc(), this->__begin_, __p, __v.__begin_);
    std::__1::__construct_forward_with_exception_guarantees(this->__alloc(), __p, this->__end_, __v.__end_);
    std::__1::swap(this->__begin_, __v.__begin_);
    std::__1::swap(this->__end_, __v.__end_);
    std::__1::swap(this->__end_cap(), __v.__end_cap());
    __v.__first_ = __v.__begin_;
    __annotate_new(size());
    __invalidate_all_iterators();
    return __r;
}
# 1009 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/vector" 3
template <class _Tp, class _Allocator>
void
vector<_Tp, _Allocator>::__vallocate(size_type __n)
{
    if (__n > max_size())
        this->__throw_length_error();
    this->__begin_ = this->__end_ = __alloc_traits::allocate(this->__alloc(), __n);
    this->__end_cap() = this->__begin_ + __n;
    __annotate_new(0);
}

template <class _Tp, class _Allocator>
void
vector<_Tp, _Allocator>::__vdeallocate() noexcept
{
    if (this->__begin_ != nullptr)
    {
        clear();
        __alloc_traits::deallocate(this->__alloc(), this->__begin_, capacity());
        this->__begin_ = this->__end_ = this->__end_cap() = nullptr;
    }
}

template <class _Tp, class _Allocator>
typename vector<_Tp, _Allocator>::size_type
vector<_Tp, _Allocator>::max_size() const noexcept
{
    return std::__1::min<size_type>(__alloc_traits::max_size(this->__alloc()),
                                 numeric_limits<difference_type>::max());
}


template <class _Tp, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename vector<_Tp, _Allocator>::size_type
vector<_Tp, _Allocator>::__recommend(size_type __new_size) const
{
    const size_type __ms = max_size();
    if (__new_size > __ms)
        this->__throw_length_error();
    const size_type __cap = capacity();
    if (__cap >= __ms / 2)
        return __ms;
    return std::__1::max<size_type>(2 * __cap, __new_size);
}






template <class _Tp, class _Allocator>
void
vector<_Tp, _Allocator>::__construct_at_end(size_type __n)
{
    _ConstructTransaction __tx(*this, __n);
    const_pointer __new_end = __tx.__new_end_;
    for (pointer __pos = __tx.__pos_; __pos != __new_end; ++__pos, __tx.__pos_ = __pos) {
        __alloc_traits::construct(this->__alloc(), std::__1::__to_address(__pos));
    }
}







template <class _Tp, class _Allocator>
inline
void
vector<_Tp, _Allocator>::__construct_at_end(size_type __n, const_reference __x)
{
    _ConstructTransaction __tx(*this, __n);
    const_pointer __new_end = __tx.__new_end_;
    for (pointer __pos = __tx.__pos_; __pos != __new_end; ++__pos, __tx.__pos_ = __pos) {
        __alloc_traits::construct(this->__alloc(), std::__1::__to_address(__pos), __x);
    }
}

template <class _Tp, class _Allocator>
template <class _ForwardIterator>
typename enable_if
<
    __is_cpp17_forward_iterator<_ForwardIterator>::value,
    void
>::type
vector<_Tp, _Allocator>::__construct_at_end(_ForwardIterator __first, _ForwardIterator __last, size_type __n)
{
    _ConstructTransaction __tx(*this, __n);
    std::__1::__construct_range_forward(this->__alloc(), __first, __last, __tx.__pos_);
}





template <class _Tp, class _Allocator>
void
vector<_Tp, _Allocator>::__append(size_type __n)
{
    if (static_cast<size_type>(this->__end_cap() - this->__end_) >= __n)
        this->__construct_at_end(__n);
    else
    {
        allocator_type& __a = this->__alloc();
        __split_buffer<value_type, allocator_type&> __v(__recommend(size() + __n), size(), __a);
        __v.__construct_at_end(__n);
        __swap_out_circular_buffer(__v);
    }
}





template <class _Tp, class _Allocator>
void
vector<_Tp, _Allocator>::__append(size_type __n, const_reference __x)
{
    if (static_cast<size_type>(this->__end_cap() - this->__end_) >= __n)
        this->__construct_at_end(__n, __x);
    else
    {
        allocator_type& __a = this->__alloc();
        __split_buffer<value_type, allocator_type&> __v(__recommend(size() + __n), size(), __a);
        __v.__construct_at_end(__n, __x);
        __swap_out_circular_buffer(__v);
    }
}

template <class _Tp, class _Allocator>
vector<_Tp, _Allocator>::vector(size_type __n)
{



    if (__n > 0)
    {
        __vallocate(__n);
        __construct_at_end(__n);
    }
}


template <class _Tp, class _Allocator>
vector<_Tp, _Allocator>::vector(size_type __n, const allocator_type& __a)
    : __base(__a)
{



    if (__n > 0)
    {
        __vallocate(__n);
        __construct_at_end(__n);
    }
}


template <class _Tp, class _Allocator>
vector<_Tp, _Allocator>::vector(size_type __n, const value_type& __x)
{



    if (__n > 0)
    {
        __vallocate(__n);
        __construct_at_end(__n, __x);
    }
}

template <class _Tp, class _Allocator>
vector<_Tp, _Allocator>::vector(size_type __n, const value_type& __x, const allocator_type& __a)
    : __base(__a)
{



    if (__n > 0)
    {
        __vallocate(__n);
        __construct_at_end(__n, __x);
    }
}

template <class _Tp, class _Allocator>
template <class _InputIterator>
vector<_Tp, _Allocator>::vector(_InputIterator __first,
       typename enable_if<__is_cpp17_input_iterator <_InputIterator>::value &&
                         !__is_cpp17_forward_iterator<_InputIterator>::value &&
                         is_constructible<
                            value_type,
                            typename iterator_traits<_InputIterator>::reference>::value,
                          _InputIterator>::type __last)
{



    for (; __first != __last; ++__first)
        __emplace_back(*__first);
}

template <class _Tp, class _Allocator>
template <class _InputIterator>
vector<_Tp, _Allocator>::vector(_InputIterator __first, _InputIterator __last, const allocator_type& __a,
       typename enable_if<__is_cpp17_input_iterator <_InputIterator>::value &&
                         !__is_cpp17_forward_iterator<_InputIterator>::value &&
                         is_constructible<
                            value_type,
                            typename iterator_traits<_InputIterator>::reference>::value>::type*)
    : __base(__a)
{



    for (; __first != __last; ++__first)
        __emplace_back(*__first);
}

template <class _Tp, class _Allocator>
template <class _ForwardIterator>
vector<_Tp, _Allocator>::vector(_ForwardIterator __first,
                                typename enable_if<__is_cpp17_forward_iterator<_ForwardIterator>::value &&
                                is_constructible<
                                   value_type,
                                   typename iterator_traits<_ForwardIterator>::reference>::value,
                                                   _ForwardIterator>::type __last)
{



    size_type __n = static_cast<size_type>(std::__1::distance(__first, __last));
    if (__n > 0)
    {
        __vallocate(__n);
        __construct_at_end(__first, __last, __n);
    }
}

template <class _Tp, class _Allocator>
template <class _ForwardIterator>
vector<_Tp, _Allocator>::vector(_ForwardIterator __first, _ForwardIterator __last, const allocator_type& __a,
                                typename enable_if<__is_cpp17_forward_iterator<_ForwardIterator>::value &&
                                is_constructible<
                                   value_type,
                                   typename iterator_traits<_ForwardIterator>::reference>::value>::type*)
    : __base(__a)
{



    size_type __n = static_cast<size_type>(std::__1::distance(__first, __last));
    if (__n > 0)
    {
        __vallocate(__n);
        __construct_at_end(__first, __last, __n);
    }
}

template <class _Tp, class _Allocator>
vector<_Tp, _Allocator>::vector(const vector& __x)
    : __base(__alloc_traits::select_on_container_copy_construction(__x.__alloc()))
{



    size_type __n = __x.size();
    if (__n > 0)
    {
        __vallocate(__n);
        __construct_at_end(__x.__begin_, __x.__end_, __n);
    }
}

template <class _Tp, class _Allocator>
vector<_Tp, _Allocator>::vector(const vector& __x, const __identity_t<allocator_type>& __a)
    : __base(__a)
{



    size_type __n = __x.size();
    if (__n > 0)
    {
        __vallocate(__n);
        __construct_at_end(__x.__begin_, __x.__end_, __n);
    }
}



template <class _Tp, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
vector<_Tp, _Allocator>::vector(vector&& __x)

        noexcept



    : __base(std::__1::move(__x.__alloc()))
{




    this->__begin_ = __x.__begin_;
    this->__end_ = __x.__end_;
    this->__end_cap() = __x.__end_cap();
    __x.__begin_ = __x.__end_ = __x.__end_cap() = nullptr;
}

template <class _Tp, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
vector<_Tp, _Allocator>::vector(vector&& __x, const __identity_t<allocator_type>& __a)
    : __base(__a)
{



    if (__a == __x.__alloc())
    {
        this->__begin_ = __x.__begin_;
        this->__end_ = __x.__end_;
        this->__end_cap() = __x.__end_cap();
        __x.__begin_ = __x.__end_ = __x.__end_cap() = nullptr;



    }
    else
    {
        typedef move_iterator<iterator> _Ip;
        assign(_Ip(__x.begin()), _Ip(__x.end()));
    }
}

template <class _Tp, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
vector<_Tp, _Allocator>::vector(initializer_list<value_type> __il)
{



    if (__il.size() > 0)
    {
        __vallocate(__il.size());
        __construct_at_end(__il.begin(), __il.end(), __il.size());
    }
}

template <class _Tp, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
vector<_Tp, _Allocator>::vector(initializer_list<value_type> __il, const allocator_type& __a)
    : __base(__a)
{



    if (__il.size() > 0)
    {
        __vallocate(__il.size());
        __construct_at_end(__il.begin(), __il.end(), __il.size());
    }
}

template <class _Tp, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
vector<_Tp, _Allocator>&
vector<_Tp, _Allocator>::operator=(vector&& __x)
    noexcept((__noexcept_move_assign_container<_Allocator, __alloc_traits>::value))
{
    __move_assign(__x, integral_constant<bool,
          __alloc_traits::propagate_on_container_move_assignment::value>());
    return *this;
}

template <class _Tp, class _Allocator>
void
vector<_Tp, _Allocator>::__move_assign(vector& __c, false_type)
    noexcept(__alloc_traits::is_always_equal::value)
{
    if (__base::__alloc() != __c.__alloc())
    {
        typedef move_iterator<iterator> _Ip;
        assign(_Ip(__c.begin()), _Ip(__c.end()));
    }
    else
        __move_assign(__c, true_type());
}

template <class _Tp, class _Allocator>
void
vector<_Tp, _Allocator>::__move_assign(vector& __c, true_type)
    noexcept(is_nothrow_move_assignable<allocator_type>::value)
{
    __vdeallocate();
    __base::__move_assign_alloc(__c);
    this->__begin_ = __c.__begin_;
    this->__end_ = __c.__end_;
    this->__end_cap() = __c.__end_cap();
    __c.__begin_ = __c.__end_ = __c.__end_cap() = nullptr;



}



template <class _Tp, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
vector<_Tp, _Allocator>&
vector<_Tp, _Allocator>::operator=(const vector& __x)
{
    if (this != &__x)
    {
        __base::__copy_assign_alloc(__x);
        assign(__x.__begin_, __x.__end_);
    }
    return *this;
}

template <class _Tp, class _Allocator>
template <class _InputIterator>
typename enable_if
<
     __is_cpp17_input_iterator <_InputIterator>::value &&
    !__is_cpp17_forward_iterator<_InputIterator>::value &&
    is_constructible<
       _Tp,
       typename iterator_traits<_InputIterator>::reference>::value,
    void
>::type
vector<_Tp, _Allocator>::assign(_InputIterator __first, _InputIterator __last)
{
    clear();
    for (; __first != __last; ++__first)
        __emplace_back(*__first);
}

template <class _Tp, class _Allocator>
template <class _ForwardIterator>
typename enable_if
<
    __is_cpp17_forward_iterator<_ForwardIterator>::value &&
    is_constructible<
       _Tp,
       typename iterator_traits<_ForwardIterator>::reference>::value,
    void
>::type
vector<_Tp, _Allocator>::assign(_ForwardIterator __first, _ForwardIterator __last)
{
    size_type __new_size = static_cast<size_type>(std::__1::distance(__first, __last));
    if (__new_size <= capacity())
    {
        _ForwardIterator __mid = __last;
        bool __growing = false;
        if (__new_size > size())
        {
            __growing = true;
            __mid = __first;
            std::__1::advance(__mid, size());
        }
        pointer __m = std::__1::copy(__first, __mid, this->__begin_);
        if (__growing)
            __construct_at_end(__mid, __last, __new_size - size());
        else
            this->__destruct_at_end(__m);
    }
    else
    {
        __vdeallocate();
        __vallocate(__recommend(__new_size));
        __construct_at_end(__first, __last, __new_size);
    }
    __invalidate_all_iterators();
}

template <class _Tp, class _Allocator>
void
vector<_Tp, _Allocator>::assign(size_type __n, const_reference __u)
{
    if (__n <= capacity())
    {
        size_type __s = size();
        std::__1::fill_n(this->__begin_, std::__1::min(__n, __s), __u);
        if (__n > __s)
            __construct_at_end(__n - __s, __u);
        else
            this->__destruct_at_end(this->__begin_ + __n);
    }
    else
    {
        __vdeallocate();
        __vallocate(__recommend(static_cast<size_type>(__n)));
        __construct_at_end(__n, __u);
    }
    __invalidate_all_iterators();
}

template <class _Tp, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename vector<_Tp, _Allocator>::iterator
vector<_Tp, _Allocator>::__make_iter(pointer __p) noexcept
{



    return iterator(__p);

}

template <class _Tp, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename vector<_Tp, _Allocator>::const_iterator
vector<_Tp, _Allocator>::__make_iter(const_pointer __p) const noexcept
{



    return const_iterator(__p);

}

template <class _Tp, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename vector<_Tp, _Allocator>::iterator
vector<_Tp, _Allocator>::begin() noexcept
{
    return __make_iter(this->__begin_);
}

template <class _Tp, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename vector<_Tp, _Allocator>::const_iterator
vector<_Tp, _Allocator>::begin() const noexcept
{
    return __make_iter(this->__begin_);
}

template <class _Tp, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename vector<_Tp, _Allocator>::iterator
vector<_Tp, _Allocator>::end() noexcept
{
    return __make_iter(this->__end_);
}

template <class _Tp, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename vector<_Tp, _Allocator>::const_iterator
vector<_Tp, _Allocator>::end() const noexcept
{
    return __make_iter(this->__end_);
}

template <class _Tp, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename vector<_Tp, _Allocator>::reference
vector<_Tp, _Allocator>::operator[](size_type __n) noexcept
{
    ((void)0);
    return this->__begin_[__n];
}

template <class _Tp, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename vector<_Tp, _Allocator>::const_reference
vector<_Tp, _Allocator>::operator[](size_type __n) const noexcept
{
    ((void)0);
    return this->__begin_[__n];
}

template <class _Tp, class _Allocator>
typename vector<_Tp, _Allocator>::reference
vector<_Tp, _Allocator>::at(size_type __n)
{
    if (__n >= size())
        this->__throw_out_of_range();
    return this->__begin_[__n];
}

template <class _Tp, class _Allocator>
typename vector<_Tp, _Allocator>::const_reference
vector<_Tp, _Allocator>::at(size_type __n) const
{
    if (__n >= size())
        this->__throw_out_of_range();
    return this->__begin_[__n];
}

template <class _Tp, class _Allocator>
void
vector<_Tp, _Allocator>::reserve(size_type __n)
{
    if (__n > capacity())
    {
        allocator_type& __a = this->__alloc();
        __split_buffer<value_type, allocator_type&> __v(__n, size(), __a);
        __swap_out_circular_buffer(__v);
    }
}

template <class _Tp, class _Allocator>
void
vector<_Tp, _Allocator>::shrink_to_fit() noexcept
{
    if (capacity() > size())
    {

        try
        {

            allocator_type& __a = this->__alloc();
            __split_buffer<value_type, allocator_type&> __v(size(), size(), __a);
            __swap_out_circular_buffer(__v);

        }
        catch (...)
        {
        }

    }
}

template <class _Tp, class _Allocator>
template <class _Up>
void

vector<_Tp, _Allocator>::__push_back_slow_path(_Up&& __x)



{
    allocator_type& __a = this->__alloc();
    __split_buffer<value_type, allocator_type&> __v(__recommend(size() + 1), size(), __a);

    __alloc_traits::construct(__a, std::__1::__to_address(__v.__end_), std::__1::forward<_Up>(__x));
    __v.__end_++;
    __swap_out_circular_buffer(__v);
}

template <class _Tp, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void
vector<_Tp, _Allocator>::push_back(const_reference __x)
{
    if (this->__end_ != this->__end_cap())
    {
        __construct_one_at_end(__x);
    }
    else
        __push_back_slow_path(__x);
}



template <class _Tp, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void
vector<_Tp, _Allocator>::push_back(value_type&& __x)
{
    if (this->__end_ < this->__end_cap())
    {
        __construct_one_at_end(std::__1::move(__x));
    }
    else
        __push_back_slow_path(std::__1::move(__x));
}

template <class _Tp, class _Allocator>
template <class... _Args>
void
vector<_Tp, _Allocator>::__emplace_back_slow_path(_Args&&... __args)
{
    allocator_type& __a = this->__alloc();
    __split_buffer<value_type, allocator_type&> __v(__recommend(size() + 1), size(), __a);

    __alloc_traits::construct(__a, std::__1::__to_address(__v.__end_), std::__1::forward<_Args>(__args)...);
    __v.__end_++;
    __swap_out_circular_buffer(__v);
}

template <class _Tp, class _Allocator>
template <class... _Args>
inline

typename vector<_Tp, _Allocator>::reference



vector<_Tp, _Allocator>::emplace_back(_Args&&... __args)
{
    if (this->__end_ < this->__end_cap())
    {
        __construct_one_at_end(std::__1::forward<_Args>(__args)...);
    }
    else
        __emplace_back_slow_path(std::__1::forward<_Args>(__args)...);

    return this->back();

}



template <class _Tp, class _Allocator>
inline
void
vector<_Tp, _Allocator>::pop_back()
{
    ((void)0);
    this->__destruct_at_end(this->__end_ - 1);
}

template <class _Tp, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename vector<_Tp, _Allocator>::iterator
vector<_Tp, _Allocator>::erase(const_iterator __position)
{





    ((void)0);

    difference_type __ps = __position - cbegin();
    pointer __p = this->__begin_ + __ps;
    this->__destruct_at_end(std::__1::move(__p + 1, this->__end_, __p));
    this->__invalidate_iterators_past(__p-1);
    iterator __r = __make_iter(__p);
    return __r;
}

template <class _Tp, class _Allocator>
typename vector<_Tp, _Allocator>::iterator
vector<_Tp, _Allocator>::erase(const_iterator __first, const_iterator __last)
{
# 1758 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/vector" 3
    ((void)0);
    pointer __p = this->__begin_ + (__first - begin());
    if (__first != __last) {
        this->__destruct_at_end(std::__1::move(__p + (__last - __first), this->__end_, __p));
        this->__invalidate_iterators_past(__p - 1);
    }
    iterator __r = __make_iter(__p);
    return __r;
}

template <class _Tp, class _Allocator>
void
vector<_Tp, _Allocator>::__move_range(pointer __from_s, pointer __from_e, pointer __to)
{
    pointer __old_last = this->__end_;
    difference_type __n = __old_last - __to;
    {
      pointer __i = __from_s + __n;
      _ConstructTransaction __tx(*this, __from_e - __i);
      for (pointer __pos = __tx.__pos_; __i < __from_e;
           ++__i, ++__pos, __tx.__pos_ = __pos) {
          __alloc_traits::construct(this->__alloc(),
                                    std::__1::__to_address(__pos),
                                    std::__1::move(*__i));
      }
    }
    std::__1::move_backward(__from_s, __from_s + __n, __old_last);
}

template <class _Tp, class _Allocator>
typename vector<_Tp, _Allocator>::iterator
vector<_Tp, _Allocator>::insert(const_iterator __position, const_reference __x)
{





    pointer __p = this->__begin_ + (__position - begin());
    if (this->__end_ < this->__end_cap())
    {
        if (__p == this->__end_)
        {
            __construct_one_at_end(__x);
        }
        else
        {
            __move_range(__p, this->__end_, __p + 1);
            const_pointer __xr = pointer_traits<const_pointer>::pointer_to(__x);
            if (__p <= __xr && __xr < this->__end_)
                ++__xr;
            *__p = *__xr;
        }
    }
    else
    {
        allocator_type& __a = this->__alloc();
        __split_buffer<value_type, allocator_type&> __v(__recommend(size() + 1), __p - this->__begin_, __a);
        __v.push_back(__x);
        __p = __swap_out_circular_buffer(__v, __p);
    }
    return __make_iter(__p);
}



template <class _Tp, class _Allocator>
typename vector<_Tp, _Allocator>::iterator
vector<_Tp, _Allocator>::insert(const_iterator __position, value_type&& __x)
{





    pointer __p = this->__begin_ + (__position - begin());
    if (this->__end_ < this->__end_cap())
    {
        if (__p == this->__end_)
        {
            __construct_one_at_end(std::__1::move(__x));
        }
        else
        {
            __move_range(__p, this->__end_, __p + 1);
            *__p = std::__1::move(__x);
        }
    }
    else
    {
        allocator_type& __a = this->__alloc();
        __split_buffer<value_type, allocator_type&> __v(__recommend(size() + 1), __p - this->__begin_, __a);
        __v.push_back(std::__1::move(__x));
        __p = __swap_out_circular_buffer(__v, __p);
    }
    return __make_iter(__p);
}

template <class _Tp, class _Allocator>
template <class... _Args>
typename vector<_Tp, _Allocator>::iterator
vector<_Tp, _Allocator>::emplace(const_iterator __position, _Args&&... __args)
{





    pointer __p = this->__begin_ + (__position - begin());
    if (this->__end_ < this->__end_cap())
    {
        if (__p == this->__end_)
        {
            __construct_one_at_end(std::__1::forward<_Args>(__args)...);
        }
        else
        {
            __temp_value<value_type, _Allocator> __tmp(this->__alloc(), std::__1::forward<_Args>(__args)...);
            __move_range(__p, this->__end_, __p + 1);
            *__p = std::__1::move(__tmp.get());
        }
    }
    else
    {
        allocator_type& __a = this->__alloc();
        __split_buffer<value_type, allocator_type&> __v(__recommend(size() + 1), __p - this->__begin_, __a);
        __v.emplace_back(std::__1::forward<_Args>(__args)...);
        __p = __swap_out_circular_buffer(__v, __p);
    }
    return __make_iter(__p);
}



template <class _Tp, class _Allocator>
typename vector<_Tp, _Allocator>::iterator
vector<_Tp, _Allocator>::insert(const_iterator __position, size_type __n, const_reference __x)
{





    pointer __p = this->__begin_ + (__position - begin());
    if (__n > 0)
    {
        if (__n <= static_cast<size_type>(this->__end_cap() - this->__end_))
        {
            size_type __old_n = __n;
            pointer __old_last = this->__end_;
            if (__n > static_cast<size_type>(this->__end_ - __p))
            {
                size_type __cx = __n - (this->__end_ - __p);
                __construct_at_end(__cx, __x);
                __n -= __cx;
            }
            if (__n > 0)
            {
                __move_range(__p, __old_last, __p + __old_n);
                const_pointer __xr = pointer_traits<const_pointer>::pointer_to(__x);
                if (__p <= __xr && __xr < this->__end_)
                    __xr += __old_n;
                std::__1::fill_n(__p, __n, *__xr);
            }
        }
        else
        {
            allocator_type& __a = this->__alloc();
            __split_buffer<value_type, allocator_type&> __v(__recommend(size() + __n), __p - this->__begin_, __a);
            __v.__construct_at_end(__n, __x);
            __p = __swap_out_circular_buffer(__v, __p);
        }
    }
    return __make_iter(__p);
}

template <class _Tp, class _Allocator>
template <class _InputIterator>
typename enable_if
<
     __is_cpp17_input_iterator <_InputIterator>::value &&
    !__is_cpp17_forward_iterator<_InputIterator>::value &&
    is_constructible<
       _Tp,
       typename iterator_traits<_InputIterator>::reference>::value,
    typename vector<_Tp, _Allocator>::iterator
>::type
vector<_Tp, _Allocator>::insert(const_iterator __position, _InputIterator __first, _InputIterator __last)
{





    difference_type __off = __position - begin();
    pointer __p = this->__begin_ + __off;
    allocator_type& __a = this->__alloc();
    pointer __old_last = this->__end_;
    for (; this->__end_ != this->__end_cap() && __first != __last; ++__first)
    {
        __construct_one_at_end(*__first);
    }
    __split_buffer<value_type, allocator_type&> __v(__a);
    if (__first != __last)
    {

        try
        {

            __v.__construct_at_end(__first, __last);
            difference_type __old_size = __old_last - this->__begin_;
            difference_type __old_p = __p - this->__begin_;
            reserve(__recommend(size() + __v.size()));
            __p = this->__begin_ + __old_p;
            __old_last = this->__begin_ + __old_size;

        }
        catch (...)
        {
            erase(__make_iter(__old_last), end());
            throw;
        }

    }
    __p = std::__1::rotate(__p, __old_last, this->__end_);
    insert(__make_iter(__p), std::__1::make_move_iterator(__v.begin()),
                             std::__1::make_move_iterator(__v.end()));
    return begin() + __off;
}

template <class _Tp, class _Allocator>
template <class _ForwardIterator>
typename enable_if
<
    __is_cpp17_forward_iterator<_ForwardIterator>::value &&
    is_constructible<
       _Tp,
       typename iterator_traits<_ForwardIterator>::reference>::value,
    typename vector<_Tp, _Allocator>::iterator
>::type
vector<_Tp, _Allocator>::insert(const_iterator __position, _ForwardIterator __first, _ForwardIterator __last)
{





    pointer __p = this->__begin_ + (__position - begin());
    difference_type __n = std::__1::distance(__first, __last);
    if (__n > 0)
    {
        if (__n <= this->__end_cap() - this->__end_)
        {
            size_type __old_n = __n;
            pointer __old_last = this->__end_;
            _ForwardIterator __m = __last;
            difference_type __dx = this->__end_ - __p;
            if (__n > __dx)
            {
                __m = __first;
                difference_type __diff = this->__end_ - __p;
                std::__1::advance(__m, __diff);
                __construct_at_end(__m, __last, __n - __diff);
                __n = __dx;
            }
            if (__n > 0)
            {
                __move_range(__p, __old_last, __p + __old_n);
                std::__1::copy(__first, __m, __p);
            }
        }
        else
        {
            allocator_type& __a = this->__alloc();
            __split_buffer<value_type, allocator_type&> __v(__recommend(size() + __n), __p - this->__begin_, __a);
            __v.__construct_at_end(__first, __last);
            __p = __swap_out_circular_buffer(__v, __p);
        }
    }
    return __make_iter(__p);
}

template <class _Tp, class _Allocator>
void
vector<_Tp, _Allocator>::resize(size_type __sz)
{
    size_type __cs = size();
    if (__cs < __sz)
        this->__append(__sz - __cs);
    else if (__cs > __sz)
        this->__destruct_at_end(this->__begin_ + __sz);
}

template <class _Tp, class _Allocator>
void
vector<_Tp, _Allocator>::resize(size_type __sz, const_reference __x)
{
    size_type __cs = size();
    if (__cs < __sz)
        this->__append(__sz - __cs, __x);
    else if (__cs > __sz)
        this->__destruct_at_end(this->__begin_ + __sz);
}

template <class _Tp, class _Allocator>
void
vector<_Tp, _Allocator>::swap(vector& __x)

    noexcept




{
    ((void)0);



    std::__1::swap(this->__begin_, __x.__begin_);
    std::__1::swap(this->__end_, __x.__end_);
    std::__1::swap(this->__end_cap(), __x.__end_cap());
    std::__1::__swap_allocator(this->__alloc(), __x.__alloc(),
        integral_constant<bool,__alloc_traits::propagate_on_container_swap::value>());



}

template <class _Tp, class _Allocator>
bool
vector<_Tp, _Allocator>::__invariants() const
{
    if (this->__begin_ == nullptr)
    {
        if (this->__end_ != nullptr || this->__end_cap() != nullptr)
            return false;
    }
    else
    {
        if (this->__begin_ > this->__end_)
            return false;
        if (this->__begin_ == this->__end_cap())
            return false;
        if (this->__end_ > this->__end_cap())
            return false;
    }
    return true;
}
# 2141 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/vector" 3
template <class _Tp, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void
vector<_Tp, _Allocator>::__invalidate_all_iterators()
{



}


template <class _Tp, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void
vector<_Tp, _Allocator>::__invalidate_iterators_past(pointer __new_last) {
# 2169 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/vector" 3
  ((void)__new_last);

}



template <class _Allocator> class vector<bool, _Allocator>;

template <class _Allocator> struct hash<vector<bool, _Allocator> >;

template <class _Allocator>
struct __has_storage_type<vector<bool, _Allocator> >
{
    static const bool value = true;
};

template <class _Allocator>
class __attribute__ ((__type_visibility__("default"))) vector<bool, _Allocator>
    : private __vector_base_common<true>
{
public:
    typedef vector __self;
    typedef bool value_type;
    typedef _Allocator allocator_type;
    typedef allocator_traits<allocator_type> __alloc_traits;
    typedef typename __alloc_traits::size_type size_type;
    typedef typename __alloc_traits::difference_type difference_type;
    typedef size_type __storage_type;
    typedef __bit_iterator<vector, false> pointer;
    typedef __bit_iterator<vector, true> const_pointer;
    typedef pointer iterator;
    typedef const_pointer const_iterator;
    typedef std::__1::reverse_iterator<iterator> reverse_iterator;
    typedef std::__1::reverse_iterator<const_iterator> const_reverse_iterator;

private:
    typedef typename __rebind_alloc_helper<__alloc_traits, __storage_type>::type __storage_allocator;
    typedef allocator_traits<__storage_allocator> __storage_traits;
    typedef typename __storage_traits::pointer __storage_pointer;
    typedef typename __storage_traits::const_pointer __const_storage_pointer;

    __storage_pointer __begin_;
    size_type __size_;
    __compressed_pair<size_type, __storage_allocator> __cap_alloc_;
public:
    typedef __bit_reference<vector> reference;
    typedef __bit_const_reference<vector> const_reference;
private:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_type& __cap() noexcept
        {return __cap_alloc_.first();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const size_type& __cap() const noexcept
        {return __cap_alloc_.first();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __storage_allocator& __alloc() noexcept
        {return __cap_alloc_.second();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const __storage_allocator& __alloc() const noexcept
        {return __cap_alloc_.second();}

    static const unsigned __bits_per_word = static_cast<unsigned>(sizeof(__storage_type) * 8);

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    static size_type __internal_cap_to_external(size_type __n) noexcept
        {return __n * __bits_per_word;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    static size_type __external_cap_to_internal(size_type __n) noexcept
        {return (__n - 1) / __bits_per_word + 1;}

public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    vector() noexcept(is_nothrow_default_constructible<allocator_type>::value);

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) explicit vector(const allocator_type& __a)



        noexcept;

    ~vector();
    explicit vector(size_type __n);

    explicit vector(size_type __n, const allocator_type& __a);

    vector(size_type __n, const value_type& __v);
    vector(size_type __n, const value_type& __v, const allocator_type& __a);
    template <class _InputIterator>
        vector(_InputIterator __first, _InputIterator __last,
               typename enable_if<__is_cpp17_input_iterator <_InputIterator>::value &&
                                 !__is_cpp17_forward_iterator<_InputIterator>::value>::type* = 0);
    template <class _InputIterator>
        vector(_InputIterator __first, _InputIterator __last, const allocator_type& __a,
               typename enable_if<__is_cpp17_input_iterator <_InputIterator>::value &&
                                 !__is_cpp17_forward_iterator<_InputIterator>::value>::type* = 0);
    template <class _ForwardIterator>
        vector(_ForwardIterator __first, _ForwardIterator __last,
               typename enable_if<__is_cpp17_forward_iterator<_ForwardIterator>::value>::type* = 0);
    template <class _ForwardIterator>
        vector(_ForwardIterator __first, _ForwardIterator __last, const allocator_type& __a,
               typename enable_if<__is_cpp17_forward_iterator<_ForwardIterator>::value>::type* = 0);

    vector(const vector& __v);
    vector(const vector& __v, const allocator_type& __a);
    vector& operator=(const vector& __v);


    vector(initializer_list<value_type> __il);
    vector(initializer_list<value_type> __il, const allocator_type& __a);

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    vector(vector&& __v)

        noexcept;



    vector(vector&& __v, const __identity_t<allocator_type>& __a);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    vector& operator=(vector&& __v)
        noexcept((__noexcept_move_assign_container<_Allocator, __alloc_traits>::value));

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    vector& operator=(initializer_list<value_type> __il)
        {assign(__il.begin(), __il.end()); return *this;}



    template <class _InputIterator>
        typename enable_if
        <
            __is_cpp17_input_iterator<_InputIterator>::value &&
           !__is_cpp17_forward_iterator<_InputIterator>::value,
           void
        >::type
        assign(_InputIterator __first, _InputIterator __last);
    template <class _ForwardIterator>
        typename enable_if
        <
            __is_cpp17_forward_iterator<_ForwardIterator>::value,
           void
        >::type
        assign(_ForwardIterator __first, _ForwardIterator __last);

    void assign(size_type __n, const value_type& __x);


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void assign(initializer_list<value_type> __il)
        {assign(__il.begin(), __il.end());}


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) allocator_type get_allocator() const noexcept
        {return allocator_type(this->__alloc());}

    size_type max_size() const noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_type capacity() const noexcept
        {return __internal_cap_to_external(__cap());}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_type size() const noexcept
        {return __size_;}
                                  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    bool empty() const noexcept
        {return __size_ == 0;}
    void reserve(size_type __n);
    void shrink_to_fit() noexcept;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iterator begin() noexcept
        {return __make_iter(0);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_iterator begin() const noexcept
        {return __make_iter(0);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iterator end() noexcept
        {return __make_iter(__size_);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_iterator end() const noexcept
        {return __make_iter(__size_);}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    reverse_iterator rbegin() noexcept
        {return reverse_iterator(end());}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_reverse_iterator rbegin() const noexcept
        {return const_reverse_iterator(end());}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    reverse_iterator rend() noexcept
        {return reverse_iterator(begin());}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_reverse_iterator rend() const noexcept
        {return const_reverse_iterator(begin());}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_iterator cbegin() const noexcept
        {return __make_iter(0);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_iterator cend() const noexcept
        {return __make_iter(__size_);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_reverse_iterator crbegin() const noexcept
        {return rbegin();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_reverse_iterator crend() const noexcept
        {return rend();}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) reference operator[](size_type __n) {return __make_ref(__n);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) const_reference operator[](size_type __n) const {return __make_ref(__n);}
    reference at(size_type __n);
    const_reference at(size_type __n) const;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) reference front() {return __make_ref(0);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) const_reference front() const {return __make_ref(0);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) reference back() {return __make_ref(__size_ - 1);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) const_reference back() const {return __make_ref(__size_ - 1);}

    void push_back(const value_type& __x);

    template <class... _Args>

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) reference emplace_back(_Args&&... __args)



    {
        push_back ( value_type ( std::__1::forward<_Args>(__args)... ));

        return this->back();

    }


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) void pop_back() {--__size_;}


    template <class... _Args>
   __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) iterator emplace(const_iterator position, _Args&&... __args)
        { return insert ( position, value_type ( std::__1::forward<_Args>(__args)... )); }


    iterator insert(const_iterator __position, const value_type& __x);
    iterator insert(const_iterator __position, size_type __n, const value_type& __x);
    iterator insert(const_iterator __position, size_type __n, const_reference __x);
    template <class _InputIterator>
        typename enable_if
        <
             __is_cpp17_input_iterator <_InputIterator>::value &&
            !__is_cpp17_forward_iterator<_InputIterator>::value,
            iterator
        >::type
        insert(const_iterator __position, _InputIterator __first, _InputIterator __last);
    template <class _ForwardIterator>
        typename enable_if
        <
            __is_cpp17_forward_iterator<_ForwardIterator>::value,
            iterator
        >::type
        insert(const_iterator __position, _ForwardIterator __first, _ForwardIterator __last);


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iterator insert(const_iterator __position, initializer_list<value_type> __il)
        {return insert(__position, __il.begin(), __il.end());}


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) iterator erase(const_iterator __position);
    iterator erase(const_iterator __first, const_iterator __last);

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void clear() noexcept {__size_ = 0;}

    void swap(vector&)

        noexcept;




    static void swap(reference __x, reference __y) noexcept { std::__1::swap(__x, __y); }

    void resize(size_type __sz, value_type __x = false);
    void flip() noexcept;

    bool __invariants() const;

private:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) void __invalidate_all_iterators();
    void __vallocate(size_type __n);
    void __vdeallocate() noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    static size_type __align_it(size_type __new_size) noexcept
        {return __new_size + (__bits_per_word-1) & ~((size_type)__bits_per_word-1);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) size_type __recommend(size_type __new_size) const;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) void __construct_at_end(size_type __n, bool __x);
    template <class _ForwardIterator>
        typename enable_if
        <
            __is_cpp17_forward_iterator<_ForwardIterator>::value,
            void
        >::type
        __construct_at_end(_ForwardIterator __first, _ForwardIterator __last);
    void __append(size_type __n, const_reference __x);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    reference __make_ref(size_type __pos) noexcept
        {return reference(__begin_ + __pos / __bits_per_word, __storage_type(1) << __pos % __bits_per_word);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_reference __make_ref(size_type __pos) const noexcept
        {return const_reference(__begin_ + __pos / __bits_per_word, __storage_type(1) << __pos % __bits_per_word);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iterator __make_iter(size_type __pos) noexcept
        {return iterator(__begin_ + __pos / __bits_per_word, static_cast<unsigned>(__pos % __bits_per_word));}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_iterator __make_iter(size_type __pos) const noexcept
        {return const_iterator(__begin_ + __pos / __bits_per_word, static_cast<unsigned>(__pos % __bits_per_word));}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iterator __const_iterator_cast(const_iterator __p) noexcept
        {return begin() + (__p - cbegin());}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void __copy_assign_alloc(const vector& __v)
        {__copy_assign_alloc(__v, integral_constant<bool,
                      __storage_traits::propagate_on_container_copy_assignment::value>());}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void __copy_assign_alloc(const vector& __c, true_type)
        {
            if (__alloc() != __c.__alloc())
                __vdeallocate();
            __alloc() = __c.__alloc();
        }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void __copy_assign_alloc(const vector&, false_type)
        {}

    void __move_assign(vector& __c, false_type);
    void __move_assign(vector& __c, true_type)
        noexcept(is_nothrow_move_assignable<allocator_type>::value);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void __move_assign_alloc(vector& __c)
        noexcept(!__storage_traits::propagate_on_container_move_assignment::value || is_nothrow_move_assignable<allocator_type>::value)


        {__move_assign_alloc(__c, integral_constant<bool,
                      __storage_traits::propagate_on_container_move_assignment::value>());}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void __move_assign_alloc(vector& __c, true_type)
        noexcept(is_nothrow_move_assignable<allocator_type>::value)
        {
            __alloc() = std::__1::move(__c.__alloc());
        }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void __move_assign_alloc(vector&, false_type)
        noexcept
        {}

    size_t __hash_code() const noexcept;

    friend class __bit_reference<vector>;
    friend class __bit_const_reference<vector>;
    friend class __bit_iterator<vector, false>;
    friend class __bit_iterator<vector, true>;
    friend struct __bit_array<vector>;
    friend struct __attribute__ ((__type_visibility__("default"))) hash<vector>;
};

template <class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void
vector<bool, _Allocator>::__invalidate_all_iterators()
{
}
# 2550 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/vector" 3
template <class _Allocator>
void
vector<bool, _Allocator>::__vallocate(size_type __n)
{
    if (__n > max_size())
        this->__throw_length_error();
    __n = __external_cap_to_internal(__n);
    this->__begin_ = __storage_traits::allocate(this->__alloc(), __n);
    this->__size_ = 0;
    this->__cap() = __n;
}

template <class _Allocator>
void
vector<bool, _Allocator>::__vdeallocate() noexcept
{
    if (this->__begin_ != nullptr)
    {
        __storage_traits::deallocate(this->__alloc(), this->__begin_, __cap());
        __invalidate_all_iterators();
        this->__begin_ = nullptr;
        this->__size_ = this->__cap() = 0;
    }
}

template <class _Allocator>
typename vector<bool, _Allocator>::size_type
vector<bool, _Allocator>::max_size() const noexcept
{
    size_type __amax = __storage_traits::max_size(__alloc());
    size_type __nmax = numeric_limits<size_type>::max() / 2;
    if (__nmax / __bits_per_word <= __amax)
        return __nmax;
    return __internal_cap_to_external(__amax);
}


template <class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename vector<bool, _Allocator>::size_type
vector<bool, _Allocator>::__recommend(size_type __new_size) const
{
    const size_type __ms = max_size();
    if (__new_size > __ms)
        this->__throw_length_error();
    const size_type __cap = capacity();
    if (__cap >= __ms / 2)
        return __ms;
    return std::__1::max(2 * __cap, __align_it(__new_size));
}





template <class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void
vector<bool, _Allocator>::__construct_at_end(size_type __n, bool __x)
{
    size_type __old_size = this->__size_;
    this->__size_ += __n;
    if (__old_size == 0 || ((__old_size - 1) / __bits_per_word) != ((this->__size_ - 1) / __bits_per_word))
    {
        if (this->__size_ <= __bits_per_word)
            this->__begin_[0] = __storage_type(0);
        else
            this->__begin_[(this->__size_ - 1) / __bits_per_word] = __storage_type(0);
    }
    std::__1::fill_n(__make_iter(__old_size), __n, __x);
}

template <class _Allocator>
template <class _ForwardIterator>
typename enable_if
<
    __is_cpp17_forward_iterator<_ForwardIterator>::value,
    void
>::type
vector<bool, _Allocator>::__construct_at_end(_ForwardIterator __first, _ForwardIterator __last)
{
    size_type __old_size = this->__size_;
    this->__size_ += std::__1::distance(__first, __last);
    if (__old_size == 0 || ((__old_size - 1) / __bits_per_word) != ((this->__size_ - 1) / __bits_per_word))
    {
        if (this->__size_ <= __bits_per_word)
            this->__begin_[0] = __storage_type(0);
        else
            this->__begin_[(this->__size_ - 1) / __bits_per_word] = __storage_type(0);
    }
    std::__1::copy(__first, __last, __make_iter(__old_size));
}

template <class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
vector<bool, _Allocator>::vector()
    noexcept(is_nothrow_default_constructible<allocator_type>::value)
    : __begin_(nullptr),
      __size_(0),
      __cap_alloc_(0, __default_init_tag())
{
}

template <class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
vector<bool, _Allocator>::vector(const allocator_type& __a)



        noexcept

    : __begin_(nullptr),
      __size_(0),
      __cap_alloc_(0, static_cast<__storage_allocator>(__a))
{
}

template <class _Allocator>
vector<bool, _Allocator>::vector(size_type __n)
    : __begin_(nullptr),
      __size_(0),
      __cap_alloc_(0, __default_init_tag())
{
    if (__n > 0)
    {
        __vallocate(__n);
        __construct_at_end(__n, false);
    }
}


template <class _Allocator>
vector<bool, _Allocator>::vector(size_type __n, const allocator_type& __a)
    : __begin_(nullptr),
      __size_(0),
      __cap_alloc_(0, static_cast<__storage_allocator>(__a))
{
    if (__n > 0)
    {
        __vallocate(__n);
        __construct_at_end(__n, false);
    }
}


template <class _Allocator>
vector<bool, _Allocator>::vector(size_type __n, const value_type& __x)
    : __begin_(nullptr),
      __size_(0),
      __cap_alloc_(0, __default_init_tag())
{
    if (__n > 0)
    {
        __vallocate(__n);
        __construct_at_end(__n, __x);
    }
}

template <class _Allocator>
vector<bool, _Allocator>::vector(size_type __n, const value_type& __x, const allocator_type& __a)
    : __begin_(nullptr),
      __size_(0),
      __cap_alloc_(0, static_cast<__storage_allocator>(__a))
{
    if (__n > 0)
    {
        __vallocate(__n);
        __construct_at_end(__n, __x);
    }
}

template <class _Allocator>
template <class _InputIterator>
vector<bool, _Allocator>::vector(_InputIterator __first, _InputIterator __last,
       typename enable_if<__is_cpp17_input_iterator <_InputIterator>::value &&
                         !__is_cpp17_forward_iterator<_InputIterator>::value>::type*)
    : __begin_(nullptr),
      __size_(0),
      __cap_alloc_(0, __default_init_tag())
{

    try
    {

        for (; __first != __last; ++__first)
            push_back(*__first);

    }
    catch (...)
    {
        if (__begin_ != nullptr)
            __storage_traits::deallocate(__alloc(), __begin_, __cap());
        __invalidate_all_iterators();
        throw;
    }

}

template <class _Allocator>
template <class _InputIterator>
vector<bool, _Allocator>::vector(_InputIterator __first, _InputIterator __last, const allocator_type& __a,
       typename enable_if<__is_cpp17_input_iterator <_InputIterator>::value &&
                         !__is_cpp17_forward_iterator<_InputIterator>::value>::type*)
    : __begin_(nullptr),
      __size_(0),
      __cap_alloc_(0, static_cast<__storage_allocator>(__a))
{

    try
    {

        for (; __first != __last; ++__first)
            push_back(*__first);

    }
    catch (...)
    {
        if (__begin_ != nullptr)
            __storage_traits::deallocate(__alloc(), __begin_, __cap());
        __invalidate_all_iterators();
        throw;
    }

}

template <class _Allocator>
template <class _ForwardIterator>
vector<bool, _Allocator>::vector(_ForwardIterator __first, _ForwardIterator __last,
                                typename enable_if<__is_cpp17_forward_iterator<_ForwardIterator>::value>::type*)
    : __begin_(nullptr),
      __size_(0),
      __cap_alloc_(0, __default_init_tag())
{
    size_type __n = static_cast<size_type>(std::__1::distance(__first, __last));
    if (__n > 0)
    {
        __vallocate(__n);
        __construct_at_end(__first, __last);
    }
}

template <class _Allocator>
template <class _ForwardIterator>
vector<bool, _Allocator>::vector(_ForwardIterator __first, _ForwardIterator __last, const allocator_type& __a,
                                typename enable_if<__is_cpp17_forward_iterator<_ForwardIterator>::value>::type*)
    : __begin_(nullptr),
      __size_(0),
      __cap_alloc_(0, static_cast<__storage_allocator>(__a))
{
    size_type __n = static_cast<size_type>(std::__1::distance(__first, __last));
    if (__n > 0)
    {
        __vallocate(__n);
        __construct_at_end(__first, __last);
    }
}



template <class _Allocator>
vector<bool, _Allocator>::vector(initializer_list<value_type> __il)
    : __begin_(nullptr),
      __size_(0),
      __cap_alloc_(0, __default_init_tag())
{
    size_type __n = static_cast<size_type>(__il.size());
    if (__n > 0)
    {
        __vallocate(__n);
        __construct_at_end(__il.begin(), __il.end());
    }
}

template <class _Allocator>
vector<bool, _Allocator>::vector(initializer_list<value_type> __il, const allocator_type& __a)
    : __begin_(nullptr),
      __size_(0),
      __cap_alloc_(0, static_cast<__storage_allocator>(__a))
{
    size_type __n = static_cast<size_type>(__il.size());
    if (__n > 0)
    {
        __vallocate(__n);
        __construct_at_end(__il.begin(), __il.end());
    }
}



template <class _Allocator>
vector<bool, _Allocator>::~vector()
{
    if (__begin_ != nullptr)
        __storage_traits::deallocate(__alloc(), __begin_, __cap());
    __invalidate_all_iterators();
}

template <class _Allocator>
vector<bool, _Allocator>::vector(const vector& __v)
    : __begin_(nullptr),
      __size_(0),
      __cap_alloc_(0, __storage_traits::select_on_container_copy_construction(__v.__alloc()))
{
    if (__v.size() > 0)
    {
        __vallocate(__v.size());
        __construct_at_end(__v.begin(), __v.end());
    }
}

template <class _Allocator>
vector<bool, _Allocator>::vector(const vector& __v, const allocator_type& __a)
    : __begin_(nullptr),
      __size_(0),
      __cap_alloc_(0, __a)
{
    if (__v.size() > 0)
    {
        __vallocate(__v.size());
        __construct_at_end(__v.begin(), __v.end());
    }
}

template <class _Allocator>
vector<bool, _Allocator>&
vector<bool, _Allocator>::operator=(const vector& __v)
{
    if (this != &__v)
    {
        __copy_assign_alloc(__v);
        if (__v.__size_)
        {
            if (__v.__size_ > capacity())
            {
                __vdeallocate();
                __vallocate(__v.__size_);
            }
            std::__1::copy(__v.__begin_, __v.__begin_ + __external_cap_to_internal(__v.__size_), __begin_);
        }
        __size_ = __v.__size_;
    }
    return *this;
}



template <class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) vector<bool, _Allocator>::vector(vector&& __v)

    noexcept



    : __begin_(__v.__begin_),
      __size_(__v.__size_),
      __cap_alloc_(std::__1::move(__v.__cap_alloc_)) {
    __v.__begin_ = nullptr;
    __v.__size_ = 0;
    __v.__cap() = 0;
}

template <class _Allocator>
vector<bool, _Allocator>::vector(vector&& __v, const __identity_t<allocator_type>& __a)
    : __begin_(nullptr),
      __size_(0),
      __cap_alloc_(0, __a)
{
    if (__a == allocator_type(__v.__alloc()))
    {
        this->__begin_ = __v.__begin_;
        this->__size_ = __v.__size_;
        this->__cap() = __v.__cap();
        __v.__begin_ = nullptr;
        __v.__cap() = __v.__size_ = 0;
    }
    else if (__v.size() > 0)
    {
        __vallocate(__v.size());
        __construct_at_end(__v.begin(), __v.end());
    }
}

template <class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
vector<bool, _Allocator>&
vector<bool, _Allocator>::operator=(vector&& __v)
    noexcept((__noexcept_move_assign_container<_Allocator, __alloc_traits>::value))
{
    __move_assign(__v, integral_constant<bool,
          __storage_traits::propagate_on_container_move_assignment::value>());
    return *this;
}

template <class _Allocator>
void
vector<bool, _Allocator>::__move_assign(vector& __c, false_type)
{
    if (__alloc() != __c.__alloc())
        assign(__c.begin(), __c.end());
    else
        __move_assign(__c, true_type());
}

template <class _Allocator>
void
vector<bool, _Allocator>::__move_assign(vector& __c, true_type)
    noexcept(is_nothrow_move_assignable<allocator_type>::value)
{
    __vdeallocate();
    __move_assign_alloc(__c);
    this->__begin_ = __c.__begin_;
    this->__size_ = __c.__size_;
    this->__cap() = __c.__cap();
    __c.__begin_ = nullptr;
    __c.__cap() = __c.__size_ = 0;
}



template <class _Allocator>
void
vector<bool, _Allocator>::assign(size_type __n, const value_type& __x)
{
    __size_ = 0;
    if (__n > 0)
    {
        size_type __c = capacity();
        if (__n <= __c)
            __size_ = __n;
        else
        {
            vector __v(__alloc());
            __v.reserve(__recommend(__n));
            __v.__size_ = __n;
            swap(__v);
        }
        std::__1::fill_n(begin(), __n, __x);
    }
  __invalidate_all_iterators();
}

template <class _Allocator>
template <class _InputIterator>
typename enable_if
<
    __is_cpp17_input_iterator<_InputIterator>::value &&
   !__is_cpp17_forward_iterator<_InputIterator>::value,
   void
>::type
vector<bool, _Allocator>::assign(_InputIterator __first, _InputIterator __last)
{
    clear();
    for (; __first != __last; ++__first)
        push_back(*__first);
}

template <class _Allocator>
template <class _ForwardIterator>
typename enable_if
<
    __is_cpp17_forward_iterator<_ForwardIterator>::value,
   void
>::type
vector<bool, _Allocator>::assign(_ForwardIterator __first, _ForwardIterator __last)
{
    clear();
    difference_type __ns = std::__1::distance(__first, __last);
    ((void)0);
    const size_t __n = static_cast<size_type>(__ns);
    if (__n)
    {
        if (__n > capacity())
        {
            __vdeallocate();
            __vallocate(__n);
        }
        __construct_at_end(__first, __last);
    }
}

template <class _Allocator>
void
vector<bool, _Allocator>::reserve(size_type __n)
{
    if (__n > capacity())
    {
        vector __v(this->__alloc());
        __v.__vallocate(__n);
        __v.__construct_at_end(this->begin(), this->end());
        swap(__v);
        __invalidate_all_iterators();
    }
}

template <class _Allocator>
void
vector<bool, _Allocator>::shrink_to_fit() noexcept
{
    if (__external_cap_to_internal(size()) > __cap())
    {

        try
        {

            vector(*this, allocator_type(__alloc())).swap(*this);

        }
        catch (...)
        {
        }

    }
}

template <class _Allocator>
typename vector<bool, _Allocator>::reference
vector<bool, _Allocator>::at(size_type __n)
{
    if (__n >= size())
        this->__throw_out_of_range();
    return (*this)[__n];
}

template <class _Allocator>
typename vector<bool, _Allocator>::const_reference
vector<bool, _Allocator>::at(size_type __n) const
{
    if (__n >= size())
        this->__throw_out_of_range();
    return (*this)[__n];
}

template <class _Allocator>
void
vector<bool, _Allocator>::push_back(const value_type& __x)
{
    if (this->__size_ == this->capacity())
        reserve(__recommend(this->__size_ + 1));
    ++this->__size_;
    back() = __x;
}

template <class _Allocator>
typename vector<bool, _Allocator>::iterator
vector<bool, _Allocator>::insert(const_iterator __position, const value_type& __x)
{
    iterator __r;
    if (size() < capacity())
    {
        const_iterator __old_end = end();
        ++__size_;
        std::__1::copy_backward(__position, __old_end, end());
        __r = __const_iterator_cast(__position);
    }
    else
    {
        vector __v(__alloc());
        __v.reserve(__recommend(__size_ + 1));
        __v.__size_ = __size_ + 1;
        __r = std::__1::copy(cbegin(), __position, __v.begin());
        std::__1::copy_backward(__position, cend(), __v.end());
        swap(__v);
    }
    *__r = __x;
    return __r;
}

template <class _Allocator>
typename vector<bool, _Allocator>::iterator
vector<bool, _Allocator>::insert(const_iterator __position, size_type __n, const value_type& __x)
{
    iterator __r;
    size_type __c = capacity();
    if (__n <= __c && size() <= __c - __n)
    {
        const_iterator __old_end = end();
        __size_ += __n;
        std::__1::copy_backward(__position, __old_end, end());
        __r = __const_iterator_cast(__position);
    }
    else
    {
        vector __v(__alloc());
        __v.reserve(__recommend(__size_ + __n));
        __v.__size_ = __size_ + __n;
        __r = std::__1::copy(cbegin(), __position, __v.begin());
        std::__1::copy_backward(__position, cend(), __v.end());
        swap(__v);
    }
    std::__1::fill_n(__r, __n, __x);
    return __r;
}

template <class _Allocator>
template <class _InputIterator>
typename enable_if
<
     __is_cpp17_input_iterator <_InputIterator>::value &&
    !__is_cpp17_forward_iterator<_InputIterator>::value,
    typename vector<bool, _Allocator>::iterator
>::type
vector<bool, _Allocator>::insert(const_iterator __position, _InputIterator __first, _InputIterator __last)
{
    difference_type __off = __position - begin();
    iterator __p = __const_iterator_cast(__position);
    iterator __old_end = end();
    for (; size() != capacity() && __first != __last; ++__first)
    {
        ++this->__size_;
        back() = *__first;
    }
    vector __v(__alloc());
    if (__first != __last)
    {

        try
        {

            __v.assign(__first, __last);
            difference_type __old_size = static_cast<difference_type>(__old_end - begin());
            difference_type __old_p = __p - begin();
            reserve(__recommend(size() + __v.size()));
            __p = begin() + __old_p;
            __old_end = begin() + __old_size;

        }
        catch (...)
        {
            erase(__old_end, end());
            throw;
        }

    }
    __p = std::__1::rotate(__p, __old_end, end());
    insert(__p, __v.begin(), __v.end());
    return begin() + __off;
}

template <class _Allocator>
template <class _ForwardIterator>
typename enable_if
<
    __is_cpp17_forward_iterator<_ForwardIterator>::value,
    typename vector<bool, _Allocator>::iterator
>::type
vector<bool, _Allocator>::insert(const_iterator __position, _ForwardIterator __first, _ForwardIterator __last)
{
    const difference_type __n_signed = std::__1::distance(__first, __last);
    ((void)0);
    const size_type __n = static_cast<size_type>(__n_signed);
    iterator __r;
    size_type __c = capacity();
    if (__n <= __c && size() <= __c - __n)
    {
        const_iterator __old_end = end();
        __size_ += __n;
        std::__1::copy_backward(__position, __old_end, end());
        __r = __const_iterator_cast(__position);
    }
    else
    {
        vector __v(__alloc());
        __v.reserve(__recommend(__size_ + __n));
        __v.__size_ = __size_ + __n;
        __r = std::__1::copy(cbegin(), __position, __v.begin());
        std::__1::copy_backward(__position, cend(), __v.end());
        swap(__v);
    }
    std::__1::copy(__first, __last, __r);
    return __r;
}

template <class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename vector<bool, _Allocator>::iterator
vector<bool, _Allocator>::erase(const_iterator __position)
{
    iterator __r = __const_iterator_cast(__position);
    std::__1::copy(__position + 1, this->cend(), __r);
    --__size_;
    return __r;
}

template <class _Allocator>
typename vector<bool, _Allocator>::iterator
vector<bool, _Allocator>::erase(const_iterator __first, const_iterator __last)
{
    iterator __r = __const_iterator_cast(__first);
    difference_type __d = __last - __first;
    std::__1::copy(__last, this->cend(), __r);
    __size_ -= __d;
    return __r;
}

template <class _Allocator>
void
vector<bool, _Allocator>::swap(vector& __x)

    noexcept




{
    std::__1::swap(this->__begin_, __x.__begin_);
    std::__1::swap(this->__size_, __x.__size_);
    std::__1::swap(this->__cap(), __x.__cap());
    std::__1::__swap_allocator(this->__alloc(), __x.__alloc(),
        integral_constant<bool, __alloc_traits::propagate_on_container_swap::value>());
}

template <class _Allocator>
void
vector<bool, _Allocator>::resize(size_type __sz, value_type __x)
{
    size_type __cs = size();
    if (__cs < __sz)
    {
        iterator __r;
        size_type __c = capacity();
        size_type __n = __sz - __cs;
        if (__n <= __c && __cs <= __c - __n)
        {
            __r = end();
            __size_ += __n;
        }
        else
        {
            vector __v(__alloc());
            __v.reserve(__recommend(__size_ + __n));
            __v.__size_ = __size_ + __n;
            __r = std::__1::copy(cbegin(), cend(), __v.begin());
            swap(__v);
        }
        std::__1::fill_n(__r, __n, __x);
    }
    else
        __size_ = __sz;
}

template <class _Allocator>
void
vector<bool, _Allocator>::flip() noexcept
{

    size_type __n = __size_;
    __storage_pointer __p = __begin_;
    for (; __n >= __bits_per_word; ++__p, __n -= __bits_per_word)
        *__p = ~*__p;

    if (__n > 0)
    {
        __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
        __storage_type __b = *__p & __m;
        *__p &= ~__m;
        *__p |= ~__b & __m;
    }
}

template <class _Allocator>
bool
vector<bool, _Allocator>::__invariants() const
{
    if (this->__begin_ == nullptr)
    {
        if (this->__size_ != 0 || this->__cap() != 0)
            return false;
    }
    else
    {
        if (this->__cap() == 0)
            return false;
        if (this->__size_ > this->capacity())
            return false;
    }
    return true;
}

template <class _Allocator>
size_t
vector<bool, _Allocator>::__hash_code() const noexcept
{
    size_t __h = 0;

    size_type __n = __size_;
    __storage_pointer __p = __begin_;
    for (; __n >= __bits_per_word; ++__p, __n -= __bits_per_word)
        __h ^= *__p;

    if (__n > 0)
    {
        const __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
        __h ^= *__p & __m;
    }
    return __h;
}

template <class _Allocator>
struct __attribute__ ((__type_visibility__("default"))) hash<vector<bool, _Allocator> >
    : public unary_function<vector<bool, _Allocator>, size_t>
{
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_t operator()(const vector<bool, _Allocator>& __vec) const noexcept
        {return __vec.__hash_code();}
};

template <class _Tp, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator==(const vector<_Tp, _Allocator>& __x, const vector<_Tp, _Allocator>& __y)
{
    const typename vector<_Tp, _Allocator>::size_type __sz = __x.size();
    return __sz == __y.size() && std::__1::equal(__x.begin(), __x.end(), __y.begin());
}

template <class _Tp, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator!=(const vector<_Tp, _Allocator>& __x, const vector<_Tp, _Allocator>& __y)
{
    return !(__x == __y);
}

template <class _Tp, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator< (const vector<_Tp, _Allocator>& __x, const vector<_Tp, _Allocator>& __y)
{
    return std::__1::lexicographical_compare(__x.begin(), __x.end(), __y.begin(), __y.end());
}

template <class _Tp, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator> (const vector<_Tp, _Allocator>& __x, const vector<_Tp, _Allocator>& __y)
{
    return __y < __x;
}

template <class _Tp, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator>=(const vector<_Tp, _Allocator>& __x, const vector<_Tp, _Allocator>& __y)
{
    return !(__x < __y);
}

template <class _Tp, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator<=(const vector<_Tp, _Allocator>& __x, const vector<_Tp, _Allocator>& __y)
{
    return !(__y < __x);
}

template <class _Tp, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void
swap(vector<_Tp, _Allocator>& __x, vector<_Tp, _Allocator>& __y)
    noexcept(noexcept(__x.swap(__y)))
{
    __x.swap(__y);
}
# 3432 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/vector" 3
} }
# 189 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/queue" 2 3
# 192 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/queue" 3


namespace std { inline namespace __1 {

template <class _Tp, class _Container = deque<_Tp> > class __attribute__ ((__type_visibility__("default"))) queue;

template <class _Tp, class _Container>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator==(const queue<_Tp, _Container>& __x,const queue<_Tp, _Container>& __y);

template <class _Tp, class _Container>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator< (const queue<_Tp, _Container>& __x,const queue<_Tp, _Container>& __y);

template <class _Tp, class _Container >
class __attribute__ ((__type_visibility__("default"))) queue
{
public:
    typedef _Container container_type;
    typedef typename container_type::value_type value_type;
    typedef typename container_type::reference reference;
    typedef typename container_type::const_reference const_reference;
    typedef typename container_type::size_type size_type;
    static_assert((is_same<_Tp, value_type>::value), "" );

protected:
    container_type c;

public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    queue()
        noexcept(is_nothrow_default_constructible<container_type>::value)
        : c() {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    queue(const queue& __q) : c(__q.c) {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    queue& operator=(const queue& __q) {c = __q.c; return *this;}


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    queue(queue&& __q)
        noexcept(is_nothrow_move_constructible<container_type>::value)
        : c(std::__1::move(__q.c)) {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    queue& operator=(queue&& __q)
        noexcept(is_nothrow_move_assignable<container_type>::value)
        {c = std::__1::move(__q.c); return *this;}


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit queue(const container_type& __c) : c(__c) {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit queue(container_type&& __c) : c(std::__1::move(__c)) {}

    template <class _Alloc>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        explicit queue(const _Alloc& __a,
                       _EnableIf<uses_allocator<container_type, _Alloc>::value>* = 0)
            : c(__a) {}
    template <class _Alloc>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        queue(const queue& __q, const _Alloc& __a,
                       _EnableIf<uses_allocator<container_type, _Alloc>::value>* = 0)
            : c(__q.c, __a) {}
    template <class _Alloc>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        queue(const container_type& __c, const _Alloc& __a,
                       _EnableIf<uses_allocator<container_type, _Alloc>::value>* = 0)
            : c(__c, __a) {}

    template <class _Alloc>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        queue(container_type&& __c, const _Alloc& __a,
                       _EnableIf<uses_allocator<container_type, _Alloc>::value>* = 0)
            : c(std::__1::move(__c), __a) {}
    template <class _Alloc>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        queue(queue&& __q, const _Alloc& __a,
                       _EnableIf<uses_allocator<container_type, _Alloc>::value>* = 0)
            : c(std::__1::move(__q.c), __a) {}



                                  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    bool empty() const {return c.empty();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_type size() const {return c.size();}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    reference front() {return c.front();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_reference front() const {return c.front();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    reference back() {return c.back();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_reference back() const {return c.back();}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void push(const value_type& __v) {c.push_back(__v);}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void push(value_type&& __v) {c.push_back(std::__1::move(__v));}
    template <class... _Args>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))

        decltype(auto) emplace(_Args&&... __args)
            { return c.emplace_back(std::__1::forward<_Args>(__args)...);}





    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void pop() {c.pop_front();}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void swap(queue& __q)
        noexcept(__is_nothrow_swappable<container_type>::value)
    {
        using std::__1::swap;
        swap(c, __q.c);
    }

    template <class _T1, class _C1>
    friend
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    bool
    operator==(const queue<_T1, _C1>& __x,const queue<_T1, _C1>& __y);

    template <class _T1, class _C1>
    friend
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    bool
    operator< (const queue<_T1, _C1>& __x,const queue<_T1, _C1>& __y);
};


template<class _Container,
         class = _EnableIf<!__is_allocator<_Container>::value>
>
queue(_Container)
    -> queue<typename _Container::value_type, _Container>;

template<class _Container,
         class _Alloc,
         class = _EnableIf<!__is_allocator<_Container>::value>,
         class = _EnableIf<uses_allocator<_Container, _Alloc>::value>
>
queue(_Container, _Alloc)
    -> queue<typename _Container::value_type, _Container>;


template <class _Tp, class _Container>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator==(const queue<_Tp, _Container>& __x,const queue<_Tp, _Container>& __y)
{
    return __x.c == __y.c;
}

template <class _Tp, class _Container>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator< (const queue<_Tp, _Container>& __x,const queue<_Tp, _Container>& __y)
{
    return __x.c < __y.c;
}

template <class _Tp, class _Container>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator!=(const queue<_Tp, _Container>& __x,const queue<_Tp, _Container>& __y)
{
    return !(__x == __y);
}

template <class _Tp, class _Container>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator> (const queue<_Tp, _Container>& __x,const queue<_Tp, _Container>& __y)
{
    return __y < __x;
}

template <class _Tp, class _Container>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator>=(const queue<_Tp, _Container>& __x,const queue<_Tp, _Container>& __y)
{
    return !(__x < __y);
}

template <class _Tp, class _Container>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator<=(const queue<_Tp, _Container>& __x,const queue<_Tp, _Container>& __y)
{
    return !(__y < __x);
}

template <class _Tp, class _Container>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
_EnableIf<__is_swappable<_Container>::value, void>
swap(queue<_Tp, _Container>& __x, queue<_Tp, _Container>& __y)
    noexcept(noexcept(__x.swap(__y)))
{
    __x.swap(__y);
}

template <class _Tp, class _Container, class _Alloc>
struct __attribute__ ((__type_visibility__("default"))) uses_allocator<queue<_Tp, _Container>, _Alloc>
    : public uses_allocator<_Container, _Alloc>
{
};

template <class _Tp, class _Container = vector<_Tp>,
          class _Compare = less<typename _Container::value_type> >
class __attribute__ ((__type_visibility__("default"))) priority_queue
{
public:
    typedef _Container container_type;
    typedef _Compare value_compare;
    typedef typename container_type::value_type value_type;
    typedef typename container_type::reference reference;
    typedef typename container_type::const_reference const_reference;
    typedef typename container_type::size_type size_type;
    static_assert((is_same<_Tp, value_type>::value), "" );

protected:
    container_type c;
    value_compare comp;

public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    priority_queue()
        noexcept(is_nothrow_default_constructible<container_type>::value && is_nothrow_default_constructible<value_compare>::value)

        : c(), comp() {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    priority_queue(const priority_queue& __q) : c(__q.c), comp(__q.comp) {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    priority_queue& operator=(const priority_queue& __q)
        {c = __q.c; comp = __q.comp; return *this;}


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    priority_queue(priority_queue&& __q)
        noexcept(is_nothrow_move_constructible<container_type>::value && is_nothrow_move_constructible<value_compare>::value)

        : c(std::__1::move(__q.c)), comp(std::__1::move(__q.comp)) {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    priority_queue& operator=(priority_queue&& __q)
        noexcept(is_nothrow_move_assignable<container_type>::value && is_nothrow_move_assignable<value_compare>::value)

        {c = std::__1::move(__q.c); comp = std::__1::move(__q.comp); return *this;}


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit priority_queue(const value_compare& __comp)
        : c(), comp(__comp) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    priority_queue(const value_compare& __comp, const container_type& __c);

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    priority_queue(const value_compare& __comp, container_type&& __c);

    template <class _InputIter>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        priority_queue(_InputIter __f, _InputIter __l,
                       const value_compare& __comp = value_compare());
    template <class _InputIter>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        priority_queue(_InputIter __f, _InputIter __l,
                       const value_compare& __comp, const container_type& __c);

    template <class _InputIter>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        priority_queue(_InputIter __f, _InputIter __l,
                       const value_compare& __comp, container_type&& __c);

    template <class _Alloc>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        explicit priority_queue(const _Alloc& __a,
                       _EnableIf<uses_allocator<container_type, _Alloc>::value>* = 0);
    template <class _Alloc>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        priority_queue(const value_compare& __comp, const _Alloc& __a,
                       _EnableIf<uses_allocator<container_type, _Alloc>::value>* = 0);
    template <class _Alloc>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        priority_queue(const value_compare& __comp, const container_type& __c,
                       const _Alloc& __a,
                       _EnableIf<uses_allocator<container_type, _Alloc>::value>* = 0);
    template <class _Alloc>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        priority_queue(const priority_queue& __q, const _Alloc& __a,
                       _EnableIf<uses_allocator<container_type, _Alloc>::value>* = 0);

    template <class _Alloc>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        priority_queue(const value_compare& __comp, container_type&& __c,
                       const _Alloc& __a,
                       _EnableIf<uses_allocator<container_type, _Alloc>::value>* = 0);
    template <class _Alloc>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        priority_queue(priority_queue&& __q, const _Alloc& __a,
                       _EnableIf<uses_allocator<container_type, _Alloc>::value>* = 0);


                                  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    bool empty() const {return c.empty();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_type size() const {return c.size();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_reference top() const {return c.front();}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void push(const value_type& __v);

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void push(value_type&& __v);
    template <class... _Args>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void emplace(_Args&&... __args);

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void pop();

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void swap(priority_queue& __q)
        noexcept(__is_nothrow_swappable<container_type>::value && __is_nothrow_swappable<value_compare>::value);

};


template <class _Compare,
          class _Container,
          class = _EnableIf<!__is_allocator<_Compare>::value>,
          class = _EnableIf<!__is_allocator<_Container>::value>
>
priority_queue(_Compare, _Container)
    -> priority_queue<typename _Container::value_type, _Container, _Compare>;

template<class _InputIterator,
         class _Compare = less<__iter_value_type<_InputIterator>>,
         class _Container = vector<__iter_value_type<_InputIterator>>,
         class = _EnableIf<__is_cpp17_input_iterator<_InputIterator>::value>,
         class = _EnableIf<!__is_allocator<_Compare>::value>,
         class = _EnableIf<!__is_allocator<_Container>::value>
>
priority_queue(_InputIterator, _InputIterator, _Compare = _Compare(), _Container = _Container())
    -> priority_queue<__iter_value_type<_InputIterator>, _Container, _Compare>;

template<class _Compare,
         class _Container,
         class _Alloc,
         class = _EnableIf<!__is_allocator<_Compare>::value>,
         class = _EnableIf<!__is_allocator<_Container>::value>,
         class = _EnableIf<uses_allocator<_Container, _Alloc>::value>
>
priority_queue(_Compare, _Container, _Alloc)
    -> priority_queue<typename _Container::value_type, _Container, _Compare>;


template <class _Tp, class _Container, class _Compare>
inline
priority_queue<_Tp, _Container, _Compare>::priority_queue(const _Compare& __comp,
                                                          const container_type& __c)
    : c(__c),
      comp(__comp)
{
    std::__1::make_heap(c.begin(), c.end(), comp);
}



template <class _Tp, class _Container, class _Compare>
inline
priority_queue<_Tp, _Container, _Compare>::priority_queue(const value_compare& __comp,
                                                          container_type&& __c)
    : c(std::__1::move(__c)),
      comp(__comp)
{
    std::__1::make_heap(c.begin(), c.end(), comp);
}



template <class _Tp, class _Container, class _Compare>
template <class _InputIter>
inline
priority_queue<_Tp, _Container, _Compare>::priority_queue(_InputIter __f, _InputIter __l,
                                                          const value_compare& __comp)
    : c(__f, __l),
      comp(__comp)
{
    std::__1::make_heap(c.begin(), c.end(), comp);
}

template <class _Tp, class _Container, class _Compare>
template <class _InputIter>
inline
priority_queue<_Tp, _Container, _Compare>::priority_queue(_InputIter __f, _InputIter __l,
                                                          const value_compare& __comp,
                                                          const container_type& __c)
    : c(__c),
      comp(__comp)
{
    c.insert(c.end(), __f, __l);
    std::__1::make_heap(c.begin(), c.end(), comp);
}



template <class _Tp, class _Container, class _Compare>
template <class _InputIter>
inline
priority_queue<_Tp, _Container, _Compare>::priority_queue(_InputIter __f, _InputIter __l,
                                                          const value_compare& __comp,
                                                          container_type&& __c)
    : c(std::__1::move(__c)),
      comp(__comp)
{
    c.insert(c.end(), __f, __l);
    std::__1::make_heap(c.begin(), c.end(), comp);
}



template <class _Tp, class _Container, class _Compare>
template <class _Alloc>
inline
priority_queue<_Tp, _Container, _Compare>::priority_queue(const _Alloc& __a,
                       _EnableIf<uses_allocator<container_type, _Alloc>::value>*)
    : c(__a)
{
}

template <class _Tp, class _Container, class _Compare>
template <class _Alloc>
inline
priority_queue<_Tp, _Container, _Compare>::priority_queue(const value_compare& __comp,
                                                          const _Alloc& __a,
                       _EnableIf<uses_allocator<container_type, _Alloc>::value>*)
    : c(__a),
      comp(__comp)
{
}

template <class _Tp, class _Container, class _Compare>
template <class _Alloc>
inline
priority_queue<_Tp, _Container, _Compare>::priority_queue(const value_compare& __comp,
                                                          const container_type& __c,
                                                          const _Alloc& __a,
                       _EnableIf<uses_allocator<container_type, _Alloc>::value>*)
    : c(__c, __a),
      comp(__comp)
{
    std::__1::make_heap(c.begin(), c.end(), comp);
}

template <class _Tp, class _Container, class _Compare>
template <class _Alloc>
inline
priority_queue<_Tp, _Container, _Compare>::priority_queue(const priority_queue& __q,
                                                          const _Alloc& __a,
                       _EnableIf<uses_allocator<container_type, _Alloc>::value>*)
    : c(__q.c, __a),
      comp(__q.comp)
{
    std::__1::make_heap(c.begin(), c.end(), comp);
}



template <class _Tp, class _Container, class _Compare>
template <class _Alloc>
inline
priority_queue<_Tp, _Container, _Compare>::priority_queue(const value_compare& __comp,
                                                          container_type&& __c,
                                                          const _Alloc& __a,
                       _EnableIf<uses_allocator<container_type, _Alloc>::value>*)
    : c(std::__1::move(__c), __a),
      comp(__comp)
{
    std::__1::make_heap(c.begin(), c.end(), comp);
}

template <class _Tp, class _Container, class _Compare>
template <class _Alloc>
inline
priority_queue<_Tp, _Container, _Compare>::priority_queue(priority_queue&& __q,
                                                          const _Alloc& __a,
                       _EnableIf<uses_allocator<container_type, _Alloc>::value>*)
    : c(std::__1::move(__q.c), __a),
      comp(std::__1::move(__q.comp))
{
    std::__1::make_heap(c.begin(), c.end(), comp);
}



template <class _Tp, class _Container, class _Compare>
inline
void
priority_queue<_Tp, _Container, _Compare>::push(const value_type& __v)
{
    c.push_back(__v);
    std::__1::push_heap(c.begin(), c.end(), comp);
}



template <class _Tp, class _Container, class _Compare>
inline
void
priority_queue<_Tp, _Container, _Compare>::push(value_type&& __v)
{
    c.push_back(std::__1::move(__v));
    std::__1::push_heap(c.begin(), c.end(), comp);
}

template <class _Tp, class _Container, class _Compare>
template <class... _Args>
inline
void
priority_queue<_Tp, _Container, _Compare>::emplace(_Args&&... __args)
{
    c.emplace_back(std::__1::forward<_Args>(__args)...);
    std::__1::push_heap(c.begin(), c.end(), comp);
}



template <class _Tp, class _Container, class _Compare>
inline
void
priority_queue<_Tp, _Container, _Compare>::pop()
{
    std::__1::pop_heap(c.begin(), c.end(), comp);
    c.pop_back();
}

template <class _Tp, class _Container, class _Compare>
inline
void
priority_queue<_Tp, _Container, _Compare>::swap(priority_queue& __q)
        noexcept(__is_nothrow_swappable<container_type>::value && __is_nothrow_swappable<value_compare>::value)

{
    using std::__1::swap;
    swap(c, __q.c);
    swap(comp, __q.comp);
}

template <class _Tp, class _Container, class _Compare>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
_EnableIf<
    __is_swappable<_Container>::value && __is_swappable<_Compare>::value,
    void
>
swap(priority_queue<_Tp, _Container, _Compare>& __x,
     priority_queue<_Tp, _Container, _Compare>& __y)
    noexcept(noexcept(__x.swap(__y)))
{
    __x.swap(__y);
}

template <class _Tp, class _Container, class _Compare, class _Alloc>
struct __attribute__ ((__type_visibility__("default"))) uses_allocator<priority_queue<_Tp, _Container, _Compare>, _Alloc>
    : public uses_allocator<_Container, _Alloc>
{
};

} }
# 182 "/usr/local/include/bits/stdc++.h" 2


# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/set" 1 3
# 450 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/set" 3


namespace std { inline namespace __1 {

template <class _Key, class _Compare, class _Allocator>
class multiset;

template <class _Key, class _Compare = less<_Key>,
          class _Allocator = allocator<_Key> >
class __attribute__ ((__type_visibility__("default"))) set
{
public:

    typedef _Key key_type;
    typedef key_type value_type;
    typedef _Compare key_compare;
    typedef key_compare value_compare;
    typedef __identity_t<_Allocator> allocator_type;
    typedef value_type& reference;
    typedef const value_type& const_reference;

    static_assert((is_same<typename allocator_type::value_type, value_type>::value),
                  "Allocator::value_type must be same type as value_type");

private:
    typedef __tree<value_type, value_compare, allocator_type> __base;
    typedef allocator_traits<allocator_type> __alloc_traits;
    typedef typename __base::__node_holder __node_holder;

    __base __tree_;

public:
    typedef typename __base::pointer pointer;
    typedef typename __base::const_pointer const_pointer;
    typedef typename __base::size_type size_type;
    typedef typename __base::difference_type difference_type;
    typedef typename __base::const_iterator iterator;
    typedef typename __base::const_iterator const_iterator;
    typedef std::__1::reverse_iterator<iterator> reverse_iterator;
    typedef std::__1::reverse_iterator<const_iterator> const_reverse_iterator;


    typedef __set_node_handle<typename __base::__node, allocator_type> node_type;
    typedef __insert_return_type<iterator, node_type> insert_return_type;


    template <class _Key2, class _Compare2, class _Alloc2>
        friend class __attribute__ ((__type_visibility__("default"))) set;
    template <class _Key2, class _Compare2, class _Alloc2>
        friend class __attribute__ ((__type_visibility__("default"))) multiset;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    set()
        noexcept(is_nothrow_default_constructible<allocator_type>::value && is_nothrow_default_constructible<key_compare>::value && is_nothrow_copy_constructible<key_compare>::value)



        : __tree_(value_compare()) {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit set(const value_compare& __comp)
        noexcept(is_nothrow_default_constructible<allocator_type>::value && is_nothrow_copy_constructible<key_compare>::value)


        : __tree_(__comp) {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit set(const value_compare& __comp, const allocator_type& __a)
        : __tree_(__comp, __a) {}
    template <class _InputIterator>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        set(_InputIterator __f, _InputIterator __l,
            const value_compare& __comp = value_compare())
        : __tree_(__comp)
        {
            insert(__f, __l);
        }

    template <class _InputIterator>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        set(_InputIterator __f, _InputIterator __l, const value_compare& __comp,
            const allocator_type& __a)
        : __tree_(__comp, __a)
        {
            insert(__f, __l);
        }


        template <class _InputIterator>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        set(_InputIterator __f, _InputIterator __l, const allocator_type& __a)
            : set(__f, __l, key_compare(), __a) {}


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    set(const set& __s)
        : __tree_(__s.__tree_)
        {
            insert(__s.begin(), __s.end());
        }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    set& operator=(const set& __s)
        {
            __tree_ = __s.__tree_;
            return *this;
        }


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    set(set&& __s)
        noexcept(is_nothrow_move_constructible<__base>::value)
        : __tree_(std::__1::move(__s.__tree_)) {}


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit set(const allocator_type& __a)
        : __tree_(__a) {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    set(const set& __s, const allocator_type& __a)
        : __tree_(__s.__tree_.value_comp(), __a)
        {
            insert(__s.begin(), __s.end());
        }


    set(set&& __s, const allocator_type& __a);

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    set(initializer_list<value_type> __il, const value_compare& __comp = value_compare())
        : __tree_(__comp)
        {
            insert(__il.begin(), __il.end());
        }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    set(initializer_list<value_type> __il, const value_compare& __comp,
        const allocator_type& __a)
        : __tree_(__comp, __a)
        {
            insert(__il.begin(), __il.end());
        }


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    set(initializer_list<value_type> __il, const allocator_type& __a)
        : set(__il, key_compare(), __a) {}


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    set& operator=(initializer_list<value_type> __il)
        {
            __tree_.__assign_unique(__il.begin(), __il.end());
            return *this;
        }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    set& operator=(set&& __s)
        noexcept(is_nothrow_move_assignable<__base>::value)
        {
            __tree_ = std::__1::move(__s.__tree_);
            return *this;
        }


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    ~set() {
        static_assert(sizeof(__diagnose_non_const_comparator<_Key, _Compare>()), "");
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
          iterator begin() noexcept {return __tree_.begin();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_iterator begin() const noexcept {return __tree_.begin();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
          iterator end() noexcept {return __tree_.end();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_iterator end() const noexcept {return __tree_.end();}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
          reverse_iterator rbegin() noexcept
            {return reverse_iterator(end());}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_reverse_iterator rbegin() const noexcept
        {return const_reverse_iterator(end());}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
          reverse_iterator rend() noexcept
            {return reverse_iterator(begin());}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_reverse_iterator rend() const noexcept
        {return const_reverse_iterator(begin());}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_iterator cbegin() const noexcept {return begin();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_iterator cend() const noexcept {return end();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_reverse_iterator crbegin() const noexcept {return rbegin();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_reverse_iterator crend() const noexcept {return rend();}

                                  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    bool empty() const noexcept {return __tree_.size() == 0;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_type size() const noexcept {return __tree_.size();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_type max_size() const noexcept {return __tree_.max_size();}



    template <class... _Args>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        pair<iterator, bool> emplace(_Args&&... __args)
            {return __tree_.__emplace_unique(std::__1::forward<_Args>(__args)...);}
    template <class... _Args>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        iterator emplace_hint(const_iterator __p, _Args&&... __args)
            {return __tree_.__emplace_hint_unique(__p, std::__1::forward<_Args>(__args)...);}


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    pair<iterator,bool> insert(const value_type& __v)
        {return __tree_.__insert_unique(__v);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iterator insert(const_iterator __p, const value_type& __v)
        {return __tree_.__insert_unique(__p, __v);}

    template <class _InputIterator>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        void insert(_InputIterator __f, _InputIterator __l)
        {
            for (const_iterator __e = cend(); __f != __l; ++__f)
                __tree_.__insert_unique(__e, *__f);
        }


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    pair<iterator,bool> insert(value_type&& __v)
        {return __tree_.__insert_unique(std::__1::move(__v));}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iterator insert(const_iterator __p, value_type&& __v)
        {return __tree_.__insert_unique(__p, std::__1::move(__v));}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void insert(initializer_list<value_type> __il)
        {insert(__il.begin(), __il.end());}


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iterator erase(const_iterator __p) {return __tree_.erase(__p);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_type erase(const key_type& __k)
        {return __tree_.__erase_unique(__k);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iterator erase(const_iterator __f, const_iterator __l)
        {return __tree_.erase(__f, __l);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void clear() noexcept {__tree_.clear();}


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    insert_return_type insert(node_type&& __nh)
    {
        ((void)0);

        return __tree_.template __node_handle_insert_unique<
            node_type, insert_return_type>(std::__1::move(__nh));
    }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iterator insert(const_iterator __hint, node_type&& __nh)
    {
        ((void)0);

        return __tree_.template __node_handle_insert_unique<node_type>(
            __hint, std::__1::move(__nh));
    }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    node_type extract(key_type const& __key)
    {
        return __tree_.template __node_handle_extract<node_type>(__key);
    }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    node_type extract(const_iterator __it)
    {
        return __tree_.template __node_handle_extract<node_type>(__it);
    }
    template <class _Compare2>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void merge(set<key_type, _Compare2, allocator_type>& __source)
    {
        ((void)0);

        __tree_.__node_handle_merge_unique(__source.__tree_);
    }
    template <class _Compare2>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void merge(set<key_type, _Compare2, allocator_type>&& __source)
    {
        ((void)0);

        __tree_.__node_handle_merge_unique(__source.__tree_);
    }
    template <class _Compare2>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void merge(multiset<key_type, _Compare2, allocator_type>& __source)
    {
        ((void)0);

        __tree_.__node_handle_merge_unique(__source.__tree_);
    }
    template <class _Compare2>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void merge(multiset<key_type, _Compare2, allocator_type>&& __source)
    {
        ((void)0);

        __tree_.__node_handle_merge_unique(__source.__tree_);
    }


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void swap(set& __s) noexcept(__is_nothrow_swappable<__base>::value)
        {__tree_.swap(__s.__tree_);}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    allocator_type get_allocator() const noexcept {return __tree_.__alloc();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    key_compare key_comp() const {return __tree_.value_comp();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    value_compare value_comp() const {return __tree_.value_comp();}


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iterator find(const key_type& __k) {return __tree_.find(__k);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_iterator find(const key_type& __k) const {return __tree_.find(__k);}

    template <typename _K2>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    typename enable_if<__is_transparent<_Compare, _K2>::value,iterator>::type
    find(const _K2& __k) {return __tree_.find(__k);}
    template <typename _K2>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    typename enable_if<__is_transparent<_Compare, _K2>::value,const_iterator>::type
    find(const _K2& __k) const {return __tree_.find(__k);}


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_type count(const key_type& __k) const
        {return __tree_.__count_unique(__k);}

    template <typename _K2>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    typename enable_if<__is_transparent<_Compare, _K2>::value,size_type>::type
    count(const _K2& __k) const {return __tree_.__count_multi(__k);}
# 818 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/set" 3
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iterator lower_bound(const key_type& __k)
        {return __tree_.lower_bound(__k);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_iterator lower_bound(const key_type& __k) const
        {return __tree_.lower_bound(__k);}

    template <typename _K2>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    typename enable_if<__is_transparent<_Compare, _K2>::value,iterator>::type
    lower_bound(const _K2& __k) {return __tree_.lower_bound(__k);}

    template <typename _K2>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    typename enable_if<__is_transparent<_Compare, _K2>::value,const_iterator>::type
    lower_bound(const _K2& __k) const {return __tree_.lower_bound(__k);}


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iterator upper_bound(const key_type& __k)
        {return __tree_.upper_bound(__k);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_iterator upper_bound(const key_type& __k) const
        {return __tree_.upper_bound(__k);}

    template <typename _K2>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    typename enable_if<__is_transparent<_Compare, _K2>::value,iterator>::type
    upper_bound(const _K2& __k) {return __tree_.upper_bound(__k);}
    template <typename _K2>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    typename enable_if<__is_transparent<_Compare, _K2>::value,const_iterator>::type
    upper_bound(const _K2& __k) const {return __tree_.upper_bound(__k);}


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    pair<iterator,iterator> equal_range(const key_type& __k)
        {return __tree_.__equal_range_unique(__k);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    pair<const_iterator,const_iterator> equal_range(const key_type& __k) const
        {return __tree_.__equal_range_unique(__k);}

    template <typename _K2>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    typename enable_if<__is_transparent<_Compare, _K2>::value,pair<iterator,iterator>>::type
    equal_range(const _K2& __k) {return __tree_.__equal_range_multi(__k);}
    template <typename _K2>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    typename enable_if<__is_transparent<_Compare, _K2>::value,pair<const_iterator,const_iterator>>::type
    equal_range(const _K2& __k) const {return __tree_.__equal_range_multi(__k);}

};


template<class _InputIterator,
         class _Compare = less<__iter_value_type<_InputIterator>>,
         class _Allocator = allocator<__iter_value_type<_InputIterator>>,
         class = _EnableIf<__is_allocator<_Allocator>::value, void>,
         class = _EnableIf<!__is_allocator<_Compare>::value, void>>
set(_InputIterator, _InputIterator, _Compare = _Compare(), _Allocator = _Allocator())
  -> set<__iter_value_type<_InputIterator>, _Compare, _Allocator>;

template<class _Key, class _Compare = less<_Key>,
         class _Allocator = allocator<_Key>,
         class = _EnableIf<__is_allocator<_Allocator>::value, void>,
         class = _EnableIf<!__is_allocator<_Compare>::value, void>>
set(initializer_list<_Key>, _Compare = _Compare(), _Allocator = _Allocator())
  -> set<_Key, _Compare, _Allocator>;

template<class _InputIterator, class _Allocator,
         class = _EnableIf<__is_allocator<_Allocator>::value, void>>
set(_InputIterator, _InputIterator, _Allocator)
  -> set<__iter_value_type<_InputIterator>,
         less<__iter_value_type<_InputIterator>>, _Allocator>;

template<class _Key, class _Allocator,
         class = _EnableIf<__is_allocator<_Allocator>::value, void>>
set(initializer_list<_Key>, _Allocator)
  -> set<_Key, less<_Key>, _Allocator>;




template <class _Key, class _Compare, class _Allocator>
set<_Key, _Compare, _Allocator>::set(set&& __s, const allocator_type& __a)
    : __tree_(std::__1::move(__s.__tree_), __a)
{
    if (__a != __s.get_allocator())
    {
        const_iterator __e = cend();
        while (!__s.empty())
            insert(__e, std::__1::move(__s.__tree_.remove(__s.begin())->__value_));
    }
}



template <class _Key, class _Compare, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator==(const set<_Key, _Compare, _Allocator>& __x,
           const set<_Key, _Compare, _Allocator>& __y)
{
    return __x.size() == __y.size() && std::__1::equal(__x.begin(), __x.end(), __y.begin());
}

template <class _Key, class _Compare, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator< (const set<_Key, _Compare, _Allocator>& __x,
           const set<_Key, _Compare, _Allocator>& __y)
{
    return std::__1::lexicographical_compare(__x.begin(), __x.end(), __y.begin(), __y.end());
}

template <class _Key, class _Compare, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator!=(const set<_Key, _Compare, _Allocator>& __x,
           const set<_Key, _Compare, _Allocator>& __y)
{
    return !(__x == __y);
}

template <class _Key, class _Compare, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator> (const set<_Key, _Compare, _Allocator>& __x,
           const set<_Key, _Compare, _Allocator>& __y)
{
    return __y < __x;
}

template <class _Key, class _Compare, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator>=(const set<_Key, _Compare, _Allocator>& __x,
           const set<_Key, _Compare, _Allocator>& __y)
{
    return !(__x < __y);
}

template <class _Key, class _Compare, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator<=(const set<_Key, _Compare, _Allocator>& __x,
           const set<_Key, _Compare, _Allocator>& __y)
{
    return !(__y < __x);
}


template <class _Key, class _Compare, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void
swap(set<_Key, _Compare, _Allocator>& __x,
     set<_Key, _Compare, _Allocator>& __y)
    noexcept(noexcept(__x.swap(__y)))
{
    __x.swap(__y);
}
# 989 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/set" 3
template <class _Key, class _Compare = less<_Key>,
          class _Allocator = allocator<_Key> >
class __attribute__ ((__type_visibility__("default"))) multiset
{
public:

    typedef _Key key_type;
    typedef key_type value_type;
    typedef _Compare key_compare;
    typedef key_compare value_compare;
    typedef __identity_t<_Allocator> allocator_type;
    typedef value_type& reference;
    typedef const value_type& const_reference;

    static_assert((is_same<typename allocator_type::value_type, value_type>::value),
                  "Allocator::value_type must be same type as value_type");

private:
    typedef __tree<value_type, value_compare, allocator_type> __base;
    typedef allocator_traits<allocator_type> __alloc_traits;
    typedef typename __base::__node_holder __node_holder;

    __base __tree_;

public:
    typedef typename __base::pointer pointer;
    typedef typename __base::const_pointer const_pointer;
    typedef typename __base::size_type size_type;
    typedef typename __base::difference_type difference_type;
    typedef typename __base::const_iterator iterator;
    typedef typename __base::const_iterator const_iterator;
    typedef std::__1::reverse_iterator<iterator> reverse_iterator;
    typedef std::__1::reverse_iterator<const_iterator> const_reverse_iterator;


    typedef __set_node_handle<typename __base::__node, allocator_type> node_type;


    template <class _Key2, class _Compare2, class _Alloc2>
        friend class __attribute__ ((__type_visibility__("default"))) set;
    template <class _Key2, class _Compare2, class _Alloc2>
        friend class __attribute__ ((__type_visibility__("default"))) multiset;


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    multiset()
        noexcept(is_nothrow_default_constructible<allocator_type>::value && is_nothrow_default_constructible<key_compare>::value && is_nothrow_copy_constructible<key_compare>::value)



        : __tree_(value_compare()) {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit multiset(const value_compare& __comp)
        noexcept(is_nothrow_default_constructible<allocator_type>::value && is_nothrow_copy_constructible<key_compare>::value)


        : __tree_(__comp) {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit multiset(const value_compare& __comp, const allocator_type& __a)
        : __tree_(__comp, __a) {}
    template <class _InputIterator>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        multiset(_InputIterator __f, _InputIterator __l,
                 const value_compare& __comp = value_compare())
        : __tree_(__comp)
        {
            insert(__f, __l);
        }


        template <class _InputIterator>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        multiset(_InputIterator __f, _InputIterator __l, const allocator_type& __a)
            : multiset(__f, __l, key_compare(), __a) {}


    template <class _InputIterator>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        multiset(_InputIterator __f, _InputIterator __l,
                 const value_compare& __comp, const allocator_type& __a)
        : __tree_(__comp, __a)
        {
            insert(__f, __l);
        }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    multiset(const multiset& __s)
        : __tree_(__s.__tree_.value_comp(),
          __alloc_traits::select_on_container_copy_construction(__s.__tree_.__alloc()))
        {
            insert(__s.begin(), __s.end());
        }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    multiset& operator=(const multiset& __s)
        {
            __tree_ = __s.__tree_;
            return *this;
        }


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    multiset(multiset&& __s)
        noexcept(is_nothrow_move_constructible<__base>::value)
        : __tree_(std::__1::move(__s.__tree_)) {}

    multiset(multiset&& __s, const allocator_type& __a);

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit multiset(const allocator_type& __a)
        : __tree_(__a) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    multiset(const multiset& __s, const allocator_type& __a)
        : __tree_(__s.__tree_.value_comp(), __a)
        {
            insert(__s.begin(), __s.end());
        }


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    multiset(initializer_list<value_type> __il, const value_compare& __comp = value_compare())
        : __tree_(__comp)
        {
            insert(__il.begin(), __il.end());
        }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    multiset(initializer_list<value_type> __il, const value_compare& __comp,
        const allocator_type& __a)
        : __tree_(__comp, __a)
        {
            insert(__il.begin(), __il.end());
        }


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    multiset(initializer_list<value_type> __il, const allocator_type& __a)
        : multiset(__il, key_compare(), __a) {}


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    multiset& operator=(initializer_list<value_type> __il)
        {
            __tree_.__assign_multi(__il.begin(), __il.end());
            return *this;
        }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    multiset& operator=(multiset&& __s)
        noexcept(is_nothrow_move_assignable<__base>::value)
        {
            __tree_ = std::__1::move(__s.__tree_);
            return *this;
        }


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    ~multiset() {
        static_assert(sizeof(__diagnose_non_const_comparator<_Key, _Compare>()), "");
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
          iterator begin() noexcept {return __tree_.begin();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_iterator begin() const noexcept {return __tree_.begin();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
          iterator end() noexcept {return __tree_.end();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_iterator end() const noexcept {return __tree_.end();}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
          reverse_iterator rbegin() noexcept
            {return reverse_iterator(end());}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_reverse_iterator rbegin() const noexcept
        {return const_reverse_iterator(end());}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
          reverse_iterator rend() noexcept
            {return reverse_iterator(begin());}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_reverse_iterator rend() const noexcept
        {return const_reverse_iterator(begin());}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_iterator cbegin() const noexcept {return begin();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_iterator cend() const noexcept {return end();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_reverse_iterator crbegin() const noexcept {return rbegin();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_reverse_iterator crend() const noexcept {return rend();}

                                  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    bool empty() const noexcept {return __tree_.size() == 0;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_type size() const noexcept {return __tree_.size();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_type max_size() const noexcept {return __tree_.max_size();}



    template <class... _Args>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        iterator emplace(_Args&&... __args)
            {return __tree_.__emplace_multi(std::__1::forward<_Args>(__args)...);}
    template <class... _Args>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        iterator emplace_hint(const_iterator __p, _Args&&... __args)
            {return __tree_.__emplace_hint_multi(__p, std::__1::forward<_Args>(__args)...);}


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iterator insert(const value_type& __v)
        {return __tree_.__insert_multi(__v);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iterator insert(const_iterator __p, const value_type& __v)
        {return __tree_.__insert_multi(__p, __v);}

    template <class _InputIterator>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        void insert(_InputIterator __f, _InputIterator __l)
        {
            for (const_iterator __e = cend(); __f != __l; ++__f)
                __tree_.__insert_multi(__e, *__f);
        }


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iterator insert(value_type&& __v)
        {return __tree_.__insert_multi(std::__1::move(__v));}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iterator insert(const_iterator __p, value_type&& __v)
        {return __tree_.__insert_multi(__p, std::__1::move(__v));}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void insert(initializer_list<value_type> __il)
        {insert(__il.begin(), __il.end());}


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iterator erase(const_iterator __p) {return __tree_.erase(__p);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_type erase(const key_type& __k) {return __tree_.__erase_multi(__k);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iterator erase(const_iterator __f, const_iterator __l)
        {return __tree_.erase(__f, __l);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void clear() noexcept {__tree_.clear();}


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iterator insert(node_type&& __nh)
    {
        ((void)0);

        return __tree_.template __node_handle_insert_multi<node_type>(
            std::__1::move(__nh));
    }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iterator insert(const_iterator __hint, node_type&& __nh)
    {
        ((void)0);

        return __tree_.template __node_handle_insert_multi<node_type>(
            __hint, std::__1::move(__nh));
    }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    node_type extract(key_type const& __key)
    {
        return __tree_.template __node_handle_extract<node_type>(__key);
    }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    node_type extract(const_iterator __it)
    {
        return __tree_.template __node_handle_extract<node_type>(__it);
    }
    template <class _Compare2>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void merge(multiset<key_type, _Compare2, allocator_type>& __source)
    {
        ((void)0);

        __tree_.__node_handle_merge_multi(__source.__tree_);
    }
    template <class _Compare2>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void merge(multiset<key_type, _Compare2, allocator_type>&& __source)
    {
        ((void)0);

        __tree_.__node_handle_merge_multi(__source.__tree_);
    }
    template <class _Compare2>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void merge(set<key_type, _Compare2, allocator_type>& __source)
    {
        ((void)0);

        __tree_.__node_handle_merge_multi(__source.__tree_);
    }
    template <class _Compare2>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void merge(set<key_type, _Compare2, allocator_type>&& __source)
    {
        ((void)0);

        __tree_.__node_handle_merge_multi(__source.__tree_);
    }


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void swap(multiset& __s)
        noexcept(__is_nothrow_swappable<__base>::value)
        {__tree_.swap(__s.__tree_);}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    allocator_type get_allocator() const noexcept {return __tree_.__alloc();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    key_compare key_comp() const {return __tree_.value_comp();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    value_compare value_comp() const {return __tree_.value_comp();}


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iterator find(const key_type& __k) {return __tree_.find(__k);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_iterator find(const key_type& __k) const {return __tree_.find(__k);}

    template <typename _K2>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    typename enable_if<__is_transparent<_Compare, _K2>::value,iterator>::type
    find(const _K2& __k) {return __tree_.find(__k);}
    template <typename _K2>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    typename enable_if<__is_transparent<_Compare, _K2>::value,const_iterator>::type
    find(const _K2& __k) const {return __tree_.find(__k);}


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_type count(const key_type& __k) const
        {return __tree_.__count_multi(__k);}

    template <typename _K2>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    typename enable_if<__is_transparent<_Compare, _K2>::value,size_type>::type
    count(const _K2& __k) const {return __tree_.__count_multi(__k);}
# 1349 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/set" 3
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iterator lower_bound(const key_type& __k)
        {return __tree_.lower_bound(__k);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_iterator lower_bound(const key_type& __k) const
            {return __tree_.lower_bound(__k);}

    template <typename _K2>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    typename enable_if<__is_transparent<_Compare, _K2>::value,iterator>::type
    lower_bound(const _K2& __k) {return __tree_.lower_bound(__k);}

    template <typename _K2>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    typename enable_if<__is_transparent<_Compare, _K2>::value,const_iterator>::type
    lower_bound(const _K2& __k) const {return __tree_.lower_bound(__k);}


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iterator upper_bound(const key_type& __k)
            {return __tree_.upper_bound(__k);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_iterator upper_bound(const key_type& __k) const
            {return __tree_.upper_bound(__k);}

    template <typename _K2>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    typename enable_if<__is_transparent<_Compare, _K2>::value,iterator>::type
    upper_bound(const _K2& __k) {return __tree_.upper_bound(__k);}
    template <typename _K2>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    typename enable_if<__is_transparent<_Compare, _K2>::value,const_iterator>::type
    upper_bound(const _K2& __k) const {return __tree_.upper_bound(__k);}


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    pair<iterator,iterator> equal_range(const key_type& __k)
            {return __tree_.__equal_range_multi(__k);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    pair<const_iterator,const_iterator> equal_range(const key_type& __k) const
            {return __tree_.__equal_range_multi(__k);}

    template <typename _K2>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    typename enable_if<__is_transparent<_Compare, _K2>::value,pair<iterator,iterator>>::type
    equal_range(const _K2& __k) {return __tree_.__equal_range_multi(__k);}
    template <typename _K2>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    typename enable_if<__is_transparent<_Compare, _K2>::value,pair<const_iterator,const_iterator>>::type
    equal_range(const _K2& __k) const {return __tree_.__equal_range_multi(__k);}

};


template<class _InputIterator,
         class _Compare = less<__iter_value_type<_InputIterator>>,
         class _Allocator = allocator<__iter_value_type<_InputIterator>>,
         class = _EnableIf<__is_allocator<_Allocator>::value, void>,
         class = _EnableIf<!__is_allocator<_Compare>::value, void>>
multiset(_InputIterator, _InputIterator, _Compare = _Compare(), _Allocator = _Allocator())
  -> multiset<__iter_value_type<_InputIterator>, _Compare, _Allocator>;

template<class _Key, class _Compare = less<_Key>,
         class _Allocator = allocator<_Key>,
         class = _EnableIf<__is_allocator<_Allocator>::value, void>,
         class = _EnableIf<!__is_allocator<_Compare>::value, void>>
multiset(initializer_list<_Key>, _Compare = _Compare(), _Allocator = _Allocator())
  -> multiset<_Key, _Compare, _Allocator>;

template<class _InputIterator, class _Allocator,
         class = _EnableIf<__is_allocator<_Allocator>::value, void>>
multiset(_InputIterator, _InputIterator, _Allocator)
  -> multiset<__iter_value_type<_InputIterator>,
         less<__iter_value_type<_InputIterator>>, _Allocator>;

template<class _Key, class _Allocator,
         class = _EnableIf<__is_allocator<_Allocator>::value, void>>
multiset(initializer_list<_Key>, _Allocator)
  -> multiset<_Key, less<_Key>, _Allocator>;




template <class _Key, class _Compare, class _Allocator>
multiset<_Key, _Compare, _Allocator>::multiset(multiset&& __s, const allocator_type& __a)
    : __tree_(std::__1::move(__s.__tree_), __a)
{
    if (__a != __s.get_allocator())
    {
        const_iterator __e = cend();
        while (!__s.empty())
            insert(__e, std::__1::move(__s.__tree_.remove(__s.begin())->__value_));
    }
}



template <class _Key, class _Compare, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator==(const multiset<_Key, _Compare, _Allocator>& __x,
           const multiset<_Key, _Compare, _Allocator>& __y)
{
    return __x.size() == __y.size() && std::__1::equal(__x.begin(), __x.end(), __y.begin());
}

template <class _Key, class _Compare, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator< (const multiset<_Key, _Compare, _Allocator>& __x,
           const multiset<_Key, _Compare, _Allocator>& __y)
{
    return std::__1::lexicographical_compare(__x.begin(), __x.end(), __y.begin(), __y.end());
}

template <class _Key, class _Compare, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator!=(const multiset<_Key, _Compare, _Allocator>& __x,
           const multiset<_Key, _Compare, _Allocator>& __y)
{
    return !(__x == __y);
}

template <class _Key, class _Compare, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator> (const multiset<_Key, _Compare, _Allocator>& __x,
           const multiset<_Key, _Compare, _Allocator>& __y)
{
    return __y < __x;
}

template <class _Key, class _Compare, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator>=(const multiset<_Key, _Compare, _Allocator>& __x,
           const multiset<_Key, _Compare, _Allocator>& __y)
{
    return !(__x < __y);
}

template <class _Key, class _Compare, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator<=(const multiset<_Key, _Compare, _Allocator>& __x,
           const multiset<_Key, _Compare, _Allocator>& __y)
{
    return !(__y < __x);
}

template <class _Key, class _Compare, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void
swap(multiset<_Key, _Compare, _Allocator>& __x,
     multiset<_Key, _Compare, _Allocator>& __y)
    noexcept(noexcept(__x.swap(__y)))
{
    __x.swap(__y);
}
# 1519 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/set" 3
} }
# 185 "/usr/local/include/bits/stdc++.h" 2
# 208 "/usr/local/include/bits/stdc++.h"
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/valarray" 1 3
# 352 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/valarray" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 356 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/valarray" 2 3

namespace std { inline namespace __1 {

template<class _Tp> class __attribute__ ((__type_visibility__("default"))) valarray;

class __attribute__ ((__type_visibility__("default"))) slice
{
    size_t __start_;
    size_t __size_;
    size_t __stride_;
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    slice()
        : __start_(0),
          __size_(0),
          __stride_(0)
          {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    slice(size_t __start, size_t __size, size_t __stride)
        : __start_(__start),
          __size_(__size),
          __stride_(__stride)
          {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) size_t start() const {return __start_;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) size_t size() const {return __size_;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) size_t stride() const {return __stride_;}
};

template <class _Tp> class __attribute__ ((__type_visibility__("default"))) slice_array;
class __attribute__ ((__visibility__("default"))) gslice;
template <class _Tp> class __attribute__ ((__type_visibility__("default"))) gslice_array;
template <class _Tp> class __attribute__ ((__type_visibility__("default"))) mask_array;
template <class _Tp> class __attribute__ ((__type_visibility__("default"))) indirect_array;

template <class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
_Tp*
begin(valarray<_Tp>& __v);

template <class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
const _Tp*
begin(const valarray<_Tp>& __v);

template <class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
_Tp*
end(valarray<_Tp>& __v);

template <class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
const _Tp*
end(const valarray<_Tp>& __v);

template <class _Op, class _A0>
struct _UnaryOp
{
    typedef typename _Op::__result_type __result_type;
    typedef typename decay<__result_type>::type value_type;

    _Op __op_;
    _A0 __a0_;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    _UnaryOp(const _Op& __op, const _A0& __a0) : __op_(__op), __a0_(__a0) {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __result_type operator[](size_t __i) const {return __op_(__a0_[__i]);}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_t size() const {return __a0_.size();}
};

template <class _Op, class _A0, class _A1>
struct _BinaryOp
{
    typedef typename _Op::__result_type __result_type;
    typedef typename decay<__result_type>::type value_type;

    _Op __op_;
    _A0 __a0_;
    _A1 __a1_;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    _BinaryOp(const _Op& __op, const _A0& __a0, const _A1& __a1)
        : __op_(__op), __a0_(__a0), __a1_(__a1) {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __result_type operator[](size_t __i) const {return __op_(__a0_[__i], __a1_[__i]);}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_t size() const {return __a0_.size();}
};

template <class _Tp>
class __scalar_expr
{
public:
    typedef _Tp value_type;
    typedef const _Tp& __result_type;
private:
    const value_type& __t_;
    size_t __s_;
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit __scalar_expr(const value_type& __t, size_t __s) : __t_(__t), __s_(__s) {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __result_type operator[](size_t) const {return __t_;}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_t size() const {return __s_;}
};

template <class _Tp>
struct __unary_plus
{
    typedef _Tp __result_type;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    _Tp operator()(const _Tp& __x) const
        {return +__x;}
};

template <class _Tp>
struct __bit_not
{
    typedef _Tp __result_type;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    _Tp operator()(const _Tp& __x) const
        {return ~__x;}
};

template <class _Tp>
struct __bit_shift_left
{
    typedef _Tp __result_type;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    _Tp operator()(const _Tp& __x, const _Tp& __y) const
        {return __x << __y;}
};

template <class _Tp>
struct __bit_shift_right
{
    typedef _Tp __result_type;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    _Tp operator()(const _Tp& __x, const _Tp& __y) const
        {return __x >> __y;}
};

template <class _Tp, class _Fp>
struct __apply_expr
{
private:
    _Fp __f_;
public:
    typedef _Tp __result_type;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit __apply_expr(_Fp __f) : __f_(__f) {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    _Tp operator()(const _Tp& __x) const
        {return __f_(__x);}
};

template <class _Tp>
struct __abs_expr
{
    typedef _Tp __result_type;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    _Tp operator()(const _Tp& __x) const
        {return abs(__x);}
};

template <class _Tp>
struct __acos_expr
{
    typedef _Tp __result_type;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    _Tp operator()(const _Tp& __x) const
        {return acos(__x);}
};

template <class _Tp>
struct __asin_expr
{
    typedef _Tp __result_type;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    _Tp operator()(const _Tp& __x) const
        {return asin(__x);}
};

template <class _Tp>
struct __atan_expr
{
    typedef _Tp __result_type;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    _Tp operator()(const _Tp& __x) const
        {return atan(__x);}
};

template <class _Tp>
struct __atan2_expr
{
    typedef _Tp __result_type;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    _Tp operator()(const _Tp& __x, const _Tp& __y) const
        {return atan2(__x, __y);}
};

template <class _Tp>
struct __cos_expr
{
    typedef _Tp __result_type;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    _Tp operator()(const _Tp& __x) const
        {return cos(__x);}
};

template <class _Tp>
struct __cosh_expr
{
    typedef _Tp __result_type;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    _Tp operator()(const _Tp& __x) const
        {return cosh(__x);}
};

template <class _Tp>
struct __exp_expr
{
    typedef _Tp __result_type;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    _Tp operator()(const _Tp& __x) const
        {return exp(__x);}
};

template <class _Tp>
struct __log_expr
{
    typedef _Tp __result_type;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    _Tp operator()(const _Tp& __x) const
        {return log(__x);}
};

template <class _Tp>
struct __log10_expr
{
    typedef _Tp __result_type;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    _Tp operator()(const _Tp& __x) const
        {return log10(__x);}
};

template <class _Tp>
struct __pow_expr
{
    typedef _Tp __result_type;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    _Tp operator()(const _Tp& __x, const _Tp& __y) const
        {return pow(__x, __y);}
};

template <class _Tp>
struct __sin_expr
{
    typedef _Tp __result_type;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    _Tp operator()(const _Tp& __x) const
        {return sin(__x);}
};

template <class _Tp>
struct __sinh_expr
{
    typedef _Tp __result_type;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    _Tp operator()(const _Tp& __x) const
        {return sinh(__x);}
};

template <class _Tp>
struct __sqrt_expr
{
    typedef _Tp __result_type;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    _Tp operator()(const _Tp& __x) const
        {return sqrt(__x);}
};

template <class _Tp>
struct __tan_expr
{
    typedef _Tp __result_type;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    _Tp operator()(const _Tp& __x) const
        {return tan(__x);}
};

template <class _Tp>
struct __tanh_expr
{
    typedef _Tp __result_type;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    _Tp operator()(const _Tp& __x) const
        {return tanh(__x);}
};

template <class _ValExpr>
class __slice_expr
{
    typedef typename remove_reference<_ValExpr>::type _RmExpr;
public:
    typedef typename _RmExpr::value_type value_type;
    typedef value_type __result_type;

private:
    _ValExpr __expr_;
    size_t __start_;
    size_t __size_;
    size_t __stride_;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __slice_expr(const slice& __sl, const _RmExpr& __e)
        : __expr_(__e),
          __start_(__sl.start()),
          __size_(__sl.size()),
          __stride_(__sl.stride())
        {}
public:

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __result_type operator[](size_t __i) const
        {return __expr_[__start_ + __i * __stride_];}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_t size() const {return __size_;}

    template <class> friend class __val_expr;
    template <class> friend class __attribute__ ((__type_visibility__("default"))) valarray;
};

template <class _ValExpr>
class __mask_expr;

template <class _ValExpr>
class __indirect_expr;

template <class _ValExpr>
class __shift_expr
{
    typedef typename remove_reference<_ValExpr>::type _RmExpr;
public:
    typedef typename _RmExpr::value_type value_type;
    typedef value_type __result_type;

private:
    _ValExpr __expr_;
    size_t __size_;
    ptrdiff_t __ul_;
    ptrdiff_t __sn_;
    ptrdiff_t __n_;
    static const ptrdiff_t _Np = static_cast<ptrdiff_t>(
                                    sizeof(ptrdiff_t) * 8 - 1);

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __shift_expr(int __n, const _RmExpr& __e)
        : __expr_(__e),
          __size_(__e.size()),
          __n_(__n)
        {
            ptrdiff_t __neg_n = static_cast<ptrdiff_t>(__n_ >> _Np);
            __sn_ = __neg_n | static_cast<ptrdiff_t>(static_cast<size_t>(-__n_) >> _Np);
            __ul_ = ((__size_ - __n_) & ~__neg_n) | ((__n_ + 1) & __neg_n);
        }
public:

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __result_type operator[](size_t __j) const
        {
            ptrdiff_t __i = static_cast<ptrdiff_t>(__j);
            ptrdiff_t __m = (__sn_ * __i - __ul_) >> _Np;
            return (__expr_[(__i + __n_) & __m] & __m) | (value_type() & ~__m);
        }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_t size() const {return __size_;}

    template <class> friend class __val_expr;
};

template <class _ValExpr>
class __cshift_expr
{
    typedef typename remove_reference<_ValExpr>::type _RmExpr;
public:
    typedef typename _RmExpr::value_type value_type;
    typedef value_type __result_type;

private:
    _ValExpr __expr_;
    size_t __size_;
    size_t __m_;
    size_t __o1_;
    size_t __o2_;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __cshift_expr(int __n, const _RmExpr& __e)
        : __expr_(__e),
          __size_(__e.size())
        {
            __n %= static_cast<int>(__size_);
            if (__n >= 0)
            {
                __m_ = __size_ - __n;
                __o1_ = __n;
                __o2_ = __n - __size_;
            }
            else
            {
                __m_ = -__n;
                __o1_ = __n + __size_;
                __o2_ = __n;
            }
        }
public:

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __result_type operator[](size_t __i) const
        {
            if (__i < __m_)
                return __expr_[__i + __o1_];
            return __expr_[__i + __o2_];
        }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_t size() const {return __size_;}

    template <class> friend class __val_expr;
};

template<class _ValExpr>
class __val_expr;

template<class _ValExpr>
struct __is_val_expr : false_type {};

template<class _ValExpr>
struct __is_val_expr<__val_expr<_ValExpr> > : true_type {};

template<class _Tp>
struct __is_val_expr<valarray<_Tp> > : true_type {};

template<class _Tp>
class __attribute__ ((__type_visibility__("default"))) valarray
{
public:
    typedef _Tp value_type;
    typedef _Tp __result_type;

private:
    value_type* __begin_;
    value_type* __end_;

public:

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    valarray() : __begin_(nullptr), __end_(nullptr) {}
    inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit valarray(size_t __n);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    valarray(const value_type& __x, size_t __n);
    valarray(const value_type* __p, size_t __n);
    valarray(const valarray& __v);

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    valarray(valarray&& __v) noexcept;
    valarray(initializer_list<value_type> __il);

    valarray(const slice_array<value_type>& __sa);
    valarray(const gslice_array<value_type>& __ga);
    valarray(const mask_array<value_type>& __ma);
    valarray(const indirect_array<value_type>& __ia);
    inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    ~valarray();


    valarray& operator=(const valarray& __v);

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    valarray& operator=(valarray&& __v) noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    valarray& operator=(initializer_list<value_type>);

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    valarray& operator=(const value_type& __x);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    valarray& operator=(const slice_array<value_type>& __sa);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    valarray& operator=(const gslice_array<value_type>& __ga);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    valarray& operator=(const mask_array<value_type>& __ma);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    valarray& operator=(const indirect_array<value_type>& __ia);
    template <class _ValExpr>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        valarray& operator=(const __val_expr<_ValExpr>& __v);


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const value_type& operator[](size_t __i) const {return __begin_[__i];}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    value_type& operator[](size_t __i) {return __begin_[__i];}


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __val_expr<__slice_expr<const valarray&> > operator[](slice __s) const;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    slice_array<value_type> operator[](slice __s);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __val_expr<__indirect_expr<const valarray&> > operator[](const gslice& __gs) const;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    gslice_array<value_type> operator[](const gslice& __gs);

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __val_expr<__indirect_expr<const valarray&> > operator[](gslice&& __gs) const;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    gslice_array<value_type> operator[](gslice&& __gs);

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __val_expr<__mask_expr<const valarray&> > operator[](const valarray<bool>& __vb) const;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    mask_array<value_type> operator[](const valarray<bool>& __vb);

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __val_expr<__mask_expr<const valarray&> > operator[](valarray<bool>&& __vb) const;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    mask_array<value_type> operator[](valarray<bool>&& __vb);

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __val_expr<__indirect_expr<const valarray&> > operator[](const valarray<size_t>& __vs) const;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    indirect_array<value_type> operator[](const valarray<size_t>& __vs);

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __val_expr<__indirect_expr<const valarray&> > operator[](valarray<size_t>&& __vs) const;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    indirect_array<value_type> operator[](valarray<size_t>&& __vs);



    valarray operator+() const;
    valarray operator-() const;
    valarray operator~() const;
    valarray<bool> operator!() const;


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    valarray& operator*= (const value_type& __x);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    valarray& operator/= (const value_type& __x);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    valarray& operator%= (const value_type& __x);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    valarray& operator+= (const value_type& __x);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    valarray& operator-= (const value_type& __x);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    valarray& operator^= (const value_type& __x);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    valarray& operator&= (const value_type& __x);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    valarray& operator|= (const value_type& __x);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    valarray& operator<<=(const value_type& __x);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    valarray& operator>>=(const value_type& __x);

    template <class _Expr>
    typename enable_if
    <
        __is_val_expr<_Expr>::value,
        valarray&
    >::type
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    operator*= (const _Expr& __v);

    template <class _Expr>
    typename enable_if
    <
        __is_val_expr<_Expr>::value,
        valarray&
    >::type
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    operator/= (const _Expr& __v);

    template <class _Expr>
    typename enable_if
    <
        __is_val_expr<_Expr>::value,
        valarray&
    >::type
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    operator%= (const _Expr& __v);

    template <class _Expr>
    typename enable_if
    <
        __is_val_expr<_Expr>::value,
        valarray&
    >::type
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    operator+= (const _Expr& __v);

    template <class _Expr>
    typename enable_if
    <
        __is_val_expr<_Expr>::value,
        valarray&
    >::type
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    operator-= (const _Expr& __v);

    template <class _Expr>
    typename enable_if
    <
        __is_val_expr<_Expr>::value,
        valarray&
    >::type
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    operator^= (const _Expr& __v);

    template <class _Expr>
    typename enable_if
    <
        __is_val_expr<_Expr>::value,
        valarray&
    >::type
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    operator|= (const _Expr& __v);

    template <class _Expr>
    typename enable_if
    <
        __is_val_expr<_Expr>::value,
        valarray&
    >::type
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    operator&= (const _Expr& __v);

    template <class _Expr>
    typename enable_if
    <
        __is_val_expr<_Expr>::value,
        valarray&
    >::type
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    operator<<= (const _Expr& __v);

    template <class _Expr>
    typename enable_if
    <
        __is_val_expr<_Expr>::value,
        valarray&
    >::type
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    operator>>= (const _Expr& __v);


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void swap(valarray& __v) noexcept;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_t size() const {return static_cast<size_t>(__end_ - __begin_);}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    value_type sum() const;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    value_type min() const;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    value_type max() const;

    valarray shift (int __i) const;
    valarray cshift(int __i) const;
    valarray apply(value_type __f(value_type)) const;
    valarray apply(value_type __f(const value_type&)) const;
    void resize(size_t __n, value_type __x = value_type());

private:
    template <class> friend class __attribute__ ((__type_visibility__("default"))) valarray;
    template <class> friend class __attribute__ ((__type_visibility__("default"))) slice_array;
    template <class> friend class __attribute__ ((__type_visibility__("default"))) gslice_array;
    template <class> friend class __attribute__ ((__type_visibility__("default"))) mask_array;
    template <class> friend class __mask_expr;
    template <class> friend class __attribute__ ((__type_visibility__("default"))) indirect_array;
    template <class> friend class __indirect_expr;
    template <class> friend class __val_expr;

    template <class _Up>
    friend
    _Up*
    begin(valarray<_Up>& __v);

    template <class _Up>
    friend
    const _Up*
    begin(const valarray<_Up>& __v);

    template <class _Up>
    friend
    _Up*
    end(valarray<_Up>& __v);

    template <class _Up>
    friend
    const _Up*
    end(const valarray<_Up>& __v);

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void __clear(size_t __capacity);
    valarray& __assign_range(const value_type* __f, const value_type* __l);
};

extern template __attribute__ ((__visibility__("default"))) void valarray<size_t>::resize(size_t, size_t);

template <class _Op, class _Tp>
struct _UnaryOp<_Op, valarray<_Tp> >
{
    typedef typename _Op::__result_type __result_type;
    typedef typename decay<__result_type>::type value_type;

    _Op __op_;
    const valarray<_Tp>& __a0_;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    _UnaryOp(const _Op& __op, const valarray<_Tp>& __a0) : __op_(__op), __a0_(__a0) {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __result_type operator[](size_t __i) const {return __op_(__a0_[__i]);}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_t size() const {return __a0_.size();}
};

template <class _Op, class _Tp, class _A1>
struct _BinaryOp<_Op, valarray<_Tp>, _A1>
{
    typedef typename _Op::__result_type __result_type;
    typedef typename decay<__result_type>::type value_type;

    _Op __op_;
    const valarray<_Tp>& __a0_;
    _A1 __a1_;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    _BinaryOp(const _Op& __op, const valarray<_Tp>& __a0, const _A1& __a1)
        : __op_(__op), __a0_(__a0), __a1_(__a1) {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __result_type operator[](size_t __i) const {return __op_(__a0_[__i], __a1_[__i]);}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_t size() const {return __a0_.size();}
};

template <class _Op, class _A0, class _Tp>
struct _BinaryOp<_Op, _A0, valarray<_Tp> >
{
    typedef typename _Op::__result_type __result_type;
    typedef typename decay<__result_type>::type value_type;

    _Op __op_;
    _A0 __a0_;
    const valarray<_Tp>& __a1_;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    _BinaryOp(const _Op& __op, const _A0& __a0, const valarray<_Tp>& __a1)
        : __op_(__op), __a0_(__a0), __a1_(__a1) {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __result_type operator[](size_t __i) const {return __op_(__a0_[__i], __a1_[__i]);}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_t size() const {return __a0_.size();}
};

template <class _Op, class _Tp>
struct _BinaryOp<_Op, valarray<_Tp>, valarray<_Tp> >
{
    typedef typename _Op::__result_type __result_type;
    typedef typename decay<__result_type>::type value_type;

    _Op __op_;
    const valarray<_Tp>& __a0_;
    const valarray<_Tp>& __a1_;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    _BinaryOp(const _Op& __op, const valarray<_Tp>& __a0, const valarray<_Tp>& __a1)
        : __op_(__op), __a0_(__a0), __a1_(__a1) {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __result_type operator[](size_t __i) const {return __op_(__a0_[__i], __a1_[__i]);}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_t size() const {return __a0_.size();}
};



template <class _Tp>
class __attribute__ ((__type_visibility__("default"))) slice_array
{
public:
    typedef _Tp value_type;

private:
    value_type* __vp_;
    size_t __size_;
    size_t __stride_;

public:
    template <class _Expr>
    typename enable_if
    <
        __is_val_expr<_Expr>::value,
        void
    >::type
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    operator=(const _Expr& __v) const;

    template <class _Expr>
    typename enable_if
    <
        __is_val_expr<_Expr>::value,
        void
    >::type
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    operator*=(const _Expr& __v) const;

    template <class _Expr>
    typename enable_if
    <
        __is_val_expr<_Expr>::value,
        void
    >::type
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    operator/=(const _Expr& __v) const;

    template <class _Expr>
    typename enable_if
    <
        __is_val_expr<_Expr>::value,
        void
    >::type
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    operator%=(const _Expr& __v) const;

    template <class _Expr>
    typename enable_if
    <
        __is_val_expr<_Expr>::value,
        void
    >::type
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    operator+=(const _Expr& __v) const;

    template <class _Expr>
    typename enable_if
    <
        __is_val_expr<_Expr>::value,
        void
    >::type
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    operator-=(const _Expr& __v) const;

    template <class _Expr>
    typename enable_if
    <
        __is_val_expr<_Expr>::value,
        void
    >::type
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    operator^=(const _Expr& __v) const;

    template <class _Expr>
    typename enable_if
    <
        __is_val_expr<_Expr>::value,
        void
    >::type
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    operator&=(const _Expr& __v) const;

    template <class _Expr>
    typename enable_if
    <
        __is_val_expr<_Expr>::value,
        void
    >::type
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    operator|=(const _Expr& __v) const;

    template <class _Expr>
    typename enable_if
    <
        __is_val_expr<_Expr>::value,
        void
    >::type
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    operator<<=(const _Expr& __v) const;

    template <class _Expr>
    typename enable_if
    <
        __is_val_expr<_Expr>::value,
        void
    >::type
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    operator>>=(const _Expr& __v) const;

    slice_array(slice_array const&) = default;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const slice_array& operator=(const slice_array& __sa) const;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void operator=(const value_type& __x) const;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void operator=(const valarray<value_type>& __va) const;

private:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    slice_array(const slice& __sl, const valarray<value_type>& __v)
        : __vp_(const_cast<value_type*>(__v.__begin_ + __sl.start())),
          __size_(__sl.size()),
          __stride_(__sl.stride())
        {}

    template <class> friend class valarray;
    template <class> friend class sliceExpr;
};

template <class _Tp>
inline
const slice_array<_Tp>&
slice_array<_Tp>::operator=(const slice_array& __sa) const
{
    value_type* __t = __vp_;
    const value_type* __s = __sa.__vp_;
    for (size_t __n = __size_; __n; --__n, __t += __stride_, __s += __sa.__stride_)
        *__t = *__s;
    return *this;
}

template <class _Tp>
template <class _Expr>
inline
typename enable_if
<
    __is_val_expr<_Expr>::value,
    void
>::type
slice_array<_Tp>::operator=(const _Expr& __v) const
{
    value_type* __t = __vp_;
    for (size_t __i = 0; __i < __size_; ++__i, __t += __stride_)
        *__t = __v[__i];
}

template <class _Tp>
inline void
slice_array<_Tp>::operator=(const valarray<value_type>& __va) const
{
    value_type* __t = __vp_;
    for (size_t __i = 0; __i < __va.size(); ++__i, __t += __stride_)
        *__t = __va[__i];
}

template <class _Tp>
template <class _Expr>
inline
typename enable_if
<
    __is_val_expr<_Expr>::value,
    void
>::type
slice_array<_Tp>::operator*=(const _Expr& __v) const
{
    value_type* __t = __vp_;
    for (size_t __i = 0; __i < __size_; ++__i, __t += __stride_)
        *__t *= __v[__i];
}

template <class _Tp>
template <class _Expr>
inline
typename enable_if
<
    __is_val_expr<_Expr>::value,
    void
>::type
slice_array<_Tp>::operator/=(const _Expr& __v) const
{
    value_type* __t = __vp_;
    for (size_t __i = 0; __i < __size_; ++__i, __t += __stride_)
        *__t /= __v[__i];
}

template <class _Tp>
template <class _Expr>
inline
typename enable_if
<
    __is_val_expr<_Expr>::value,
    void
>::type
slice_array<_Tp>::operator%=(const _Expr& __v) const
{
    value_type* __t = __vp_;
    for (size_t __i = 0; __i < __size_; ++__i, __t += __stride_)
        *__t %= __v[__i];
}

template <class _Tp>
template <class _Expr>
inline
typename enable_if
<
    __is_val_expr<_Expr>::value,
    void
>::type
slice_array<_Tp>::operator+=(const _Expr& __v) const
{
    value_type* __t = __vp_;
    for (size_t __i = 0; __i < __size_; ++__i, __t += __stride_)
        *__t += __v[__i];
}

template <class _Tp>
template <class _Expr>
inline
typename enable_if
<
    __is_val_expr<_Expr>::value,
    void
>::type
slice_array<_Tp>::operator-=(const _Expr& __v) const
{
    value_type* __t = __vp_;
    for (size_t __i = 0; __i < __size_; ++__i, __t += __stride_)
        *__t -= __v[__i];
}

template <class _Tp>
template <class _Expr>
inline
typename enable_if
<
    __is_val_expr<_Expr>::value,
    void
>::type
slice_array<_Tp>::operator^=(const _Expr& __v) const
{
    value_type* __t = __vp_;
    for (size_t __i = 0; __i < __size_; ++__i, __t += __stride_)
        *__t ^= __v[__i];
}

template <class _Tp>
template <class _Expr>
inline
typename enable_if
<
    __is_val_expr<_Expr>::value,
    void
>::type
slice_array<_Tp>::operator&=(const _Expr& __v) const
{
    value_type* __t = __vp_;
    for (size_t __i = 0; __i < __size_; ++__i, __t += __stride_)
        *__t &= __v[__i];
}

template <class _Tp>
template <class _Expr>
inline
typename enable_if
<
    __is_val_expr<_Expr>::value,
    void
>::type
slice_array<_Tp>::operator|=(const _Expr& __v) const
{
    value_type* __t = __vp_;
    for (size_t __i = 0; __i < __size_; ++__i, __t += __stride_)
        *__t |= __v[__i];
}

template <class _Tp>
template <class _Expr>
inline
typename enable_if
<
    __is_val_expr<_Expr>::value,
    void
>::type
slice_array<_Tp>::operator<<=(const _Expr& __v) const
{
    value_type* __t = __vp_;
    for (size_t __i = 0; __i < __size_; ++__i, __t += __stride_)
        *__t <<= __v[__i];
}

template <class _Tp>
template <class _Expr>
inline
typename enable_if
<
    __is_val_expr<_Expr>::value,
    void
>::type
slice_array<_Tp>::operator>>=(const _Expr& __v) const
{
    value_type* __t = __vp_;
    for (size_t __i = 0; __i < __size_; ++__i, __t += __stride_)
        *__t >>= __v[__i];
}

template <class _Tp>
inline
void
slice_array<_Tp>::operator=(const value_type& __x) const
{
    value_type* __t = __vp_;
    for (size_t __n = __size_; __n; --__n, __t += __stride_)
        *__t = __x;
}



class __attribute__ ((__visibility__("default"))) gslice
{
    valarray<size_t> __size_;
    valarray<size_t> __stride_;
    valarray<size_t> __1d_;

public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    gslice() {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    gslice(size_t __start, const valarray<size_t>& __size,
                           const valarray<size_t>& __stride)
        : __size_(__size),
          __stride_(__stride)
        {__init(__start);}



    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    gslice(size_t __start, const valarray<size_t>& __size,
                                 valarray<size_t>&& __stride)
        : __size_(__size),
          __stride_(move(__stride))
        {__init(__start);}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    gslice(size_t __start, valarray<size_t>&& __size,
                           const valarray<size_t>& __stride)
        : __size_(move(__size)),
          __stride_(__stride)
        {__init(__start);}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    gslice(size_t __start, valarray<size_t>&& __size,
                                 valarray<size_t>&& __stride)
        : __size_(move(__size)),
          __stride_(move(__stride))
        {__init(__start);}



    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_t start() const {return __1d_.size() ? __1d_[0] : 0;}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    valarray<size_t> size() const {return __size_;}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    valarray<size_t> stride() const {return __stride_;}

private:
    void __init(size_t __start);

    template <class> friend class gslice_array;
    template <class> friend class valarray;
    template <class> friend class __val_expr;
};



template <class _Tp>
class __attribute__ ((__type_visibility__("default"))) gslice_array
{
public:
    typedef _Tp value_type;

private:
    value_type* __vp_;
    valarray<size_t> __1d_;

public:
    template <class _Expr>
    typename enable_if
    <
        __is_val_expr<_Expr>::value,
        void
    >::type
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    operator=(const _Expr& __v) const;

    template <class _Expr>
    typename enable_if
    <
        __is_val_expr<_Expr>::value,
        void
    >::type
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    operator*=(const _Expr& __v) const;

    template <class _Expr>
    typename enable_if
    <
        __is_val_expr<_Expr>::value,
        void
    >::type
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    operator/=(const _Expr& __v) const;

    template <class _Expr>
    typename enable_if
    <
        __is_val_expr<_Expr>::value,
        void
    >::type
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    operator%=(const _Expr& __v) const;

    template <class _Expr>
    typename enable_if
    <
        __is_val_expr<_Expr>::value,
        void
    >::type
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    operator+=(const _Expr& __v) const;

    template <class _Expr>
    typename enable_if
    <
        __is_val_expr<_Expr>::value,
        void
    >::type
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    operator-=(const _Expr& __v) const;

    template <class _Expr>
    typename enable_if
    <
        __is_val_expr<_Expr>::value,
        void
    >::type
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    operator^=(const _Expr& __v) const;

    template <class _Expr>
    typename enable_if
    <
        __is_val_expr<_Expr>::value,
        void
    >::type
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    operator&=(const _Expr& __v) const;

    template <class _Expr>
    typename enable_if
    <
        __is_val_expr<_Expr>::value,
        void
    >::type
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    operator|=(const _Expr& __v) const;

    template <class _Expr>
    typename enable_if
    <
        __is_val_expr<_Expr>::value,
        void
    >::type
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    operator<<=(const _Expr& __v) const;

    template <class _Expr>
    typename enable_if
    <
        __is_val_expr<_Expr>::value,
        void
    >::type
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    operator>>=(const _Expr& __v) const;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const gslice_array& operator=(const gslice_array& __ga) const;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void operator=(const value_type& __x) const;

    gslice_array(const gslice_array&) = default;

private:
    gslice_array(const gslice& __gs, const valarray<value_type>& __v)
        : __vp_(const_cast<value_type*>(__v.__begin_)),
          __1d_(__gs.__1d_)
        {}


    gslice_array(gslice&& __gs, const valarray<value_type>& __v)
        : __vp_(const_cast<value_type*>(__v.__begin_)),
          __1d_(move(__gs.__1d_))
        {}


    template <class> friend class valarray;
};

template <class _Tp>
template <class _Expr>
inline
typename enable_if
<
    __is_val_expr<_Expr>::value,
    void
>::type
gslice_array<_Tp>::operator=(const _Expr& __v) const
{
    typedef const size_t* _Ip;
    size_t __j = 0;
    for (_Ip __i = __1d_.__begin_, __e = __1d_.__end_; __i != __e; ++__i, ++__j)
        __vp_[*__i] = __v[__j];
}

template <class _Tp>
template <class _Expr>
inline
typename enable_if
<
    __is_val_expr<_Expr>::value,
    void
>::type
gslice_array<_Tp>::operator*=(const _Expr& __v) const
{
    typedef const size_t* _Ip;
    size_t __j = 0;
    for (_Ip __i = __1d_.__begin_, __e = __1d_.__end_; __i != __e; ++__i, ++__j)
        __vp_[*__i] *= __v[__j];
}

template <class _Tp>
template <class _Expr>
inline
typename enable_if
<
    __is_val_expr<_Expr>::value,
    void
>::type
gslice_array<_Tp>::operator/=(const _Expr& __v) const
{
    typedef const size_t* _Ip;
    size_t __j = 0;
    for (_Ip __i = __1d_.__begin_, __e = __1d_.__end_; __i != __e; ++__i, ++__j)
        __vp_[*__i] /= __v[__j];
}

template <class _Tp>
template <class _Expr>
inline
typename enable_if
<
    __is_val_expr<_Expr>::value,
    void
>::type
gslice_array<_Tp>::operator%=(const _Expr& __v) const
{
    typedef const size_t* _Ip;
    size_t __j = 0;
    for (_Ip __i = __1d_.__begin_, __e = __1d_.__end_; __i != __e; ++__i, ++__j)
        __vp_[*__i] %= __v[__j];
}

template <class _Tp>
template <class _Expr>
inline
typename enable_if
<
    __is_val_expr<_Expr>::value,
    void
>::type
gslice_array<_Tp>::operator+=(const _Expr& __v) const
{
    typedef const size_t* _Ip;
    size_t __j = 0;
    for (_Ip __i = __1d_.__begin_, __e = __1d_.__end_; __i != __e; ++__i, ++__j)
        __vp_[*__i] += __v[__j];
}

template <class _Tp>
template <class _Expr>
inline
typename enable_if
<
    __is_val_expr<_Expr>::value,
    void
>::type
gslice_array<_Tp>::operator-=(const _Expr& __v) const
{
    typedef const size_t* _Ip;
    size_t __j = 0;
    for (_Ip __i = __1d_.__begin_, __e = __1d_.__end_; __i != __e; ++__i, ++__j)
        __vp_[*__i] -= __v[__j];
}

template <class _Tp>
template <class _Expr>
inline
typename enable_if
<
    __is_val_expr<_Expr>::value,
    void
>::type
gslice_array<_Tp>::operator^=(const _Expr& __v) const
{
    typedef const size_t* _Ip;
    size_t __j = 0;
    for (_Ip __i = __1d_.__begin_, __e = __1d_.__end_; __i != __e; ++__i, ++__j)
        __vp_[*__i] ^= __v[__j];
}

template <class _Tp>
template <class _Expr>
inline
typename enable_if
<
    __is_val_expr<_Expr>::value,
    void
>::type
gslice_array<_Tp>::operator&=(const _Expr& __v) const
{
    typedef const size_t* _Ip;
    size_t __j = 0;
    for (_Ip __i = __1d_.__begin_, __e = __1d_.__end_; __i != __e; ++__i, ++__j)
        __vp_[*__i] &= __v[__j];
}

template <class _Tp>
template <class _Expr>
inline
typename enable_if
<
    __is_val_expr<_Expr>::value,
    void
>::type
gslice_array<_Tp>::operator|=(const _Expr& __v) const
{
    typedef const size_t* _Ip;
    size_t __j = 0;
    for (_Ip __i = __1d_.__begin_, __e = __1d_.__end_; __i != __e; ++__i, ++__j)
        __vp_[*__i] |= __v[__j];
}

template <class _Tp>
template <class _Expr>
inline
typename enable_if
<
    __is_val_expr<_Expr>::value,
    void
>::type
gslice_array<_Tp>::operator<<=(const _Expr& __v) const
{
    typedef const size_t* _Ip;
    size_t __j = 0;
    for (_Ip __i = __1d_.__begin_, __e = __1d_.__end_; __i != __e; ++__i, ++__j)
        __vp_[*__i] <<= __v[__j];
}

template <class _Tp>
template <class _Expr>
inline
typename enable_if
<
    __is_val_expr<_Expr>::value,
    void
>::type
gslice_array<_Tp>::operator>>=(const _Expr& __v) const
{
    typedef const size_t* _Ip;
    size_t __j = 0;
    for (_Ip __i = __1d_.__begin_, __e = __1d_.__end_; __i != __e; ++__i, ++__j)
        __vp_[*__i] >>= __v[__j];
}

template <class _Tp>
inline
const gslice_array<_Tp>&
gslice_array<_Tp>::operator=(const gslice_array& __ga) const
{
    typedef const size_t* _Ip;
    const value_type* __s = __ga.__vp_;
    for (_Ip __i = __1d_.__begin_, __e = __1d_.__end_, __j = __ga.__1d_.__begin_;
            __i != __e; ++__i, ++__j)
        __vp_[*__i] = __s[*__j];
    return *this;
}

template <class _Tp>
inline
void
gslice_array<_Tp>::operator=(const value_type& __x) const
{
    typedef const size_t* _Ip;
    for (_Ip __i = __1d_.__begin_, __e = __1d_.__end_; __i != __e; ++__i)
        __vp_[*__i] = __x;
}



template <class _Tp>
class __attribute__ ((__type_visibility__("default"))) mask_array
{
public:
    typedef _Tp value_type;

private:
    value_type* __vp_;
    valarray<size_t> __1d_;

public:
    template <class _Expr>
    typename enable_if
    <
        __is_val_expr<_Expr>::value,
        void
    >::type
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    operator=(const _Expr& __v) const;

    template <class _Expr>
    typename enable_if
    <
        __is_val_expr<_Expr>::value,
        void
    >::type
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    operator*=(const _Expr& __v) const;

    template <class _Expr>
    typename enable_if
    <
        __is_val_expr<_Expr>::value,
        void
    >::type
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    operator/=(const _Expr& __v) const;

    template <class _Expr>
    typename enable_if
    <
        __is_val_expr<_Expr>::value,
        void
    >::type
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    operator%=(const _Expr& __v) const;

    template <class _Expr>
    typename enable_if
    <
        __is_val_expr<_Expr>::value,
        void
    >::type
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    operator+=(const _Expr& __v) const;

    template <class _Expr>
    typename enable_if
    <
        __is_val_expr<_Expr>::value,
        void
    >::type
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    operator-=(const _Expr& __v) const;

    template <class _Expr>
    typename enable_if
    <
        __is_val_expr<_Expr>::value,
        void
    >::type
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    operator^=(const _Expr& __v) const;

    template <class _Expr>
    typename enable_if
    <
        __is_val_expr<_Expr>::value,
        void
    >::type
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    operator&=(const _Expr& __v) const;

    template <class _Expr>
    typename enable_if
    <
        __is_val_expr<_Expr>::value,
        void
    >::type
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    operator|=(const _Expr& __v) const;

    template <class _Expr>
    typename enable_if
    <
        __is_val_expr<_Expr>::value,
        void
    >::type
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    operator<<=(const _Expr& __v) const;

    template <class _Expr>
    typename enable_if
    <
        __is_val_expr<_Expr>::value,
        void
    >::type
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    operator>>=(const _Expr& __v) const;

    mask_array(const mask_array&) = default;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const mask_array& operator=(const mask_array& __ma) const;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void operator=(const value_type& __x) const;

private:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    mask_array(const valarray<bool>& __vb, const valarray<value_type>& __v)
        : __vp_(const_cast<value_type*>(__v.__begin_)),
          __1d_(static_cast<size_t>(count(__vb.__begin_, __vb.__end_, true)))
          {
              size_t __j = 0;
              for (size_t __i = 0; __i < __vb.size(); ++__i)
                  if (__vb[__i])
                      __1d_[__j++] = __i;
          }

    template <class> friend class valarray;
};

template <class _Tp>
template <class _Expr>
inline
typename enable_if
<
    __is_val_expr<_Expr>::value,
    void
>::type
mask_array<_Tp>::operator=(const _Expr& __v) const
{
    size_t __n = __1d_.size();
    for (size_t __i = 0; __i < __n; ++__i)
        __vp_[__1d_[__i]] = __v[__i];
}

template <class _Tp>
template <class _Expr>
inline
typename enable_if
<
    __is_val_expr<_Expr>::value,
    void
>::type
mask_array<_Tp>::operator*=(const _Expr& __v) const
{
    size_t __n = __1d_.size();
    for (size_t __i = 0; __i < __n; ++__i)
        __vp_[__1d_[__i]] *= __v[__i];
}

template <class _Tp>
template <class _Expr>
inline
typename enable_if
<
    __is_val_expr<_Expr>::value,
    void
>::type
mask_array<_Tp>::operator/=(const _Expr& __v) const
{
    size_t __n = __1d_.size();
    for (size_t __i = 0; __i < __n; ++__i)
        __vp_[__1d_[__i]] /= __v[__i];
}

template <class _Tp>
template <class _Expr>
inline
typename enable_if
<
    __is_val_expr<_Expr>::value,
    void
>::type
mask_array<_Tp>::operator%=(const _Expr& __v) const
{
    size_t __n = __1d_.size();
    for (size_t __i = 0; __i < __n; ++__i)
        __vp_[__1d_[__i]] %= __v[__i];
}

template <class _Tp>
template <class _Expr>
inline
typename enable_if
<
    __is_val_expr<_Expr>::value,
    void
>::type
mask_array<_Tp>::operator+=(const _Expr& __v) const
{
    size_t __n = __1d_.size();
    for (size_t __i = 0; __i < __n; ++__i)
        __vp_[__1d_[__i]] += __v[__i];
}

template <class _Tp>
template <class _Expr>
inline
typename enable_if
<
    __is_val_expr<_Expr>::value,
    void
>::type
mask_array<_Tp>::operator-=(const _Expr& __v) const
{
    size_t __n = __1d_.size();
    for (size_t __i = 0; __i < __n; ++__i)
        __vp_[__1d_[__i]] -= __v[__i];
}

template <class _Tp>
template <class _Expr>
inline
typename enable_if
<
    __is_val_expr<_Expr>::value,
    void
>::type
mask_array<_Tp>::operator^=(const _Expr& __v) const
{
    size_t __n = __1d_.size();
    for (size_t __i = 0; __i < __n; ++__i)
        __vp_[__1d_[__i]] ^= __v[__i];
}

template <class _Tp>
template <class _Expr>
inline
typename enable_if
<
    __is_val_expr<_Expr>::value,
    void
>::type
mask_array<_Tp>::operator&=(const _Expr& __v) const
{
    size_t __n = __1d_.size();
    for (size_t __i = 0; __i < __n; ++__i)
        __vp_[__1d_[__i]] &= __v[__i];
}

template <class _Tp>
template <class _Expr>
inline
typename enable_if
<
    __is_val_expr<_Expr>::value,
    void
>::type
mask_array<_Tp>::operator|=(const _Expr& __v) const
{
    size_t __n = __1d_.size();
    for (size_t __i = 0; __i < __n; ++__i)
        __vp_[__1d_[__i]] |= __v[__i];
}

template <class _Tp>
template <class _Expr>
inline
typename enable_if
<
    __is_val_expr<_Expr>::value,
    void
>::type
mask_array<_Tp>::operator<<=(const _Expr& __v) const
{
    size_t __n = __1d_.size();
    for (size_t __i = 0; __i < __n; ++__i)
        __vp_[__1d_[__i]] <<= __v[__i];
}

template <class _Tp>
template <class _Expr>
inline
typename enable_if
<
    __is_val_expr<_Expr>::value,
    void
>::type
mask_array<_Tp>::operator>>=(const _Expr& __v) const
{
    size_t __n = __1d_.size();
    for (size_t __i = 0; __i < __n; ++__i)
        __vp_[__1d_[__i]] >>= __v[__i];
}

template <class _Tp>
inline
const mask_array<_Tp>&
mask_array<_Tp>::operator=(const mask_array& __ma) const
{
    size_t __n = __1d_.size();
    for (size_t __i = 0; __i < __n; ++__i)
        __vp_[__1d_[__i]] = __ma.__vp_[__1d_[__i]];
    return *this;
}

template <class _Tp>
inline
void
mask_array<_Tp>::operator=(const value_type& __x) const
{
    size_t __n = __1d_.size();
    for (size_t __i = 0; __i < __n; ++__i)
        __vp_[__1d_[__i]] = __x;
}

template <class _ValExpr>
class __mask_expr
{
    typedef typename remove_reference<_ValExpr>::type _RmExpr;
public:
    typedef typename _RmExpr::value_type value_type;
    typedef value_type __result_type;

private:
    _ValExpr __expr_;
    valarray<size_t> __1d_;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __mask_expr(const valarray<bool>& __vb, const _RmExpr& __e)
        : __expr_(__e),
          __1d_(static_cast<size_t>(count(__vb.__begin_, __vb.__end_, true)))
          {
              size_t __j = 0;
              for (size_t __i = 0; __i < __vb.size(); ++__i)
                  if (__vb[__i])
                      __1d_[__j++] = __i;
          }

public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __result_type operator[](size_t __i) const
        {return __expr_[__1d_[__i]];}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_t size() const {return __1d_.size();}

    template <class> friend class __val_expr;
    template <class> friend class valarray;
};



template <class _Tp>
class __attribute__ ((__type_visibility__("default"))) indirect_array
{
public:
    typedef _Tp value_type;

private:
    value_type* __vp_;
    valarray<size_t> __1d_;

public:
    template <class _Expr>
    typename enable_if
    <
        __is_val_expr<_Expr>::value,
        void
    >::type
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    operator=(const _Expr& __v) const;

    template <class _Expr>
    typename enable_if
    <
        __is_val_expr<_Expr>::value,
        void
    >::type
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    operator*=(const _Expr& __v) const;

    template <class _Expr>
    typename enable_if
    <
        __is_val_expr<_Expr>::value,
        void
    >::type
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    operator/=(const _Expr& __v) const;

    template <class _Expr>
    typename enable_if
    <
        __is_val_expr<_Expr>::value,
        void
    >::type
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    operator%=(const _Expr& __v) const;

    template <class _Expr>
    typename enable_if
    <
        __is_val_expr<_Expr>::value,
        void
    >::type
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    operator+=(const _Expr& __v) const;

    template <class _Expr>
    typename enable_if
    <
        __is_val_expr<_Expr>::value,
        void
    >::type
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    operator-=(const _Expr& __v) const;

    template <class _Expr>
    typename enable_if
    <
        __is_val_expr<_Expr>::value,
        void
    >::type
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    operator^=(const _Expr& __v) const;

    template <class _Expr>
    typename enable_if
    <
        __is_val_expr<_Expr>::value,
        void
    >::type
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    operator&=(const _Expr& __v) const;

    template <class _Expr>
    typename enable_if
    <
        __is_val_expr<_Expr>::value,
        void
    >::type
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    operator|=(const _Expr& __v) const;

    template <class _Expr>
    typename enable_if
    <
        __is_val_expr<_Expr>::value,
        void
    >::type
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    operator<<=(const _Expr& __v) const;

    template <class _Expr>
    typename enable_if
    <
        __is_val_expr<_Expr>::value,
        void
    >::type
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    operator>>=(const _Expr& __v) const;

    indirect_array(const indirect_array&) = default;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const indirect_array& operator=(const indirect_array& __ia) const;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void operator=(const value_type& __x) const;

private:
     __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
   indirect_array(const valarray<size_t>& __ia, const valarray<value_type>& __v)
        : __vp_(const_cast<value_type*>(__v.__begin_)),
          __1d_(__ia)
        {}



    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    indirect_array(valarray<size_t>&& __ia, const valarray<value_type>& __v)
        : __vp_(const_cast<value_type*>(__v.__begin_)),
          __1d_(move(__ia))
        {}



    template <class> friend class valarray;
};

template <class _Tp>
template <class _Expr>
inline
typename enable_if
<
    __is_val_expr<_Expr>::value,
    void
>::type
indirect_array<_Tp>::operator=(const _Expr& __v) const
{
    size_t __n = __1d_.size();
    for (size_t __i = 0; __i < __n; ++__i)
        __vp_[__1d_[__i]] = __v[__i];
}

template <class _Tp>
template <class _Expr>
inline
typename enable_if
<
    __is_val_expr<_Expr>::value,
    void
>::type
indirect_array<_Tp>::operator*=(const _Expr& __v) const
{
    size_t __n = __1d_.size();
    for (size_t __i = 0; __i < __n; ++__i)
        __vp_[__1d_[__i]] *= __v[__i];
}

template <class _Tp>
template <class _Expr>
inline
typename enable_if
<
    __is_val_expr<_Expr>::value,
    void
>::type
indirect_array<_Tp>::operator/=(const _Expr& __v) const
{
    size_t __n = __1d_.size();
    for (size_t __i = 0; __i < __n; ++__i)
        __vp_[__1d_[__i]] /= __v[__i];
}

template <class _Tp>
template <class _Expr>
inline
typename enable_if
<
    __is_val_expr<_Expr>::value,
    void
>::type
indirect_array<_Tp>::operator%=(const _Expr& __v) const
{
    size_t __n = __1d_.size();
    for (size_t __i = 0; __i < __n; ++__i)
        __vp_[__1d_[__i]] %= __v[__i];
}

template <class _Tp>
template <class _Expr>
inline
typename enable_if
<
    __is_val_expr<_Expr>::value,
    void
>::type
indirect_array<_Tp>::operator+=(const _Expr& __v) const
{
    size_t __n = __1d_.size();
    for (size_t __i = 0; __i < __n; ++__i)
        __vp_[__1d_[__i]] += __v[__i];
}

template <class _Tp>
template <class _Expr>
inline
typename enable_if
<
    __is_val_expr<_Expr>::value,
    void
>::type
indirect_array<_Tp>::operator-=(const _Expr& __v) const
{
    size_t __n = __1d_.size();
    for (size_t __i = 0; __i < __n; ++__i)
        __vp_[__1d_[__i]] -= __v[__i];
}

template <class _Tp>
template <class _Expr>
inline
typename enable_if
<
    __is_val_expr<_Expr>::value,
    void
>::type
indirect_array<_Tp>::operator^=(const _Expr& __v) const
{
    size_t __n = __1d_.size();
    for (size_t __i = 0; __i < __n; ++__i)
        __vp_[__1d_[__i]] ^= __v[__i];
}

template <class _Tp>
template <class _Expr>
inline
typename enable_if
<
    __is_val_expr<_Expr>::value,
    void
>::type
indirect_array<_Tp>::operator&=(const _Expr& __v) const
{
    size_t __n = __1d_.size();
    for (size_t __i = 0; __i < __n; ++__i)
        __vp_[__1d_[__i]] &= __v[__i];
}

template <class _Tp>
template <class _Expr>
inline
typename enable_if
<
    __is_val_expr<_Expr>::value,
    void
>::type
indirect_array<_Tp>::operator|=(const _Expr& __v) const
{
    size_t __n = __1d_.size();
    for (size_t __i = 0; __i < __n; ++__i)
        __vp_[__1d_[__i]] |= __v[__i];
}

template <class _Tp>
template <class _Expr>
inline
typename enable_if
<
    __is_val_expr<_Expr>::value,
    void
>::type
indirect_array<_Tp>::operator<<=(const _Expr& __v) const
{
    size_t __n = __1d_.size();
    for (size_t __i = 0; __i < __n; ++__i)
        __vp_[__1d_[__i]] <<= __v[__i];
}

template <class _Tp>
template <class _Expr>
inline
typename enable_if
<
    __is_val_expr<_Expr>::value,
    void
>::type
indirect_array<_Tp>::operator>>=(const _Expr& __v) const
{
    size_t __n = __1d_.size();
    for (size_t __i = 0; __i < __n; ++__i)
        __vp_[__1d_[__i]] >>= __v[__i];
}

template <class _Tp>
inline
const indirect_array<_Tp>&
indirect_array<_Tp>::operator=(const indirect_array& __ia) const
{
    typedef const size_t* _Ip;
    const value_type* __s = __ia.__vp_;
    for (_Ip __i = __1d_.__begin_, __e = __1d_.__end_, __j = __ia.__1d_.__begin_;
            __i != __e; ++__i, ++__j)
        __vp_[*__i] = __s[*__j];
    return *this;
}

template <class _Tp>
inline
void
indirect_array<_Tp>::operator=(const value_type& __x) const
{
    typedef const size_t* _Ip;
    for (_Ip __i = __1d_.__begin_, __e = __1d_.__end_; __i != __e; ++__i)
        __vp_[*__i] = __x;
}

template <class _ValExpr>
class __indirect_expr
{
    typedef typename remove_reference<_ValExpr>::type _RmExpr;
public:
    typedef typename _RmExpr::value_type value_type;
    typedef value_type __result_type;

private:
    _ValExpr __expr_;
    valarray<size_t> __1d_;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __indirect_expr(const valarray<size_t>& __ia, const _RmExpr& __e)
        : __expr_(__e),
          __1d_(__ia)
          {}



    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __indirect_expr(valarray<size_t>&& __ia, const _RmExpr& __e)
        : __expr_(__e),
          __1d_(move(__ia))
          {}



public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __result_type operator[](size_t __i) const
        {return __expr_[__1d_[__i]];}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_t size() const {return __1d_.size();}

    template <class> friend class __val_expr;
    template <class> friend class __attribute__ ((__type_visibility__("default"))) valarray;
};

template<class _ValExpr>
class __val_expr
{
    typedef typename remove_reference<_ValExpr>::type _RmExpr;

    _ValExpr __expr_;
public:
    typedef typename _RmExpr::value_type value_type;
    typedef typename _RmExpr::__result_type __result_type;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit __val_expr(const _RmExpr& __e) : __expr_(__e) {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __result_type operator[](size_t __i) const
        {return __expr_[__i];}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __val_expr<__slice_expr<_ValExpr> > operator[](slice __s) const
    {
        typedef __slice_expr<_ValExpr> _NewExpr;
        return __val_expr< _NewExpr >(_NewExpr(__s, __expr_));
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __val_expr<__indirect_expr<_ValExpr> > operator[](const gslice& __gs) const
    {
        typedef __indirect_expr<_ValExpr> _NewExpr;
        return __val_expr<_NewExpr >(_NewExpr(__gs.__1d_, __expr_));
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __val_expr<__mask_expr<_ValExpr> > operator[](const valarray<bool>& __vb) const
    {
        typedef __mask_expr<_ValExpr> _NewExpr;
        return __val_expr< _NewExpr >( _NewExpr(__vb, __expr_));
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __val_expr<__indirect_expr<_ValExpr> > operator[](const valarray<size_t>& __vs) const
    {
        typedef __indirect_expr<_ValExpr> _NewExpr;
        return __val_expr< _NewExpr >(_NewExpr(__vs, __expr_));
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __val_expr<_UnaryOp<__unary_plus<value_type>, _ValExpr> >
    operator+() const
    {
        typedef _UnaryOp<__unary_plus<value_type>, _ValExpr> _NewExpr;
        return __val_expr<_NewExpr>(_NewExpr(__unary_plus<value_type>(), __expr_));
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __val_expr<_UnaryOp<negate<value_type>, _ValExpr> >
    operator-() const
    {
        typedef _UnaryOp<negate<value_type>, _ValExpr> _NewExpr;
        return __val_expr<_NewExpr>(_NewExpr(negate<value_type>(), __expr_));
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __val_expr<_UnaryOp<__bit_not<value_type>, _ValExpr> >
    operator~() const
    {
        typedef _UnaryOp<__bit_not<value_type>, _ValExpr> _NewExpr;
        return __val_expr<_NewExpr>(_NewExpr(__bit_not<value_type>(), __expr_));
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __val_expr<_UnaryOp<logical_not<value_type>, _ValExpr> >
    operator!() const
    {
        typedef _UnaryOp<logical_not<value_type>, _ValExpr> _NewExpr;
        return __val_expr<_NewExpr>(_NewExpr(logical_not<value_type>(), __expr_));
    }

    operator valarray<__result_type>() const;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_t size() const {return __expr_.size();}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __result_type sum() const
    {
        size_t __n = __expr_.size();
        __result_type __r = __n ? __expr_[0] : __result_type();
        for (size_t __i = 1; __i < __n; ++__i)
            __r += __expr_[__i];
        return __r;
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __result_type min() const
    {
        size_t __n = size();
        __result_type __r = __n ? (*this)[0] : __result_type();
        for (size_t __i = 1; __i < __n; ++__i)
        {
            __result_type __x = __expr_[__i];
            if (__x < __r)
                __r = __x;
        }
        return __r;
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __result_type max() const
    {
        size_t __n = size();
        __result_type __r = __n ? (*this)[0] : __result_type();
        for (size_t __i = 1; __i < __n; ++__i)
        {
            __result_type __x = __expr_[__i];
            if (__r < __x)
                __r = __x;
        }
        return __r;
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __val_expr<__shift_expr<_ValExpr> > shift (int __i) const
        {return __val_expr<__shift_expr<_ValExpr> >(__shift_expr<_ValExpr>(__i, __expr_));}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __val_expr<__cshift_expr<_ValExpr> > cshift(int __i) const
        {return __val_expr<__cshift_expr<_ValExpr> >(__cshift_expr<_ValExpr>(__i, __expr_));}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __val_expr<_UnaryOp<__apply_expr<value_type, value_type(*)(value_type)>, _ValExpr> >
    apply(value_type __f(value_type)) const
    {
        typedef __apply_expr<value_type, value_type(*)(value_type)> _Op;
        typedef _UnaryOp<_Op, _ValExpr> _NewExpr;
        return __val_expr<_NewExpr>(_NewExpr(_Op(__f), __expr_));
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __val_expr<_UnaryOp<__apply_expr<value_type, value_type(*)(const value_type&)>, _ValExpr> >
    apply(value_type __f(const value_type&)) const
    {
        typedef __apply_expr<value_type, value_type(*)(const value_type&)> _Op;
        typedef _UnaryOp<_Op, _ValExpr> _NewExpr;
        return __val_expr<_NewExpr>(_NewExpr(_Op(__f), __expr_));
    }
};

template<class _ValExpr>
__val_expr<_ValExpr>::operator valarray<__val_expr::__result_type>() const
{
    valarray<__result_type> __r;
    size_t __n = __expr_.size();
    if (__n)
    {
        __r.__begin_ =
            __r.__end_ = allocator<__result_type>().allocate(__n);
        for (size_t __i = 0; __i != __n; ++__r.__end_, ++__i)
            ::new ((void*)__r.__end_) __result_type(__expr_[__i]);
    }
    return __r;
}



template <class _Tp>
inline
valarray<_Tp>::valarray(size_t __n)
    : __begin_(nullptr),
      __end_(nullptr)
{
    if (__n)
    {
        __begin_ = __end_ = allocator<value_type>().allocate(__n);

        try
        {

            for (size_t __n_left = __n; __n_left; --__n_left, ++__end_)
                ::new ((void*)__end_) value_type();

        }
        catch (...)
        {
            __clear(__n);
            throw;
        }

    }
}

template <class _Tp>
inline
valarray<_Tp>::valarray(const value_type& __x, size_t __n)
    : __begin_(nullptr),
      __end_(nullptr)
{
    resize(__n, __x);
}

template <class _Tp>
valarray<_Tp>::valarray(const value_type* __p, size_t __n)
    : __begin_(nullptr),
      __end_(nullptr)
{
    if (__n)
    {
        __begin_ = __end_ = allocator<value_type>().allocate(__n);

        try
        {

            for (size_t __n_left = __n; __n_left; ++__end_, ++__p, --__n_left)
                ::new ((void*)__end_) value_type(*__p);

        }
        catch (...)
        {
            __clear(__n);
            throw;
        }

    }
}

template <class _Tp>
valarray<_Tp>::valarray(const valarray& __v)
    : __begin_(nullptr),
      __end_(nullptr)
{
    if (__v.size())
    {
        __begin_ = __end_ = allocator<value_type>().allocate(__v.size());

        try
        {

            for (value_type* __p = __v.__begin_; __p != __v.__end_; ++__end_, ++__p)
                ::new ((void*)__end_) value_type(*__p);

        }
        catch (...)
        {
            __clear(__v.size());
            throw;
        }

    }
}



template <class _Tp>
inline
valarray<_Tp>::valarray(valarray&& __v) noexcept
    : __begin_(__v.__begin_),
      __end_(__v.__end_)
{
    __v.__begin_ = __v.__end_ = nullptr;
}

template <class _Tp>
valarray<_Tp>::valarray(initializer_list<value_type> __il)
    : __begin_(nullptr),
      __end_(nullptr)
{
    const size_t __n = __il.size();
    if (__n)
    {
        __begin_ = __end_ = allocator<value_type>().allocate(__n);

        try
        {

            size_t __n_left = __n;
            for (const value_type* __p = __il.begin(); __n_left; ++__end_, ++__p, --__n_left)
                ::new ((void*)__end_) value_type(*__p);

        }
        catch (...)
        {
            __clear(__n);
            throw;
        }

    }
}



template <class _Tp>
valarray<_Tp>::valarray(const slice_array<value_type>& __sa)
    : __begin_(nullptr),
      __end_(nullptr)
{
    const size_t __n = __sa.__size_;
    if (__n)
    {
        __begin_ = __end_ = allocator<value_type>().allocate(__n);

        try
        {

            size_t __n_left = __n;
            for (const value_type* __p = __sa.__vp_; __n_left; ++__end_, __p += __sa.__stride_, --__n_left)
                ::new ((void*)__end_) value_type(*__p);

        }
        catch (...)
        {
            __clear(__n);
            throw;
        }

    }
}

template <class _Tp>
valarray<_Tp>::valarray(const gslice_array<value_type>& __ga)
    : __begin_(nullptr),
      __end_(nullptr)
{
    const size_t __n = __ga.__1d_.size();
    if (__n)
    {
        __begin_ = __end_ = allocator<value_type>().allocate(__n);

        try
        {

            typedef const size_t* _Ip;
            const value_type* __s = __ga.__vp_;
            for (_Ip __i = __ga.__1d_.__begin_, __e = __ga.__1d_.__end_;
                    __i != __e; ++__i, ++__end_)
                ::new ((void*)__end_) value_type(__s[*__i]);

        }
        catch (...)
        {
            __clear(__n);
            throw;
        }

    }
}

template <class _Tp>
valarray<_Tp>::valarray(const mask_array<value_type>& __ma)
    : __begin_(nullptr),
      __end_(nullptr)
{
    const size_t __n = __ma.__1d_.size();
    if (__n)
    {
        __begin_ = __end_ = allocator<value_type>().allocate(__n);

        try
        {

            typedef const size_t* _Ip;
            const value_type* __s = __ma.__vp_;
            for (_Ip __i = __ma.__1d_.__begin_, __e = __ma.__1d_.__end_;
                    __i != __e; ++__i, ++__end_)
                ::new ((void*)__end_) value_type(__s[*__i]);

        }
        catch (...)
        {
            __clear(__n);
            throw;
        }

    }
}

template <class _Tp>
valarray<_Tp>::valarray(const indirect_array<value_type>& __ia)
    : __begin_(nullptr),
      __end_(nullptr)
{
    const size_t __n = __ia.__1d_.size();
    if (__n)
    {
        __begin_ = __end_ = allocator<value_type>().allocate(__n);

        try
        {

            typedef const size_t* _Ip;
            const value_type* __s = __ia.__vp_;
            for (_Ip __i = __ia.__1d_.__begin_, __e = __ia.__1d_.__end_;
                    __i != __e; ++__i, ++__end_)
                ::new ((void*)__end_) value_type(__s[*__i]);

        }
        catch (...)
        {
            __clear(__n);
            throw;
        }

    }
}

template <class _Tp>
inline
valarray<_Tp>::~valarray()
{
    __clear(size());
}

template <class _Tp>
valarray<_Tp>&
valarray<_Tp>::__assign_range(const value_type* __f, const value_type* __l)
{
    size_t __n = __l - __f;
    if (size() != __n)
    {
        __clear(size());
        __begin_ = allocator<value_type>().allocate(__n);
        __end_ = __begin_ + __n;
        std::__1::uninitialized_copy(__f, __l, __begin_);
    } else {
        std::__1::copy(__f, __l, __begin_);
    }
    return *this;
}

template <class _Tp>
valarray<_Tp>&
valarray<_Tp>::operator=(const valarray& __v)
{
    if (this != &__v)
        return __assign_range(__v.__begin_, __v.__end_);
    return *this;
}



template <class _Tp>
inline
valarray<_Tp>&
valarray<_Tp>::operator=(valarray&& __v) noexcept
{
    __clear(size());
    __begin_ = __v.__begin_;
    __end_ = __v.__end_;
    __v.__begin_ = nullptr;
    __v.__end_ = nullptr;
    return *this;
}

template <class _Tp>
inline
valarray<_Tp>&
valarray<_Tp>::operator=(initializer_list<value_type> __il)
{
    return __assign_range(__il.begin(), __il.end());
}



template <class _Tp>
inline
valarray<_Tp>&
valarray<_Tp>::operator=(const value_type& __x)
{
    std::__1::fill(__begin_, __end_, __x);
    return *this;
}

template <class _Tp>
inline
valarray<_Tp>&
valarray<_Tp>::operator=(const slice_array<value_type>& __sa)
{
    value_type* __t = __begin_;
    const value_type* __s = __sa.__vp_;
    for (size_t __n = __sa.__size_; __n; --__n, __s += __sa.__stride_, ++__t)
        *__t = *__s;
    return *this;
}

template <class _Tp>
inline
valarray<_Tp>&
valarray<_Tp>::operator=(const gslice_array<value_type>& __ga)
{
    typedef const size_t* _Ip;
    value_type* __t = __begin_;
    const value_type* __s = __ga.__vp_;
    for (_Ip __i = __ga.__1d_.__begin_, __e = __ga.__1d_.__end_;
                    __i != __e; ++__i, ++__t)
        *__t = __s[*__i];
    return *this;
}

template <class _Tp>
inline
valarray<_Tp>&
valarray<_Tp>::operator=(const mask_array<value_type>& __ma)
{
    typedef const size_t* _Ip;
    value_type* __t = __begin_;
    const value_type* __s = __ma.__vp_;
    for (_Ip __i = __ma.__1d_.__begin_, __e = __ma.__1d_.__end_;
                    __i != __e; ++__i, ++__t)
        *__t = __s[*__i];
    return *this;
}

template <class _Tp>
inline
valarray<_Tp>&
valarray<_Tp>::operator=(const indirect_array<value_type>& __ia)
{
    typedef const size_t* _Ip;
    value_type* __t = __begin_;
    const value_type* __s = __ia.__vp_;
    for (_Ip __i = __ia.__1d_.__begin_, __e = __ia.__1d_.__end_;
                    __i != __e; ++__i, ++__t)
        *__t = __s[*__i];
    return *this;
}

template <class _Tp>
template <class _ValExpr>
inline
valarray<_Tp>&
valarray<_Tp>::operator=(const __val_expr<_ValExpr>& __v)
{
    size_t __n = __v.size();
    if (size() != __n)
        resize(__n);
    value_type* __t = __begin_;
    for (size_t __i = 0; __i != __n; ++__t, ++__i)
        *__t = __result_type(__v[__i]);
    return *this;
}

template <class _Tp>
inline
__val_expr<__slice_expr<const valarray<_Tp>&> >
valarray<_Tp>::operator[](slice __s) const
{
    return __val_expr<__slice_expr<const valarray&> >(__slice_expr<const valarray&>(__s, *this));
}

template <class _Tp>
inline
slice_array<_Tp>
valarray<_Tp>::operator[](slice __s)
{
    return slice_array<value_type>(__s, *this);
}

template <class _Tp>
inline
__val_expr<__indirect_expr<const valarray<_Tp>&> >
valarray<_Tp>::operator[](const gslice& __gs) const
{
    return __val_expr<__indirect_expr<const valarray&> >(__indirect_expr<const valarray&>(__gs.__1d_, *this));
}

template <class _Tp>
inline
gslice_array<_Tp>
valarray<_Tp>::operator[](const gslice& __gs)
{
    return gslice_array<value_type>(__gs, *this);
}



template <class _Tp>
inline
__val_expr<__indirect_expr<const valarray<_Tp>&> >
valarray<_Tp>::operator[](gslice&& __gs) const
{
    return __val_expr<__indirect_expr<const valarray&> >(__indirect_expr<const valarray&>(move(__gs.__1d_), *this));
}

template <class _Tp>
inline
gslice_array<_Tp>
valarray<_Tp>::operator[](gslice&& __gs)
{
    return gslice_array<value_type>(move(__gs), *this);
}



template <class _Tp>
inline
__val_expr<__mask_expr<const valarray<_Tp>&> >
valarray<_Tp>::operator[](const valarray<bool>& __vb) const
{
    return __val_expr<__mask_expr<const valarray&> >(__mask_expr<const valarray&>(__vb, *this));
}

template <class _Tp>
inline
mask_array<_Tp>
valarray<_Tp>::operator[](const valarray<bool>& __vb)
{
    return mask_array<value_type>(__vb, *this);
}



template <class _Tp>
inline
__val_expr<__mask_expr<const valarray<_Tp>&> >
valarray<_Tp>::operator[](valarray<bool>&& __vb) const
{
    return __val_expr<__mask_expr<const valarray&> >(__mask_expr<const valarray&>(move(__vb), *this));
}

template <class _Tp>
inline
mask_array<_Tp>
valarray<_Tp>::operator[](valarray<bool>&& __vb)
{
    return mask_array<value_type>(move(__vb), *this);
}



template <class _Tp>
inline
__val_expr<__indirect_expr<const valarray<_Tp>&> >
valarray<_Tp>::operator[](const valarray<size_t>& __vs) const
{
    return __val_expr<__indirect_expr<const valarray&> >(__indirect_expr<const valarray&>(__vs, *this));
}

template <class _Tp>
inline
indirect_array<_Tp>
valarray<_Tp>::operator[](const valarray<size_t>& __vs)
{
    return indirect_array<value_type>(__vs, *this);
}



template <class _Tp>
inline
__val_expr<__indirect_expr<const valarray<_Tp>&> >
valarray<_Tp>::operator[](valarray<size_t>&& __vs) const
{
    return __val_expr<__indirect_expr<const valarray&> >(__indirect_expr<const valarray&>(move(__vs), *this));
}

template <class _Tp>
inline
indirect_array<_Tp>
valarray<_Tp>::operator[](valarray<size_t>&& __vs)
{
    return indirect_array<value_type>(move(__vs), *this);
}



template <class _Tp>
valarray<_Tp>
valarray<_Tp>::operator+() const
{
    valarray<value_type> __r;
    size_t __n = size();
    if (__n)
    {
        __r.__begin_ = __r.__end_ = allocator<value_type>().allocate(__n);
        for (const value_type* __p = __begin_; __n; ++__r.__end_, ++__p, --__n)
            ::new ((void*)__r.__end_) value_type(+*__p);
    }
    return __r;
}

template <class _Tp>
valarray<_Tp>
valarray<_Tp>::operator-() const
{
    valarray<value_type> __r;
    size_t __n = size();
    if (__n)
    {
        __r.__begin_ = __r.__end_ = allocator<value_type>().allocate(__n);
        for (const value_type* __p = __begin_; __n; ++__r.__end_, ++__p, --__n)
            ::new ((void*)__r.__end_) value_type(-*__p);
    }
    return __r;
}

template <class _Tp>
valarray<_Tp>
valarray<_Tp>::operator~() const
{
    valarray<value_type> __r;
    size_t __n = size();
    if (__n)
    {
        __r.__begin_ = __r.__end_ = allocator<value_type>().allocate(__n);
        for (const value_type* __p = __begin_; __n; ++__r.__end_, ++__p, --__n)
            ::new ((void*)__r.__end_) value_type(~*__p);
    }
    return __r;
}

template <class _Tp>
valarray<bool>
valarray<_Tp>::operator!() const
{
    valarray<bool> __r;
    size_t __n = size();
    if (__n)
    {
        __r.__begin_ = __r.__end_ = allocator<bool>().allocate(__n);
        for (const value_type* __p = __begin_; __n; ++__r.__end_, ++__p, --__n)
            ::new ((void*)__r.__end_) bool(!*__p);
    }
    return __r;
}

template <class _Tp>
inline
valarray<_Tp>&
valarray<_Tp>::operator*=(const value_type& __x)
{
    for (value_type* __p = __begin_; __p != __end_; ++__p)
        *__p *= __x;
    return *this;
}

template <class _Tp>
inline
valarray<_Tp>&
valarray<_Tp>::operator/=(const value_type& __x)
{
    for (value_type* __p = __begin_; __p != __end_; ++__p)
        *__p /= __x;
    return *this;
}

template <class _Tp>
inline
valarray<_Tp>&
valarray<_Tp>::operator%=(const value_type& __x)
{
    for (value_type* __p = __begin_; __p != __end_; ++__p)
        *__p %= __x;
    return *this;
}

template <class _Tp>
inline
valarray<_Tp>&
valarray<_Tp>::operator+=(const value_type& __x)
{
    for (value_type* __p = __begin_; __p != __end_; ++__p)
        *__p += __x;
    return *this;
}

template <class _Tp>
inline
valarray<_Tp>&
valarray<_Tp>::operator-=(const value_type& __x)
{
    for (value_type* __p = __begin_; __p != __end_; ++__p)
        *__p -= __x;
    return *this;
}

template <class _Tp>
inline
valarray<_Tp>&
valarray<_Tp>::operator^=(const value_type& __x)
{
    for (value_type* __p = __begin_; __p != __end_; ++__p)
        *__p ^= __x;
    return *this;
}

template <class _Tp>
inline
valarray<_Tp>&
valarray<_Tp>::operator&=(const value_type& __x)
{
    for (value_type* __p = __begin_; __p != __end_; ++__p)
        *__p &= __x;
    return *this;
}

template <class _Tp>
inline
valarray<_Tp>&
valarray<_Tp>::operator|=(const value_type& __x)
{
    for (value_type* __p = __begin_; __p != __end_; ++__p)
        *__p |= __x;
    return *this;
}

template <class _Tp>
inline
valarray<_Tp>&
valarray<_Tp>::operator<<=(const value_type& __x)
{
    for (value_type* __p = __begin_; __p != __end_; ++__p)
        *__p <<= __x;
    return *this;
}

template <class _Tp>
inline
valarray<_Tp>&
valarray<_Tp>::operator>>=(const value_type& __x)
{
    for (value_type* __p = __begin_; __p != __end_; ++__p)
        *__p >>= __x;
    return *this;
}

template <class _Tp>
template <class _Expr>
inline
typename enable_if
<
    __is_val_expr<_Expr>::value,
    valarray<_Tp>&
>::type
valarray<_Tp>::operator*=(const _Expr& __v)
{
    size_t __i = 0;
    for (value_type* __t = __begin_; __t != __end_ ; ++__t, ++__i)
        *__t *= __v[__i];
    return *this;
}

template <class _Tp>
template <class _Expr>
inline
typename enable_if
<
    __is_val_expr<_Expr>::value,
    valarray<_Tp>&
>::type
valarray<_Tp>::operator/=(const _Expr& __v)
{
    size_t __i = 0;
    for (value_type* __t = __begin_; __t != __end_ ; ++__t, ++__i)
        *__t /= __v[__i];
    return *this;
}

template <class _Tp>
template <class _Expr>
inline
typename enable_if
<
    __is_val_expr<_Expr>::value,
    valarray<_Tp>&
>::type
valarray<_Tp>::operator%=(const _Expr& __v)
{
    size_t __i = 0;
    for (value_type* __t = __begin_; __t != __end_ ; ++__t, ++__i)
        *__t %= __v[__i];
    return *this;
}

template <class _Tp>
template <class _Expr>
inline
typename enable_if
<
    __is_val_expr<_Expr>::value,
    valarray<_Tp>&
>::type
valarray<_Tp>::operator+=(const _Expr& __v)
{
    size_t __i = 0;
    for (value_type* __t = __begin_; __t != __end_ ; ++__t, ++__i)
        *__t += __v[__i];
    return *this;
}

template <class _Tp>
template <class _Expr>
inline
typename enable_if
<
    __is_val_expr<_Expr>::value,
    valarray<_Tp>&
>::type
valarray<_Tp>::operator-=(const _Expr& __v)
{
    size_t __i = 0;
    for (value_type* __t = __begin_; __t != __end_ ; ++__t, ++__i)
        *__t -= __v[__i];
    return *this;
}

template <class _Tp>
template <class _Expr>
inline
typename enable_if
<
    __is_val_expr<_Expr>::value,
    valarray<_Tp>&
>::type
valarray<_Tp>::operator^=(const _Expr& __v)
{
    size_t __i = 0;
    for (value_type* __t = __begin_; __t != __end_ ; ++__t, ++__i)
        *__t ^= __v[__i];
    return *this;
}

template <class _Tp>
template <class _Expr>
inline
typename enable_if
<
    __is_val_expr<_Expr>::value,
    valarray<_Tp>&
>::type
valarray<_Tp>::operator|=(const _Expr& __v)
{
    size_t __i = 0;
    for (value_type* __t = __begin_; __t != __end_ ; ++__t, ++__i)
        *__t |= __v[__i];
    return *this;
}

template <class _Tp>
template <class _Expr>
inline
typename enable_if
<
    __is_val_expr<_Expr>::value,
    valarray<_Tp>&
>::type
valarray<_Tp>::operator&=(const _Expr& __v)
{
    size_t __i = 0;
    for (value_type* __t = __begin_; __t != __end_ ; ++__t, ++__i)
        *__t &= __v[__i];
    return *this;
}

template <class _Tp>
template <class _Expr>
inline
typename enable_if
<
    __is_val_expr<_Expr>::value,
    valarray<_Tp>&
>::type
valarray<_Tp>::operator<<=(const _Expr& __v)
{
    size_t __i = 0;
    for (value_type* __t = __begin_; __t != __end_ ; ++__t, ++__i)
        *__t <<= __v[__i];
    return *this;
}

template <class _Tp>
template <class _Expr>
inline
typename enable_if
<
    __is_val_expr<_Expr>::value,
    valarray<_Tp>&
>::type
valarray<_Tp>::operator>>=(const _Expr& __v)
{
    size_t __i = 0;
    for (value_type* __t = __begin_; __t != __end_ ; ++__t, ++__i)
        *__t >>= __v[__i];
    return *this;
}

template <class _Tp>
inline
void
valarray<_Tp>::swap(valarray& __v) noexcept
{
    std::__1::swap(__begin_, __v.__begin_);
    std::__1::swap(__end_, __v.__end_);
}

template <class _Tp>
inline
_Tp
valarray<_Tp>::sum() const
{
    if (__begin_ == __end_)
        return value_type();
    const value_type* __p = __begin_;
    _Tp __r = *__p;
    for (++__p; __p != __end_; ++__p)
        __r += *__p;
    return __r;
}

template <class _Tp>
inline
_Tp
valarray<_Tp>::min() const
{
    if (__begin_ == __end_)
        return value_type();
    return *std::__1::min_element(__begin_, __end_);
}

template <class _Tp>
inline
_Tp
valarray<_Tp>::max() const
{
    if (__begin_ == __end_)
        return value_type();
    return *std::__1::max_element(__begin_, __end_);
}

template <class _Tp>
valarray<_Tp>
valarray<_Tp>::shift(int __i) const
{
    valarray<value_type> __r;
    size_t __n = size();
    if (__n)
    {
        __r.__begin_ = __r.__end_ = allocator<value_type>().allocate(__n);
        const value_type* __sb;
        value_type* __tb;
        value_type* __te;
        if (__i >= 0)
        {
            __i = std::__1::min(__i, static_cast<int>(__n));
            __sb = __begin_ + __i;
            __tb = __r.__begin_;
            __te = __r.__begin_ + (__n - __i);
        }
        else
        {
            __i = std::__1::min(-__i, static_cast<int>(__n));
            __sb = __begin_;
            __tb = __r.__begin_ + __i;
            __te = __r.__begin_ + __n;
        }
        for (; __r.__end_ != __tb; ++__r.__end_)
            ::new ((void*)__r.__end_) value_type();
        for (; __r.__end_ != __te; ++__r.__end_, ++__sb)
            ::new ((void*)__r.__end_) value_type(*__sb);
        for (__te = __r.__begin_ + __n; __r.__end_ != __te; ++__r.__end_)
            ::new ((void*)__r.__end_) value_type();
    }
    return __r;
}

template <class _Tp>
valarray<_Tp>
valarray<_Tp>::cshift(int __i) const
{
    valarray<value_type> __r;
    size_t __n = size();
    if (__n)
    {
        __r.__begin_ = __r.__end_ = allocator<value_type>().allocate(__n);
        __i %= static_cast<int>(__n);
        const value_type* __m = __i >= 0 ? __begin_ + __i : __end_ + __i;
        for (const value_type* __s = __m; __s != __end_; ++__r.__end_, ++__s)
            ::new ((void*)__r.__end_) value_type(*__s);
        for (const value_type* __s = __begin_; __s != __m; ++__r.__end_, ++__s)
            ::new ((void*)__r.__end_) value_type(*__s);
    }
    return __r;
}

template <class _Tp>
valarray<_Tp>
valarray<_Tp>::apply(value_type __f(value_type)) const
{
    valarray<value_type> __r;
    size_t __n = size();
    if (__n)
    {
        __r.__begin_ = __r.__end_ = allocator<value_type>().allocate(__n);
        for (const value_type* __p = __begin_; __n; ++__r.__end_, ++__p, --__n)
            ::new ((void*)__r.__end_) value_type(__f(*__p));
    }
    return __r;
}

template <class _Tp>
valarray<_Tp>
valarray<_Tp>::apply(value_type __f(const value_type&)) const
{
    valarray<value_type> __r;
    size_t __n = size();
    if (__n)
    {
        __r.__begin_ = __r.__end_ = allocator<value_type>().allocate(__n);
        for (const value_type* __p = __begin_; __n; ++__r.__end_, ++__p, --__n)
            ::new ((void*)__r.__end_) value_type(__f(*__p));
    }
    return __r;
}

template <class _Tp>
inline
void valarray<_Tp>::__clear(size_t __capacity)
{
  if (__begin_ != nullptr)
  {
    while (__end_ != __begin_)
      (--__end_)->~value_type();
    allocator<value_type>().deallocate(__begin_, __capacity);
    __begin_ = __end_ = nullptr;
  }
}

template <class _Tp>
void
valarray<_Tp>::resize(size_t __n, value_type __x)
{
    __clear(size());
    if (__n)
    {
        __begin_ = __end_ = allocator<value_type>().allocate(__n);

        try
        {

            for (size_t __n_left = __n; __n_left; --__n_left, ++__end_)
                ::new ((void*)__end_) value_type(__x);

        }
        catch (...)
        {
            __clear(__n);
            throw;
        }

    }
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void
swap(valarray<_Tp>& __x, valarray<_Tp>& __y) noexcept
{
    __x.swap(__y);
}

template<class _Expr1, class _Expr2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename enable_if
<
    __is_val_expr<_Expr1>::value && __is_val_expr<_Expr2>::value,
    __val_expr<_BinaryOp<multiplies<typename _Expr1::value_type>, _Expr1, _Expr2> >
>::type
operator*(const _Expr1& __x, const _Expr2& __y)
{
    typedef typename _Expr1::value_type value_type;
    typedef _BinaryOp<multiplies<value_type>, _Expr1, _Expr2> _Op;
    return __val_expr<_Op>(_Op(multiplies<value_type>(), __x, __y));
}

template<class _Expr>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename enable_if
<
    __is_val_expr<_Expr>::value,
    __val_expr<_BinaryOp<multiplies<typename _Expr::value_type>,
               _Expr, __scalar_expr<typename _Expr::value_type> > >
>::type
operator*(const _Expr& __x, const typename _Expr::value_type& __y)
{
    typedef typename _Expr::value_type value_type;
    typedef _BinaryOp<multiplies<value_type>, _Expr, __scalar_expr<value_type> > _Op;
    return __val_expr<_Op>(_Op(multiplies<value_type>(),
                           __x, __scalar_expr<value_type>(__y, __x.size())));
}

template<class _Expr>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename enable_if
<
    __is_val_expr<_Expr>::value,
    __val_expr<_BinaryOp<multiplies<typename _Expr::value_type>,
               __scalar_expr<typename _Expr::value_type>, _Expr> >
>::type
operator*(const typename _Expr::value_type& __x, const _Expr& __y)
{
    typedef typename _Expr::value_type value_type;
    typedef _BinaryOp<multiplies<value_type>, __scalar_expr<value_type>, _Expr> _Op;
    return __val_expr<_Op>(_Op(multiplies<value_type>(),
                           __scalar_expr<value_type>(__x, __y.size()), __y));
}

template<class _Expr1, class _Expr2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename enable_if
<
    __is_val_expr<_Expr1>::value && __is_val_expr<_Expr2>::value,
    __val_expr<_BinaryOp<divides<typename _Expr1::value_type>, _Expr1, _Expr2> >
>::type
operator/(const _Expr1& __x, const _Expr2& __y)
{
    typedef typename _Expr1::value_type value_type;
    typedef _BinaryOp<divides<value_type>, _Expr1, _Expr2> _Op;
    return __val_expr<_Op>(_Op(divides<value_type>(), __x, __y));
}

template<class _Expr>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename enable_if
<
    __is_val_expr<_Expr>::value,
    __val_expr<_BinaryOp<divides<typename _Expr::value_type>,
               _Expr, __scalar_expr<typename _Expr::value_type> > >
>::type
operator/(const _Expr& __x, const typename _Expr::value_type& __y)
{
    typedef typename _Expr::value_type value_type;
    typedef _BinaryOp<divides<value_type>, _Expr, __scalar_expr<value_type> > _Op;
    return __val_expr<_Op>(_Op(divides<value_type>(),
                           __x, __scalar_expr<value_type>(__y, __x.size())));
}

template<class _Expr>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename enable_if
<
    __is_val_expr<_Expr>::value,
    __val_expr<_BinaryOp<divides<typename _Expr::value_type>,
               __scalar_expr<typename _Expr::value_type>, _Expr> >
>::type
operator/(const typename _Expr::value_type& __x, const _Expr& __y)
{
    typedef typename _Expr::value_type value_type;
    typedef _BinaryOp<divides<value_type>, __scalar_expr<value_type>, _Expr> _Op;
    return __val_expr<_Op>(_Op(divides<value_type>(),
                           __scalar_expr<value_type>(__x, __y.size()), __y));
}

template<class _Expr1, class _Expr2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename enable_if
<
    __is_val_expr<_Expr1>::value && __is_val_expr<_Expr2>::value,
    __val_expr<_BinaryOp<modulus<typename _Expr1::value_type>, _Expr1, _Expr2> >
>::type
operator%(const _Expr1& __x, const _Expr2& __y)
{
    typedef typename _Expr1::value_type value_type;
    typedef _BinaryOp<modulus<value_type>, _Expr1, _Expr2> _Op;
    return __val_expr<_Op>(_Op(modulus<value_type>(), __x, __y));
}

template<class _Expr>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename enable_if
<
    __is_val_expr<_Expr>::value,
    __val_expr<_BinaryOp<modulus<typename _Expr::value_type>,
               _Expr, __scalar_expr<typename _Expr::value_type> > >
>::type
operator%(const _Expr& __x, const typename _Expr::value_type& __y)
{
    typedef typename _Expr::value_type value_type;
    typedef _BinaryOp<modulus<value_type>, _Expr, __scalar_expr<value_type> > _Op;
    return __val_expr<_Op>(_Op(modulus<value_type>(),
                           __x, __scalar_expr<value_type>(__y, __x.size())));
}

template<class _Expr>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename enable_if
<
    __is_val_expr<_Expr>::value,
    __val_expr<_BinaryOp<modulus<typename _Expr::value_type>,
               __scalar_expr<typename _Expr::value_type>, _Expr> >
>::type
operator%(const typename _Expr::value_type& __x, const _Expr& __y)
{
    typedef typename _Expr::value_type value_type;
    typedef _BinaryOp<modulus<value_type>, __scalar_expr<value_type>, _Expr> _Op;
    return __val_expr<_Op>(_Op(modulus<value_type>(),
                           __scalar_expr<value_type>(__x, __y.size()), __y));
}

template<class _Expr1, class _Expr2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename enable_if
<
    __is_val_expr<_Expr1>::value && __is_val_expr<_Expr2>::value,
    __val_expr<_BinaryOp<plus<typename _Expr1::value_type>, _Expr1, _Expr2> >
>::type
operator+(const _Expr1& __x, const _Expr2& __y)
{
    typedef typename _Expr1::value_type value_type;
    typedef _BinaryOp<plus<value_type>, _Expr1, _Expr2> _Op;
    return __val_expr<_Op>(_Op(plus<value_type>(), __x, __y));
}

template<class _Expr>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename enable_if
<
    __is_val_expr<_Expr>::value,
    __val_expr<_BinaryOp<plus<typename _Expr::value_type>,
               _Expr, __scalar_expr<typename _Expr::value_type> > >
>::type
operator+(const _Expr& __x, const typename _Expr::value_type& __y)
{
    typedef typename _Expr::value_type value_type;
    typedef _BinaryOp<plus<value_type>, _Expr, __scalar_expr<value_type> > _Op;
    return __val_expr<_Op>(_Op(plus<value_type>(),
                           __x, __scalar_expr<value_type>(__y, __x.size())));
}

template<class _Expr>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename enable_if
<
    __is_val_expr<_Expr>::value,
    __val_expr<_BinaryOp<plus<typename _Expr::value_type>,
               __scalar_expr<typename _Expr::value_type>, _Expr> >
>::type
operator+(const typename _Expr::value_type& __x, const _Expr& __y)
{
    typedef typename _Expr::value_type value_type;
    typedef _BinaryOp<plus<value_type>, __scalar_expr<value_type>, _Expr> _Op;
    return __val_expr<_Op>(_Op(plus<value_type>(),
                           __scalar_expr<value_type>(__x, __y.size()), __y));
}

template<class _Expr1, class _Expr2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename enable_if
<
    __is_val_expr<_Expr1>::value && __is_val_expr<_Expr2>::value,
    __val_expr<_BinaryOp<minus<typename _Expr1::value_type>, _Expr1, _Expr2> >
>::type
operator-(const _Expr1& __x, const _Expr2& __y)
{
    typedef typename _Expr1::value_type value_type;
    typedef _BinaryOp<minus<value_type>, _Expr1, _Expr2> _Op;
    return __val_expr<_Op>(_Op(minus<value_type>(), __x, __y));
}

template<class _Expr>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename enable_if
<
    __is_val_expr<_Expr>::value,
    __val_expr<_BinaryOp<minus<typename _Expr::value_type>,
               _Expr, __scalar_expr<typename _Expr::value_type> > >
>::type
operator-(const _Expr& __x, const typename _Expr::value_type& __y)
{
    typedef typename _Expr::value_type value_type;
    typedef _BinaryOp<minus<value_type>, _Expr, __scalar_expr<value_type> > _Op;
    return __val_expr<_Op>(_Op(minus<value_type>(),
                           __x, __scalar_expr<value_type>(__y, __x.size())));
}

template<class _Expr>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename enable_if
<
    __is_val_expr<_Expr>::value,
    __val_expr<_BinaryOp<minus<typename _Expr::value_type>,
               __scalar_expr<typename _Expr::value_type>, _Expr> >
>::type
operator-(const typename _Expr::value_type& __x, const _Expr& __y)
{
    typedef typename _Expr::value_type value_type;
    typedef _BinaryOp<minus<value_type>, __scalar_expr<value_type>, _Expr> _Op;
    return __val_expr<_Op>(_Op(minus<value_type>(),
                           __scalar_expr<value_type>(__x, __y.size()), __y));
}

template<class _Expr1, class _Expr2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename enable_if
<
    __is_val_expr<_Expr1>::value && __is_val_expr<_Expr2>::value,
    __val_expr<_BinaryOp<bit_xor<typename _Expr1::value_type>, _Expr1, _Expr2> >
>::type
operator^(const _Expr1& __x, const _Expr2& __y)
{
    typedef typename _Expr1::value_type value_type;
    typedef _BinaryOp<bit_xor<value_type>, _Expr1, _Expr2> _Op;
    return __val_expr<_Op>(_Op(bit_xor<value_type>(), __x, __y));
}

template<class _Expr>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename enable_if
<
    __is_val_expr<_Expr>::value,
    __val_expr<_BinaryOp<bit_xor<typename _Expr::value_type>,
               _Expr, __scalar_expr<typename _Expr::value_type> > >
>::type
operator^(const _Expr& __x, const typename _Expr::value_type& __y)
{
    typedef typename _Expr::value_type value_type;
    typedef _BinaryOp<bit_xor<value_type>, _Expr, __scalar_expr<value_type> > _Op;
    return __val_expr<_Op>(_Op(bit_xor<value_type>(),
                           __x, __scalar_expr<value_type>(__y, __x.size())));
}

template<class _Expr>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename enable_if
<
    __is_val_expr<_Expr>::value,
    __val_expr<_BinaryOp<bit_xor<typename _Expr::value_type>,
               __scalar_expr<typename _Expr::value_type>, _Expr> >
>::type
operator^(const typename _Expr::value_type& __x, const _Expr& __y)
{
    typedef typename _Expr::value_type value_type;
    typedef _BinaryOp<bit_xor<value_type>, __scalar_expr<value_type>, _Expr> _Op;
    return __val_expr<_Op>(_Op(bit_xor<value_type>(),
                           __scalar_expr<value_type>(__x, __y.size()), __y));
}

template<class _Expr1, class _Expr2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename enable_if
<
    __is_val_expr<_Expr1>::value && __is_val_expr<_Expr2>::value,
    __val_expr<_BinaryOp<bit_and<typename _Expr1::value_type>, _Expr1, _Expr2> >
>::type
operator&(const _Expr1& __x, const _Expr2& __y)
{
    typedef typename _Expr1::value_type value_type;
    typedef _BinaryOp<bit_and<value_type>, _Expr1, _Expr2> _Op;
    return __val_expr<_Op>(_Op(bit_and<value_type>(), __x, __y));
}

template<class _Expr>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename enable_if
<
    __is_val_expr<_Expr>::value,
    __val_expr<_BinaryOp<bit_and<typename _Expr::value_type>,
               _Expr, __scalar_expr<typename _Expr::value_type> > >
>::type
operator&(const _Expr& __x, const typename _Expr::value_type& __y)
{
    typedef typename _Expr::value_type value_type;
    typedef _BinaryOp<bit_and<value_type>, _Expr, __scalar_expr<value_type> > _Op;
    return __val_expr<_Op>(_Op(bit_and<value_type>(),
                           __x, __scalar_expr<value_type>(__y, __x.size())));
}

template<class _Expr>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename enable_if
<
    __is_val_expr<_Expr>::value,
    __val_expr<_BinaryOp<bit_and<typename _Expr::value_type>,
               __scalar_expr<typename _Expr::value_type>, _Expr> >
>::type
operator&(const typename _Expr::value_type& __x, const _Expr& __y)
{
    typedef typename _Expr::value_type value_type;
    typedef _BinaryOp<bit_and<value_type>, __scalar_expr<value_type>, _Expr> _Op;
    return __val_expr<_Op>(_Op(bit_and<value_type>(),
                           __scalar_expr<value_type>(__x, __y.size()), __y));
}

template<class _Expr1, class _Expr2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename enable_if
<
    __is_val_expr<_Expr1>::value && __is_val_expr<_Expr2>::value,
    __val_expr<_BinaryOp<bit_or<typename _Expr1::value_type>, _Expr1, _Expr2> >
>::type
operator|(const _Expr1& __x, const _Expr2& __y)
{
    typedef typename _Expr1::value_type value_type;
    typedef _BinaryOp<bit_or<value_type>, _Expr1, _Expr2> _Op;
    return __val_expr<_Op>(_Op(bit_or<value_type>(), __x, __y));
}

template<class _Expr>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename enable_if
<
    __is_val_expr<_Expr>::value,
    __val_expr<_BinaryOp<bit_or<typename _Expr::value_type>,
               _Expr, __scalar_expr<typename _Expr::value_type> > >
>::type
operator|(const _Expr& __x, const typename _Expr::value_type& __y)
{
    typedef typename _Expr::value_type value_type;
    typedef _BinaryOp<bit_or<value_type>, _Expr, __scalar_expr<value_type> > _Op;
    return __val_expr<_Op>(_Op(bit_or<value_type>(),
                           __x, __scalar_expr<value_type>(__y, __x.size())));
}

template<class _Expr>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename enable_if
<
    __is_val_expr<_Expr>::value,
    __val_expr<_BinaryOp<bit_or<typename _Expr::value_type>,
               __scalar_expr<typename _Expr::value_type>, _Expr> >
>::type
operator|(const typename _Expr::value_type& __x, const _Expr& __y)
{
    typedef typename _Expr::value_type value_type;
    typedef _BinaryOp<bit_or<value_type>, __scalar_expr<value_type>, _Expr> _Op;
    return __val_expr<_Op>(_Op(bit_or<value_type>(),
                           __scalar_expr<value_type>(__x, __y.size()), __y));
}

template<class _Expr1, class _Expr2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename enable_if
<
    __is_val_expr<_Expr1>::value && __is_val_expr<_Expr2>::value,
    __val_expr<_BinaryOp<__bit_shift_left<typename _Expr1::value_type>, _Expr1, _Expr2> >
>::type
operator<<(const _Expr1& __x, const _Expr2& __y)
{
    typedef typename _Expr1::value_type value_type;
    typedef _BinaryOp<__bit_shift_left<value_type>, _Expr1, _Expr2> _Op;
    return __val_expr<_Op>(_Op(__bit_shift_left<value_type>(), __x, __y));
}

template<class _Expr>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename enable_if
<
    __is_val_expr<_Expr>::value,
    __val_expr<_BinaryOp<__bit_shift_left<typename _Expr::value_type>,
               _Expr, __scalar_expr<typename _Expr::value_type> > >
>::type
operator<<(const _Expr& __x, const typename _Expr::value_type& __y)
{
    typedef typename _Expr::value_type value_type;
    typedef _BinaryOp<__bit_shift_left<value_type>, _Expr, __scalar_expr<value_type> > _Op;
    return __val_expr<_Op>(_Op(__bit_shift_left<value_type>(),
                           __x, __scalar_expr<value_type>(__y, __x.size())));
}

template<class _Expr>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename enable_if
<
    __is_val_expr<_Expr>::value,
    __val_expr<_BinaryOp<__bit_shift_left<typename _Expr::value_type>,
               __scalar_expr<typename _Expr::value_type>, _Expr> >
>::type
operator<<(const typename _Expr::value_type& __x, const _Expr& __y)
{
    typedef typename _Expr::value_type value_type;
    typedef _BinaryOp<__bit_shift_left<value_type>, __scalar_expr<value_type>, _Expr> _Op;
    return __val_expr<_Op>(_Op(__bit_shift_left<value_type>(),
                           __scalar_expr<value_type>(__x, __y.size()), __y));
}

template<class _Expr1, class _Expr2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename enable_if
<
    __is_val_expr<_Expr1>::value && __is_val_expr<_Expr2>::value,
    __val_expr<_BinaryOp<__bit_shift_right<typename _Expr1::value_type>, _Expr1, _Expr2> >
>::type
operator>>(const _Expr1& __x, const _Expr2& __y)
{
    typedef typename _Expr1::value_type value_type;
    typedef _BinaryOp<__bit_shift_right<value_type>, _Expr1, _Expr2> _Op;
    return __val_expr<_Op>(_Op(__bit_shift_right<value_type>(), __x, __y));
}

template<class _Expr>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename enable_if
<
    __is_val_expr<_Expr>::value,
    __val_expr<_BinaryOp<__bit_shift_right<typename _Expr::value_type>,
               _Expr, __scalar_expr<typename _Expr::value_type> > >
>::type
operator>>(const _Expr& __x, const typename _Expr::value_type& __y)
{
    typedef typename _Expr::value_type value_type;
    typedef _BinaryOp<__bit_shift_right<value_type>, _Expr, __scalar_expr<value_type> > _Op;
    return __val_expr<_Op>(_Op(__bit_shift_right<value_type>(),
                           __x, __scalar_expr<value_type>(__y, __x.size())));
}

template<class _Expr>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename enable_if
<
    __is_val_expr<_Expr>::value,
    __val_expr<_BinaryOp<__bit_shift_right<typename _Expr::value_type>,
               __scalar_expr<typename _Expr::value_type>, _Expr> >
>::type
operator>>(const typename _Expr::value_type& __x, const _Expr& __y)
{
    typedef typename _Expr::value_type value_type;
    typedef _BinaryOp<__bit_shift_right<value_type>, __scalar_expr<value_type>, _Expr> _Op;
    return __val_expr<_Op>(_Op(__bit_shift_right<value_type>(),
                           __scalar_expr<value_type>(__x, __y.size()), __y));
}

template<class _Expr1, class _Expr2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename enable_if
<
    __is_val_expr<_Expr1>::value && __is_val_expr<_Expr2>::value,
    __val_expr<_BinaryOp<logical_and<typename _Expr1::value_type>, _Expr1, _Expr2> >
>::type
operator&&(const _Expr1& __x, const _Expr2& __y)
{
    typedef typename _Expr1::value_type value_type;
    typedef _BinaryOp<logical_and<value_type>, _Expr1, _Expr2> _Op;
    return __val_expr<_Op>(_Op(logical_and<value_type>(), __x, __y));
}

template<class _Expr>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename enable_if
<
    __is_val_expr<_Expr>::value,
    __val_expr<_BinaryOp<logical_and<typename _Expr::value_type>,
               _Expr, __scalar_expr<typename _Expr::value_type> > >
>::type
operator&&(const _Expr& __x, const typename _Expr::value_type& __y)
{
    typedef typename _Expr::value_type value_type;
    typedef _BinaryOp<logical_and<value_type>, _Expr, __scalar_expr<value_type> > _Op;
    return __val_expr<_Op>(_Op(logical_and<value_type>(),
                           __x, __scalar_expr<value_type>(__y, __x.size())));
}

template<class _Expr>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename enable_if
<
    __is_val_expr<_Expr>::value,
    __val_expr<_BinaryOp<logical_and<typename _Expr::value_type>,
               __scalar_expr<typename _Expr::value_type>, _Expr> >
>::type
operator&&(const typename _Expr::value_type& __x, const _Expr& __y)
{
    typedef typename _Expr::value_type value_type;
    typedef _BinaryOp<logical_and<value_type>, __scalar_expr<value_type>, _Expr> _Op;
    return __val_expr<_Op>(_Op(logical_and<value_type>(),
                           __scalar_expr<value_type>(__x, __y.size()), __y));
}

template<class _Expr1, class _Expr2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename enable_if
<
    __is_val_expr<_Expr1>::value && __is_val_expr<_Expr2>::value,
    __val_expr<_BinaryOp<logical_or<typename _Expr1::value_type>, _Expr1, _Expr2> >
>::type
operator||(const _Expr1& __x, const _Expr2& __y)
{
    typedef typename _Expr1::value_type value_type;
    typedef _BinaryOp<logical_or<value_type>, _Expr1, _Expr2> _Op;
    return __val_expr<_Op>(_Op(logical_or<value_type>(), __x, __y));
}

template<class _Expr>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename enable_if
<
    __is_val_expr<_Expr>::value,
    __val_expr<_BinaryOp<logical_or<typename _Expr::value_type>,
               _Expr, __scalar_expr<typename _Expr::value_type> > >
>::type
operator||(const _Expr& __x, const typename _Expr::value_type& __y)
{
    typedef typename _Expr::value_type value_type;
    typedef _BinaryOp<logical_or<value_type>, _Expr, __scalar_expr<value_type> > _Op;
    return __val_expr<_Op>(_Op(logical_or<value_type>(),
                           __x, __scalar_expr<value_type>(__y, __x.size())));
}

template<class _Expr>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename enable_if
<
    __is_val_expr<_Expr>::value,
    __val_expr<_BinaryOp<logical_or<typename _Expr::value_type>,
               __scalar_expr<typename _Expr::value_type>, _Expr> >
>::type
operator||(const typename _Expr::value_type& __x, const _Expr& __y)
{
    typedef typename _Expr::value_type value_type;
    typedef _BinaryOp<logical_or<value_type>, __scalar_expr<value_type>, _Expr> _Op;
    return __val_expr<_Op>(_Op(logical_or<value_type>(),
                           __scalar_expr<value_type>(__x, __y.size()), __y));
}

template<class _Expr1, class _Expr2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename enable_if
<
    __is_val_expr<_Expr1>::value && __is_val_expr<_Expr2>::value,
    __val_expr<_BinaryOp<equal_to<typename _Expr1::value_type>, _Expr1, _Expr2> >
>::type
operator==(const _Expr1& __x, const _Expr2& __y)
{
    typedef typename _Expr1::value_type value_type;
    typedef _BinaryOp<equal_to<value_type>, _Expr1, _Expr2> _Op;
    return __val_expr<_Op>(_Op(equal_to<value_type>(), __x, __y));
}

template<class _Expr>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename enable_if
<
    __is_val_expr<_Expr>::value,
    __val_expr<_BinaryOp<equal_to<typename _Expr::value_type>,
               _Expr, __scalar_expr<typename _Expr::value_type> > >
>::type
operator==(const _Expr& __x, const typename _Expr::value_type& __y)
{
    typedef typename _Expr::value_type value_type;
    typedef _BinaryOp<equal_to<value_type>, _Expr, __scalar_expr<value_type> > _Op;
    return __val_expr<_Op>(_Op(equal_to<value_type>(),
                           __x, __scalar_expr<value_type>(__y, __x.size())));
}

template<class _Expr>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename enable_if
<
    __is_val_expr<_Expr>::value,
    __val_expr<_BinaryOp<equal_to<typename _Expr::value_type>,
               __scalar_expr<typename _Expr::value_type>, _Expr> >
>::type
operator==(const typename _Expr::value_type& __x, const _Expr& __y)
{
    typedef typename _Expr::value_type value_type;
    typedef _BinaryOp<equal_to<value_type>, __scalar_expr<value_type>, _Expr> _Op;
    return __val_expr<_Op>(_Op(equal_to<value_type>(),
                           __scalar_expr<value_type>(__x, __y.size()), __y));
}

template<class _Expr1, class _Expr2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename enable_if
<
    __is_val_expr<_Expr1>::value && __is_val_expr<_Expr2>::value,
    __val_expr<_BinaryOp<not_equal_to<typename _Expr1::value_type>, _Expr1, _Expr2> >
>::type
operator!=(const _Expr1& __x, const _Expr2& __y)
{
    typedef typename _Expr1::value_type value_type;
    typedef _BinaryOp<not_equal_to<value_type>, _Expr1, _Expr2> _Op;
    return __val_expr<_Op>(_Op(not_equal_to<value_type>(), __x, __y));
}

template<class _Expr>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename enable_if
<
    __is_val_expr<_Expr>::value,
    __val_expr<_BinaryOp<not_equal_to<typename _Expr::value_type>,
               _Expr, __scalar_expr<typename _Expr::value_type> > >
>::type
operator!=(const _Expr& __x, const typename _Expr::value_type& __y)
{
    typedef typename _Expr::value_type value_type;
    typedef _BinaryOp<not_equal_to<value_type>, _Expr, __scalar_expr<value_type> > _Op;
    return __val_expr<_Op>(_Op(not_equal_to<value_type>(),
                           __x, __scalar_expr<value_type>(__y, __x.size())));
}

template<class _Expr>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename enable_if
<
    __is_val_expr<_Expr>::value,
    __val_expr<_BinaryOp<not_equal_to<typename _Expr::value_type>,
               __scalar_expr<typename _Expr::value_type>, _Expr> >
>::type
operator!=(const typename _Expr::value_type& __x, const _Expr& __y)
{
    typedef typename _Expr::value_type value_type;
    typedef _BinaryOp<not_equal_to<value_type>, __scalar_expr<value_type>, _Expr> _Op;
    return __val_expr<_Op>(_Op(not_equal_to<value_type>(),
                           __scalar_expr<value_type>(__x, __y.size()), __y));
}

template<class _Expr1, class _Expr2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename enable_if
<
    __is_val_expr<_Expr1>::value && __is_val_expr<_Expr2>::value,
    __val_expr<_BinaryOp<less<typename _Expr1::value_type>, _Expr1, _Expr2> >
>::type
operator<(const _Expr1& __x, const _Expr2& __y)
{
    typedef typename _Expr1::value_type value_type;
    typedef _BinaryOp<less<value_type>, _Expr1, _Expr2> _Op;
    return __val_expr<_Op>(_Op(less<value_type>(), __x, __y));
}

template<class _Expr>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename enable_if
<
    __is_val_expr<_Expr>::value,
    __val_expr<_BinaryOp<less<typename _Expr::value_type>,
               _Expr, __scalar_expr<typename _Expr::value_type> > >
>::type
operator<(const _Expr& __x, const typename _Expr::value_type& __y)
{
    typedef typename _Expr::value_type value_type;
    typedef _BinaryOp<less<value_type>, _Expr, __scalar_expr<value_type> > _Op;
    return __val_expr<_Op>(_Op(less<value_type>(),
                           __x, __scalar_expr<value_type>(__y, __x.size())));
}

template<class _Expr>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename enable_if
<
    __is_val_expr<_Expr>::value,
    __val_expr<_BinaryOp<less<typename _Expr::value_type>,
               __scalar_expr<typename _Expr::value_type>, _Expr> >
>::type
operator<(const typename _Expr::value_type& __x, const _Expr& __y)
{
    typedef typename _Expr::value_type value_type;
    typedef _BinaryOp<less<value_type>, __scalar_expr<value_type>, _Expr> _Op;
    return __val_expr<_Op>(_Op(less<value_type>(),
                           __scalar_expr<value_type>(__x, __y.size()), __y));
}

template<class _Expr1, class _Expr2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename enable_if
<
    __is_val_expr<_Expr1>::value && __is_val_expr<_Expr2>::value,
    __val_expr<_BinaryOp<greater<typename _Expr1::value_type>, _Expr1, _Expr2> >
>::type
operator>(const _Expr1& __x, const _Expr2& __y)
{
    typedef typename _Expr1::value_type value_type;
    typedef _BinaryOp<greater<value_type>, _Expr1, _Expr2> _Op;
    return __val_expr<_Op>(_Op(greater<value_type>(), __x, __y));
}

template<class _Expr>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename enable_if
<
    __is_val_expr<_Expr>::value,
    __val_expr<_BinaryOp<greater<typename _Expr::value_type>,
               _Expr, __scalar_expr<typename _Expr::value_type> > >
>::type
operator>(const _Expr& __x, const typename _Expr::value_type& __y)
{
    typedef typename _Expr::value_type value_type;
    typedef _BinaryOp<greater<value_type>, _Expr, __scalar_expr<value_type> > _Op;
    return __val_expr<_Op>(_Op(greater<value_type>(),
                           __x, __scalar_expr<value_type>(__y, __x.size())));
}

template<class _Expr>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename enable_if
<
    __is_val_expr<_Expr>::value,
    __val_expr<_BinaryOp<greater<typename _Expr::value_type>,
               __scalar_expr<typename _Expr::value_type>, _Expr> >
>::type
operator>(const typename _Expr::value_type& __x, const _Expr& __y)
{
    typedef typename _Expr::value_type value_type;
    typedef _BinaryOp<greater<value_type>, __scalar_expr<value_type>, _Expr> _Op;
    return __val_expr<_Op>(_Op(greater<value_type>(),
                           __scalar_expr<value_type>(__x, __y.size()), __y));
}

template<class _Expr1, class _Expr2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename enable_if
<
    __is_val_expr<_Expr1>::value && __is_val_expr<_Expr2>::value,
    __val_expr<_BinaryOp<less_equal<typename _Expr1::value_type>, _Expr1, _Expr2> >
>::type
operator<=(const _Expr1& __x, const _Expr2& __y)
{
    typedef typename _Expr1::value_type value_type;
    typedef _BinaryOp<less_equal<value_type>, _Expr1, _Expr2> _Op;
    return __val_expr<_Op>(_Op(less_equal<value_type>(), __x, __y));
}

template<class _Expr>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename enable_if
<
    __is_val_expr<_Expr>::value,
    __val_expr<_BinaryOp<less_equal<typename _Expr::value_type>,
               _Expr, __scalar_expr<typename _Expr::value_type> > >
>::type
operator<=(const _Expr& __x, const typename _Expr::value_type& __y)
{
    typedef typename _Expr::value_type value_type;
    typedef _BinaryOp<less_equal<value_type>, _Expr, __scalar_expr<value_type> > _Op;
    return __val_expr<_Op>(_Op(less_equal<value_type>(),
                           __x, __scalar_expr<value_type>(__y, __x.size())));
}

template<class _Expr>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename enable_if
<
    __is_val_expr<_Expr>::value,
    __val_expr<_BinaryOp<less_equal<typename _Expr::value_type>,
               __scalar_expr<typename _Expr::value_type>, _Expr> >
>::type
operator<=(const typename _Expr::value_type& __x, const _Expr& __y)
{
    typedef typename _Expr::value_type value_type;
    typedef _BinaryOp<less_equal<value_type>, __scalar_expr<value_type>, _Expr> _Op;
    return __val_expr<_Op>(_Op(less_equal<value_type>(),
                           __scalar_expr<value_type>(__x, __y.size()), __y));
}

template<class _Expr1, class _Expr2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename enable_if
<
    __is_val_expr<_Expr1>::value && __is_val_expr<_Expr2>::value,
    __val_expr<_BinaryOp<greater_equal<typename _Expr1::value_type>, _Expr1, _Expr2> >
>::type
operator>=(const _Expr1& __x, const _Expr2& __y)
{
    typedef typename _Expr1::value_type value_type;
    typedef _BinaryOp<greater_equal<value_type>, _Expr1, _Expr2> _Op;
    return __val_expr<_Op>(_Op(greater_equal<value_type>(), __x, __y));
}

template<class _Expr>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename enable_if
<
    __is_val_expr<_Expr>::value,
    __val_expr<_BinaryOp<greater_equal<typename _Expr::value_type>,
               _Expr, __scalar_expr<typename _Expr::value_type> > >
>::type
operator>=(const _Expr& __x, const typename _Expr::value_type& __y)
{
    typedef typename _Expr::value_type value_type;
    typedef _BinaryOp<greater_equal<value_type>, _Expr, __scalar_expr<value_type> > _Op;
    return __val_expr<_Op>(_Op(greater_equal<value_type>(),
                           __x, __scalar_expr<value_type>(__y, __x.size())));
}

template<class _Expr>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename enable_if
<
    __is_val_expr<_Expr>::value,
    __val_expr<_BinaryOp<greater_equal<typename _Expr::value_type>,
               __scalar_expr<typename _Expr::value_type>, _Expr> >
>::type
operator>=(const typename _Expr::value_type& __x, const _Expr& __y)
{
    typedef typename _Expr::value_type value_type;
    typedef _BinaryOp<greater_equal<value_type>, __scalar_expr<value_type>, _Expr> _Op;
    return __val_expr<_Op>(_Op(greater_equal<value_type>(),
                           __scalar_expr<value_type>(__x, __y.size()), __y));
}

template<class _Expr>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename enable_if
<
    __is_val_expr<_Expr>::value,
    __val_expr<_UnaryOp<__abs_expr<typename _Expr::value_type>, _Expr> >
>::type
abs(const _Expr& __x)
{
    typedef typename _Expr::value_type value_type;
    typedef _UnaryOp<__abs_expr<value_type>, _Expr> _Op;
    return __val_expr<_Op>(_Op(__abs_expr<value_type>(), __x));
}

template<class _Expr>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename enable_if
<
    __is_val_expr<_Expr>::value,
    __val_expr<_UnaryOp<__acos_expr<typename _Expr::value_type>, _Expr> >
>::type
acos(const _Expr& __x)
{
    typedef typename _Expr::value_type value_type;
    typedef _UnaryOp<__acos_expr<value_type>, _Expr> _Op;
    return __val_expr<_Op>(_Op(__acos_expr<value_type>(), __x));
}

template<class _Expr>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename enable_if
<
    __is_val_expr<_Expr>::value,
    __val_expr<_UnaryOp<__asin_expr<typename _Expr::value_type>, _Expr> >
>::type
asin(const _Expr& __x)
{
    typedef typename _Expr::value_type value_type;
    typedef _UnaryOp<__asin_expr<value_type>, _Expr> _Op;
    return __val_expr<_Op>(_Op(__asin_expr<value_type>(), __x));
}

template<class _Expr>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename enable_if
<
    __is_val_expr<_Expr>::value,
    __val_expr<_UnaryOp<__atan_expr<typename _Expr::value_type>, _Expr> >
>::type
atan(const _Expr& __x)
{
    typedef typename _Expr::value_type value_type;
    typedef _UnaryOp<__atan_expr<value_type>, _Expr> _Op;
    return __val_expr<_Op>(_Op(__atan_expr<value_type>(), __x));
}

template<class _Expr1, class _Expr2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename enable_if
<
    __is_val_expr<_Expr1>::value && __is_val_expr<_Expr2>::value,
    __val_expr<_BinaryOp<__atan2_expr<typename _Expr1::value_type>, _Expr1, _Expr2> >
>::type
atan2(const _Expr1& __x, const _Expr2& __y)
{
    typedef typename _Expr1::value_type value_type;
    typedef _BinaryOp<__atan2_expr<value_type>, _Expr1, _Expr2> _Op;
    return __val_expr<_Op>(_Op(__atan2_expr<value_type>(), __x, __y));
}

template<class _Expr>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename enable_if
<
    __is_val_expr<_Expr>::value,
    __val_expr<_BinaryOp<__atan2_expr<typename _Expr::value_type>,
               _Expr, __scalar_expr<typename _Expr::value_type> > >
>::type
atan2(const _Expr& __x, const typename _Expr::value_type& __y)
{
    typedef typename _Expr::value_type value_type;
    typedef _BinaryOp<__atan2_expr<value_type>, _Expr, __scalar_expr<value_type> > _Op;
    return __val_expr<_Op>(_Op(__atan2_expr<value_type>(),
                           __x, __scalar_expr<value_type>(__y, __x.size())));
}

template<class _Expr>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename enable_if
<
    __is_val_expr<_Expr>::value,
    __val_expr<_BinaryOp<__atan2_expr<typename _Expr::value_type>,
               __scalar_expr<typename _Expr::value_type>, _Expr> >
>::type
atan2(const typename _Expr::value_type& __x, const _Expr& __y)
{
    typedef typename _Expr::value_type value_type;
    typedef _BinaryOp<__atan2_expr<value_type>, __scalar_expr<value_type>, _Expr> _Op;
    return __val_expr<_Op>(_Op(__atan2_expr<value_type>(),
                           __scalar_expr<value_type>(__x, __y.size()), __y));
}

template<class _Expr>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename enable_if
<
    __is_val_expr<_Expr>::value,
    __val_expr<_UnaryOp<__cos_expr<typename _Expr::value_type>, _Expr> >
>::type
cos(const _Expr& __x)
{
    typedef typename _Expr::value_type value_type;
    typedef _UnaryOp<__cos_expr<value_type>, _Expr> _Op;
    return __val_expr<_Op>(_Op(__cos_expr<value_type>(), __x));
}

template<class _Expr>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename enable_if
<
    __is_val_expr<_Expr>::value,
    __val_expr<_UnaryOp<__cosh_expr<typename _Expr::value_type>, _Expr> >
>::type
cosh(const _Expr& __x)
{
    typedef typename _Expr::value_type value_type;
    typedef _UnaryOp<__cosh_expr<value_type>, _Expr> _Op;
    return __val_expr<_Op>(_Op(__cosh_expr<value_type>(), __x));
}

template<class _Expr>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename enable_if
<
    __is_val_expr<_Expr>::value,
    __val_expr<_UnaryOp<__exp_expr<typename _Expr::value_type>, _Expr> >
>::type
exp(const _Expr& __x)
{
    typedef typename _Expr::value_type value_type;
    typedef _UnaryOp<__exp_expr<value_type>, _Expr> _Op;
    return __val_expr<_Op>(_Op(__exp_expr<value_type>(), __x));
}

template<class _Expr>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename enable_if
<
    __is_val_expr<_Expr>::value,
    __val_expr<_UnaryOp<__log_expr<typename _Expr::value_type>, _Expr> >
>::type
log(const _Expr& __x)
{
    typedef typename _Expr::value_type value_type;
    typedef _UnaryOp<__log_expr<value_type>, _Expr> _Op;
    return __val_expr<_Op>(_Op(__log_expr<value_type>(), __x));
}

template<class _Expr>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename enable_if
<
    __is_val_expr<_Expr>::value,
    __val_expr<_UnaryOp<__log10_expr<typename _Expr::value_type>, _Expr> >
>::type
log10(const _Expr& __x)
{
    typedef typename _Expr::value_type value_type;
    typedef _UnaryOp<__log10_expr<value_type>, _Expr> _Op;
    return __val_expr<_Op>(_Op(__log10_expr<value_type>(), __x));
}

template<class _Expr1, class _Expr2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename enable_if
<
    __is_val_expr<_Expr1>::value && __is_val_expr<_Expr2>::value,
    __val_expr<_BinaryOp<__pow_expr<typename _Expr1::value_type>, _Expr1, _Expr2> >
>::type
pow(const _Expr1& __x, const _Expr2& __y)
{
    typedef typename _Expr1::value_type value_type;
    typedef _BinaryOp<__pow_expr<value_type>, _Expr1, _Expr2> _Op;
    return __val_expr<_Op>(_Op(__pow_expr<value_type>(), __x, __y));
}

template<class _Expr>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename enable_if
<
    __is_val_expr<_Expr>::value,
    __val_expr<_BinaryOp<__pow_expr<typename _Expr::value_type>,
               _Expr, __scalar_expr<typename _Expr::value_type> > >
>::type
pow(const _Expr& __x, const typename _Expr::value_type& __y)
{
    typedef typename _Expr::value_type value_type;
    typedef _BinaryOp<__pow_expr<value_type>, _Expr, __scalar_expr<value_type> > _Op;
    return __val_expr<_Op>(_Op(__pow_expr<value_type>(),
                           __x, __scalar_expr<value_type>(__y, __x.size())));
}

template<class _Expr>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename enable_if
<
    __is_val_expr<_Expr>::value,
    __val_expr<_BinaryOp<__pow_expr<typename _Expr::value_type>,
               __scalar_expr<typename _Expr::value_type>, _Expr> >
>::type
pow(const typename _Expr::value_type& __x, const _Expr& __y)
{
    typedef typename _Expr::value_type value_type;
    typedef _BinaryOp<__pow_expr<value_type>, __scalar_expr<value_type>, _Expr> _Op;
    return __val_expr<_Op>(_Op(__pow_expr<value_type>(),
                           __scalar_expr<value_type>(__x, __y.size()), __y));
}

template<class _Expr>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename enable_if
<
    __is_val_expr<_Expr>::value,
    __val_expr<_UnaryOp<__sin_expr<typename _Expr::value_type>, _Expr> >
>::type
sin(const _Expr& __x)
{
    typedef typename _Expr::value_type value_type;
    typedef _UnaryOp<__sin_expr<value_type>, _Expr> _Op;
    return __val_expr<_Op>(_Op(__sin_expr<value_type>(), __x));
}

template<class _Expr>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename enable_if
<
    __is_val_expr<_Expr>::value,
    __val_expr<_UnaryOp<__sinh_expr<typename _Expr::value_type>, _Expr> >
>::type
sinh(const _Expr& __x)
{
    typedef typename _Expr::value_type value_type;
    typedef _UnaryOp<__sinh_expr<value_type>, _Expr> _Op;
    return __val_expr<_Op>(_Op(__sinh_expr<value_type>(), __x));
}

template<class _Expr>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename enable_if
<
    __is_val_expr<_Expr>::value,
    __val_expr<_UnaryOp<__sqrt_expr<typename _Expr::value_type>, _Expr> >
>::type
sqrt(const _Expr& __x)
{
    typedef typename _Expr::value_type value_type;
    typedef _UnaryOp<__sqrt_expr<value_type>, _Expr> _Op;
    return __val_expr<_Op>(_Op(__sqrt_expr<value_type>(), __x));
}

template<class _Expr>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename enable_if
<
    __is_val_expr<_Expr>::value,
    __val_expr<_UnaryOp<__tan_expr<typename _Expr::value_type>, _Expr> >
>::type
tan(const _Expr& __x)
{
    typedef typename _Expr::value_type value_type;
    typedef _UnaryOp<__tan_expr<value_type>, _Expr> _Op;
    return __val_expr<_Op>(_Op(__tan_expr<value_type>(), __x));
}

template<class _Expr>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename enable_if
<
    __is_val_expr<_Expr>::value,
    __val_expr<_UnaryOp<__tanh_expr<typename _Expr::value_type>, _Expr> >
>::type
tanh(const _Expr& __x)
{
    typedef typename _Expr::value_type value_type;
    typedef _UnaryOp<__tanh_expr<value_type>, _Expr> _Op;
    return __val_expr<_Op>(_Op(__tanh_expr<value_type>(), __x));
}

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
_Tp*
begin(valarray<_Tp>& __v)
{
    return __v.__begin_;
}

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
const _Tp*
begin(const valarray<_Tp>& __v)
{
    return __v.__begin_;
}

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
_Tp*
end(valarray<_Tp>& __v)
{
    return __v.__end_;
}

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
const _Tp*
end(const valarray<_Tp>& __v)
{
    return __v.__end_;
}

} }
# 209 "/usr/local/include/bits/stdc++.h" 2







# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/array" 1 3
# 118 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/array" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 1 3
# 119 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/array" 2 3
# 124 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/array" 3


namespace std { inline namespace __1 {

template <class _Tp, size_t _Size>
struct __attribute__ ((__type_visibility__("default"))) array
{

    typedef array __self;
    typedef _Tp value_type;
    typedef value_type& reference;
    typedef const value_type& const_reference;
    typedef value_type* iterator;
    typedef const value_type* const_iterator;
    typedef value_type* pointer;
    typedef const value_type* const_pointer;
    typedef size_t size_type;
    typedef ptrdiff_t difference_type;
    typedef std::__1::reverse_iterator<iterator> reverse_iterator;
    typedef std::__1::reverse_iterator<const_iterator> const_reverse_iterator;

    _Tp __elems_[_Size];


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void fill(const value_type& __u) {
        std::__1::fill_n(data(), _Size, __u);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void swap(array& __a) noexcept(__is_nothrow_swappable<_Tp>::value) {
        std::__1::swap_ranges(data(), data() + _Size, __a.data());
    }


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
    iterator begin() noexcept {return iterator(data());}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
    const_iterator begin() const noexcept {return const_iterator(data());}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
    iterator end() noexcept {return iterator(data() + _Size);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
    const_iterator end() const noexcept {return const_iterator(data() + _Size);}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
    reverse_iterator rbegin() noexcept {return reverse_iterator(end());}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
    const_reverse_iterator rbegin() const noexcept {return const_reverse_iterator(end());}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
    reverse_iterator rend() noexcept {return reverse_iterator(begin());}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
    const_reverse_iterator rend() const noexcept {return const_reverse_iterator(begin());}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
    const_iterator cbegin() const noexcept {return begin();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
    const_iterator cend() const noexcept {return end();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
    const_reverse_iterator crbegin() const noexcept {return rbegin();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
    const_reverse_iterator crend() const noexcept {return rend();}


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    constexpr size_type size() const noexcept {return _Size;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    constexpr size_type max_size() const noexcept {return _Size;}
                                  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    constexpr bool empty() const noexcept {return _Size == 0;}


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
    reference operator[](size_type __n) noexcept {
        ((void)0);
        return __elems_[__n];
    }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
    const_reference operator[](size_type __n) const noexcept {
        ((void)0);
        return __elems_[__n];
    }

    constexpr reference at(size_type __n)
    {
        if (__n >= _Size)
            __throw_out_of_range("array::at");
        return __elems_[__n];
    }

    constexpr const_reference at(size_type __n) const
    {
        if (__n >= _Size)
            __throw_out_of_range("array::at");
        return __elems_[__n];
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr reference front() noexcept {return (*this)[0];}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr const_reference front() const noexcept {return (*this)[0];}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr reference back() noexcept {return (*this)[_Size - 1];}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr const_reference back() const noexcept {return (*this)[_Size - 1];}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
    value_type* data() noexcept {return __elems_;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
    const value_type* data() const noexcept {return __elems_;}
};

template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) array<_Tp, 0>
{

    typedef array __self;
    typedef _Tp value_type;
    typedef value_type& reference;
    typedef const value_type& const_reference;
    typedef value_type* iterator;
    typedef const value_type* const_iterator;
    typedef value_type* pointer;
    typedef const value_type* const_pointer;
    typedef size_t size_type;
    typedef ptrdiff_t difference_type;
    typedef std::__1::reverse_iterator<iterator> reverse_iterator;
    typedef std::__1::reverse_iterator<const_iterator> const_reverse_iterator;

    typedef typename conditional<is_const<_Tp>::value, const char,
                                char>::type _CharType;

    struct _ArrayInStructT { _Tp __data_[1]; };
    alignas(_ArrayInStructT) _CharType __elems_[sizeof(_ArrayInStructT)];

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
    value_type* data() noexcept {return nullptr;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
    const value_type* data() const noexcept {return nullptr;}


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void fill(const value_type&) {
      static_assert(!is_const<_Tp>::value,
                    "cannot fill zero-sized array of type 'const T'");
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void swap(array&) noexcept {
      static_assert(!is_const<_Tp>::value,
                    "cannot swap zero-sized array of type 'const T'");
    }


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
    iterator begin() noexcept {return iterator(data());}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
    const_iterator begin() const noexcept {return const_iterator(data());}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
    iterator end() noexcept {return iterator(data());}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
    const_iterator end() const noexcept {return const_iterator(data());}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
    reverse_iterator rbegin() noexcept {return reverse_iterator(end());}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
    const_reverse_iterator rbegin() const noexcept {return const_reverse_iterator(end());}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
    reverse_iterator rend() noexcept {return reverse_iterator(begin());}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
    const_reverse_iterator rend() const noexcept {return const_reverse_iterator(begin());}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
    const_iterator cbegin() const noexcept {return begin();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
    const_iterator cend() const noexcept {return end();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
    const_reverse_iterator crbegin() const noexcept {return rbegin();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
    const_reverse_iterator crend() const noexcept {return rend();}


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    constexpr size_type size() const noexcept {return 0; }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    constexpr size_type max_size() const noexcept {return 0;}
                                  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    constexpr bool empty() const noexcept {return true;}


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
    reference operator[](size_type) noexcept {
      ((void)0);
      __builtin_unreachable();
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
    const_reference operator[](size_type) const noexcept {
      ((void)0);
      __builtin_unreachable();
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
    reference at(size_type) {
      __throw_out_of_range("array<T, 0>::at");
      __builtin_unreachable();
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
    const_reference at(size_type) const {
      __throw_out_of_range("array<T, 0>::at");
      __builtin_unreachable();
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
    reference front() noexcept {
      ((void)0);
      __builtin_unreachable();
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
    const_reference front() const noexcept {
      ((void)0);
      __builtin_unreachable();
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
    reference back() noexcept {
      ((void)0);
      __builtin_unreachable();
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
    const_reference back() const noexcept {
      ((void)0);
      __builtin_unreachable();
    }
};



template<class _Tp, class... _Args,
         class = _EnableIf<__all<_IsSame<_Tp, _Args>::value...>::value>
         >
array(_Tp, _Args...)
  -> array<_Tp, 1 + sizeof...(_Args)>;


template <class _Tp, size_t _Size>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
                              bool
operator==(const array<_Tp, _Size>& __x, const array<_Tp, _Size>& __y)
{
    return std::__1::equal(__x.begin(), __x.end(), __y.begin());
}

template <class _Tp, size_t _Size>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
                              bool
operator!=(const array<_Tp, _Size>& __x, const array<_Tp, _Size>& __y)
{
    return !(__x == __y);
}

template <class _Tp, size_t _Size>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
                              bool
operator<(const array<_Tp, _Size>& __x, const array<_Tp, _Size>& __y)
{
    return std::__1::lexicographical_compare(__x.begin(), __x.end(),
                                          __y.begin(), __y.end());
}

template <class _Tp, size_t _Size>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
                              bool
operator>(const array<_Tp, _Size>& __x, const array<_Tp, _Size>& __y)
{
    return __y < __x;
}

template <class _Tp, size_t _Size>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
                              bool
operator<=(const array<_Tp, _Size>& __x, const array<_Tp, _Size>& __y)
{
    return !(__y < __x);
}

template <class _Tp, size_t _Size>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
                              bool
operator>=(const array<_Tp, _Size>& __x, const array<_Tp, _Size>& __y)
{
    return !(__x < __y);
}

template <class _Tp, size_t _Size>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename enable_if
<
    _Size == 0 ||
    __is_swappable<_Tp>::value,
    void
>::type
swap(array<_Tp, _Size>& __x, array<_Tp, _Size>& __y)
                                  noexcept(noexcept(__x.swap(__y)))
{
    __x.swap(__y);
}

template <class _Tp, size_t _Size>
struct __attribute__ ((__type_visibility__("default"))) tuple_size<array<_Tp, _Size> >
    : public integral_constant<size_t, _Size> {};

template <size_t _Ip, class _Tp, size_t _Size>
struct __attribute__ ((__type_visibility__("default"))) tuple_element<_Ip, array<_Tp, _Size> >
{
    static_assert(_Ip < _Size, "Index out of bounds in std::tuple_element<> (std::array)");
    typedef _Tp type;
};

template <size_t _Ip, class _Tp, size_t _Size>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
_Tp&
get(array<_Tp, _Size>& __a) noexcept
{
    static_assert(_Ip < _Size, "Index out of bounds in std::get<> (std::array)");
    return __a.__elems_[_Ip];
}

template <size_t _Ip, class _Tp, size_t _Size>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
const _Tp&
get(const array<_Tp, _Size>& __a) noexcept
{
    static_assert(_Ip < _Size, "Index out of bounds in std::get<> (const std::array)");
    return __a.__elems_[_Ip];
}

template <size_t _Ip, class _Tp, size_t _Size>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
_Tp&&
get(array<_Tp, _Size>&& __a) noexcept
{
    static_assert(_Ip < _Size, "Index out of bounds in std::get<> (std::array &&)");
    return std::__1::move(__a.__elems_[_Ip]);
}

template <size_t _Ip, class _Tp, size_t _Size>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
const _Tp&&
get(const array<_Tp, _Size>&& __a) noexcept
{
    static_assert(_Ip < _Size, "Index out of bounds in std::get<> (const std::array &&)");
    return std::__1::move(__a.__elems_[_Ip]);
}
# 518 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/array" 3
} }
# 217 "/usr/local/include/bits/stdc++.h" 2








# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/codecvt" 1 3
# 62 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/codecvt" 3


namespace std { inline namespace __1 {

enum codecvt_mode
{
    consume_header = 4,
    generate_header = 2,
    little_endian = 1
};



template <class _Elem> class __codecvt_utf8;


template <>
class __attribute__ ((__visibility__("default"))) __codecvt_utf8<wchar_t>
    : public codecvt<wchar_t, char, mbstate_t>
{
    unsigned long _Maxcode_;
    codecvt_mode _Mode_;
public:
    typedef wchar_t intern_type;
    typedef char extern_type;
    typedef mbstate_t state_type;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit __codecvt_utf8(size_t __refs, unsigned long _Maxcode,
                            codecvt_mode _Mode)
        : codecvt<wchar_t, char, mbstate_t>(__refs), _Maxcode_(_Maxcode),
          _Mode_(_Mode) {}
protected:
    virtual result
        do_out(state_type& __st,
               const intern_type* __frm, const intern_type* __frm_end, const intern_type*& __frm_nxt,
               extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const;
    virtual result
        do_in(state_type& __st,
              const extern_type* __frm, const extern_type* __frm_end, const extern_type*& __frm_nxt,
              intern_type* __to, intern_type* __to_end, intern_type*& __to_nxt) const;
    virtual result
        do_unshift(state_type& __st,
                   extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const;
    virtual int do_encoding() const noexcept;
    virtual bool do_always_noconv() const noexcept;
    virtual int do_length(state_type&, const extern_type* __frm, const extern_type* __end,
                          size_t __mx) const;
    virtual int do_max_length() const noexcept;
};


#pragma GCC diagnostic push
# 114 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/codecvt" 3
#pragma GCC diagnostic ignored "-Wdeprecated"
# 114 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/codecvt" 3
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
template <>
class __attribute__ ((__visibility__("default"))) __codecvt_utf8<char16_t>
    : public codecvt<char16_t, char, mbstate_t>
{
    unsigned long _Maxcode_;
    codecvt_mode _Mode_;
public:
    typedef char16_t intern_type;
    typedef char extern_type;
    typedef mbstate_t state_type;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit __codecvt_utf8(size_t __refs, unsigned long _Maxcode,
                            codecvt_mode _Mode)
        : codecvt<char16_t, char, mbstate_t>(__refs), _Maxcode_(_Maxcode),
          _Mode_(_Mode) {}
#pragma GCC diagnostic pop

protected:
    virtual result
        do_out(state_type& __st,
               const intern_type* __frm, const intern_type* __frm_end, const intern_type*& __frm_nxt,
               extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const;
    virtual result
        do_in(state_type& __st,
              const extern_type* __frm, const extern_type* __frm_end, const extern_type*& __frm_nxt,
              intern_type* __to, intern_type* __to_end, intern_type*& __to_nxt) const;
    virtual result
        do_unshift(state_type& __st,
                   extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const;
    virtual int do_encoding() const noexcept;
    virtual bool do_always_noconv() const noexcept;
    virtual int do_length(state_type&, const extern_type* __frm, const extern_type* __end,
                          size_t __mx) const;
    virtual int do_max_length() const noexcept;
};

#pragma GCC diagnostic push
# 152 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/codecvt" 3
#pragma GCC diagnostic ignored "-Wdeprecated"
# 152 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/codecvt" 3
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
template <>
class __attribute__ ((__visibility__("default"))) __codecvt_utf8<char32_t>
    : public codecvt<char32_t, char, mbstate_t>
{
    unsigned long _Maxcode_;
    codecvt_mode _Mode_;
public:
    typedef char32_t intern_type;
    typedef char extern_type;
    typedef mbstate_t state_type;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit __codecvt_utf8(size_t __refs, unsigned long _Maxcode,
                            codecvt_mode _Mode)
        : codecvt<char32_t, char, mbstate_t>(__refs), _Maxcode_(_Maxcode),
          _Mode_(_Mode) {}
#pragma GCC diagnostic pop

protected:
    virtual result
        do_out(state_type& __st,
               const intern_type* __frm, const intern_type* __frm_end, const intern_type*& __frm_nxt,
               extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const;
    virtual result
        do_in(state_type& __st,
              const extern_type* __frm, const extern_type* __frm_end, const extern_type*& __frm_nxt,
              intern_type* __to, intern_type* __to_end, intern_type*& __to_nxt) const;
    virtual result
        do_unshift(state_type& __st,
                   extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const;
    virtual int do_encoding() const noexcept;
    virtual bool do_always_noconv() const noexcept;
    virtual int do_length(state_type&, const extern_type* __frm, const extern_type* __end,
                          size_t __mx) const;
    virtual int do_max_length() const noexcept;
};

template <class _Elem, unsigned long _Maxcode = 0x10ffff,
          codecvt_mode _Mode = (codecvt_mode)0>
class __attribute__ ((__type_visibility__("default"))) codecvt_utf8
    : public __codecvt_utf8<_Elem>
{
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit codecvt_utf8(size_t __refs = 0)
        : __codecvt_utf8<_Elem>(__refs, _Maxcode, _Mode) {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    ~codecvt_utf8() {}
};



template <class _Elem, bool _LittleEndian> class __codecvt_utf16;


template <>
class __attribute__ ((__visibility__("default"))) __codecvt_utf16<wchar_t, false>
    : public codecvt<wchar_t, char, mbstate_t>
{
    unsigned long _Maxcode_;
    codecvt_mode _Mode_;
public:
    typedef wchar_t intern_type;
    typedef char extern_type;
    typedef mbstate_t state_type;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit __codecvt_utf16(size_t __refs, unsigned long _Maxcode,
                            codecvt_mode _Mode)
        : codecvt<wchar_t, char, mbstate_t>(__refs), _Maxcode_(_Maxcode),
          _Mode_(_Mode) {}
protected:
    virtual result
        do_out(state_type& __st,
               const intern_type* __frm, const intern_type* __frm_end, const intern_type*& __frm_nxt,
               extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const;
    virtual result
        do_in(state_type& __st,
              const extern_type* __frm, const extern_type* __frm_end, const extern_type*& __frm_nxt,
              intern_type* __to, intern_type* __to_end, intern_type*& __to_nxt) const;
    virtual result
        do_unshift(state_type& __st,
                   extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const;
    virtual int do_encoding() const noexcept;
    virtual bool do_always_noconv() const noexcept;
    virtual int do_length(state_type&, const extern_type* __frm, const extern_type* __end,
                          size_t __mx) const;
    virtual int do_max_length() const noexcept;
};

template <>
class __attribute__ ((__visibility__("default"))) __codecvt_utf16<wchar_t, true>
    : public codecvt<wchar_t, char, mbstate_t>
{
    unsigned long _Maxcode_;
    codecvt_mode _Mode_;
public:
    typedef wchar_t intern_type;
    typedef char extern_type;
    typedef mbstate_t state_type;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit __codecvt_utf16(size_t __refs, unsigned long _Maxcode,
                            codecvt_mode _Mode)
        : codecvt<wchar_t, char, mbstate_t>(__refs), _Maxcode_(_Maxcode),
          _Mode_(_Mode) {}
protected:
    virtual result
        do_out(state_type& __st,
               const intern_type* __frm, const intern_type* __frm_end, const intern_type*& __frm_nxt,
               extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const;
    virtual result
        do_in(state_type& __st,
              const extern_type* __frm, const extern_type* __frm_end, const extern_type*& __frm_nxt,
              intern_type* __to, intern_type* __to_end, intern_type*& __to_nxt) const;
    virtual result
        do_unshift(state_type& __st,
                   extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const;
    virtual int do_encoding() const noexcept;
    virtual bool do_always_noconv() const noexcept;
    virtual int do_length(state_type&, const extern_type* __frm, const extern_type* __end,
                          size_t __mx) const;
    virtual int do_max_length() const noexcept;
};


#pragma GCC diagnostic push
# 280 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/codecvt" 3
#pragma GCC diagnostic ignored "-Wdeprecated"
# 280 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/codecvt" 3
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
template <>
class __attribute__ ((__visibility__("default"))) __codecvt_utf16<char16_t, false>
    : public codecvt<char16_t, char, mbstate_t>
{
    unsigned long _Maxcode_;
    codecvt_mode _Mode_;
public:
    typedef char16_t intern_type;
    typedef char extern_type;
    typedef mbstate_t state_type;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit __codecvt_utf16(size_t __refs, unsigned long _Maxcode,
                            codecvt_mode _Mode)
        : codecvt<char16_t, char, mbstate_t>(__refs), _Maxcode_(_Maxcode),
          _Mode_(_Mode) {}
#pragma GCC diagnostic pop

protected:
    virtual result
        do_out(state_type& __st,
               const intern_type* __frm, const intern_type* __frm_end, const intern_type*& __frm_nxt,
               extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const;
    virtual result
        do_in(state_type& __st,
              const extern_type* __frm, const extern_type* __frm_end, const extern_type*& __frm_nxt,
              intern_type* __to, intern_type* __to_end, intern_type*& __to_nxt) const;
    virtual result
        do_unshift(state_type& __st,
                   extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const;
    virtual int do_encoding() const noexcept;
    virtual bool do_always_noconv() const noexcept;
    virtual int do_length(state_type&, const extern_type* __frm, const extern_type* __end,
                          size_t __mx) const;
    virtual int do_max_length() const noexcept;
};

#pragma GCC diagnostic push
# 318 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/codecvt" 3
#pragma GCC diagnostic ignored "-Wdeprecated"
# 318 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/codecvt" 3
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
template <>
class __attribute__ ((__visibility__("default"))) __codecvt_utf16<char16_t, true>
    : public codecvt<char16_t, char, mbstate_t>
{
    unsigned long _Maxcode_;
    codecvt_mode _Mode_;
public:
    typedef char16_t intern_type;
    typedef char extern_type;
    typedef mbstate_t state_type;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit __codecvt_utf16(size_t __refs, unsigned long _Maxcode,
                            codecvt_mode _Mode)
        : codecvt<char16_t, char, mbstate_t>(__refs), _Maxcode_(_Maxcode),
          _Mode_(_Mode) {}
#pragma GCC diagnostic pop

protected:
    virtual result
        do_out(state_type& __st,
               const intern_type* __frm, const intern_type* __frm_end, const intern_type*& __frm_nxt,
               extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const;
    virtual result
        do_in(state_type& __st,
              const extern_type* __frm, const extern_type* __frm_end, const extern_type*& __frm_nxt,
              intern_type* __to, intern_type* __to_end, intern_type*& __to_nxt) const;
    virtual result
        do_unshift(state_type& __st,
                   extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const;
    virtual int do_encoding() const noexcept;
    virtual bool do_always_noconv() const noexcept;
    virtual int do_length(state_type&, const extern_type* __frm, const extern_type* __end,
                          size_t __mx) const;
    virtual int do_max_length() const noexcept;
};

#pragma GCC diagnostic push
# 356 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/codecvt" 3
#pragma GCC diagnostic ignored "-Wdeprecated"
# 356 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/codecvt" 3
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
template <>
class __attribute__ ((__visibility__("default"))) __codecvt_utf16<char32_t, false>
    : public codecvt<char32_t, char, mbstate_t>
{
    unsigned long _Maxcode_;
    codecvt_mode _Mode_;
public:
    typedef char32_t intern_type;
    typedef char extern_type;
    typedef mbstate_t state_type;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit __codecvt_utf16(size_t __refs, unsigned long _Maxcode,
                            codecvt_mode _Mode)
        : codecvt<char32_t, char, mbstate_t>(__refs), _Maxcode_(_Maxcode),
          _Mode_(_Mode) {}
#pragma GCC diagnostic pop

protected:
    virtual result
        do_out(state_type& __st,
               const intern_type* __frm, const intern_type* __frm_end, const intern_type*& __frm_nxt,
               extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const;
    virtual result
        do_in(state_type& __st,
              const extern_type* __frm, const extern_type* __frm_end, const extern_type*& __frm_nxt,
              intern_type* __to, intern_type* __to_end, intern_type*& __to_nxt) const;
    virtual result
        do_unshift(state_type& __st,
                   extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const;
    virtual int do_encoding() const noexcept;
    virtual bool do_always_noconv() const noexcept;
    virtual int do_length(state_type&, const extern_type* __frm, const extern_type* __end,
                          size_t __mx) const;
    virtual int do_max_length() const noexcept;
};

#pragma GCC diagnostic push
# 394 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/codecvt" 3
#pragma GCC diagnostic ignored "-Wdeprecated"
# 394 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/codecvt" 3
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
template <>
class __attribute__ ((__visibility__("default"))) __codecvt_utf16<char32_t, true>
    : public codecvt<char32_t, char, mbstate_t>
{
    unsigned long _Maxcode_;
    codecvt_mode _Mode_;
public:
    typedef char32_t intern_type;
    typedef char extern_type;
    typedef mbstate_t state_type;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit __codecvt_utf16(size_t __refs, unsigned long _Maxcode,
                            codecvt_mode _Mode)
        : codecvt<char32_t, char, mbstate_t>(__refs), _Maxcode_(_Maxcode),
          _Mode_(_Mode) {}
#pragma GCC diagnostic pop

protected:
    virtual result
        do_out(state_type& __st,
               const intern_type* __frm, const intern_type* __frm_end, const intern_type*& __frm_nxt,
               extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const;
    virtual result
        do_in(state_type& __st,
              const extern_type* __frm, const extern_type* __frm_end, const extern_type*& __frm_nxt,
              intern_type* __to, intern_type* __to_end, intern_type*& __to_nxt) const;
    virtual result
        do_unshift(state_type& __st,
                   extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const;
    virtual int do_encoding() const noexcept;
    virtual bool do_always_noconv() const noexcept;
    virtual int do_length(state_type&, const extern_type* __frm, const extern_type* __end,
                          size_t __mx) const;
    virtual int do_max_length() const noexcept;
};

template <class _Elem, unsigned long _Maxcode = 0x10ffff,
          codecvt_mode _Mode = (codecvt_mode)0>
class __attribute__ ((__type_visibility__("default"))) codecvt_utf16
    : public __codecvt_utf16<_Elem, _Mode & little_endian>
{
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit codecvt_utf16(size_t __refs = 0)
        : __codecvt_utf16<_Elem, _Mode & little_endian>(__refs, _Maxcode, _Mode) {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    ~codecvt_utf16() {}
};



template <class _Elem> class __codecvt_utf8_utf16;


template <>
class __attribute__ ((__visibility__("default"))) __codecvt_utf8_utf16<wchar_t>
    : public codecvt<wchar_t, char, mbstate_t>
{
    unsigned long _Maxcode_;
    codecvt_mode _Mode_;
public:
    typedef wchar_t intern_type;
    typedef char extern_type;
    typedef mbstate_t state_type;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit __codecvt_utf8_utf16(size_t __refs, unsigned long _Maxcode,
                            codecvt_mode _Mode)
        : codecvt<wchar_t, char, mbstate_t>(__refs), _Maxcode_(_Maxcode),
          _Mode_(_Mode) {}
protected:
    virtual result
        do_out(state_type& __st,
               const intern_type* __frm, const intern_type* __frm_end, const intern_type*& __frm_nxt,
               extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const;
    virtual result
        do_in(state_type& __st,
              const extern_type* __frm, const extern_type* __frm_end, const extern_type*& __frm_nxt,
              intern_type* __to, intern_type* __to_end, intern_type*& __to_nxt) const;
    virtual result
        do_unshift(state_type& __st,
                   extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const;
    virtual int do_encoding() const noexcept;
    virtual bool do_always_noconv() const noexcept;
    virtual int do_length(state_type&, const extern_type* __frm, const extern_type* __end,
                          size_t __mx) const;
    virtual int do_max_length() const noexcept;
};


#pragma GCC diagnostic push
# 487 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/codecvt" 3
#pragma GCC diagnostic ignored "-Wdeprecated"
# 487 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/codecvt" 3
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
template <>
class __attribute__ ((__visibility__("default"))) __codecvt_utf8_utf16<char32_t>
    : public codecvt<char32_t, char, mbstate_t>
{
    unsigned long _Maxcode_;
    codecvt_mode _Mode_;
public:
    typedef char32_t intern_type;
    typedef char extern_type;
    typedef mbstate_t state_type;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit __codecvt_utf8_utf16(size_t __refs, unsigned long _Maxcode,
                            codecvt_mode _Mode)
        : codecvt<char32_t, char, mbstate_t>(__refs), _Maxcode_(_Maxcode),
          _Mode_(_Mode) {}
#pragma GCC diagnostic pop

protected:
    virtual result
        do_out(state_type& __st,
               const intern_type* __frm, const intern_type* __frm_end, const intern_type*& __frm_nxt,
               extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const;
    virtual result
        do_in(state_type& __st,
              const extern_type* __frm, const extern_type* __frm_end, const extern_type*& __frm_nxt,
              intern_type* __to, intern_type* __to_end, intern_type*& __to_nxt) const;
    virtual result
        do_unshift(state_type& __st,
                   extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const;
    virtual int do_encoding() const noexcept;
    virtual bool do_always_noconv() const noexcept;
    virtual int do_length(state_type&, const extern_type* __frm, const extern_type* __end,
                          size_t __mx) const;
    virtual int do_max_length() const noexcept;
};

#pragma GCC diagnostic push
# 525 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/codecvt" 3
#pragma GCC diagnostic ignored "-Wdeprecated"
# 525 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/codecvt" 3
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
template <>
class __attribute__ ((__visibility__("default"))) __codecvt_utf8_utf16<char16_t>
    : public codecvt<char16_t, char, mbstate_t>
{
    unsigned long _Maxcode_;
    codecvt_mode _Mode_;
public:
    typedef char16_t intern_type;
    typedef char extern_type;
    typedef mbstate_t state_type;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit __codecvt_utf8_utf16(size_t __refs, unsigned long _Maxcode,
                            codecvt_mode _Mode)
        : codecvt<char16_t, char, mbstate_t>(__refs), _Maxcode_(_Maxcode),
          _Mode_(_Mode) {}
#pragma GCC diagnostic pop

protected:
    virtual result
        do_out(state_type& __st,
               const intern_type* __frm, const intern_type* __frm_end, const intern_type*& __frm_nxt,
               extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const;
    virtual result
        do_in(state_type& __st,
              const extern_type* __frm, const extern_type* __frm_end, const extern_type*& __frm_nxt,
              intern_type* __to, intern_type* __to_end, intern_type*& __to_nxt) const;
    virtual result
        do_unshift(state_type& __st,
                   extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const;
    virtual int do_encoding() const noexcept;
    virtual bool do_always_noconv() const noexcept;
    virtual int do_length(state_type&, const extern_type* __frm, const extern_type* __end,
                          size_t __mx) const;
    virtual int do_max_length() const noexcept;
};

template <class _Elem, unsigned long _Maxcode = 0x10ffff,
          codecvt_mode _Mode = (codecvt_mode)0>
class __attribute__ ((__type_visibility__("default"))) codecvt_utf8_utf16
    : public __codecvt_utf8_utf16<_Elem>
{
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit codecvt_utf8_utf16(size_t __refs = 0)
        : __codecvt_utf8_utf16<_Elem>(__refs, _Maxcode, _Mode) {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    ~codecvt_utf8_utf16() {}
};

} }
# 226 "/usr/local/include/bits/stdc++.h" 2


# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/condition_variable" 1 3
# 111 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/condition_variable" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/memory" 1 3
# 974 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/memory" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 1 3
# 20 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/assert.h" 1 3 4
# 44 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/assert.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/stdlib.h" 1 3 4
# 45 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/assert.h" 2 3 4
# 81 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/assert.h" 3 4
extern "C" {
void __assert_rtn(const char *, const char *, int, const char *) __attribute__((__noreturn__)) __attribute__((__cold__)) __attribute__((__disable_tail_calls__));



}
# 21 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 2 3
# 24 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 3
# 975 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/memory" 2 3
# 112 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/condition_variable" 2 3
# 115 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/condition_variable" 3




namespace std { inline namespace __1 {

class __attribute__ ((__visibility__("default"))) condition_variable_any
{
    condition_variable __cv_;
    shared_ptr<mutex> __mut_;
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    condition_variable_any();

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void notify_one() noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void notify_all() noexcept;

    template <class _Lock>
        inline __attribute__ ((__visibility__("hidden")))
        void wait(_Lock& __lock);
    template <class _Lock, class _Predicate>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        void wait(_Lock& __lock, _Predicate __pred);

    template <class _Lock, class _Clock, class _Duration>
        inline __attribute__ ((__visibility__("hidden")))
        cv_status
        wait_until(_Lock& __lock,
                   const chrono::time_point<_Clock, _Duration>& __t);

    template <class _Lock, class _Clock, class _Duration, class _Predicate>
        bool
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        wait_until(_Lock& __lock,
                   const chrono::time_point<_Clock, _Duration>& __t,
                   _Predicate __pred);

    template <class _Lock, class _Rep, class _Period>
        cv_status
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        wait_for(_Lock& __lock,
                 const chrono::duration<_Rep, _Period>& __d);

    template <class _Lock, class _Rep, class _Period, class _Predicate>
        bool
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        wait_for(_Lock& __lock,
                 const chrono::duration<_Rep, _Period>& __d,
                 _Predicate __pred);
};

inline
condition_variable_any::condition_variable_any()
    : __mut_(make_shared<mutex>()) {}

inline
void
condition_variable_any::notify_one() noexcept
{
    {lock_guard<mutex> __lx(*__mut_);}
    __cv_.notify_one();
}

inline
void
condition_variable_any::notify_all() noexcept
{
    {lock_guard<mutex> __lx(*__mut_);}
    __cv_.notify_all();
}

struct __lock_external
{
    template <class _Lock>
    void operator()(_Lock* __m) {__m->lock();}
};

template <class _Lock>
void
condition_variable_any::wait(_Lock& __lock)
{
    shared_ptr<mutex> __mut = __mut_;
    unique_lock<mutex> __lk(*__mut);
    __lock.unlock();
    unique_ptr<_Lock, __lock_external> __lxx(&__lock);
    lock_guard<unique_lock<mutex> > __lx(__lk, adopt_lock);
    __cv_.wait(__lk);
}

template <class _Lock, class _Predicate>
inline
void
condition_variable_any::wait(_Lock& __lock, _Predicate __pred)
{
    while (!__pred())
        wait(__lock);
}

template <class _Lock, class _Clock, class _Duration>
cv_status
condition_variable_any::wait_until(_Lock& __lock,
                                   const chrono::time_point<_Clock, _Duration>& __t)
{
    shared_ptr<mutex> __mut = __mut_;
    unique_lock<mutex> __lk(*__mut);
    __lock.unlock();
    unique_ptr<_Lock, __lock_external> __lxx(&__lock);
    lock_guard<unique_lock<mutex> > __lx(__lk, adopt_lock);
    return __cv_.wait_until(__lk, __t);
}

template <class _Lock, class _Clock, class _Duration, class _Predicate>
inline
bool
condition_variable_any::wait_until(_Lock& __lock,
                                   const chrono::time_point<_Clock, _Duration>& __t,
                                   _Predicate __pred)
{
    while (!__pred())
        if (wait_until(__lock, __t) == cv_status::timeout)
            return __pred();
    return true;
}

template <class _Lock, class _Rep, class _Period>
inline
cv_status
condition_variable_any::wait_for(_Lock& __lock,
                                 const chrono::duration<_Rep, _Period>& __d)
{
    return wait_until(__lock, chrono::steady_clock::now() + __d);
}

template <class _Lock, class _Rep, class _Period, class _Predicate>
inline
bool
condition_variable_any::wait_for(_Lock& __lock,
                                 const chrono::duration<_Rep, _Period>& __d,
                                 _Predicate __pred)
{
    return wait_until(__lock, chrono::steady_clock::now() + __d,
                      std::__1::move(__pred));
}

__attribute__ ((__visibility__("default")))
void notify_all_at_thread_exit(condition_variable& cond, unique_lock<mutex> lk);

} }
# 229 "/usr/local/include/bits/stdc++.h" 2


# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/forward_list" 1 3
# 188 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/forward_list" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/memory" 1 3
# 974 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/memory" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 1 3
# 20 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/assert.h" 1 3 4
# 44 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/assert.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/stdlib.h" 1 3 4
# 45 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/assert.h" 2 3 4
# 81 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/assert.h" 3 4
extern "C" {
void __assert_rtn(const char *, const char *, int, const char *) __attribute__((__noreturn__)) __attribute__((__cold__)) __attribute__((__disable_tail_calls__));



}
# 21 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 2 3
# 24 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 3
# 975 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/memory" 2 3
# 189 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/forward_list" 2 3
# 193 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/forward_list" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 197 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/forward_list" 2 3


namespace std { inline namespace __1 {

template <class _Tp, class _VoidPtr> struct __forward_list_node;
template <class _NodePtr> struct __forward_begin_node;


template <class>
struct __forward_list_node_value_type;

template <class _Tp, class _VoidPtr>
struct __forward_list_node_value_type<__forward_list_node<_Tp, _VoidPtr> > {
  typedef _Tp type;
};

template <class _NodePtr>
struct __forward_node_traits {

  typedef typename remove_cv<
        typename pointer_traits<_NodePtr>::element_type>::type __node;
  typedef typename __forward_list_node_value_type<__node>::type __node_value_type;
  typedef _NodePtr __node_pointer;
  typedef __forward_begin_node<_NodePtr> __begin_node;
  typedef typename __rebind_pointer<_NodePtr, __begin_node>::type
                                                                __begin_node_pointer;
  typedef typename __rebind_pointer<_NodePtr, void>::type __void_pointer;




  typedef typename conditional<
          is_pointer<__void_pointer>::value,
          __begin_node_pointer,
          __node_pointer
    >::type __iter_node_pointer;


  typedef typename conditional<
          is_same<__iter_node_pointer, __node_pointer>::value,
          __begin_node_pointer,
          __node_pointer
    >::type __non_iter_node_pointer;

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  static __iter_node_pointer __as_iter_node(__iter_node_pointer __p) {
      return __p;
  }
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  static __iter_node_pointer __as_iter_node(__non_iter_node_pointer __p) {
      return static_cast<__iter_node_pointer>(static_cast<__void_pointer>(__p));
  }
};

template <class _NodePtr>
struct __forward_begin_node
{
    typedef _NodePtr pointer;
    typedef typename __rebind_pointer<_NodePtr, __forward_begin_node>::type __begin_node_pointer;

    pointer __next_;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) __forward_begin_node() : __next_(nullptr) {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __begin_node_pointer __next_as_begin() const {
        return static_cast<__begin_node_pointer>(__next_);
    }
};

template <class _Tp, class _VoidPtr>
struct __attribute__ ((__visibility__("hidden"))) __begin_node_of
{
    typedef __forward_begin_node<
        typename __rebind_pointer<_VoidPtr, __forward_list_node<_Tp, _VoidPtr> >::type
    > type;
};

template <class _Tp, class _VoidPtr>
struct __attribute__((__standalone_debug__)) __forward_list_node
    : public __begin_node_of<_Tp, _VoidPtr>::type
{
    typedef _Tp value_type;

    value_type __value_;
};


template <class _Tp, class _Alloc = allocator<_Tp> > class __attribute__ ((__type_visibility__("default"))) forward_list;
template<class _NodeConstPtr> class __attribute__ ((__type_visibility__("default"))) __forward_list_const_iterator;

template <class _NodePtr>
class __attribute__ ((__type_visibility__("default"))) __forward_list_iterator
{
    typedef __forward_node_traits<_NodePtr> __traits;
    typedef typename __traits::__node_pointer __node_pointer;
    typedef typename __traits::__begin_node_pointer __begin_node_pointer;
    typedef typename __traits::__iter_node_pointer __iter_node_pointer;
    typedef typename __traits::__void_pointer __void_pointer;

    __iter_node_pointer __ptr_;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __begin_node_pointer __get_begin() const {
        return static_cast<__begin_node_pointer>(
                static_cast<__void_pointer>(__ptr_));
    }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __node_pointer __get_unsafe_node_pointer() const {
        return static_cast<__node_pointer>(
                static_cast<__void_pointer>(__ptr_));
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit __forward_list_iterator(nullptr_t) noexcept : __ptr_(nullptr) {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit __forward_list_iterator(__begin_node_pointer __p) noexcept
        : __ptr_(__traits::__as_iter_node(__p)) {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit __forward_list_iterator(__node_pointer __p) noexcept
        : __ptr_(__traits::__as_iter_node(__p)) {}

    template<class, class> friend class __attribute__ ((__type_visibility__("default"))) forward_list;
    template<class> friend class __attribute__ ((__type_visibility__("default"))) __forward_list_const_iterator;

public:
    typedef forward_iterator_tag iterator_category;
    typedef typename __traits::__node_value_type value_type;
    typedef value_type& reference;
    typedef typename pointer_traits<__node_pointer>::difference_type
                                                              difference_type;
    typedef typename __rebind_pointer<__node_pointer, value_type>::type pointer;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __forward_list_iterator() noexcept : __ptr_(nullptr) {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    reference operator*() const {return __get_unsafe_node_pointer()->__value_;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    pointer operator->() const {
        return pointer_traits<pointer>::pointer_to(__get_unsafe_node_pointer()->__value_);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __forward_list_iterator& operator++()
    {
        __ptr_ = __traits::__as_iter_node(__ptr_->__next_);
        return *this;
    }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __forward_list_iterator operator++(int)
    {
        __forward_list_iterator __t(*this);
        ++(*this);
        return __t;
    }

    friend __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    bool operator==(const __forward_list_iterator& __x,
                    const __forward_list_iterator& __y)
        {return __x.__ptr_ == __y.__ptr_;}
    friend __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    bool operator!=(const __forward_list_iterator& __x,
                    const __forward_list_iterator& __y)
        {return !(__x == __y);}
};

template <class _NodeConstPtr>
class __attribute__ ((__type_visibility__("default"))) __forward_list_const_iterator
{
    static_assert((!is_const<typename pointer_traits<_NodeConstPtr>::element_type>::value), "");
    typedef _NodeConstPtr _NodePtr;

    typedef __forward_node_traits<_NodePtr> __traits;
    typedef typename __traits::__node __node;
    typedef typename __traits::__node_pointer __node_pointer;
    typedef typename __traits::__begin_node_pointer __begin_node_pointer;
    typedef typename __traits::__iter_node_pointer __iter_node_pointer;
    typedef typename __traits::__void_pointer __void_pointer;

    __iter_node_pointer __ptr_;

    __begin_node_pointer __get_begin() const {
        return static_cast<__begin_node_pointer>(
                static_cast<__void_pointer>(__ptr_));
    }
    __node_pointer __get_unsafe_node_pointer() const {
        return static_cast<__node_pointer>(
                static_cast<__void_pointer>(__ptr_));
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit __forward_list_const_iterator(nullptr_t) noexcept
        : __ptr_(nullptr) {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit __forward_list_const_iterator(__begin_node_pointer __p) noexcept
        : __ptr_(__traits::__as_iter_node(__p)) {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit __forward_list_const_iterator(__node_pointer __p) noexcept
        : __ptr_(__traits::__as_iter_node(__p)) {}


    template<class, class> friend class forward_list;

public:
    typedef forward_iterator_tag iterator_category;
    typedef typename __traits::__node_value_type value_type;
    typedef const value_type& reference;
    typedef typename pointer_traits<__node_pointer>::difference_type
                                                              difference_type;
    typedef typename __rebind_pointer<__node_pointer, const value_type>::type
                                                              pointer;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __forward_list_const_iterator() noexcept : __ptr_(nullptr) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __forward_list_const_iterator(__forward_list_iterator<__node_pointer> __p) noexcept
        : __ptr_(__p.__ptr_) {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    reference operator*() const {return __get_unsafe_node_pointer()->__value_;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    pointer operator->() const {return pointer_traits<pointer>::pointer_to(
                __get_unsafe_node_pointer()->__value_);}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __forward_list_const_iterator& operator++()
    {
        __ptr_ = __traits::__as_iter_node(__ptr_->__next_);
        return *this;
    }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __forward_list_const_iterator operator++(int)
    {
        __forward_list_const_iterator __t(*this);
        ++(*this);
        return __t;
    }

    friend __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    bool operator==(const __forward_list_const_iterator& __x,
                    const __forward_list_const_iterator& __y)
        {return __x.__ptr_ == __y.__ptr_;}
    friend __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    bool operator!=(const __forward_list_const_iterator& __x,
                           const __forward_list_const_iterator& __y)
        {return !(__x == __y);}
};

template <class _Tp, class _Alloc>
class __forward_list_base
{
protected:
    typedef _Tp value_type;
    typedef _Alloc allocator_type;

    typedef typename allocator_traits<allocator_type>::void_pointer void_pointer;
    typedef __forward_list_node<value_type, void_pointer> __node;
    typedef typename __begin_node_of<value_type, void_pointer>::type __begin_node;
    typedef typename __rebind_alloc_helper<allocator_traits<allocator_type>, __node>::type __node_allocator;
    typedef allocator_traits<__node_allocator> __node_traits;
    typedef typename __node_traits::pointer __node_pointer;

    typedef typename __rebind_alloc_helper<
        allocator_traits<allocator_type>, __begin_node
    >::type __begin_node_allocator;
    typedef typename allocator_traits<__begin_node_allocator>::pointer
                                                      __begin_node_pointer;

    static_assert((!is_same<allocator_type, __node_allocator>::value),
                  "internal allocator type must differ from user-specified "
                  "type; otherwise overload resolution breaks");

    __compressed_pair<__begin_node, __node_allocator> __before_begin_;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __begin_node_pointer __before_begin() noexcept
        {return pointer_traits<__begin_node_pointer>::pointer_to(__before_begin_.first());}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __begin_node_pointer __before_begin() const noexcept
        {return pointer_traits<__begin_node_pointer>::pointer_to(const_cast<__begin_node&>(__before_begin_.first()));}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
          __node_allocator& __alloc() noexcept
            {return __before_begin_.second();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const __node_allocator& __alloc() const noexcept
        {return __before_begin_.second();}

    typedef __forward_list_iterator<__node_pointer> iterator;
    typedef __forward_list_const_iterator<__node_pointer> const_iterator;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __forward_list_base()
        noexcept(is_nothrow_default_constructible<__node_allocator>::value)
        : __before_begin_(__begin_node(), __default_init_tag()) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit __forward_list_base(const allocator_type& __a)
        : __before_begin_(__begin_node(), __node_allocator(__a)) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit __forward_list_base(const __node_allocator& __a)
        : __before_begin_(__begin_node(), __a) {}

public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __forward_list_base(__forward_list_base&& __x)
        noexcept(is_nothrow_move_constructible<__node_allocator>::value);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __forward_list_base(__forward_list_base&& __x, const allocator_type& __a);


private:
    __forward_list_base(const __forward_list_base&);
    __forward_list_base& operator=(const __forward_list_base&);

public:
    ~__forward_list_base();

protected:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void __copy_assign_alloc(const __forward_list_base& __x)
        {__copy_assign_alloc(__x, integral_constant<bool,
              __node_traits::propagate_on_container_copy_assignment::value>());}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void __move_assign_alloc(__forward_list_base& __x)
        noexcept(!__node_traits::propagate_on_container_move_assignment::value || is_nothrow_move_assignable<__node_allocator>::value)

        {__move_assign_alloc(__x, integral_constant<bool,
              __node_traits::propagate_on_container_move_assignment::value>());}

public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void swap(__forward_list_base& __x)

        noexcept;




protected:
    void clear() noexcept;

private:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void __copy_assign_alloc(const __forward_list_base&, false_type) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void __copy_assign_alloc(const __forward_list_base& __x, true_type)
    {
        if (__alloc() != __x.__alloc())
            clear();
        __alloc() = __x.__alloc();
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void __move_assign_alloc(__forward_list_base&, false_type) noexcept
        {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void __move_assign_alloc(__forward_list_base& __x, true_type)
        noexcept(is_nothrow_move_assignable<__node_allocator>::value)
        {__alloc() = std::__1::move(__x.__alloc());}
};



template <class _Tp, class _Alloc>
inline
__forward_list_base<_Tp, _Alloc>::__forward_list_base(__forward_list_base&& __x)
        noexcept(is_nothrow_move_constructible<__node_allocator>::value)
    : __before_begin_(std::__1::move(__x.__before_begin_))
{
    __x.__before_begin()->__next_ = nullptr;
}

template <class _Tp, class _Alloc>
inline
__forward_list_base<_Tp, _Alloc>::__forward_list_base(__forward_list_base&& __x,
                                                      const allocator_type& __a)
    : __before_begin_(__begin_node(), __node_allocator(__a))
{
    if (__alloc() == __x.__alloc())
    {
        __before_begin()->__next_ = __x.__before_begin()->__next_;
        __x.__before_begin()->__next_ = nullptr;
    }
}



template <class _Tp, class _Alloc>
__forward_list_base<_Tp, _Alloc>::~__forward_list_base()
{
    clear();
}

template <class _Tp, class _Alloc>
inline
void
__forward_list_base<_Tp, _Alloc>::swap(__forward_list_base& __x)

        noexcept




{
    std::__1::__swap_allocator(__alloc(), __x.__alloc(),
            integral_constant<bool, __node_traits::propagate_on_container_swap::value>());
    using std::__1::swap;
    swap(__before_begin()->__next_, __x.__before_begin()->__next_);
}

template <class _Tp, class _Alloc>
void
__forward_list_base<_Tp, _Alloc>::clear() noexcept
{
    __node_allocator& __a = __alloc();
    for (__node_pointer __p = __before_begin()->__next_; __p != nullptr;)
    {
        __node_pointer __next = __p->__next_;
        __node_traits::destroy(__a, std::__1::addressof(__p->__value_));
        __node_traits::deallocate(__a, __p, 1);
        __p = __next;
    }
    __before_begin()->__next_ = nullptr;
}

template <class _Tp, class _Alloc >
class __attribute__ ((__type_visibility__("default"))) forward_list
    : private __forward_list_base<_Tp, _Alloc>
{
    typedef __forward_list_base<_Tp, _Alloc> base;
    typedef typename base::__node_allocator __node_allocator;
    typedef typename base::__node __node;
    typedef typename base::__node_traits __node_traits;
    typedef typename base::__node_pointer __node_pointer;
    typedef typename base::__begin_node_pointer __begin_node_pointer;

public:
    typedef _Tp value_type;
    typedef _Alloc allocator_type;

    static_assert((is_same<typename allocator_type::value_type, value_type>::value),
                  "Allocator::value_type must be same type as value_type");

    typedef value_type& reference;
    typedef const value_type& const_reference;
    typedef typename allocator_traits<allocator_type>::pointer pointer;
    typedef typename allocator_traits<allocator_type>::const_pointer const_pointer;
    typedef typename allocator_traits<allocator_type>::size_type size_type;
    typedef typename allocator_traits<allocator_type>::difference_type difference_type;

    typedef typename base::iterator iterator;
    typedef typename base::const_iterator const_iterator;



    typedef void __remove_return_type;


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    forward_list()
        noexcept(is_nothrow_default_constructible<__node_allocator>::value)
        {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit forward_list(const allocator_type& __a);
    explicit forward_list(size_type __n);

    explicit forward_list(size_type __n, const allocator_type& __a);

    forward_list(size_type __n, const value_type& __v);
    forward_list(size_type __n, const value_type& __v, const allocator_type& __a);
    template <class _InputIterator>
        forward_list(_InputIterator __f, _InputIterator __l,
                     typename enable_if<
                       __is_cpp17_input_iterator<_InputIterator>::value
                     >::type* = nullptr);
    template <class _InputIterator>
        forward_list(_InputIterator __f, _InputIterator __l,
                     const allocator_type& __a,
                     typename enable_if<
                       __is_cpp17_input_iterator<_InputIterator>::value
                     >::type* = nullptr);
    forward_list(const forward_list& __x);
    forward_list(const forward_list& __x, const __identity_t<allocator_type>& __a);

    forward_list& operator=(const forward_list& __x);


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    forward_list(forward_list&& __x)
        noexcept(is_nothrow_move_constructible<base>::value)
        : base(std::__1::move(__x)) {}
    forward_list(forward_list&& __x, const __identity_t<allocator_type>& __a);

    forward_list(initializer_list<value_type> __il);
    forward_list(initializer_list<value_type> __il, const allocator_type& __a);

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    forward_list& operator=(forward_list&& __x)
        noexcept(__node_traits::propagate_on_container_move_assignment::value && is_nothrow_move_assignable<allocator_type>::value);



    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    forward_list& operator=(initializer_list<value_type> __il);

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void assign(initializer_list<value_type> __il);




    template <class _InputIterator>
        typename enable_if
        <
            __is_cpp17_input_iterator<_InputIterator>::value,
            void
        >::type
        assign(_InputIterator __f, _InputIterator __l);
    void assign(size_type __n, const value_type& __v);

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    allocator_type get_allocator() const noexcept
        {return allocator_type(base::__alloc());}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iterator begin() noexcept
        {return iterator(base::__before_begin()->__next_);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_iterator begin() const noexcept
        {return const_iterator(base::__before_begin()->__next_);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iterator end() noexcept
        {return iterator(nullptr);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_iterator end() const noexcept
        {return const_iterator(nullptr);}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_iterator cbegin() const noexcept
        {return const_iterator(base::__before_begin()->__next_);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_iterator cend() const noexcept
        {return const_iterator(nullptr);}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iterator before_begin() noexcept
        {return iterator(base::__before_begin());}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_iterator before_begin() const noexcept
        {return const_iterator(base::__before_begin());}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_iterator cbefore_begin() const noexcept
        {return const_iterator(base::__before_begin());}

                                  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    bool empty() const noexcept
        {return base::__before_begin()->__next_ == nullptr;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_type max_size() const noexcept {
        return std::__1::min<size_type>(
            __node_traits::max_size(base::__alloc()),
            numeric_limits<difference_type>::max());
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    reference front() {return base::__before_begin()->__next_->__value_;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_reference front() const {return base::__before_begin()->__next_->__value_;}



    template <class... _Args> reference emplace_front(_Args&&... __args);



    void push_front(value_type&& __v);

    void push_front(const value_type& __v);

    void pop_front();


    template <class... _Args>
        iterator emplace_after(const_iterator __p, _Args&&... __args);

    iterator insert_after(const_iterator __p, value_type&& __v);
    iterator insert_after(const_iterator __p, initializer_list<value_type> __il)
        {return insert_after(__p, __il.begin(), __il.end());}

    iterator insert_after(const_iterator __p, const value_type& __v);
    iterator insert_after(const_iterator __p, size_type __n, const value_type& __v);
    template <class _InputIterator>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        typename enable_if
        <
            __is_cpp17_input_iterator<_InputIterator>::value,
            iterator
        >::type
        insert_after(const_iterator __p, _InputIterator __f, _InputIterator __l);

    iterator erase_after(const_iterator __p);
    iterator erase_after(const_iterator __f, const_iterator __l);

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void swap(forward_list& __x)

        noexcept




        {base::swap(__x);}

    void resize(size_type __n);
    void resize(size_type __n, const value_type& __v);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void clear() noexcept {base::clear();}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void splice_after(const_iterator __p, forward_list&& __x);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void splice_after(const_iterator __p, forward_list&& __x, const_iterator __i);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void splice_after(const_iterator __p, forward_list&& __x,
                      const_iterator __f, const_iterator __l);
    void splice_after(const_iterator __p, forward_list& __x);
    void splice_after(const_iterator __p, forward_list& __x, const_iterator __i);
    void splice_after(const_iterator __p, forward_list& __x,
                      const_iterator __f, const_iterator __l);
    __remove_return_type remove(const value_type& __v);
    template <class _Predicate> __remove_return_type remove_if(_Predicate __pred);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __remove_return_type unique() {return unique(__equal_to<value_type>());}
    template <class _BinaryPredicate> __remove_return_type unique(_BinaryPredicate __binary_pred);

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void merge(forward_list&& __x) {merge(__x, __less<value_type>());}
    template <class _Compare>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        void merge(forward_list&& __x, _Compare __comp)
        {merge(__x, std::__1::move(__comp));}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void merge(forward_list& __x) {merge(__x, __less<value_type>());}
    template <class _Compare> void merge(forward_list& __x, _Compare __comp);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void sort() {sort(__less<value_type>());}
    template <class _Compare> __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) void sort(_Compare __comp);
    void reverse() noexcept;

private:


    void __move_assign(forward_list& __x, true_type)
        noexcept(is_nothrow_move_assignable<allocator_type>::value);
    void __move_assign(forward_list& __x, false_type);


    template <class _Compare>
        static
        __node_pointer
        __merge(__node_pointer __f1, __node_pointer __f2, _Compare& __comp);

    template <class _Compare>
        static
        __node_pointer
        __sort(__node_pointer __f, difference_type __sz, _Compare& __comp);
};



template<class _InputIterator,
         class _Alloc = allocator<__iter_value_type<_InputIterator>>,
         class = _EnableIf<__is_allocator<_Alloc>::value>
         >
forward_list(_InputIterator, _InputIterator)
  -> forward_list<__iter_value_type<_InputIterator>, _Alloc>;

template<class _InputIterator,
         class _Alloc,
         class = _EnableIf<__is_allocator<_Alloc>::value>
         >
forward_list(_InputIterator, _InputIterator, _Alloc)
  -> forward_list<__iter_value_type<_InputIterator>, _Alloc>;


template <class _Tp, class _Alloc>
inline
forward_list<_Tp, _Alloc>::forward_list(const allocator_type& __a)
    : base(__a)
{
}

template <class _Tp, class _Alloc>
forward_list<_Tp, _Alloc>::forward_list(size_type __n)
{
    if (__n > 0)
    {
        __node_allocator& __a = base::__alloc();
        typedef __allocator_destructor<__node_allocator> _Dp;
        unique_ptr<__node, _Dp> __h(nullptr, _Dp(__a, 1));
        for (__begin_node_pointer __p = base::__before_begin(); __n > 0; --__n,
                                                             __p = __p->__next_as_begin())
        {
            __h.reset(__node_traits::allocate(__a, 1));
            __node_traits::construct(__a, std::__1::addressof(__h->__value_));
            __h->__next_ = nullptr;
            __p->__next_ = __h.release();
        }
    }
}


template <class _Tp, class _Alloc>
forward_list<_Tp, _Alloc>::forward_list(size_type __n,
                                        const allocator_type& __base_alloc)
    : base ( __base_alloc )
{
    if (__n > 0)
    {
        __node_allocator& __a = base::__alloc();
        typedef __allocator_destructor<__node_allocator> _Dp;
        unique_ptr<__node, _Dp> __h(nullptr, _Dp(__a, 1));
        for (__begin_node_pointer __p = base::__before_begin(); __n > 0; --__n,
                                                             __p = __p->__next_as_begin())
        {
            __h.reset(__node_traits::allocate(__a, 1));
            __node_traits::construct(__a, std::__1::addressof(__h->__value_));
            __h->__next_ = nullptr;
            __p->__next_ = __h.release();
        }
    }
}


template <class _Tp, class _Alloc>
forward_list<_Tp, _Alloc>::forward_list(size_type __n, const value_type& __v)
{
    insert_after(cbefore_begin(), __n, __v);
}

template <class _Tp, class _Alloc>
forward_list<_Tp, _Alloc>::forward_list(size_type __n, const value_type& __v,
                                        const allocator_type& __a)
    : base(__a)
{
    insert_after(cbefore_begin(), __n, __v);
}

template <class _Tp, class _Alloc>
template <class _InputIterator>
forward_list<_Tp, _Alloc>::forward_list(_InputIterator __f, _InputIterator __l,
                                        typename enable_if<
                                          __is_cpp17_input_iterator<_InputIterator>::value
                                        >::type*)
{
    insert_after(cbefore_begin(), __f, __l);
}

template <class _Tp, class _Alloc>
template <class _InputIterator>
forward_list<_Tp, _Alloc>::forward_list(_InputIterator __f, _InputIterator __l,
                                        const allocator_type& __a,
                                        typename enable_if<
                                          __is_cpp17_input_iterator<_InputIterator>::value
                                        >::type*)
    : base(__a)
{
    insert_after(cbefore_begin(), __f, __l);
}

template <class _Tp, class _Alloc>
forward_list<_Tp, _Alloc>::forward_list(const forward_list& __x)
    : base(
          __node_traits::select_on_container_copy_construction(__x.__alloc())) {
  insert_after(cbefore_begin(), __x.begin(), __x.end());
}

template <class _Tp, class _Alloc>
forward_list<_Tp, _Alloc>::forward_list(const forward_list& __x,
                                        const __identity_t<allocator_type>& __a)
    : base(__a)
{
    insert_after(cbefore_begin(), __x.begin(), __x.end());
}

template <class _Tp, class _Alloc>
forward_list<_Tp, _Alloc>&
forward_list<_Tp, _Alloc>::operator=(const forward_list& __x)
{
    if (this != &__x)
    {
        base::__copy_assign_alloc(__x);
        assign(__x.begin(), __x.end());
    }
    return *this;
}


template <class _Tp, class _Alloc>
forward_list<_Tp, _Alloc>::forward_list(forward_list&& __x,
                                        const __identity_t<allocator_type>& __a)
    : base(std::__1::move(__x), __a)
{
    if (base::__alloc() != __x.__alloc())
    {
        typedef move_iterator<iterator> _Ip;
        insert_after(cbefore_begin(), _Ip(__x.begin()), _Ip(__x.end()));
    }
}

template <class _Tp, class _Alloc>
forward_list<_Tp, _Alloc>::forward_list(initializer_list<value_type> __il)
{
    insert_after(cbefore_begin(), __il.begin(), __il.end());
}

template <class _Tp, class _Alloc>
forward_list<_Tp, _Alloc>::forward_list(initializer_list<value_type> __il,
                                        const allocator_type& __a)
    : base(__a)
{
    insert_after(cbefore_begin(), __il.begin(), __il.end());
}

template <class _Tp, class _Alloc>
void
forward_list<_Tp, _Alloc>::__move_assign(forward_list& __x, true_type)
    noexcept(is_nothrow_move_assignable<allocator_type>::value)
{
    clear();
    base::__move_assign_alloc(__x);
    base::__before_begin()->__next_ = __x.__before_begin()->__next_;
    __x.__before_begin()->__next_ = nullptr;
}

template <class _Tp, class _Alloc>
void
forward_list<_Tp, _Alloc>::__move_assign(forward_list& __x, false_type)
{
    if (base::__alloc() == __x.__alloc())
        __move_assign(__x, true_type());
    else
    {
        typedef move_iterator<iterator> _Ip;
        assign(_Ip(__x.begin()), _Ip(__x.end()));
    }
}

template <class _Tp, class _Alloc>
inline
forward_list<_Tp, _Alloc>&
forward_list<_Tp, _Alloc>::operator=(forward_list&& __x)
    noexcept(__node_traits::propagate_on_container_move_assignment::value && is_nothrow_move_assignable<allocator_type>::value)


{
    __move_assign(__x, integral_constant<bool,
          __node_traits::propagate_on_container_move_assignment::value>());
    return *this;
}

template <class _Tp, class _Alloc>
inline
forward_list<_Tp, _Alloc>&
forward_list<_Tp, _Alloc>::operator=(initializer_list<value_type> __il)
{
    assign(__il.begin(), __il.end());
    return *this;
}



template <class _Tp, class _Alloc>
template <class _InputIterator>
typename enable_if
<
    __is_cpp17_input_iterator<_InputIterator>::value,
    void
>::type
forward_list<_Tp, _Alloc>::assign(_InputIterator __f, _InputIterator __l)
{
    iterator __i = before_begin();
    iterator __j = std::__1::next(__i);
    iterator __e = end();
    for (; __j != __e && __f != __l; ++__i, (void) ++__j, ++__f)
        *__j = *__f;
    if (__j == __e)
        insert_after(__i, __f, __l);
    else
        erase_after(__i, __e);
}

template <class _Tp, class _Alloc>
void
forward_list<_Tp, _Alloc>::assign(size_type __n, const value_type& __v)
{
    iterator __i = before_begin();
    iterator __j = std::__1::next(__i);
    iterator __e = end();
    for (; __j != __e && __n > 0; --__n, ++__i, ++__j)
        *__j = __v;
    if (__j == __e)
        insert_after(__i, __n, __v);
    else
        erase_after(__i, __e);
}



template <class _Tp, class _Alloc>
inline
void
forward_list<_Tp, _Alloc>::assign(initializer_list<value_type> __il)
{
    assign(__il.begin(), __il.end());
}

template <class _Tp, class _Alloc>
template <class... _Args>

typename forward_list<_Tp, _Alloc>::reference



forward_list<_Tp, _Alloc>::emplace_front(_Args&&... __args)
{
    __node_allocator& __a = base::__alloc();
    typedef __allocator_destructor<__node_allocator> _Dp;
    unique_ptr<__node, _Dp> __h(__node_traits::allocate(__a, 1), _Dp(__a, 1));
    __node_traits::construct(__a, std::__1::addressof(__h->__value_),
                                  std::__1::forward<_Args>(__args)...);
    __h->__next_ = base::__before_begin()->__next_;
    base::__before_begin()->__next_ = __h.release();

    return base::__before_begin()->__next_->__value_;

}

template <class _Tp, class _Alloc>
void
forward_list<_Tp, _Alloc>::push_front(value_type&& __v)
{
    __node_allocator& __a = base::__alloc();
    typedef __allocator_destructor<__node_allocator> _Dp;
    unique_ptr<__node, _Dp> __h(__node_traits::allocate(__a, 1), _Dp(__a, 1));
    __node_traits::construct(__a, std::__1::addressof(__h->__value_), std::__1::move(__v));
    __h->__next_ = base::__before_begin()->__next_;
    base::__before_begin()->__next_ = __h.release();
}



template <class _Tp, class _Alloc>
void
forward_list<_Tp, _Alloc>::push_front(const value_type& __v)
{
    __node_allocator& __a = base::__alloc();
    typedef __allocator_destructor<__node_allocator> _Dp;
    unique_ptr<__node, _Dp> __h(__node_traits::allocate(__a, 1), _Dp(__a, 1));
    __node_traits::construct(__a, std::__1::addressof(__h->__value_), __v);
    __h->__next_ = base::__before_begin()->__next_;
    base::__before_begin()->__next_ = __h.release();
}

template <class _Tp, class _Alloc>
void
forward_list<_Tp, _Alloc>::pop_front()
{
    __node_allocator& __a = base::__alloc();
    __node_pointer __p = base::__before_begin()->__next_;
    base::__before_begin()->__next_ = __p->__next_;
    __node_traits::destroy(__a, std::__1::addressof(__p->__value_));
    __node_traits::deallocate(__a, __p, 1);
}



template <class _Tp, class _Alloc>
template <class... _Args>
typename forward_list<_Tp, _Alloc>::iterator
forward_list<_Tp, _Alloc>::emplace_after(const_iterator __p, _Args&&... __args)
{
    __begin_node_pointer const __r = __p.__get_begin();
    __node_allocator& __a = base::__alloc();
    typedef __allocator_destructor<__node_allocator> _Dp;
    unique_ptr<__node, _Dp> __h(__node_traits::allocate(__a, 1), _Dp(__a, 1));
    __node_traits::construct(__a, std::__1::addressof(__h->__value_),
                                  std::__1::forward<_Args>(__args)...);
    __h->__next_ = __r->__next_;
    __r->__next_ = __h.release();
    return iterator(__r->__next_);
}

template <class _Tp, class _Alloc>
typename forward_list<_Tp, _Alloc>::iterator
forward_list<_Tp, _Alloc>::insert_after(const_iterator __p, value_type&& __v)
{
    __begin_node_pointer const __r = __p.__get_begin();
    __node_allocator& __a = base::__alloc();
    typedef __allocator_destructor<__node_allocator> _Dp;
    unique_ptr<__node, _Dp> __h(__node_traits::allocate(__a, 1), _Dp(__a, 1));
    __node_traits::construct(__a, std::__1::addressof(__h->__value_), std::__1::move(__v));
    __h->__next_ = __r->__next_;
    __r->__next_ = __h.release();
    return iterator(__r->__next_);
}



template <class _Tp, class _Alloc>
typename forward_list<_Tp, _Alloc>::iterator
forward_list<_Tp, _Alloc>::insert_after(const_iterator __p, const value_type& __v)
{
    __begin_node_pointer const __r = __p.__get_begin();
    __node_allocator& __a = base::__alloc();
    typedef __allocator_destructor<__node_allocator> _Dp;
    unique_ptr<__node, _Dp> __h(__node_traits::allocate(__a, 1), _Dp(__a, 1));
    __node_traits::construct(__a, std::__1::addressof(__h->__value_), __v);
    __h->__next_ = __r->__next_;
    __r->__next_ = __h.release();
    return iterator(__r->__next_);
}

template <class _Tp, class _Alloc>
typename forward_list<_Tp, _Alloc>::iterator
forward_list<_Tp, _Alloc>::insert_after(const_iterator __p, size_type __n,
                                        const value_type& __v)
{
    __begin_node_pointer __r = __p.__get_begin();
    if (__n > 0)
    {
        __node_allocator& __a = base::__alloc();
        typedef __allocator_destructor<__node_allocator> _Dp;
        unique_ptr<__node, _Dp> __h(__node_traits::allocate(__a, 1), _Dp(__a, 1));
        __node_traits::construct(__a, std::__1::addressof(__h->__value_), __v);
        __node_pointer __first = __h.release();
        __node_pointer __last = __first;

        try
        {

            for (--__n; __n != 0; --__n, __last = __last->__next_)
            {
                __h.reset(__node_traits::allocate(__a, 1));
                __node_traits::construct(__a, std::__1::addressof(__h->__value_), __v);
                __last->__next_ = __h.release();
            }

        }
        catch (...)
        {
            while (__first != nullptr)
            {
                __node_pointer __next = __first->__next_;
                __node_traits::destroy(__a, std::__1::addressof(__first->__value_));
                __node_traits::deallocate(__a, __first, 1);
                __first = __next;
            }
            throw;
        }

        __last->__next_ = __r->__next_;
        __r->__next_ = __first;
        __r = static_cast<__begin_node_pointer>(__last);
    }
    return iterator(__r);
}

template <class _Tp, class _Alloc>
template <class _InputIterator>
typename enable_if
<
    __is_cpp17_input_iterator<_InputIterator>::value,
    typename forward_list<_Tp, _Alloc>::iterator
>::type
forward_list<_Tp, _Alloc>::insert_after(const_iterator __p,
                                        _InputIterator __f, _InputIterator __l)
{
    __begin_node_pointer __r = __p.__get_begin();
    if (__f != __l)
    {
        __node_allocator& __a = base::__alloc();
        typedef __allocator_destructor<__node_allocator> _Dp;
        unique_ptr<__node, _Dp> __h(__node_traits::allocate(__a, 1), _Dp(__a, 1));
        __node_traits::construct(__a, std::__1::addressof(__h->__value_), *__f);
        __node_pointer __first = __h.release();
        __node_pointer __last = __first;

        try
        {

            for (++__f; __f != __l; ++__f, ((void)(__last = __last->__next_)))
            {
                __h.reset(__node_traits::allocate(__a, 1));
                __node_traits::construct(__a, std::__1::addressof(__h->__value_), *__f);
                __last->__next_ = __h.release();
            }

        }
        catch (...)
        {
            while (__first != nullptr)
            {
                __node_pointer __next = __first->__next_;
                __node_traits::destroy(__a, std::__1::addressof(__first->__value_));
                __node_traits::deallocate(__a, __first, 1);
                __first = __next;
            }
            throw;
        }

        __last->__next_ = __r->__next_;
        __r->__next_ = __first;
        __r = static_cast<__begin_node_pointer>(__last);
    }
    return iterator(__r);
}

template <class _Tp, class _Alloc>
typename forward_list<_Tp, _Alloc>::iterator
forward_list<_Tp, _Alloc>::erase_after(const_iterator __f)
{
    __begin_node_pointer __p = __f.__get_begin();
    __node_pointer __n = __p->__next_;
    __p->__next_ = __n->__next_;
    __node_allocator& __a = base::__alloc();
    __node_traits::destroy(__a, std::__1::addressof(__n->__value_));
    __node_traits::deallocate(__a, __n, 1);
    return iterator(__p->__next_);
}

template <class _Tp, class _Alloc>
typename forward_list<_Tp, _Alloc>::iterator
forward_list<_Tp, _Alloc>::erase_after(const_iterator __f, const_iterator __l)
{
    __node_pointer __e = __l.__get_unsafe_node_pointer();
    if (__f != __l)
    {
        __begin_node_pointer __bp = __f.__get_begin();

        __node_pointer __n = __bp->__next_;
        if (__n != __e)
        {
            __bp->__next_ = __e;
            __node_allocator& __a = base::__alloc();
            do
            {
                __node_pointer __tmp = __n->__next_;
                __node_traits::destroy(__a, std::__1::addressof(__n->__value_));
                __node_traits::deallocate(__a, __n, 1);
                __n = __tmp;
            } while (__n != __e);
        }
    }
    return iterator(__e);
}

template <class _Tp, class _Alloc>
void
forward_list<_Tp, _Alloc>::resize(size_type __n)
{
    size_type __sz = 0;
    iterator __p = before_begin();
    iterator __i = begin();
    iterator __e = end();
    for (; __i != __e && __sz < __n; ++__p, ++__i, ++__sz)
        ;
    if (__i != __e)
        erase_after(__p, __e);
    else
    {
        __n -= __sz;
        if (__n > 0)
        {
            __node_allocator& __a = base::__alloc();
            typedef __allocator_destructor<__node_allocator> _Dp;
            unique_ptr<__node, _Dp> __h(nullptr, _Dp(__a, 1));
            for (__begin_node_pointer __ptr = __p.__get_begin(); __n > 0; --__n,
                                                         __ptr = __ptr->__next_as_begin())
            {
                __h.reset(__node_traits::allocate(__a, 1));
                __node_traits::construct(__a, std::__1::addressof(__h->__value_));
                __h->__next_ = nullptr;
                __ptr->__next_ = __h.release();
            }
        }
    }
}

template <class _Tp, class _Alloc>
void
forward_list<_Tp, _Alloc>::resize(size_type __n, const value_type& __v)
{
    size_type __sz = 0;
    iterator __p = before_begin();
    iterator __i = begin();
    iterator __e = end();
    for (; __i != __e && __sz < __n; ++__p, ++__i, ++__sz)
        ;
    if (__i != __e)
        erase_after(__p, __e);
    else
    {
        __n -= __sz;
        if (__n > 0)
        {
            __node_allocator& __a = base::__alloc();
            typedef __allocator_destructor<__node_allocator> _Dp;
            unique_ptr<__node, _Dp> __h(nullptr, _Dp(__a, 1));
            for (__begin_node_pointer __ptr = __p.__get_begin(); __n > 0; --__n,
                                                         __ptr = __ptr->__next_as_begin())
            {
                __h.reset(__node_traits::allocate(__a, 1));
                __node_traits::construct(__a, std::__1::addressof(__h->__value_), __v);
                __h->__next_ = nullptr;
                __ptr->__next_ = __h.release();
            }
        }
    }
}

template <class _Tp, class _Alloc>
void
forward_list<_Tp, _Alloc>::splice_after(const_iterator __p,
                                        forward_list& __x)
{
    if (!__x.empty())
    {
        if (__p.__get_begin()->__next_ != nullptr)
        {
            const_iterator __lm1 = __x.before_begin();
            while (__lm1.__get_begin()->__next_ != nullptr)
                ++__lm1;
            __lm1.__get_begin()->__next_ = __p.__get_begin()->__next_;
        }
        __p.__get_begin()->__next_ = __x.__before_begin()->__next_;
        __x.__before_begin()->__next_ = nullptr;
    }
}

template <class _Tp, class _Alloc>
void
forward_list<_Tp, _Alloc>::splice_after(const_iterator __p,
                                        forward_list& ,
                                        const_iterator __i)
{
    const_iterator __lm1 = std::__1::next(__i);
    if (__p != __i && __p != __lm1)
    {
        __i.__get_begin()->__next_ = __lm1.__get_begin()->__next_;
        __lm1.__get_begin()->__next_ = __p.__get_begin()->__next_;
        __p.__get_begin()->__next_ = __lm1.__get_unsafe_node_pointer();
    }
}

template <class _Tp, class _Alloc>
void
forward_list<_Tp, _Alloc>::splice_after(const_iterator __p,
                                        forward_list& ,
                                        const_iterator __f, const_iterator __l)
{
    if (__f != __l && __p != __f)
    {
        const_iterator __lm1 = __f;
        while (__lm1.__get_begin()->__next_ != __l.__get_begin())
            ++__lm1;
        if (__f != __lm1)
        {
            __lm1.__get_begin()->__next_ = __p.__get_begin()->__next_;
            __p.__get_begin()->__next_ = __f.__get_begin()->__next_;
            __f.__get_begin()->__next_ = __l.__get_unsafe_node_pointer();
        }
    }
}

template <class _Tp, class _Alloc>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void
forward_list<_Tp, _Alloc>::splice_after(const_iterator __p,
                                        forward_list&& __x)
{
    splice_after(__p, __x);
}

template <class _Tp, class _Alloc>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void
forward_list<_Tp, _Alloc>::splice_after(const_iterator __p,
                                        forward_list&& __x,
                                        const_iterator __i)
{
    splice_after(__p, __x, __i);
}

template <class _Tp, class _Alloc>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void
forward_list<_Tp, _Alloc>::splice_after(const_iterator __p,
                                        forward_list&& __x,
                                        const_iterator __f, const_iterator __l)
{
    splice_after(__p, __x, __f, __l);
}

template <class _Tp, class _Alloc>
typename forward_list<_Tp, _Alloc>::__remove_return_type
forward_list<_Tp, _Alloc>::remove(const value_type& __v)
{
    forward_list<_Tp, _Alloc> __deleted_nodes(get_allocator());
    typename forward_list<_Tp, _Alloc>::size_type __count_removed = 0;
    const iterator __e = end();
    for (iterator __i = before_begin(); __i.__get_begin()->__next_ != nullptr;)
    {
        if (__i.__get_begin()->__next_->__value_ == __v)
        {
            ++__count_removed;
            iterator __j = std::__1::next(__i, 2);
            for (; __j != __e && *__j == __v; ++__j)
                ++__count_removed;
            __deleted_nodes.splice_after(__deleted_nodes.before_begin(), *this, __i, __j);
            if (__j == __e)
                break;
            __i = __j;
        }
        else
            ++__i;
    }

    return (__remove_return_type) __count_removed;
}

template <class _Tp, class _Alloc>
template <class _Predicate>
typename forward_list<_Tp, _Alloc>::__remove_return_type
forward_list<_Tp, _Alloc>::remove_if(_Predicate __pred)
{
    forward_list<_Tp, _Alloc> __deleted_nodes(get_allocator());
    typename forward_list<_Tp, _Alloc>::size_type __count_removed = 0;
    const iterator __e = end();
    for (iterator __i = before_begin(); __i.__get_begin()->__next_ != nullptr;)
    {
        if (__pred(__i.__get_begin()->__next_->__value_))
        {
            ++__count_removed;
            iterator __j = std::__1::next(__i, 2);
            for (; __j != __e && __pred(*__j); ++__j)
                ++__count_removed;
            __deleted_nodes.splice_after(__deleted_nodes.before_begin(), *this, __i, __j);
            if (__j == __e)
                break;
            __i = __j;
        }
        else
            ++__i;
    }

    return (__remove_return_type) __count_removed;
}

template <class _Tp, class _Alloc>
template <class _BinaryPredicate>
typename forward_list<_Tp, _Alloc>::__remove_return_type
forward_list<_Tp, _Alloc>::unique(_BinaryPredicate __binary_pred)
{
    forward_list<_Tp, _Alloc> __deleted_nodes(get_allocator());
    typename forward_list<_Tp, _Alloc>::size_type __count_removed = 0;
    for (iterator __i = begin(), __e = end(); __i != __e;)
    {
        iterator __j = std::__1::next(__i);
        for (; __j != __e && __binary_pred(*__i, *__j); ++__j)
            ++__count_removed;
        if (__i.__get_begin()->__next_ != __j.__get_unsafe_node_pointer())
            __deleted_nodes.splice_after(__deleted_nodes.before_begin(), *this, __i, __j);
        __i = __j;
    }

    return (__remove_return_type) __count_removed;
}

template <class _Tp, class _Alloc>
template <class _Compare>
void
forward_list<_Tp, _Alloc>::merge(forward_list& __x, _Compare __comp)
{
    if (this != &__x)
    {
        base::__before_begin()->__next_ = __merge(base::__before_begin()->__next_,
                                                    __x.__before_begin()->__next_,
                                                    __comp);
        __x.__before_begin()->__next_ = nullptr;
    }
}

template <class _Tp, class _Alloc>
template <class _Compare>
typename forward_list<_Tp, _Alloc>::__node_pointer
forward_list<_Tp, _Alloc>::__merge(__node_pointer __f1, __node_pointer __f2,
                                   _Compare& __comp)
{
    if (__f1 == nullptr)
        return __f2;
    if (__f2 == nullptr)
        return __f1;
    __node_pointer __r;
    if (__comp(__f2->__value_, __f1->__value_))
    {
        __node_pointer __t = __f2;
        while (__t->__next_ != nullptr &&
                             __comp(__t->__next_->__value_, __f1->__value_))
            __t = __t->__next_;
        __r = __f2;
        __f2 = __t->__next_;
        __t->__next_ = __f1;
    }
    else
        __r = __f1;
    __node_pointer __p = __f1;
    __f1 = __f1->__next_;
    while (__f1 != nullptr && __f2 != nullptr)
    {
        if (__comp(__f2->__value_, __f1->__value_))
        {
            __node_pointer __t = __f2;
            while (__t->__next_ != nullptr &&
                                 __comp(__t->__next_->__value_, __f1->__value_))
                __t = __t->__next_;
            __p->__next_ = __f2;
            __f2 = __t->__next_;
            __t->__next_ = __f1;
        }
        __p = __f1;
        __f1 = __f1->__next_;
    }
    if (__f2 != nullptr)
        __p->__next_ = __f2;
    return __r;
}

template <class _Tp, class _Alloc>
template <class _Compare>
inline
void
forward_list<_Tp, _Alloc>::sort(_Compare __comp)
{
    base::__before_begin()->__next_ = __sort(base::__before_begin()->__next_,
                                       std::__1::distance(begin(), end()), __comp);
}

template <class _Tp, class _Alloc>
template <class _Compare>
typename forward_list<_Tp, _Alloc>::__node_pointer
forward_list<_Tp, _Alloc>::__sort(__node_pointer __f1, difference_type __sz,
                                  _Compare& __comp)
{
    switch (__sz)
    {
    case 0:
    case 1:
        return __f1;
    case 2:
        if (__comp(__f1->__next_->__value_, __f1->__value_))
        {
            __node_pointer __t = __f1->__next_;
            __t->__next_ = __f1;
            __f1->__next_ = nullptr;
            __f1 = __t;
        }
        return __f1;
    }
    difference_type __sz1 = __sz / 2;
    difference_type __sz2 = __sz - __sz1;
    __node_pointer __t = std::__1::next(iterator(__f1), __sz1 - 1).__get_unsafe_node_pointer();
    __node_pointer __f2 = __t->__next_;
    __t->__next_ = nullptr;
    return __merge(__sort(__f1, __sz1, __comp),
                   __sort(__f2, __sz2, __comp), __comp);
}

template <class _Tp, class _Alloc>
void
forward_list<_Tp, _Alloc>::reverse() noexcept
{
    __node_pointer __p = base::__before_begin()->__next_;
    if (__p != nullptr)
    {
        __node_pointer __f = __p->__next_;
        __p->__next_ = nullptr;
        while (__f != nullptr)
        {
            __node_pointer __t = __f->__next_;
            __f->__next_ = __p;
            __p = __f;
            __f = __t;
        }
        base::__before_begin()->__next_ = __p;
    }
}

template <class _Tp, class _Alloc>
bool operator==(const forward_list<_Tp, _Alloc>& __x,
                const forward_list<_Tp, _Alloc>& __y)
{
    typedef forward_list<_Tp, _Alloc> _Cp;
    typedef typename _Cp::const_iterator _Ip;
    _Ip __ix = __x.begin();
    _Ip __ex = __x.end();
    _Ip __iy = __y.begin();
    _Ip __ey = __y.end();
    for (; __ix != __ex && __iy != __ey; ++__ix, ++__iy)
        if (!(*__ix == *__iy))
            return false;
    return (__ix == __ex) == (__iy == __ey);
}

template <class _Tp, class _Alloc>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool operator!=(const forward_list<_Tp, _Alloc>& __x,
                const forward_list<_Tp, _Alloc>& __y)
{
    return !(__x == __y);
}

template <class _Tp, class _Alloc>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool operator< (const forward_list<_Tp, _Alloc>& __x,
                const forward_list<_Tp, _Alloc>& __y)
{
    return std::__1::lexicographical_compare(__x.begin(), __x.end(),
                                         __y.begin(), __y.end());
}

template <class _Tp, class _Alloc>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool operator> (const forward_list<_Tp, _Alloc>& __x,
                const forward_list<_Tp, _Alloc>& __y)
{
    return __y < __x;
}

template <class _Tp, class _Alloc>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool operator>=(const forward_list<_Tp, _Alloc>& __x,
                const forward_list<_Tp, _Alloc>& __y)
{
    return !(__x < __y);
}

template <class _Tp, class _Alloc>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool operator<=(const forward_list<_Tp, _Alloc>& __x,
                const forward_list<_Tp, _Alloc>& __y)
{
    return !(__y < __x);
}

template <class _Tp, class _Alloc>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void
swap(forward_list<_Tp, _Alloc>& __x, forward_list<_Tp, _Alloc>& __y)
    noexcept(noexcept(__x.swap(__y)))
{
    __x.swap(__y);
}
# 1784 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/forward_list" 3
} }
# 232 "/usr/local/include/bits/stdc++.h" 2


# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/future" 1 3
# 373 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/future" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/memory" 1 3
# 974 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/memory" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 1 3
# 20 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/assert.h" 1 3 4
# 44 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/assert.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/stdlib.h" 1 3 4
# 45 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/assert.h" 2 3 4
# 81 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/assert.h" 3 4
extern "C" {
void __assert_rtn(const char *, const char *, int, const char *) __attribute__((__noreturn__)) __attribute__((__cold__)) __attribute__((__disable_tail_calls__));



}
# 21 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 2 3
# 24 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 3
# 975 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/memory" 2 3
# 374 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/future" 2 3


# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/thread" 1 3
# 97 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/thread" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/memory" 1 3
# 974 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/memory" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 1 3
# 20 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/assert.h" 1 3 4
# 44 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/assert.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/stdlib.h" 1 3 4
# 45 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/assert.h" 2 3 4
# 81 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/assert.h" 3 4
extern "C" {
void __assert_rtn(const char *, const char *, int, const char *) __attribute__((__noreturn__)) __attribute__((__cold__)) __attribute__((__disable_tail_calls__));



}
# 21 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 2 3
# 24 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 3
# 975 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/memory" 2 3
# 98 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/thread" 2 3


# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 1 3
# 101 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/thread" 2 3
# 104 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/thread" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 108 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/thread" 2 3





namespace std { inline namespace __1 {

template <class _Tp> class __thread_specific_ptr;
class __attribute__ ((__visibility__("default"))) __thread_struct;
class __attribute__ ((__visibility__("hidden"))) __thread_struct_imp;
class __assoc_sub_state;

__attribute__ ((__visibility__("default"))) __thread_specific_ptr<__thread_struct>& __thread_local_data();

class __attribute__ ((__visibility__("default"))) __thread_struct
{
    __thread_struct_imp* __p_;

    __thread_struct(const __thread_struct&);
    __thread_struct& operator=(const __thread_struct&);
public:
    __thread_struct();
    ~__thread_struct();

    void notify_all_at_thread_exit(condition_variable*, mutex*);
    void __make_ready_at_thread_exit(__assoc_sub_state*);
};

template <class _Tp>
class __thread_specific_ptr
{
    __libcpp_tls_key __key_;



    static_assert((is_same<_Tp, __thread_struct>::value), "");
    __thread_specific_ptr();
    friend __attribute__ ((__visibility__("default"))) __thread_specific_ptr<__thread_struct>& __thread_local_data();

    __thread_specific_ptr(const __thread_specific_ptr&);
    __thread_specific_ptr& operator=(const __thread_specific_ptr&);

    __attribute__ ((__visibility__("hidden"))) static void __at_thread_exit(void*);

public:
    typedef _Tp* pointer;

    ~__thread_specific_ptr();

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    pointer get() const {return static_cast<_Tp*>(__libcpp_tls_get(__key_));}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    pointer operator*() const {return *get();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    pointer operator->() const {return get();}
    void set_pointer(pointer __p);
};

template <class _Tp>
void
__thread_specific_ptr<_Tp>::__at_thread_exit(void* __p)
{
    delete static_cast<pointer>(__p);
}

template <class _Tp>
__thread_specific_ptr<_Tp>::__thread_specific_ptr()
{
  int __ec =
      __libcpp_tls_create(&__key_, &__thread_specific_ptr::__at_thread_exit);
  if (__ec)
    __throw_system_error(__ec, "__thread_specific_ptr construction failed");
}

template <class _Tp>
__thread_specific_ptr<_Tp>::~__thread_specific_ptr()
{




}

template <class _Tp>
void
__thread_specific_ptr<_Tp>::set_pointer(pointer __p)
{
    ((void)0);

    __libcpp_tls_set(__key_, __p);
}

template<>
struct __attribute__ ((__type_visibility__("default"))) hash<__thread_id>
    : public unary_function<__thread_id, size_t>
{
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_t operator()(__thread_id __v) const noexcept
    {
        return hash<__libcpp_thread_id>()(__v.__id_);
    }
};

template<class _CharT, class _Traits>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
basic_ostream<_CharT, _Traits>&
operator<<(basic_ostream<_CharT, _Traits>& __os, __thread_id __id)
{return __os << __id.__id_;}

template <typename _Tag>
struct __thread_access;

class __attribute__ ((__visibility__("default"))) thread
{
    __libcpp_thread_t __t_;

    thread(const thread&);
    thread& operator=(const thread&);
public:
    typedef __thread_id id;
    typedef __libcpp_thread_t native_handle_type;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    thread() noexcept : __t_(((__libcpp_thread_t()))) {}

    template <class _Fp, class ..._Args,
              class = typename enable_if
              <
                   !is_same<typename __uncvref<_Fp>::type, thread>::value
              >::type
             >
        inline __attribute__ ((__visibility__("hidden")))
        explicit thread(_Fp&& __f, _Args&&... __args);





    ~thread();

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    thread(thread&& __t) noexcept : __t_(__t.__t_) {
        __t.__t_ = ((__libcpp_thread_t()));
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    thread& operator=(thread&& __t) noexcept {
        if (!__libcpp_thread_isnull(&__t_))
            terminate();
        __t_ = __t.__t_;
        __t.__t_ = ((__libcpp_thread_t()));
        return *this;
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void swap(thread& __t) noexcept {std::__1::swap(__t_, __t.__t_);}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    bool joinable() const noexcept {return !__libcpp_thread_isnull(&__t_);}
    void join();
    void detach();
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    id get_id() const noexcept {return __libcpp_thread_get_id(&__t_);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    native_handle_type native_handle() noexcept {return __t_;}

    static unsigned hardware_concurrency() noexcept;

    template <typename _Tag>
    friend struct __thread_access;
};



template <class _TSp, class _Fp, class ..._Args, size_t ..._Indices>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void
__thread_execute(tuple<_TSp, _Fp, _Args...>& __t, __tuple_indices<_Indices...>)
{
    std::__1::__invoke(std::__1::move(std::__1::get<1>(__t)), std::__1::move(std::__1::get<_Indices>(__t))...);
}

template <class _Fp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void* __thread_proxy(void* __vp)
{

    unique_ptr<_Fp> __p(static_cast<_Fp*>(__vp));
    __thread_local_data().set_pointer(std::__1::get<0>(*__p.get()).release());
    typedef typename __make_tuple_indices<tuple_size<_Fp>::value, 2>::type _Index;
    std::__1::__thread_execute(*__p.get(), _Index());
    return nullptr;
}

template <class _Fp, class ..._Args,
          class
         >
thread::thread(_Fp&& __f, _Args&&... __args)
{
    typedef unique_ptr<__thread_struct> _TSPtr;
    _TSPtr __tsp(new __thread_struct);
    typedef tuple<_TSPtr, typename decay<_Fp>::type, typename decay<_Args>::type...> _Gp;
    unique_ptr<_Gp> __p(
            new _Gp(std::__1::move(__tsp),
                    std::__1::__decay_copy(std::__1::forward<_Fp>(__f)),
                    std::__1::__decay_copy(std::__1::forward<_Args>(__args))...));
    int __ec = std::__1::__libcpp_thread_create(&__t_, &__thread_proxy<_Gp>, __p.get());
    if (__ec == 0)
        __p.release();
    else
        __throw_system_error(__ec, "thread constructor failed");
}
# 358 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/thread" 3
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void swap(thread& __x, thread& __y) noexcept {__x.swap(__y);}

namespace this_thread
{

__attribute__ ((__visibility__("default"))) void sleep_for(const chrono::nanoseconds& __ns);

template <class _Rep, class _Period>
void
sleep_for(const chrono::duration<_Rep, _Period>& __d)
{
    if (__d > chrono::duration<_Rep, _Period>::zero())
    {



        constexpr chrono::duration<long double> _Max =
            chrono::duration<long double>(9223372036.0L);
        chrono::nanoseconds __ns;
        if (__d < _Max)
        {
            __ns = chrono::duration_cast<chrono::nanoseconds>(__d);
            if (__ns < __d)
                ++__ns;
        }
        else
            __ns = chrono::nanoseconds::max();
        this_thread::sleep_for(__ns);
    }
}

template <class _Clock, class _Duration>
void
sleep_until(const chrono::time_point<_Clock, _Duration>& __t)
{
    mutex __mut;
    condition_variable __cv;
    unique_lock<mutex> __lk(__mut);
    while (_Clock::now() < __t)
        __cv.wait_until(__lk, __t);
}

template <class _Duration>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void
sleep_until(const chrono::time_point<chrono::steady_clock, _Duration>& __t)
{
    this_thread::sleep_for(__t - chrono::steady_clock::now());
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void yield() noexcept {__libcpp_thread_yield();}

}

} }
# 377 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/future" 2 3
# 380 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/future" 3






namespace std { inline namespace __1 {


enum class __attribute__ ((__type_visibility__("default"))) future_errc
{
    future_already_retrieved = 1,
    promise_already_satisfied,
    no_state,
    broken_promise
};


template <>
struct __attribute__ ((__type_visibility__("default"))) is_error_code_enum<future_errc> : public true_type {};







enum class __attribute__ ((__type_visibility__("default"))) launch
{
    async = 1,
    deferred = 2,
    any = async | deferred
};




typedef underlying_type<launch>::type __launch_underlying_type;

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
constexpr
launch
operator&(launch __x, launch __y)
{
    return static_cast<launch>(static_cast<__launch_underlying_type>(__x) &
                               static_cast<__launch_underlying_type>(__y));
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
constexpr
launch
operator|(launch __x, launch __y)
{
    return static_cast<launch>(static_cast<__launch_underlying_type>(__x) |
                               static_cast<__launch_underlying_type>(__y));
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
constexpr
launch
operator^(launch __x, launch __y)
{
    return static_cast<launch>(static_cast<__launch_underlying_type>(__x) ^
                               static_cast<__launch_underlying_type>(__y));
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
constexpr
launch
operator~(launch __x)
{
    return static_cast<launch>(~static_cast<__launch_underlying_type>(__x) & 3);
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
launch&
operator&=(launch& __x, launch __y)
{
    __x = __x & __y; return __x;
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
launch&
operator|=(launch& __x, launch __y)
{
    __x = __x | __y; return __x;
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
launch&
operator^=(launch& __x, launch __y)
{
    __x = __x ^ __y; return __x;
}




enum class __attribute__ ((__type_visibility__("default"))) future_status
{
    ready,
    timeout,
    deferred
};


__attribute__ ((__visibility__("default")))
const error_category& future_category() noexcept;

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
error_code
make_error_code(future_errc __e) noexcept
{
    return error_code(static_cast<int>(__e), future_category());
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
error_condition
make_error_condition(future_errc __e) noexcept
{
    return error_condition(static_cast<int>(__e), future_category());
}

class __attribute__ ((__visibility__("default"))) __attribute__((availability(ios,strict,introduced=6.0))) future_error
    : public logic_error
{
    error_code __ec_;
public:
    future_error(error_code __ec);

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const error_code& code() const noexcept {return __ec_;}

    future_error(const future_error&) noexcept = default;
    virtual ~future_error() noexcept;
};

[[noreturn]] inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))

__attribute__((availability(ios,strict,introduced=6.0)))

void __throw_future_error(future_errc _Ev)
{

    throw future_error(make_error_code(_Ev));




}

class __attribute__ ((__visibility__("default"))) __attribute__((availability(ios,strict,introduced=6.0))) __assoc_sub_state
    : public __shared_count
{
protected:
    exception_ptr __exception_;
    mutable mutex __mut_;
    mutable condition_variable __cv_;
    unsigned __state_;

    virtual void __on_zero_shared() noexcept;
    void __sub_wait(unique_lock<mutex>& __lk);
public:
    enum
    {
        __constructed = 1,
        __future_attached = 2,
        ready = 4,
        deferred = 8
    };

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __assoc_sub_state() : __state_(0) {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    bool __has_value() const
        {return (__state_ & __constructed) || (__exception_ != nullptr);}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void __attach_future() {
        lock_guard<mutex> __lk(__mut_);
        bool __has_future_attached = (__state_ & __future_attached) != 0;
        if (__has_future_attached)
            __throw_future_error(future_errc::future_already_retrieved);
        this->__add_shared();
        __state_ |= __future_attached;
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void __set_deferred() {__state_ |= deferred;}

    void __make_ready();
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    bool __is_ready() const {return (__state_ & ready) != 0;}

    void set_value();
    void set_value_at_thread_exit();

    void set_exception(exception_ptr __p);
    void set_exception_at_thread_exit(exception_ptr __p);

    void copy();

    void wait();
    template <class _Rep, class _Period>
        future_status
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        wait_for(const chrono::duration<_Rep, _Period>& __rel_time) const;
    template <class _Clock, class _Duration>
        inline __attribute__ ((__visibility__("hidden")))
        future_status
        wait_until(const chrono::time_point<_Clock, _Duration>& __abs_time) const;

    virtual void __execute();
};

template <class _Clock, class _Duration>
future_status
__assoc_sub_state::wait_until(const chrono::time_point<_Clock, _Duration>& __abs_time) const
{
    unique_lock<mutex> __lk(__mut_);
    if (__state_ & deferred)
        return future_status::deferred;
    while (!(__state_ & ready) && _Clock::now() < __abs_time)
        __cv_.wait_until(__lk, __abs_time);
    if (__state_ & ready)
        return future_status::ready;
    return future_status::timeout;
}

template <class _Rep, class _Period>
inline
future_status
__assoc_sub_state::wait_for(const chrono::duration<_Rep, _Period>& __rel_time) const
{
    return wait_until(chrono::steady_clock::now() + __rel_time);
}

template <class _Rp>
class __attribute__((availability(ios,strict,introduced=6.0))) __attribute__ ((__visibility__("hidden"))) __assoc_state
    : public __assoc_sub_state
{
    typedef __assoc_sub_state base;
    typedef typename aligned_storage<sizeof(_Rp), alignment_of<_Rp>::value>::type _Up;
protected:
    _Up __value_;

    virtual void __on_zero_shared() noexcept;
public:

    template <class _Arg>
    void set_value(_Arg&& __arg);

    template <class _Arg>
    void set_value_at_thread_exit(_Arg&& __arg);

    _Rp move();
    typename add_lvalue_reference<_Rp>::type copy();
};

template <class _Rp>
void
__assoc_state<_Rp>::__on_zero_shared() noexcept
{
    if (this->__state_ & base::__constructed)
        reinterpret_cast<_Rp*>(&__value_)->~_Rp();
    delete this;
}

template <class _Rp>
template <class _Arg>
__attribute__((availability(ios,strict,introduced=6.0)))
void
__assoc_state<_Rp>::set_value(_Arg&& __arg)
{
    unique_lock<mutex> __lk(this->__mut_);
    if (this->__has_value())
        __throw_future_error(future_errc::promise_already_satisfied);
    ::new ((void*)&__value_) _Rp(std::__1::forward<_Arg>(__arg));
    this->__state_ |= base::__constructed | base::ready;
    __cv_.notify_all();
}

template <class _Rp>
template <class _Arg>
void
__assoc_state<_Rp>::set_value_at_thread_exit(_Arg&& __arg)
{
    unique_lock<mutex> __lk(this->__mut_);
    if (this->__has_value())
        __throw_future_error(future_errc::promise_already_satisfied);
    ::new ((void*)&__value_) _Rp(std::__1::forward<_Arg>(__arg));
    this->__state_ |= base::__constructed;
    __thread_local_data()->__make_ready_at_thread_exit(this);
}

template <class _Rp>
_Rp
__assoc_state<_Rp>::move()
{
    unique_lock<mutex> __lk(this->__mut_);
    this->__sub_wait(__lk);
    if (this->__exception_ != nullptr)
        rethrow_exception(this->__exception_);
    return std::__1::move(*reinterpret_cast<_Rp*>(&__value_));
}

template <class _Rp>
typename add_lvalue_reference<_Rp>::type
__assoc_state<_Rp>::copy()
{
    unique_lock<mutex> __lk(this->__mut_);
    this->__sub_wait(__lk);
    if (this->__exception_ != nullptr)
        rethrow_exception(this->__exception_);
    return *reinterpret_cast<_Rp*>(&__value_);
}

template <class _Rp>
class __attribute__((availability(ios,strict,introduced=6.0))) __assoc_state<_Rp&>
    : public __assoc_sub_state
{
    typedef __assoc_sub_state base;
    typedef _Rp* _Up;
protected:
    _Up __value_;

    virtual void __on_zero_shared() noexcept;
public:

    void set_value(_Rp& __arg);
    void set_value_at_thread_exit(_Rp& __arg);

    _Rp& copy();
};

template <class _Rp>
void
__assoc_state<_Rp&>::__on_zero_shared() noexcept
{
    delete this;
}

template <class _Rp>
void
__assoc_state<_Rp&>::set_value(_Rp& __arg)
{
    unique_lock<mutex> __lk(this->__mut_);
    if (this->__has_value())
        __throw_future_error(future_errc::promise_already_satisfied);
    __value_ = std::__1::addressof(__arg);
    this->__state_ |= base::__constructed | base::ready;
    __cv_.notify_all();
}

template <class _Rp>
void
__assoc_state<_Rp&>::set_value_at_thread_exit(_Rp& __arg)
{
    unique_lock<mutex> __lk(this->__mut_);
    if (this->__has_value())
        __throw_future_error(future_errc::promise_already_satisfied);
    __value_ = std::__1::addressof(__arg);
    this->__state_ |= base::__constructed;
    __thread_local_data()->__make_ready_at_thread_exit(this);
}

template <class _Rp>
_Rp&
__assoc_state<_Rp&>::copy()
{
    unique_lock<mutex> __lk(this->__mut_);
    this->__sub_wait(__lk);
    if (this->__exception_ != nullptr)
        rethrow_exception(this->__exception_);
    return *__value_;
}

template <class _Rp, class _Alloc>
class __attribute__((availability(ios,strict,introduced=6.0))) __assoc_state_alloc
    : public __assoc_state<_Rp>
{
    typedef __assoc_state<_Rp> base;
    _Alloc __alloc_;

    virtual void __on_zero_shared() noexcept;
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit __assoc_state_alloc(const _Alloc& __a)
        : __alloc_(__a) {}
};

template <class _Rp, class _Alloc>
void
__assoc_state_alloc<_Rp, _Alloc>::__on_zero_shared() noexcept
{
    if (this->__state_ & base::__constructed)
        reinterpret_cast<_Rp*>(std::__1::addressof(this->__value_))->~_Rp();
    typedef typename __allocator_traits_rebind<_Alloc, __assoc_state_alloc>::type _Al;
    typedef allocator_traits<_Al> _ATraits;
    typedef pointer_traits<typename _ATraits::pointer> _PTraits;
    _Al __a(__alloc_);
    this->~__assoc_state_alloc();
    __a.deallocate(_PTraits::pointer_to(*this), 1);
}

template <class _Rp, class _Alloc>
class __attribute__((availability(ios,strict,introduced=6.0))) __assoc_state_alloc<_Rp&, _Alloc>
    : public __assoc_state<_Rp&>
{
    typedef __assoc_state<_Rp&> base;
    _Alloc __alloc_;

    virtual void __on_zero_shared() noexcept;
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit __assoc_state_alloc(const _Alloc& __a)
        : __alloc_(__a) {}
};

template <class _Rp, class _Alloc>
void
__assoc_state_alloc<_Rp&, _Alloc>::__on_zero_shared() noexcept
{
    typedef typename __allocator_traits_rebind<_Alloc, __assoc_state_alloc>::type _Al;
    typedef allocator_traits<_Al> _ATraits;
    typedef pointer_traits<typename _ATraits::pointer> _PTraits;
    _Al __a(__alloc_);
    this->~__assoc_state_alloc();
    __a.deallocate(_PTraits::pointer_to(*this), 1);
}

template <class _Alloc>
class __attribute__((availability(ios,strict,introduced=6.0))) __assoc_sub_state_alloc
    : public __assoc_sub_state
{
    typedef __assoc_sub_state base;
    _Alloc __alloc_;

    virtual void __on_zero_shared() noexcept;
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit __assoc_sub_state_alloc(const _Alloc& __a)
        : __alloc_(__a) {}
};

template <class _Alloc>
void
__assoc_sub_state_alloc<_Alloc>::__on_zero_shared() noexcept
{
    typedef typename __allocator_traits_rebind<_Alloc, __assoc_sub_state_alloc>::type _Al;
    typedef allocator_traits<_Al> _ATraits;
    typedef pointer_traits<typename _ATraits::pointer> _PTraits;
    _Al __a(__alloc_);
    this->~__assoc_sub_state_alloc();
    __a.deallocate(_PTraits::pointer_to(*this), 1);
}

template <class _Rp, class _Fp>
class __attribute__((availability(ios,strict,introduced=6.0))) __deferred_assoc_state
    : public __assoc_state<_Rp>
{
    typedef __assoc_state<_Rp> base;

    _Fp __func_;

public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit __deferred_assoc_state(_Fp&& __f);

    virtual void __execute();
};

template <class _Rp, class _Fp>
inline
__deferred_assoc_state<_Rp, _Fp>::__deferred_assoc_state(_Fp&& __f)
    : __func_(std::__1::forward<_Fp>(__f))
{
    this->__set_deferred();
}

template <class _Rp, class _Fp>
void
__deferred_assoc_state<_Rp, _Fp>::__execute()
{

    try
    {

        this->set_value(__func_());

    }
    catch (...)
    {
        this->set_exception(current_exception());
    }

}

template <class _Fp>
class __attribute__((availability(ios,strict,introduced=6.0))) __deferred_assoc_state<void, _Fp>
    : public __assoc_sub_state
{
    typedef __assoc_sub_state base;

    _Fp __func_;

public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit __deferred_assoc_state(_Fp&& __f);

    virtual void __execute();
};

template <class _Fp>
inline
__deferred_assoc_state<void, _Fp>::__deferred_assoc_state(_Fp&& __f)
    : __func_(std::__1::forward<_Fp>(__f))
{
    this->__set_deferred();
}

template <class _Fp>
void
__deferred_assoc_state<void, _Fp>::__execute()
{

    try
    {

        __func_();
        this->set_value();

    }
    catch (...)
    {
        this->set_exception(current_exception());
    }

}

template <class _Rp, class _Fp>
class __attribute__((availability(ios,strict,introduced=6.0))) __async_assoc_state
    : public __assoc_state<_Rp>
{
    typedef __assoc_state<_Rp> base;

    _Fp __func_;

    virtual void __on_zero_shared() noexcept;
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit __async_assoc_state(_Fp&& __f);

    virtual void __execute();
};

template <class _Rp, class _Fp>
inline
__async_assoc_state<_Rp, _Fp>::__async_assoc_state(_Fp&& __f)
    : __func_(std::__1::forward<_Fp>(__f))
{
}

template <class _Rp, class _Fp>
void
__async_assoc_state<_Rp, _Fp>::__execute()
{

    try
    {

        this->set_value(__func_());

    }
    catch (...)
    {
        this->set_exception(current_exception());
    }

}

template <class _Rp, class _Fp>
void
__async_assoc_state<_Rp, _Fp>::__on_zero_shared() noexcept
{
    this->wait();
    base::__on_zero_shared();
}

template <class _Fp>
class __attribute__((availability(ios,strict,introduced=6.0))) __async_assoc_state<void, _Fp>
    : public __assoc_sub_state
{
    typedef __assoc_sub_state base;

    _Fp __func_;

    virtual void __on_zero_shared() noexcept;
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit __async_assoc_state(_Fp&& __f);

    virtual void __execute();
};

template <class _Fp>
inline
__async_assoc_state<void, _Fp>::__async_assoc_state(_Fp&& __f)
    : __func_(std::__1::forward<_Fp>(__f))
{
}

template <class _Fp>
void
__async_assoc_state<void, _Fp>::__execute()
{

    try
    {

        __func_();
        this->set_value();

    }
    catch (...)
    {
        this->set_exception(current_exception());
    }

}

template <class _Fp>
void
__async_assoc_state<void, _Fp>::__on_zero_shared() noexcept
{
    this->wait();
    base::__on_zero_shared();
}

template <class _Rp> class __attribute__ ((__type_visibility__("default"))) promise;
template <class _Rp> class __attribute__ ((__type_visibility__("default"))) shared_future;



template <class _Rp> class __attribute__ ((__type_visibility__("default"))) future;

template <class _Rp, class _Fp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) future<_Rp>
__make_deferred_assoc_state(_Fp&& __f);

template <class _Rp, class _Fp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) future<_Rp>
__make_async_assoc_state(_Fp&& __f);

template <class _Rp>
class __attribute__ ((__type_visibility__("default"))) __attribute__((availability(ios,strict,introduced=6.0))) future
{
    __assoc_state<_Rp>* __state_;

    explicit future(__assoc_state<_Rp>* __state);

    template <class> friend class promise;
    template <class> friend class shared_future;

    template <class _R1, class _Fp>
        friend future<_R1> __make_deferred_assoc_state(_Fp&& __f);
    template <class _R1, class _Fp>
        friend future<_R1> __make_async_assoc_state(_Fp&& __f);

public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    future() noexcept : __state_(nullptr) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    future(future&& __rhs) noexcept
        : __state_(__rhs.__state_) {__rhs.__state_ = nullptr;}
    future(const future&) = delete;
    future& operator=(const future&) = delete;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    future& operator=(future&& __rhs) noexcept
        {
            future(std::__1::move(__rhs)).swap(*this);
            return *this;
        }

    ~future();
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    shared_future<_Rp> share() noexcept;


    _Rp get();

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void swap(future& __rhs) noexcept {std::__1::swap(__state_, __rhs.__state_);}


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    bool valid() const noexcept {return __state_ != nullptr;}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void wait() const {__state_->wait();}
    template <class _Rep, class _Period>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        future_status
        wait_for(const chrono::duration<_Rep, _Period>& __rel_time) const
            {return __state_->wait_for(__rel_time);}
    template <class _Clock, class _Duration>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        future_status
        wait_until(const chrono::time_point<_Clock, _Duration>& __abs_time) const
            {return __state_->wait_until(__abs_time);}
};

template <class _Rp>
future<_Rp>::future(__assoc_state<_Rp>* __state)
    : __state_(__state)
{
    __state_->__attach_future();
}

struct __release_shared_count
{
    void operator()(__shared_count* p) {p->__release_shared();}
};

template <class _Rp>
future<_Rp>::~future()
{
    if (__state_)
        __state_->__release_shared();
}

template <class _Rp>
_Rp
future<_Rp>::get()
{
    unique_ptr<__shared_count, __release_shared_count> __(__state_);
    __assoc_state<_Rp>* __s = __state_;
    __state_ = nullptr;
    return __s->move();
}

template <class _Rp>
class __attribute__ ((__type_visibility__("default"))) __attribute__((availability(ios,strict,introduced=6.0))) future<_Rp&>
{
    __assoc_state<_Rp&>* __state_;

    explicit future(__assoc_state<_Rp&>* __state);

    template <class> friend class promise;
    template <class> friend class shared_future;

    template <class _R1, class _Fp>
        friend future<_R1> __make_deferred_assoc_state(_Fp&& __f);
    template <class _R1, class _Fp>
        friend future<_R1> __make_async_assoc_state(_Fp&& __f);

public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    future() noexcept : __state_(nullptr) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    future(future&& __rhs) noexcept
        : __state_(__rhs.__state_) {__rhs.__state_ = nullptr;}
    future(const future&) = delete;
    future& operator=(const future&) = delete;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    future& operator=(future&& __rhs) noexcept
        {
            future(std::__1::move(__rhs)).swap(*this);
            return *this;
        }

    ~future();
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    shared_future<_Rp&> share() noexcept;


    _Rp& get();

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void swap(future& __rhs) noexcept {std::__1::swap(__state_, __rhs.__state_);}


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    bool valid() const noexcept {return __state_ != nullptr;}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void wait() const {__state_->wait();}
    template <class _Rep, class _Period>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        future_status
        wait_for(const chrono::duration<_Rep, _Period>& __rel_time) const
            {return __state_->wait_for(__rel_time);}
    template <class _Clock, class _Duration>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        future_status
        wait_until(const chrono::time_point<_Clock, _Duration>& __abs_time) const
            {return __state_->wait_until(__abs_time);}
};

template <class _Rp>
future<_Rp&>::future(__assoc_state<_Rp&>* __state)
    : __state_(__state)
{
    __state_->__attach_future();
}

template <class _Rp>
future<_Rp&>::~future()
{
    if (__state_)
        __state_->__release_shared();
}

template <class _Rp>
_Rp&
future<_Rp&>::get()
{
    unique_ptr<__shared_count, __release_shared_count> __(__state_);
    __assoc_state<_Rp&>* __s = __state_;
    __state_ = nullptr;
    return __s->copy();
}

template <>
class __attribute__ ((__visibility__("default"))) __attribute__((availability(ios,strict,introduced=6.0))) future<void>
{
    __assoc_sub_state* __state_;

    explicit future(__assoc_sub_state* __state);

    template <class> friend class promise;
    template <class> friend class shared_future;

    template <class _R1, class _Fp>
        friend future<_R1> __make_deferred_assoc_state(_Fp&& __f);
    template <class _R1, class _Fp>
        friend future<_R1> __make_async_assoc_state(_Fp&& __f);

public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    future() noexcept : __state_(nullptr) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    future(future&& __rhs) noexcept
        : __state_(__rhs.__state_) {__rhs.__state_ = nullptr;}
    future(const future&) = delete;
    future& operator=(const future&) = delete;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    future& operator=(future&& __rhs) noexcept
        {
            future(std::__1::move(__rhs)).swap(*this);
            return *this;
        }

    ~future();
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    shared_future<void> share() noexcept;


    void get();

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void swap(future& __rhs) noexcept {std::__1::swap(__state_, __rhs.__state_);}


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    bool valid() const noexcept {return __state_ != nullptr;}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void wait() const {__state_->wait();}
    template <class _Rep, class _Period>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        future_status
        wait_for(const chrono::duration<_Rep, _Period>& __rel_time) const
            {return __state_->wait_for(__rel_time);}
    template <class _Clock, class _Duration>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        future_status
        wait_until(const chrono::time_point<_Clock, _Duration>& __abs_time) const
            {return __state_->wait_until(__abs_time);}
};

template <class _Rp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void
swap(future<_Rp>& __x, future<_Rp>& __y) noexcept
{
    __x.swap(__y);
}



template <class _Callable> class packaged_task;

template <class _Rp>
class __attribute__ ((__type_visibility__("default"))) __attribute__((availability(ios,strict,introduced=6.0))) promise
{
    __assoc_state<_Rp>* __state_;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit promise(nullptr_t) noexcept : __state_(nullptr) {}

    template <class> friend class packaged_task;
public:
    promise();
    template <class _Alloc>
        promise(allocator_arg_t, const _Alloc& __a);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    promise(promise&& __rhs) noexcept
        : __state_(__rhs.__state_) {__rhs.__state_ = nullptr;}
    promise(const promise& __rhs) = delete;
    ~promise();


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    promise& operator=(promise&& __rhs) noexcept
        {
            promise(std::__1::move(__rhs)).swap(*this);
            return *this;
        }
    promise& operator=(const promise& __rhs) = delete;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void swap(promise& __rhs) noexcept {std::__1::swap(__state_, __rhs.__state_);}


    future<_Rp> get_future();


    void set_value(const _Rp& __r);
    void set_value(_Rp&& __r);
    void set_exception(exception_ptr __p);


    void set_value_at_thread_exit(const _Rp& __r);
    void set_value_at_thread_exit(_Rp&& __r);
    void set_exception_at_thread_exit(exception_ptr __p);
};

template <class _Rp>
promise<_Rp>::promise()
    : __state_(new __assoc_state<_Rp>)
{
}

template <class _Rp>
template <class _Alloc>
promise<_Rp>::promise(allocator_arg_t, const _Alloc& __a0)
{
    typedef __assoc_state_alloc<_Rp, _Alloc> _State;
    typedef typename __allocator_traits_rebind<_Alloc, _State>::type _A2;
    typedef __allocator_destructor<_A2> _D2;
    _A2 __a(__a0);
    unique_ptr<_State, _D2> __hold(__a.allocate(1), _D2(__a, 1));
    ::new ((void*)std::__1::addressof(*__hold.get())) _State(__a0);
    __state_ = std::__1::addressof(*__hold.release());
}

template <class _Rp>
promise<_Rp>::~promise()
{
    if (__state_)
    {
        if (!__state_->__has_value() && __state_->use_count() > 1)
            __state_->set_exception(make_exception_ptr(
                      future_error(make_error_code(future_errc::broken_promise))
                                                      ));
        __state_->__release_shared();
    }
}

template <class _Rp>
future<_Rp>
promise<_Rp>::get_future()
{
    if (__state_ == nullptr)
        __throw_future_error(future_errc::no_state);
    return future<_Rp>(__state_);
}

template <class _Rp>
void
promise<_Rp>::set_value(const _Rp& __r)
{
    if (__state_ == nullptr)
        __throw_future_error(future_errc::no_state);
    __state_->set_value(__r);
}

template <class _Rp>
void
promise<_Rp>::set_value(_Rp&& __r)
{
    if (__state_ == nullptr)
        __throw_future_error(future_errc::no_state);
    __state_->set_value(std::__1::move(__r));
}

template <class _Rp>
void
promise<_Rp>::set_exception(exception_ptr __p)
{
    ((void)0);
    if (__state_ == nullptr)
        __throw_future_error(future_errc::no_state);
    __state_->set_exception(__p);
}

template <class _Rp>
void
promise<_Rp>::set_value_at_thread_exit(const _Rp& __r)
{
    if (__state_ == nullptr)
        __throw_future_error(future_errc::no_state);
    __state_->set_value_at_thread_exit(__r);
}

template <class _Rp>
void
promise<_Rp>::set_value_at_thread_exit(_Rp&& __r)
{
    if (__state_ == nullptr)
        __throw_future_error(future_errc::no_state);
    __state_->set_value_at_thread_exit(std::__1::move(__r));
}

template <class _Rp>
void
promise<_Rp>::set_exception_at_thread_exit(exception_ptr __p)
{
    ((void)0);
    if (__state_ == nullptr)
        __throw_future_error(future_errc::no_state);
    __state_->set_exception_at_thread_exit(__p);
}



template <class _Rp>
class __attribute__ ((__type_visibility__("default"))) __attribute__((availability(ios,strict,introduced=6.0))) promise<_Rp&>
{
    __assoc_state<_Rp&>* __state_;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit promise(nullptr_t) noexcept : __state_(nullptr) {}

    template <class> friend class packaged_task;

public:
    promise();
    template <class _Allocator>
        promise(allocator_arg_t, const _Allocator& __a);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    promise(promise&& __rhs) noexcept
        : __state_(__rhs.__state_) {__rhs.__state_ = nullptr;}
    promise(const promise& __rhs) = delete;
    ~promise();


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    promise& operator=(promise&& __rhs) noexcept
        {
            promise(std::__1::move(__rhs)).swap(*this);
            return *this;
        }
    promise& operator=(const promise& __rhs) = delete;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void swap(promise& __rhs) noexcept {std::__1::swap(__state_, __rhs.__state_);}


    future<_Rp&> get_future();


    void set_value(_Rp& __r);
    void set_exception(exception_ptr __p);


    void set_value_at_thread_exit(_Rp&);
    void set_exception_at_thread_exit(exception_ptr __p);
};

template <class _Rp>
promise<_Rp&>::promise()
    : __state_(new __assoc_state<_Rp&>)
{
}

template <class _Rp>
template <class _Alloc>
promise<_Rp&>::promise(allocator_arg_t, const _Alloc& __a0)
{
    typedef __assoc_state_alloc<_Rp&, _Alloc> _State;
    typedef typename __allocator_traits_rebind<_Alloc, _State>::type _A2;
    typedef __allocator_destructor<_A2> _D2;
    _A2 __a(__a0);
    unique_ptr<_State, _D2> __hold(__a.allocate(1), _D2(__a, 1));
    ::new ((void*)std::__1::addressof(*__hold.get())) _State(__a0);
    __state_ = std::__1::addressof(*__hold.release());
}

template <class _Rp>
promise<_Rp&>::~promise()
{
    if (__state_)
    {
        if (!__state_->__has_value() && __state_->use_count() > 1)
            __state_->set_exception(make_exception_ptr(
                      future_error(make_error_code(future_errc::broken_promise))
                                                      ));
        __state_->__release_shared();
    }
}

template <class _Rp>
future<_Rp&>
promise<_Rp&>::get_future()
{
    if (__state_ == nullptr)
        __throw_future_error(future_errc::no_state);
    return future<_Rp&>(__state_);
}

template <class _Rp>
void
promise<_Rp&>::set_value(_Rp& __r)
{
    if (__state_ == nullptr)
        __throw_future_error(future_errc::no_state);
    __state_->set_value(__r);
}

template <class _Rp>
void
promise<_Rp&>::set_exception(exception_ptr __p)
{
    ((void)0);
    if (__state_ == nullptr)
        __throw_future_error(future_errc::no_state);
    __state_->set_exception(__p);
}

template <class _Rp>
void
promise<_Rp&>::set_value_at_thread_exit(_Rp& __r)
{
    if (__state_ == nullptr)
        __throw_future_error(future_errc::no_state);
    __state_->set_value_at_thread_exit(__r);
}

template <class _Rp>
void
promise<_Rp&>::set_exception_at_thread_exit(exception_ptr __p)
{
    ((void)0);
    if (__state_ == nullptr)
        __throw_future_error(future_errc::no_state);
    __state_->set_exception_at_thread_exit(__p);
}



template <>
class __attribute__ ((__visibility__("default"))) __attribute__((availability(ios,strict,introduced=6.0))) promise<void>
{
    __assoc_sub_state* __state_;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit promise(nullptr_t) noexcept : __state_(nullptr) {}

    template <class> friend class packaged_task;

public:
    promise();
    template <class _Allocator>
        inline __attribute__ ((__visibility__("hidden")))
        promise(allocator_arg_t, const _Allocator& __a);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    promise(promise&& __rhs) noexcept
        : __state_(__rhs.__state_) {__rhs.__state_ = nullptr;}
    promise(const promise& __rhs) = delete;
    ~promise();


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    promise& operator=(promise&& __rhs) noexcept
        {
            promise(std::__1::move(__rhs)).swap(*this);
            return *this;
        }
    promise& operator=(const promise& __rhs) = delete;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void swap(promise& __rhs) noexcept {std::__1::swap(__state_, __rhs.__state_);}


    future<void> get_future();


    void set_value();
    void set_exception(exception_ptr __p);


    void set_value_at_thread_exit();
    void set_exception_at_thread_exit(exception_ptr __p);
};

template <class _Alloc>
promise<void>::promise(allocator_arg_t, const _Alloc& __a0)
{
    typedef __assoc_sub_state_alloc<_Alloc> _State;
    typedef typename __allocator_traits_rebind<_Alloc, _State>::type _A2;
    typedef __allocator_destructor<_A2> _D2;
    _A2 __a(__a0);
    unique_ptr<_State, _D2> __hold(__a.allocate(1), _D2(__a, 1));
    ::new ((void*)std::__1::addressof(*__hold.get())) _State(__a0);
    __state_ = std::__1::addressof(*__hold.release());
}

template <class _Rp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void
swap(promise<_Rp>& __x, promise<_Rp>& __y) noexcept
{
    __x.swap(__y);
}

template <class _Rp, class _Alloc>
    struct __attribute__ ((__type_visibility__("default"))) uses_allocator<promise<_Rp>, _Alloc>
        : public true_type {};



template<class _Fp> class __packaged_task_base;

template<class _Rp, class ..._ArgTypes>
class __attribute__((availability(ios,strict,introduced=6.0))) __packaged_task_base<_Rp(_ArgTypes...)>
{
    __packaged_task_base(const __packaged_task_base&);
    __packaged_task_base& operator=(const __packaged_task_base&);
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __packaged_task_base() {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    virtual ~__packaged_task_base() {}
    virtual void __move_to(__packaged_task_base*) noexcept = 0;
    virtual void destroy() = 0;
    virtual void destroy_deallocate() = 0;
    virtual _Rp operator()(_ArgTypes&& ...) = 0;
};

template<class _FD, class _Alloc, class _FB> class __packaged_task_func;

template<class _Fp, class _Alloc, class _Rp, class ..._ArgTypes>
class __attribute__((availability(ios,strict,introduced=6.0))) __packaged_task_func<_Fp, _Alloc, _Rp(_ArgTypes...)>
    : public __packaged_task_base<_Rp(_ArgTypes...)>
{
    __compressed_pair<_Fp, _Alloc> __f_;
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit __packaged_task_func(const _Fp& __f) : __f_(__f, __default_init_tag()) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit __packaged_task_func(_Fp&& __f) : __f_(std::__1::move(__f), __default_init_tag()) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __packaged_task_func(const _Fp& __f, const _Alloc& __a)
        : __f_(__f, __a) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __packaged_task_func(_Fp&& __f, const _Alloc& __a)
        : __f_(std::__1::move(__f), __a) {}
    virtual void __move_to(__packaged_task_base<_Rp(_ArgTypes...)>*) noexcept;
    virtual void destroy();
    virtual void destroy_deallocate();
    virtual _Rp operator()(_ArgTypes&& ... __args);
};

template<class _Fp, class _Alloc, class _Rp, class ..._ArgTypes>
void
__packaged_task_func<_Fp, _Alloc, _Rp(_ArgTypes...)>::__move_to(
                              __packaged_task_base<_Rp(_ArgTypes...)>* __p) noexcept
{
    ::new ((void*)__p) __packaged_task_func(std::__1::move(__f_.first()), std::__1::move(__f_.second()));
}

template<class _Fp, class _Alloc, class _Rp, class ..._ArgTypes>
void
__packaged_task_func<_Fp, _Alloc, _Rp(_ArgTypes...)>::destroy()
{
    __f_.~__compressed_pair<_Fp, _Alloc>();
}

template<class _Fp, class _Alloc, class _Rp, class ..._ArgTypes>
void
__packaged_task_func<_Fp, _Alloc, _Rp(_ArgTypes...)>::destroy_deallocate()
{
    typedef typename __allocator_traits_rebind<_Alloc, __packaged_task_func>::type _Ap;
    typedef allocator_traits<_Ap> _ATraits;
    typedef pointer_traits<typename _ATraits::pointer> _PTraits;
    _Ap __a(__f_.second());
    __f_.~__compressed_pair<_Fp, _Alloc>();
    __a.deallocate(_PTraits::pointer_to(*this), 1);
}

template<class _Fp, class _Alloc, class _Rp, class ..._ArgTypes>
_Rp
__packaged_task_func<_Fp, _Alloc, _Rp(_ArgTypes...)>::operator()(_ArgTypes&& ... __arg)
{
    return std::__1::__invoke(__f_.first(), std::__1::forward<_ArgTypes>(__arg)...);
}

template <class _Callable> class __packaged_task_function;

template<class _Rp, class ..._ArgTypes>
class __attribute__((availability(ios,strict,introduced=6.0))) __packaged_task_function<_Rp(_ArgTypes...)>
{
    typedef __packaged_task_base<_Rp(_ArgTypes...)> __base;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) __attribute__((__no_sanitize__("cfi")))
    __base* __get_buf() { return (__base*)&__buf_; }

    typename aligned_storage<3*sizeof(void*)>::type __buf_;
    __base* __f_;

public:
    typedef _Rp result_type;


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __packaged_task_function() noexcept : __f_(nullptr) {}
    template<class _Fp>
      __packaged_task_function(_Fp&& __f);
    template<class _Fp, class _Alloc>
      __packaged_task_function(allocator_arg_t, const _Alloc& __a, _Fp&& __f);

    __packaged_task_function(__packaged_task_function&&) noexcept;
    __packaged_task_function& operator=(__packaged_task_function&&) noexcept;

    __packaged_task_function(const __packaged_task_function&) = delete;
    __packaged_task_function& operator=(const __packaged_task_function&) = delete;

    ~__packaged_task_function();

    void swap(__packaged_task_function&) noexcept;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    _Rp operator()(_ArgTypes...) const;
};

template<class _Rp, class ..._ArgTypes>
__packaged_task_function<_Rp(_ArgTypes...)>::__packaged_task_function(__packaged_task_function&& __f) noexcept
{
    if (__f.__f_ == nullptr)
        __f_ = nullptr;
    else if (__f.__f_ == __f.__get_buf())
    {
        __f.__f_->__move_to(__get_buf());
        __f_ = (__base*)&__buf_;
    }
    else
    {
        __f_ = __f.__f_;
        __f.__f_ = nullptr;
    }
}

template<class _Rp, class ..._ArgTypes>
template <class _Fp>
__packaged_task_function<_Rp(_ArgTypes...)>::__packaged_task_function(_Fp&& __f)
    : __f_(nullptr)
{
    typedef typename remove_reference<typename decay<_Fp>::type>::type _FR;
    typedef __packaged_task_func<_FR, allocator<_FR>, _Rp(_ArgTypes...)> _FF;
    if (sizeof(_FF) <= sizeof(__buf_))
    {
        ::new ((void*)&__buf_) _FF(std::__1::forward<_Fp>(__f));
        __f_ = (__base*)&__buf_;
    }
    else
    {
        typedef allocator<_FF> _Ap;
        _Ap __a;
        typedef __allocator_destructor<_Ap> _Dp;
        unique_ptr<__base, _Dp> __hold(__a.allocate(1), _Dp(__a, 1));
        ::new ((void*)__hold.get()) _FF(std::__1::forward<_Fp>(__f), allocator<_FR>(__a));
        __f_ = __hold.release();
    }
}

template<class _Rp, class ..._ArgTypes>
template <class _Fp, class _Alloc>
__packaged_task_function<_Rp(_ArgTypes...)>::__packaged_task_function(
                                  allocator_arg_t, const _Alloc& __a0, _Fp&& __f)
    : __f_(nullptr)
{
    typedef typename remove_reference<typename decay<_Fp>::type>::type _FR;
    typedef __packaged_task_func<_FR, _Alloc, _Rp(_ArgTypes...)> _FF;
    if (sizeof(_FF) <= sizeof(__buf_))
    {
        __f_ = (__base*)&__buf_;
        ::new ((void*)__f_) _FF(std::__1::forward<_Fp>(__f));
    }
    else
    {
        typedef typename __allocator_traits_rebind<_Alloc, _FF>::type _Ap;
        _Ap __a(__a0);
        typedef __allocator_destructor<_Ap> _Dp;
        unique_ptr<__base, _Dp> __hold(__a.allocate(1), _Dp(__a, 1));
        ::new ((void*)std::__1::addressof(*__hold.get()))
            _FF(std::__1::forward<_Fp>(__f), _Alloc(__a));
        __f_ = std::__1::addressof(*__hold.release());
    }
}

template<class _Rp, class ..._ArgTypes>
__packaged_task_function<_Rp(_ArgTypes...)>&
__packaged_task_function<_Rp(_ArgTypes...)>::operator=(__packaged_task_function&& __f) noexcept
{
    if (__f_ == __get_buf())
        __f_->destroy();
    else if (__f_)
        __f_->destroy_deallocate();
    __f_ = nullptr;
    if (__f.__f_ == nullptr)
        __f_ = nullptr;
    else if (__f.__f_ == __f.__get_buf())
    {
        __f.__f_->__move_to(__get_buf());
        __f_ = __get_buf();
    }
    else
    {
        __f_ = __f.__f_;
        __f.__f_ = nullptr;
    }
    return *this;
}

template<class _Rp, class ..._ArgTypes>
__packaged_task_function<_Rp(_ArgTypes...)>::~__packaged_task_function()
{
    if (__f_ == __get_buf())
        __f_->destroy();
    else if (__f_)
        __f_->destroy_deallocate();
}

template<class _Rp, class ..._ArgTypes>
__attribute__((__no_sanitize__("cfi")))
void
__packaged_task_function<_Rp(_ArgTypes...)>::swap(__packaged_task_function& __f) noexcept
{
    if (__f_ == (__base*)&__buf_ && __f.__f_ == (__base*)&__f.__buf_)
    {
        typename aligned_storage<sizeof(__buf_)>::type __tempbuf;
        __base* __t = (__base*)&__tempbuf;
        __f_->__move_to(__t);
        __f_->destroy();
        __f_ = nullptr;
        __f.__f_->__move_to((__base*)&__buf_);
        __f.__f_->destroy();
        __f.__f_ = nullptr;
        __f_ = (__base*)&__buf_;
        __t->__move_to((__base*)&__f.__buf_);
        __t->destroy();
        __f.__f_ = (__base*)&__f.__buf_;
    }
    else if (__f_ == (__base*)&__buf_)
    {
        __f_->__move_to((__base*)&__f.__buf_);
        __f_->destroy();
        __f_ = __f.__f_;
        __f.__f_ = (__base*)&__f.__buf_;
    }
    else if (__f.__f_ == (__base*)&__f.__buf_)
    {
        __f.__f_->__move_to((__base*)&__buf_);
        __f.__f_->destroy();
        __f.__f_ = __f_;
        __f_ = (__base*)&__buf_;
    }
    else
        std::__1::swap(__f_, __f.__f_);
}

template<class _Rp, class ..._ArgTypes>
inline
_Rp
__packaged_task_function<_Rp(_ArgTypes...)>::operator()(_ArgTypes... __arg) const
{
    return (*__f_)(std::__1::forward<_ArgTypes>(__arg)...);
}

template<class _Rp, class ..._ArgTypes>
class __attribute__ ((__type_visibility__("default"))) __attribute__((availability(ios,strict,introduced=6.0))) packaged_task<_Rp(_ArgTypes...)>
{
public:
    typedef _Rp result_type;

private:
    __packaged_task_function<result_type(_ArgTypes...)> __f_;
    promise<result_type> __p_;

public:

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    packaged_task() noexcept : __p_(nullptr) {}
    template <class _Fp,
              class = typename enable_if
              <
                  !is_same<
                      typename __uncvref<_Fp>::type,
                      packaged_task
                      >::value
                  >::type
             >
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        explicit packaged_task(_Fp&& __f) : __f_(std::__1::forward<_Fp>(__f)) {}
    template <class _Fp, class _Allocator,
              class = typename enable_if
              <
                  !is_same<
                      typename __uncvref<_Fp>::type,
                      packaged_task
                      >::value
                  >::type
              >
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        packaged_task(allocator_arg_t, const _Allocator& __a, _Fp&& __f)
             : __f_(allocator_arg, __a, std::__1::forward<_Fp>(__f)),
               __p_(allocator_arg, __a) {}



    packaged_task(const packaged_task&) = delete;
    packaged_task& operator=(const packaged_task&) = delete;


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    packaged_task(packaged_task&& __other) noexcept
        : __f_(std::__1::move(__other.__f_)), __p_(std::__1::move(__other.__p_)) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    packaged_task& operator=(packaged_task&& __other) noexcept
    {
        __f_ = std::__1::move(__other.__f_);
        __p_ = std::__1::move(__other.__p_);
        return *this;
    }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void swap(packaged_task& __other) noexcept
    {
        __f_.swap(__other.__f_);
        __p_.swap(__other.__p_);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    bool valid() const noexcept {return __p_.__state_ != nullptr;}


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    future<result_type> get_future() {return __p_.get_future();}


    void operator()(_ArgTypes... __args);
    void make_ready_at_thread_exit(_ArgTypes... __args);

    void reset();
};

template<class _Rp, class ..._ArgTypes>
void
packaged_task<_Rp(_ArgTypes...)>::operator()(_ArgTypes... __args)
{
    if (__p_.__state_ == nullptr)
        __throw_future_error(future_errc::no_state);
    if (__p_.__state_->__has_value())
        __throw_future_error(future_errc::promise_already_satisfied);

    try
    {

        __p_.set_value(__f_(std::__1::forward<_ArgTypes>(__args)...));

    }
    catch (...)
    {
        __p_.set_exception(current_exception());
    }

}

template<class _Rp, class ..._ArgTypes>
void
packaged_task<_Rp(_ArgTypes...)>::make_ready_at_thread_exit(_ArgTypes... __args)
{
    if (__p_.__state_ == nullptr)
        __throw_future_error(future_errc::no_state);
    if (__p_.__state_->__has_value())
        __throw_future_error(future_errc::promise_already_satisfied);

    try
    {

        __p_.set_value_at_thread_exit(__f_(std::__1::forward<_ArgTypes>(__args)...));

    }
    catch (...)
    {
        __p_.set_exception_at_thread_exit(current_exception());
    }

}

template<class _Rp, class ..._ArgTypes>
void
packaged_task<_Rp(_ArgTypes...)>::reset()
{
    if (!valid())
        __throw_future_error(future_errc::no_state);
    __p_ = promise<result_type>();
}

template<class ..._ArgTypes>
class __attribute__ ((__type_visibility__("default"))) __attribute__((availability(ios,strict,introduced=6.0))) packaged_task<void(_ArgTypes...)>
{
public:
    typedef void result_type;

private:
    __packaged_task_function<result_type(_ArgTypes...)> __f_;
    promise<result_type> __p_;

public:

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    packaged_task() noexcept : __p_(nullptr) {}
    template <class _Fp,
              class = typename enable_if
              <
                  !is_same<
                      typename __uncvref<_Fp>::type,
                      packaged_task
                      >::value
                  >::type
              >
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        explicit packaged_task(_Fp&& __f) : __f_(std::__1::forward<_Fp>(__f)) {}
    template <class _Fp, class _Allocator,
              class = typename enable_if
              <
                  !is_same<
                      typename __uncvref<_Fp>::type,
                      packaged_task
                      >::value
                  >::type
              >
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        packaged_task(allocator_arg_t, const _Allocator& __a, _Fp&& __f)
             : __f_(allocator_arg, __a, std::__1::forward<_Fp>(__f)),
               __p_(allocator_arg, __a) {}



    packaged_task(const packaged_task&) = delete;
    packaged_task& operator=(const packaged_task&) = delete;


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    packaged_task(packaged_task&& __other) noexcept
        : __f_(std::__1::move(__other.__f_)), __p_(std::__1::move(__other.__p_)) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    packaged_task& operator=(packaged_task&& __other) noexcept
    {
        __f_ = std::__1::move(__other.__f_);
        __p_ = std::__1::move(__other.__p_);
        return *this;
    }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void swap(packaged_task& __other) noexcept
    {
        __f_.swap(__other.__f_);
        __p_.swap(__other.__p_);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    bool valid() const noexcept {return __p_.__state_ != nullptr;}


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    future<result_type> get_future() {return __p_.get_future();}


    void operator()(_ArgTypes... __args);
    void make_ready_at_thread_exit(_ArgTypes... __args);

    void reset();
};

template<class ..._ArgTypes>
void
packaged_task<void(_ArgTypes...)>::operator()(_ArgTypes... __args)
{
    if (__p_.__state_ == nullptr)
        __throw_future_error(future_errc::no_state);
    if (__p_.__state_->__has_value())
        __throw_future_error(future_errc::promise_already_satisfied);

    try
    {

        __f_(std::__1::forward<_ArgTypes>(__args)...);
        __p_.set_value();

    }
    catch (...)
    {
        __p_.set_exception(current_exception());
    }

}

template<class ..._ArgTypes>
void
packaged_task<void(_ArgTypes...)>::make_ready_at_thread_exit(_ArgTypes... __args)
{
    if (__p_.__state_ == nullptr)
        __throw_future_error(future_errc::no_state);
    if (__p_.__state_->__has_value())
        __throw_future_error(future_errc::promise_already_satisfied);

    try
    {

        __f_(std::__1::forward<_ArgTypes>(__args)...);
        __p_.set_value_at_thread_exit();

    }
    catch (...)
    {
        __p_.set_exception_at_thread_exit(current_exception());
    }

}

template<class ..._ArgTypes>
void
packaged_task<void(_ArgTypes...)>::reset()
{
    if (!valid())
        __throw_future_error(future_errc::no_state);
    __p_ = promise<result_type>();
}

template <class _Rp, class... _ArgTypes>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void
swap(packaged_task<_Rp(_ArgTypes...)>& __x, packaged_task<_Rp(_ArgTypes...)>& __y) noexcept
{
    __x.swap(__y);
}

template <class _Callable, class _Alloc>
struct __attribute__ ((__type_visibility__("default"))) uses_allocator<packaged_task<_Callable>, _Alloc>
    : public true_type {};

template <class _Rp, class _Fp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) future<_Rp>
__make_deferred_assoc_state(_Fp&& __f)
{
    unique_ptr<__deferred_assoc_state<_Rp, _Fp>, __release_shared_count>
        __h(new __deferred_assoc_state<_Rp, _Fp>(std::__1::forward<_Fp>(__f)));
    return future<_Rp>(__h.get());
}

template <class _Rp, class _Fp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) future<_Rp>
__make_async_assoc_state(_Fp&& __f)
{
    unique_ptr<__async_assoc_state<_Rp, _Fp>, __release_shared_count>
        __h(new __async_assoc_state<_Rp, _Fp>(std::__1::forward<_Fp>(__f)));
    std::__1::thread(&__async_assoc_state<_Rp, _Fp>::__execute, __h.get()).detach();
    return future<_Rp>(__h.get());
}



template <class _Fp, class... _Args>
class __attribute__ ((__visibility__("hidden"))) __async_func
{
    tuple<_Fp, _Args...> __f_;

public:
    typedef typename __invoke_of<_Fp, _Args...>::type _Rp;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit __async_func(_Fp&& __f, _Args&&... __args)
        : __f_(std::__1::move(__f), std::__1::move(__args)...) {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __async_func(__async_func&& __f) : __f_(std::__1::move(__f.__f_)) {}

    _Rp operator()()
    {
        typedef typename __make_tuple_indices<1+sizeof...(_Args), 1>::type _Index;
        return __execute(_Index());
    }
private:
    template <size_t ..._Indices>
    _Rp
    __execute(__tuple_indices<_Indices...>)
    {
        return std::__1::__invoke(std::__1::move(std::__1::get<0>(__f_)), std::__1::move(std::__1::get<_Indices>(__f_))...);
    }
};

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) bool __does_policy_contain(launch __policy, launch __value )
{ return (int(__policy) & int(__value)) != 0; }

template <class _Fp, class... _Args>

future<typename __invoke_of<typename decay<_Fp>::type, typename decay<_Args>::type...>::type>
async(launch __policy, _Fp&& __f, _Args&&... __args)
{
    typedef __async_func<typename decay<_Fp>::type, typename decay<_Args>::type...> _BF;
    typedef typename _BF::_Rp _Rp;


    try
    {

        if (__does_policy_contain(__policy, launch::async))
        return std::__1::__make_async_assoc_state<_Rp>(_BF(std::__1::__decay_copy(std::__1::forward<_Fp>(__f)),
                                                     std::__1::__decay_copy(std::__1::forward<_Args>(__args))...));

    }
    catch ( ... ) { if (__policy == launch::async) throw ; }


    if (__does_policy_contain(__policy, launch::deferred))
        return std::__1::__make_deferred_assoc_state<_Rp>(_BF(std::__1::__decay_copy(std::__1::forward<_Fp>(__f)),
                                                        std::__1::__decay_copy(std::__1::forward<_Args>(__args))...));
    return future<_Rp>{};
}

template <class _Fp, class... _Args>
                              inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
future<typename __invoke_of<typename decay<_Fp>::type, typename decay<_Args>::type...>::type>
async(_Fp&& __f, _Args&&... __args)
{
    return std::__1::async(launch::any, std::__1::forward<_Fp>(__f),
                                    std::__1::forward<_Args>(__args)...);
}





template <class _Rp>
class __attribute__ ((__type_visibility__("default"))) shared_future
{
    __assoc_state<_Rp>* __state_;

public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    shared_future() noexcept : __state_(nullptr) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    shared_future(const shared_future& __rhs) noexcept : __state_(__rhs.__state_)
        {if (__state_) __state_->__add_shared();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    shared_future(future<_Rp>&& __f) noexcept : __state_(__f.__state_)
        {__f.__state_ = nullptr;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    shared_future(shared_future&& __rhs) noexcept : __state_(__rhs.__state_)
        {__rhs.__state_ = nullptr;}
    ~shared_future();
    shared_future& operator=(const shared_future& __rhs) noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    shared_future& operator=(shared_future&& __rhs) noexcept
        {
            shared_future(std::__1::move(__rhs)).swap(*this);
            return *this;
        }


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const _Rp& get() const {return __state_->copy();}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void swap(shared_future& __rhs) noexcept {std::__1::swap(__state_, __rhs.__state_);}


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    bool valid() const noexcept {return __state_ != nullptr;}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void wait() const {__state_->wait();}
    template <class _Rep, class _Period>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        future_status
        wait_for(const chrono::duration<_Rep, _Period>& __rel_time) const
            {return __state_->wait_for(__rel_time);}
    template <class _Clock, class _Duration>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        future_status
        wait_until(const chrono::time_point<_Clock, _Duration>& __abs_time) const
            {return __state_->wait_until(__abs_time);}
};

template <class _Rp>
shared_future<_Rp>::~shared_future()
{
    if (__state_)
        __state_->__release_shared();
}

template <class _Rp>
shared_future<_Rp>&
shared_future<_Rp>::operator=(const shared_future& __rhs) noexcept
{
    if (__rhs.__state_)
        __rhs.__state_->__add_shared();
    if (__state_)
        __state_->__release_shared();
    __state_ = __rhs.__state_;
    return *this;
}

template <class _Rp>
class __attribute__ ((__type_visibility__("default"))) shared_future<_Rp&>
{
    __assoc_state<_Rp&>* __state_;

public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    shared_future() noexcept : __state_(nullptr) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    shared_future(const shared_future& __rhs) : __state_(__rhs.__state_)
        {if (__state_) __state_->__add_shared();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    shared_future(future<_Rp&>&& __f) noexcept : __state_(__f.__state_)
        {__f.__state_ = nullptr;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    shared_future(shared_future&& __rhs) noexcept : __state_(__rhs.__state_)
        {__rhs.__state_ = nullptr;}
    ~shared_future();
    shared_future& operator=(const shared_future& __rhs);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    shared_future& operator=(shared_future&& __rhs) noexcept
        {
            shared_future(std::__1::move(__rhs)).swap(*this);
            return *this;
        }


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    _Rp& get() const {return __state_->copy();}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void swap(shared_future& __rhs) noexcept {std::__1::swap(__state_, __rhs.__state_);}


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    bool valid() const noexcept {return __state_ != nullptr;}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void wait() const {__state_->wait();}
    template <class _Rep, class _Period>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        future_status
        wait_for(const chrono::duration<_Rep, _Period>& __rel_time) const
            {return __state_->wait_for(__rel_time);}
    template <class _Clock, class _Duration>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        future_status
        wait_until(const chrono::time_point<_Clock, _Duration>& __abs_time) const
            {return __state_->wait_until(__abs_time);}
};

template <class _Rp>
shared_future<_Rp&>::~shared_future()
{
    if (__state_)
        __state_->__release_shared();
}

template <class _Rp>
shared_future<_Rp&>&
shared_future<_Rp&>::operator=(const shared_future& __rhs)
{
    if (__rhs.__state_)
        __rhs.__state_->__add_shared();
    if (__state_)
        __state_->__release_shared();
    __state_ = __rhs.__state_;
    return *this;
}

template <>
class __attribute__ ((__visibility__("default"))) __attribute__((availability(ios,strict,introduced=6.0))) shared_future<void>
{
    __assoc_sub_state* __state_;

public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    shared_future() noexcept : __state_(nullptr) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    shared_future(const shared_future& __rhs) : __state_(__rhs.__state_)
        {if (__state_) __state_->__add_shared();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    shared_future(future<void>&& __f) noexcept : __state_(__f.__state_)
        {__f.__state_ = nullptr;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    shared_future(shared_future&& __rhs) noexcept : __state_(__rhs.__state_)
        {__rhs.__state_ = nullptr;}
    ~shared_future();
    shared_future& operator=(const shared_future& __rhs);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    shared_future& operator=(shared_future&& __rhs) noexcept
        {
            shared_future(std::__1::move(__rhs)).swap(*this);
            return *this;
        }


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void get() const {__state_->copy();}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void swap(shared_future& __rhs) noexcept {std::__1::swap(__state_, __rhs.__state_);}


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    bool valid() const noexcept {return __state_ != nullptr;}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void wait() const {__state_->wait();}
    template <class _Rep, class _Period>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        future_status
        wait_for(const chrono::duration<_Rep, _Period>& __rel_time) const
            {return __state_->wait_for(__rel_time);}
    template <class _Clock, class _Duration>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        future_status
        wait_until(const chrono::time_point<_Clock, _Duration>& __abs_time) const
            {return __state_->wait_until(__abs_time);}
};

template <class _Rp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void
swap(shared_future<_Rp>& __x, shared_future<_Rp>& __y) noexcept
{
    __x.swap(__y);
}

template <class _Rp>
inline
shared_future<_Rp>
future<_Rp>::share() noexcept
{
    return shared_future<_Rp>(std::__1::move(*this));
}

template <class _Rp>
inline
shared_future<_Rp&>
future<_Rp&>::share() noexcept
{
    return shared_future<_Rp&>(std::__1::move(*this));
}

inline
shared_future<void>
future<void>::share() noexcept
{
    return shared_future<void>(std::__1::move(*this));
}

} }
# 235 "/usr/local/include/bits/stdc++.h" 2








# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/random" 1 3
# 1692 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/random" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 1 3
# 1693 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/random" 2 3
# 1697 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/random" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 1701 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/random" 2 3


namespace std { inline namespace __1 {
# 1721 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/random" 3
template <class _Sseq, class _Engine>
struct __is_seed_sequence
{
    static constexpr const bool value =
              !is_convertible<_Sseq, typename _Engine::result_type>::value &&
              !is_same<typename remove_cv<_Sseq>::type, _Engine>::value;
};



template <unsigned long long __a, unsigned long long __c,
          unsigned long long __m, unsigned long long _Mp,
          bool _MightOverflow = (__a != 0 && __m != 0 && __m-1 > (_Mp-__c)/__a),
          bool _OverflowOK = ((__m | (__m-1)) > __m),
          bool _SchrageOK = (__a != 0 && __m != 0 && __m % __a <= __m / __a)>
struct __lce_alg_picker
{
    static_assert(__a != 0 || __m != 0 || !_MightOverflow || _OverflowOK || _SchrageOK,
                  "The current values of a, c, and m cannot generate a number "
                  "within bounds of linear_congruential_engine.");

    static constexpr const bool __use_schrage = _MightOverflow &&
                                                        !_OverflowOK &&
                                                        _SchrageOK;
};

template <unsigned long long __a, unsigned long long __c,
          unsigned long long __m, unsigned long long _Mp,
          bool _UseSchrage = __lce_alg_picker<__a, __c, __m, _Mp>::__use_schrage>
struct __lce_ta;



template <unsigned long long __a, unsigned long long __c, unsigned long long __m>
struct __lce_ta<__a, __c, __m, (unsigned long long)(~0), true>
{
    typedef unsigned long long result_type;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    static result_type next(result_type __x)
    {

        const result_type __q = __m / __a;
        const result_type __r = __m % __a;
        const result_type __t0 = __a * (__x % __q);
        const result_type __t1 = __r * (__x / __q);
        __x = __t0 + (__t0 < __t1) * __m - __t1;
        __x += __c - (__x >= __m - __c) * __m;
        return __x;
    }
};

template <unsigned long long __a, unsigned long long __m>
struct __lce_ta<__a, 0, __m, (unsigned long long)(~0), true>
{
    typedef unsigned long long result_type;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    static result_type next(result_type __x)
    {

        const result_type __q = __m / __a;
        const result_type __r = __m % __a;
        const result_type __t0 = __a * (__x % __q);
        const result_type __t1 = __r * (__x / __q);
        __x = __t0 + (__t0 < __t1) * __m - __t1;
        return __x;
    }
};

template <unsigned long long __a, unsigned long long __c, unsigned long long __m>
struct __lce_ta<__a, __c, __m, (unsigned long long)(~0), false>
{
    typedef unsigned long long result_type;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    static result_type next(result_type __x)
    {
        return (__a * __x + __c) % __m;
    }
};

template <unsigned long long __a, unsigned long long __c>
struct __lce_ta<__a, __c, 0, (unsigned long long)(~0), false>
{
    typedef unsigned long long result_type;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    static result_type next(result_type __x)
    {
        return __a * __x + __c;
    }
};



template <unsigned long long _Ap, unsigned long long _Cp, unsigned long long _Mp>
struct __lce_ta<_Ap, _Cp, _Mp, unsigned(~0), true>
{
    typedef unsigned result_type;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    static result_type next(result_type __x)
    {
        const result_type __a = static_cast<result_type>(_Ap);
        const result_type __c = static_cast<result_type>(_Cp);
        const result_type __m = static_cast<result_type>(_Mp);

        const result_type __q = __m / __a;
        const result_type __r = __m % __a;
        const result_type __t0 = __a * (__x % __q);
        const result_type __t1 = __r * (__x / __q);
        __x = __t0 + (__t0 < __t1) * __m - __t1;
        __x += __c - (__x >= __m - __c) * __m;
        return __x;
    }
};

template <unsigned long long _Ap, unsigned long long _Mp>
struct __lce_ta<_Ap, 0, _Mp, unsigned(~0), true>
{
    typedef unsigned result_type;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    static result_type next(result_type __x)
    {
        const result_type __a = static_cast<result_type>(_Ap);
        const result_type __m = static_cast<result_type>(_Mp);

        const result_type __q = __m / __a;
        const result_type __r = __m % __a;
        const result_type __t0 = __a * (__x % __q);
        const result_type __t1 = __r * (__x / __q);
        __x = __t0 + (__t0 < __t1) * __m - __t1;
        return __x;
    }
};

template <unsigned long long _Ap, unsigned long long _Cp, unsigned long long _Mp>
struct __lce_ta<_Ap, _Cp, _Mp, unsigned(~0), false>
{
    typedef unsigned result_type;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    static result_type next(result_type __x)
    {
        const result_type __a = static_cast<result_type>(_Ap);
        const result_type __c = static_cast<result_type>(_Cp);
        const result_type __m = static_cast<result_type>(_Mp);
        return (__a * __x + __c) % __m;
    }
};

template <unsigned long long _Ap, unsigned long long _Cp>
struct __lce_ta<_Ap, _Cp, 0, unsigned(~0), false>
{
    typedef unsigned result_type;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    static result_type next(result_type __x)
    {
        const result_type __a = static_cast<result_type>(_Ap);
        const result_type __c = static_cast<result_type>(_Cp);
        return __a * __x + __c;
    }
};



template <unsigned long long __a, unsigned long long __c, unsigned long long __m, bool __b>
struct __lce_ta<__a, __c, __m, (unsigned short)(~0), __b>
{
    typedef unsigned short result_type;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    static result_type next(result_type __x)
    {
        return static_cast<result_type>(__lce_ta<__a, __c, __m, unsigned(~0)>::next(__x));
    }
};

template <class _UIntType, _UIntType __a, _UIntType __c, _UIntType __m>
class __attribute__ ((__type_visibility__("default"))) linear_congruential_engine;

template <class _CharT, class _Traits,
          class _Up, _Up _Ap, _Up _Cp, _Up _Np>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
basic_ostream<_CharT, _Traits>&
operator<<(basic_ostream<_CharT, _Traits>& __os,
           const linear_congruential_engine<_Up, _Ap, _Cp, _Np>&);

template <class _CharT, class _Traits,
          class _Up, _Up _Ap, _Up _Cp, _Up _Np>
basic_istream<_CharT, _Traits>&
operator>>(basic_istream<_CharT, _Traits>& __is,
           linear_congruential_engine<_Up, _Ap, _Cp, _Np>& __x);

template <class _UIntType, _UIntType __a, _UIntType __c, _UIntType __m>
class __attribute__ ((__type_visibility__("default"))) linear_congruential_engine
{
public:

    typedef _UIntType result_type;

private:
    result_type __x_;

    static constexpr const result_type _Mp = result_type(~0);

    static_assert(__m == 0 || __a < __m, "linear_congruential_engine invalid parameters");
    static_assert(__m == 0 || __c < __m, "linear_congruential_engine invalid parameters");
    static_assert(is_unsigned<_UIntType>::value, "_UIntType must be unsigned type");
public:
    static constexpr const result_type _Min = __c == 0u ? 1u: 0u;
    static constexpr const result_type _Max = __m - 1u;
    static_assert(_Min < _Max, "linear_congruential_engine invalid parameters");


    static constexpr const result_type multiplier = __a;
    static constexpr const result_type increment = __c;
    static constexpr const result_type modulus = __m;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    static constexpr result_type min() {return _Min;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    static constexpr result_type max() {return _Max;}
    static constexpr const result_type default_seed = 1u;



    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    linear_congruential_engine() : linear_congruential_engine(default_seed) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit linear_congruential_engine(result_type __s) { seed(__s); }






    template<class _Sseq>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        explicit linear_congruential_engine(_Sseq& __q,
        typename enable_if<__is_seed_sequence<_Sseq, linear_congruential_engine>::value>::type* = 0)
        {seed(__q);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void seed(result_type __s = default_seed)
        {seed(integral_constant<bool, __m == 0>(),
              integral_constant<bool, __c == 0>(), __s);}
    template<class _Sseq>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        typename enable_if
        <
            __is_seed_sequence<_Sseq, linear_congruential_engine>::value,
            void
        >::type
        seed(_Sseq& __q)
            {__seed(__q, integral_constant<unsigned,
                1 + (__m == 0 ? (sizeof(result_type) * 8 - 1)/32
                             : (__m > 0x100000000ull))>());}


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    result_type operator()()
        {return __x_ = static_cast<result_type>(__lce_ta<__a, __c, __m, _Mp>::next(__x_));}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void discard(unsigned long long __z) {for (; __z; --__z) operator()();}

    friend __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    bool operator==(const linear_congruential_engine& __x,
                    const linear_congruential_engine& __y)
        {return __x.__x_ == __y.__x_;}
    friend __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    bool operator!=(const linear_congruential_engine& __x,
                    const linear_congruential_engine& __y)
        {return !(__x == __y);}

private:

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void seed(true_type, true_type, result_type __s) {__x_ = __s == 0 ? 1 : __s;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void seed(true_type, false_type, result_type __s) {__x_ = __s;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void seed(false_type, true_type, result_type __s) {__x_ = __s % __m == 0 ?
                                                                 1 : __s % __m;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void seed(false_type, false_type, result_type __s) {__x_ = __s % __m;}

    template<class _Sseq>
        void __seed(_Sseq& __q, integral_constant<unsigned, 1>);
    template<class _Sseq>
        void __seed(_Sseq& __q, integral_constant<unsigned, 2>);

    template <class _CharT, class _Traits,
              class _Up, _Up _Ap, _Up _Cp, _Up _Np>
    friend
    basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __os,
               const linear_congruential_engine<_Up, _Ap, _Cp, _Np>&);

    template <class _CharT, class _Traits,
              class _Up, _Up _Ap, _Up _Cp, _Up _Np>
    friend
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __is,
               linear_congruential_engine<_Up, _Ap, _Cp, _Np>& __x);
};

template <class _UIntType, _UIntType __a, _UIntType __c, _UIntType __m>
    constexpr const typename linear_congruential_engine<_UIntType, __a, __c, __m>::result_type
    linear_congruential_engine<_UIntType, __a, __c, __m>::multiplier;

template <class _UIntType, _UIntType __a, _UIntType __c, _UIntType __m>
    constexpr const typename linear_congruential_engine<_UIntType, __a, __c, __m>::result_type
    linear_congruential_engine<_UIntType, __a, __c, __m>::increment;

template <class _UIntType, _UIntType __a, _UIntType __c, _UIntType __m>
    constexpr const typename linear_congruential_engine<_UIntType, __a, __c, __m>::result_type
    linear_congruential_engine<_UIntType, __a, __c, __m>::modulus;

template <class _UIntType, _UIntType __a, _UIntType __c, _UIntType __m>
    constexpr const typename linear_congruential_engine<_UIntType, __a, __c, __m>::result_type
    linear_congruential_engine<_UIntType, __a, __c, __m>::default_seed;

template <class _UIntType, _UIntType __a, _UIntType __c, _UIntType __m>
template<class _Sseq>
void
linear_congruential_engine<_UIntType, __a, __c, __m>::__seed(_Sseq& __q,
                                                 integral_constant<unsigned, 1>)
{
    const unsigned __k = 1;
    uint32_t __ar[__k+3];
    __q.generate(__ar, __ar + __k + 3);
    result_type __s = static_cast<result_type>(__ar[3] % __m);
    __x_ = __c == 0 && __s == 0 ? result_type(1) : __s;
}

template <class _UIntType, _UIntType __a, _UIntType __c, _UIntType __m>
template<class _Sseq>
void
linear_congruential_engine<_UIntType, __a, __c, __m>::__seed(_Sseq& __q,
                                                 integral_constant<unsigned, 2>)
{
    const unsigned __k = 2;
    uint32_t __ar[__k+3];
    __q.generate(__ar, __ar + __k + 3);
    result_type __s = static_cast<result_type>((__ar[3] +
                                              ((uint64_t)__ar[4] << 32)) % __m);
    __x_ = __c == 0 && __s == 0 ? result_type(1) : __s;
}

template <class _CharT, class _Traits,
          class _UIntType, _UIntType __a, _UIntType __c, _UIntType __m>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
basic_ostream<_CharT, _Traits>&
operator<<(basic_ostream<_CharT, _Traits>& __os,
           const linear_congruential_engine<_UIntType, __a, __c, __m>& __x)
{
    __save_flags<_CharT, _Traits> __lx(__os);
    typedef basic_ostream<_CharT, _Traits> _Ostream;
    __os.flags(_Ostream::dec | _Ostream::left);
    __os.fill(__os.widen(' '));
    return __os << __x.__x_;
}

template <class _CharT, class _Traits,
          class _UIntType, _UIntType __a, _UIntType __c, _UIntType __m>
basic_istream<_CharT, _Traits>&
operator>>(basic_istream<_CharT, _Traits>& __is,
           linear_congruential_engine<_UIntType, __a, __c, __m>& __x)
{
    __save_flags<_CharT, _Traits> __lx(__is);
    typedef basic_istream<_CharT, _Traits> _Istream;
    __is.flags(_Istream::dec | _Istream::skipws);
    _UIntType __t;
    __is >> __t;
    if (!__is.fail())
        __x.__x_ = __t;
    return __is;
}

typedef linear_congruential_engine<uint_fast32_t, 16807, 0, 2147483647>
                                                                   minstd_rand0;
typedef linear_congruential_engine<uint_fast32_t, 48271, 0, 2147483647>
                                                                    minstd_rand;
typedef minstd_rand default_random_engine;


template <class _UIntType, size_t __w, size_t __n, size_t __m, size_t __r,
          _UIntType __a, size_t __u, _UIntType __d, size_t __s,
          _UIntType __b, size_t __t, _UIntType __c, size_t __l, _UIntType __f>
class __attribute__ ((__type_visibility__("default"))) mersenne_twister_engine;

template <class _UInt, size_t _Wp, size_t _Np, size_t _Mp, size_t _Rp,
          _UInt _Ap, size_t _Up, _UInt _Dp, size_t _Sp,
          _UInt _Bp, size_t _Tp, _UInt _Cp, size_t _Lp, _UInt _Fp>
bool
operator==(const mersenne_twister_engine<_UInt, _Wp, _Np, _Mp, _Rp, _Ap, _Up, _Dp, _Sp,
                                         _Bp, _Tp, _Cp, _Lp, _Fp>& __x,
           const mersenne_twister_engine<_UInt, _Wp, _Np, _Mp, _Rp, _Ap, _Up, _Dp, _Sp,
                                         _Bp, _Tp, _Cp, _Lp, _Fp>& __y);

template <class _UInt, size_t _Wp, size_t _Np, size_t _Mp, size_t _Rp,
          _UInt _Ap, size_t _Up, _UInt _Dp, size_t _Sp,
          _UInt _Bp, size_t _Tp, _UInt _Cp, size_t _Lp, _UInt _Fp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator!=(const mersenne_twister_engine<_UInt, _Wp, _Np, _Mp, _Rp, _Ap, _Up, _Dp, _Sp,
                                         _Bp, _Tp, _Cp, _Lp, _Fp>& __x,
           const mersenne_twister_engine<_UInt, _Wp, _Np, _Mp, _Rp, _Ap, _Up, _Dp, _Sp,
                                         _Bp, _Tp, _Cp, _Lp, _Fp>& __y);

template <class _CharT, class _Traits,
          class _UInt, size_t _Wp, size_t _Np, size_t _Mp, size_t _Rp,
          _UInt _Ap, size_t _Up, _UInt _Dp, size_t _Sp,
          _UInt _Bp, size_t _Tp, _UInt _Cp, size_t _Lp, _UInt _Fp>
basic_ostream<_CharT, _Traits>&
operator<<(basic_ostream<_CharT, _Traits>& __os,
           const mersenne_twister_engine<_UInt, _Wp, _Np, _Mp, _Rp, _Ap, _Up, _Dp, _Sp,
                                         _Bp, _Tp, _Cp, _Lp, _Fp>& __x);

template <class _CharT, class _Traits,
          class _UInt, size_t _Wp, size_t _Np, size_t _Mp, size_t _Rp,
          _UInt _Ap, size_t _Up, _UInt _Dp, size_t _Sp,
          _UInt _Bp, size_t _Tp, _UInt _Cp, size_t _Lp, _UInt _Fp>
basic_istream<_CharT, _Traits>&
operator>>(basic_istream<_CharT, _Traits>& __is,
           mersenne_twister_engine<_UInt, _Wp, _Np, _Mp, _Rp, _Ap, _Up, _Dp, _Sp,
                                   _Bp, _Tp, _Cp, _Lp, _Fp>& __x);

template <class _UIntType, size_t __w, size_t __n, size_t __m, size_t __r,
          _UIntType __a, size_t __u, _UIntType __d, size_t __s,
          _UIntType __b, size_t __t, _UIntType __c, size_t __l, _UIntType __f>
class __attribute__ ((__type_visibility__("default"))) mersenne_twister_engine
{
public:

    typedef _UIntType result_type;

private:
    result_type __x_[__n];
    size_t __i_;

    static_assert( 0 < __m, "mersenne_twister_engine invalid parameters");
    static_assert(__m <= __n, "mersenne_twister_engine invalid parameters");
    static constexpr const result_type _Dt = numeric_limits<result_type>::digits;
    static_assert(__w <= _Dt, "mersenne_twister_engine invalid parameters");
    static_assert( 2 <= __w, "mersenne_twister_engine invalid parameters");
    static_assert(__r <= __w, "mersenne_twister_engine invalid parameters");
    static_assert(__u <= __w, "mersenne_twister_engine invalid parameters");
    static_assert(__s <= __w, "mersenne_twister_engine invalid parameters");
    static_assert(__t <= __w, "mersenne_twister_engine invalid parameters");
    static_assert(__l <= __w, "mersenne_twister_engine invalid parameters");
public:
    static constexpr const result_type _Min = 0;
    static constexpr const result_type _Max = __w == _Dt ? result_type(~0) :
                                                      (result_type(1) << __w) - result_type(1);
    static_assert(_Min < _Max, "mersenne_twister_engine invalid parameters");
    static_assert(__a <= _Max, "mersenne_twister_engine invalid parameters");
    static_assert(__b <= _Max, "mersenne_twister_engine invalid parameters");
    static_assert(__c <= _Max, "mersenne_twister_engine invalid parameters");
    static_assert(__d <= _Max, "mersenne_twister_engine invalid parameters");
    static_assert(__f <= _Max, "mersenne_twister_engine invalid parameters");


    static constexpr const size_t word_size = __w;
    static constexpr const size_t state_size = __n;
    static constexpr const size_t shift_size = __m;
    static constexpr const size_t mask_bits = __r;
    static constexpr const result_type xor_mask = __a;
    static constexpr const size_t tempering_u = __u;
    static constexpr const result_type tempering_d = __d;
    static constexpr const size_t tempering_s = __s;
    static constexpr const result_type tempering_b = __b;
    static constexpr const size_t tempering_t = __t;
    static constexpr const result_type tempering_c = __c;
    static constexpr const size_t tempering_l = __l;
    static constexpr const result_type initialization_multiplier = __f;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    static constexpr result_type min() { return _Min; }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    static constexpr result_type max() { return _Max; }
    static constexpr const result_type default_seed = 5489u;



    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    mersenne_twister_engine() : mersenne_twister_engine(default_seed) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit mersenne_twister_engine(result_type __sd) { seed(__sd); }






    template<class _Sseq>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        explicit mersenne_twister_engine(_Sseq& __q,
        typename enable_if<__is_seed_sequence<_Sseq, mersenne_twister_engine>::value>::type* = 0)
        {seed(__q);}
    void seed(result_type __sd = default_seed);
    template<class _Sseq>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        typename enable_if
        <
            __is_seed_sequence<_Sseq, mersenne_twister_engine>::value,
            void
        >::type
        seed(_Sseq& __q)
            {__seed(__q, integral_constant<unsigned, 1 + (__w - 1) / 32>());}


    result_type operator()();
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void discard(unsigned long long __z) {for (; __z; --__z) operator()();}

    template <class _UInt, size_t _Wp, size_t _Np, size_t _Mp, size_t _Rp,
              _UInt _Ap, size_t _Up, _UInt _Dp, size_t _Sp,
              _UInt _Bp, size_t _Tp, _UInt _Cp, size_t _Lp, _UInt _Fp>
    friend
    bool
    operator==(const mersenne_twister_engine<_UInt, _Wp, _Np, _Mp, _Rp, _Ap, _Up, _Dp, _Sp,
                                             _Bp, _Tp, _Cp, _Lp, _Fp>& __x,
               const mersenne_twister_engine<_UInt, _Wp, _Np, _Mp, _Rp, _Ap, _Up, _Dp, _Sp,
                                             _Bp, _Tp, _Cp, _Lp, _Fp>& __y);

    template <class _UInt, size_t _Wp, size_t _Np, size_t _Mp, size_t _Rp,
              _UInt _Ap, size_t _Up, _UInt _Dp, size_t _Sp,
              _UInt _Bp, size_t _Tp, _UInt _Cp, size_t _Lp, _UInt _Fp>
    friend
    bool
    operator!=(const mersenne_twister_engine<_UInt, _Wp, _Np, _Mp, _Rp, _Ap, _Up, _Dp, _Sp,
                                             _Bp, _Tp, _Cp, _Lp, _Fp>& __x,
               const mersenne_twister_engine<_UInt, _Wp, _Np, _Mp, _Rp, _Ap, _Up, _Dp, _Sp,
                                             _Bp, _Tp, _Cp, _Lp, _Fp>& __y);

    template <class _CharT, class _Traits,
              class _UInt, size_t _Wp, size_t _Np, size_t _Mp, size_t _Rp,
              _UInt _Ap, size_t _Up, _UInt _Dp, size_t _Sp,
              _UInt _Bp, size_t _Tp, _UInt _Cp, size_t _Lp, _UInt _Fp>
    friend
    basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __os,
               const mersenne_twister_engine<_UInt, _Wp, _Np, _Mp, _Rp, _Ap, _Up, _Dp, _Sp,
                                             _Bp, _Tp, _Cp, _Lp, _Fp>& __x);

    template <class _CharT, class _Traits,
              class _UInt, size_t _Wp, size_t _Np, size_t _Mp, size_t _Rp,
              _UInt _Ap, size_t _Up, _UInt _Dp, size_t _Sp,
              _UInt _Bp, size_t _Tp, _UInt _Cp, size_t _Lp, _UInt _Fp>
    friend
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __is,
               mersenne_twister_engine<_UInt, _Wp, _Np, _Mp, _Rp, _Ap, _Up, _Dp, _Sp,
                                       _Bp, _Tp, _Cp, _Lp, _Fp>& __x);
private:

    template<class _Sseq>
        void __seed(_Sseq& __q, integral_constant<unsigned, 1>);
    template<class _Sseq>
        void __seed(_Sseq& __q, integral_constant<unsigned, 2>);

    template <size_t __count>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        static
        typename enable_if
        <
            __count < __w,
            result_type
        >::type
        __lshift(result_type __x) {return (__x << __count) & _Max;}

    template <size_t __count>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        static
        typename enable_if
        <
            (__count >= __w),
            result_type
        >::type
        __lshift(result_type) {return result_type(0);}

    template <size_t __count>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        static
        typename enable_if
        <
            __count < _Dt,
            result_type
        >::type
        __rshift(result_type __x) {return __x >> __count;}

    template <size_t __count>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        static
        typename enable_if
        <
            (__count >= _Dt),
            result_type
        >::type
        __rshift(result_type) {return result_type(0);}
};

template <class _UIntType, size_t __w, size_t __n, size_t __m, size_t __r,
          _UIntType __a, size_t __u, _UIntType __d, size_t __s,
          _UIntType __b, size_t __t, _UIntType __c, size_t __l, _UIntType __f>
    constexpr const size_t
    mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d, __s, __b, __t, __c, __l, __f>::word_size;

template <class _UIntType, size_t __w, size_t __n, size_t __m, size_t __r,
          _UIntType __a, size_t __u, _UIntType __d, size_t __s,
          _UIntType __b, size_t __t, _UIntType __c, size_t __l, _UIntType __f>
    constexpr const size_t
    mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d, __s, __b, __t, __c, __l, __f>::state_size;

template <class _UIntType, size_t __w, size_t __n, size_t __m, size_t __r,
          _UIntType __a, size_t __u, _UIntType __d, size_t __s,
          _UIntType __b, size_t __t, _UIntType __c, size_t __l, _UIntType __f>
    constexpr const size_t
    mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d, __s, __b, __t, __c, __l, __f>::shift_size;

template <class _UIntType, size_t __w, size_t __n, size_t __m, size_t __r,
          _UIntType __a, size_t __u, _UIntType __d, size_t __s,
          _UIntType __b, size_t __t, _UIntType __c, size_t __l, _UIntType __f>
    constexpr const size_t
    mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d, __s, __b, __t, __c, __l, __f>::mask_bits;

template <class _UIntType, size_t __w, size_t __n, size_t __m, size_t __r,
          _UIntType __a, size_t __u, _UIntType __d, size_t __s,
          _UIntType __b, size_t __t, _UIntType __c, size_t __l, _UIntType __f>
    constexpr const typename mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d, __s, __b, __t, __c, __l, __f>::result_type
    mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d, __s, __b, __t, __c, __l, __f>::xor_mask;

template <class _UIntType, size_t __w, size_t __n, size_t __m, size_t __r,
          _UIntType __a, size_t __u, _UIntType __d, size_t __s,
          _UIntType __b, size_t __t, _UIntType __c, size_t __l, _UIntType __f>
    constexpr const size_t
    mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d, __s, __b, __t, __c, __l, __f>::tempering_u;

template <class _UIntType, size_t __w, size_t __n, size_t __m, size_t __r,
          _UIntType __a, size_t __u, _UIntType __d, size_t __s,
          _UIntType __b, size_t __t, _UIntType __c, size_t __l, _UIntType __f>
    constexpr const typename mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d, __s, __b, __t, __c, __l, __f>::result_type
    mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d, __s, __b, __t, __c, __l, __f>::tempering_d;

template <class _UIntType, size_t __w, size_t __n, size_t __m, size_t __r,
          _UIntType __a, size_t __u, _UIntType __d, size_t __s,
          _UIntType __b, size_t __t, _UIntType __c, size_t __l, _UIntType __f>
    constexpr const size_t
    mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d, __s, __b, __t, __c, __l, __f>::tempering_s;

template <class _UIntType, size_t __w, size_t __n, size_t __m, size_t __r,
          _UIntType __a, size_t __u, _UIntType __d, size_t __s,
          _UIntType __b, size_t __t, _UIntType __c, size_t __l, _UIntType __f>
    constexpr const typename mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d, __s, __b, __t, __c, __l, __f>::result_type
    mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d, __s, __b, __t, __c, __l, __f>::tempering_b;

template <class _UIntType, size_t __w, size_t __n, size_t __m, size_t __r,
          _UIntType __a, size_t __u, _UIntType __d, size_t __s,
          _UIntType __b, size_t __t, _UIntType __c, size_t __l, _UIntType __f>
    constexpr const size_t
    mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d, __s, __b, __t, __c, __l, __f>::tempering_t;

template <class _UIntType, size_t __w, size_t __n, size_t __m, size_t __r,
          _UIntType __a, size_t __u, _UIntType __d, size_t __s,
          _UIntType __b, size_t __t, _UIntType __c, size_t __l, _UIntType __f>
    constexpr const typename mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d, __s, __b, __t, __c, __l, __f>::result_type
    mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d, __s, __b, __t, __c, __l, __f>::tempering_c;

template <class _UIntType, size_t __w, size_t __n, size_t __m, size_t __r,
          _UIntType __a, size_t __u, _UIntType __d, size_t __s,
          _UIntType __b, size_t __t, _UIntType __c, size_t __l, _UIntType __f>
    constexpr const size_t
    mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d, __s, __b, __t, __c, __l, __f>::tempering_l;

template <class _UIntType, size_t __w, size_t __n, size_t __m, size_t __r,
          _UIntType __a, size_t __u, _UIntType __d, size_t __s,
          _UIntType __b, size_t __t, _UIntType __c, size_t __l, _UIntType __f>
    constexpr const typename mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d, __s, __b, __t, __c, __l, __f>::result_type
    mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d, __s, __b, __t, __c, __l, __f>::initialization_multiplier;

template <class _UIntType, size_t __w, size_t __n, size_t __m, size_t __r,
          _UIntType __a, size_t __u, _UIntType __d, size_t __s,
          _UIntType __b, size_t __t, _UIntType __c, size_t __l, _UIntType __f>
    constexpr const typename mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d, __s, __b, __t, __c, __l, __f>::result_type
    mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d, __s, __b, __t, __c, __l, __f>::default_seed;

template <class _UIntType, size_t __w, size_t __n, size_t __m, size_t __r,
          _UIntType __a, size_t __u, _UIntType __d, size_t __s,
          _UIntType __b, size_t __t, _UIntType __c, size_t __l, _UIntType __f>
void
mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d, __s, __b,
    __t, __c, __l, __f>::seed(result_type __sd)
    __attribute__((__no_sanitize__("unsigned-integer-overflow")))
{
    __x_[0] = __sd & _Max;
    for (size_t __i = 1; __i < __n; ++__i)
        __x_[__i] = (__f * (__x_[__i-1] ^ __rshift<__w - 2>(__x_[__i-1])) + __i) & _Max;
    __i_ = 0;
}

template <class _UIntType, size_t __w, size_t __n, size_t __m, size_t __r,
          _UIntType __a, size_t __u, _UIntType __d, size_t __s,
          _UIntType __b, size_t __t, _UIntType __c, size_t __l, _UIntType __f>
template<class _Sseq>
void
mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d, __s, __b,
    __t, __c, __l, __f>::__seed(_Sseq& __q, integral_constant<unsigned, 1>)
{
    const unsigned __k = 1;
    uint32_t __ar[__n * __k];
    __q.generate(__ar, __ar + __n * __k);
    for (size_t __i = 0; __i < __n; ++__i)
        __x_[__i] = static_cast<result_type>(__ar[__i] & _Max);
    const result_type __mask = __r == _Dt ? result_type(~0) :
                                       (result_type(1) << __r) - result_type(1);
    __i_ = 0;
    if ((__x_[0] & ~__mask) == 0)
    {
        for (size_t __i = 1; __i < __n; ++__i)
            if (__x_[__i] != 0)
                return;
        __x_[0] = result_type(1) << (__w - 1);
    }
}

template <class _UIntType, size_t __w, size_t __n, size_t __m, size_t __r,
          _UIntType __a, size_t __u, _UIntType __d, size_t __s,
          _UIntType __b, size_t __t, _UIntType __c, size_t __l, _UIntType __f>
template<class _Sseq>
void
mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d, __s, __b,
    __t, __c, __l, __f>::__seed(_Sseq& __q, integral_constant<unsigned, 2>)
{
    const unsigned __k = 2;
    uint32_t __ar[__n * __k];
    __q.generate(__ar, __ar + __n * __k);
    for (size_t __i = 0; __i < __n; ++__i)
        __x_[__i] = static_cast<result_type>(
            (__ar[2 * __i] + ((uint64_t)__ar[2 * __i + 1] << 32)) & _Max);
    const result_type __mask = __r == _Dt ? result_type(~0) :
                                       (result_type(1) << __r) - result_type(1);
    __i_ = 0;
    if ((__x_[0] & ~__mask) == 0)
    {
        for (size_t __i = 1; __i < __n; ++__i)
            if (__x_[__i] != 0)
                return;
        __x_[0] = result_type(1) << (__w - 1);
    }
}

template <class _UIntType, size_t __w, size_t __n, size_t __m, size_t __r,
          _UIntType __a, size_t __u, _UIntType __d, size_t __s,
          _UIntType __b, size_t __t, _UIntType __c, size_t __l, _UIntType __f>
_UIntType
mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d, __s, __b,
    __t, __c, __l, __f>::operator()()
{
    const size_t __j = (__i_ + 1) % __n;
    const result_type __mask = __r == _Dt ? result_type(~0) :
                                       (result_type(1) << __r) - result_type(1);
    const result_type _Yp = (__x_[__i_] & ~__mask) | (__x_[__j] & __mask);
    const size_t __k = (__i_ + __m) % __n;
    __x_[__i_] = __x_[__k] ^ __rshift<1>(_Yp) ^ (__a * (_Yp & 1));
    result_type __z = __x_[__i_] ^ (__rshift<__u>(__x_[__i_]) & __d);
    __i_ = __j;
    __z ^= __lshift<__s>(__z) & __b;
    __z ^= __lshift<__t>(__z) & __c;
    return __z ^ __rshift<__l>(__z);
}

template <class _UInt, size_t _Wp, size_t _Np, size_t _Mp, size_t _Rp,
          _UInt _Ap, size_t _Up, _UInt _Dp, size_t _Sp,
          _UInt _Bp, size_t _Tp, _UInt _Cp, size_t _Lp, _UInt _Fp>
bool
operator==(const mersenne_twister_engine<_UInt, _Wp, _Np, _Mp, _Rp, _Ap, _Up, _Dp, _Sp,
                                         _Bp, _Tp, _Cp, _Lp, _Fp>& __x,
           const mersenne_twister_engine<_UInt, _Wp, _Np, _Mp, _Rp, _Ap, _Up, _Dp, _Sp,
                                         _Bp, _Tp, _Cp, _Lp, _Fp>& __y)
{
    if (__x.__i_ == __y.__i_)
        return std::__1::equal(__x.__x_, __x.__x_ + _Np, __y.__x_);
    if (__x.__i_ == 0 || __y.__i_ == 0)
    {
        size_t __j = std::__1::min(_Np - __x.__i_, _Np - __y.__i_);
        if (!std::__1::equal(__x.__x_ + __x.__i_, __x.__x_ + __x.__i_ + __j,
                         __y.__x_ + __y.__i_))
            return false;
        if (__x.__i_ == 0)
            return std::__1::equal(__x.__x_ + __j, __x.__x_ + _Np, __y.__x_);
        return std::__1::equal(__x.__x_, __x.__x_ + (_Np - __j), __y.__x_ + __j);
    }
    if (__x.__i_ < __y.__i_)
    {
        size_t __j = _Np - __y.__i_;
        if (!std::__1::equal(__x.__x_ + __x.__i_, __x.__x_ + (__x.__i_ + __j),
                         __y.__x_ + __y.__i_))
            return false;
        if (!std::__1::equal(__x.__x_ + (__x.__i_ + __j), __x.__x_ + _Np,
                         __y.__x_))
            return false;
        return std::__1::equal(__x.__x_, __x.__x_ + __x.__i_,
                           __y.__x_ + (_Np - (__x.__i_ + __j)));
    }
    size_t __j = _Np - __x.__i_;
    if (!std::__1::equal(__y.__x_ + __y.__i_, __y.__x_ + (__y.__i_ + __j),
                     __x.__x_ + __x.__i_))
        return false;
    if (!std::__1::equal(__y.__x_ + (__y.__i_ + __j), __y.__x_ + _Np,
                     __x.__x_))
        return false;
    return std::__1::equal(__y.__x_, __y.__x_ + __y.__i_,
                       __x.__x_ + (_Np - (__y.__i_ + __j)));
}

template <class _UInt, size_t _Wp, size_t _Np, size_t _Mp, size_t _Rp,
          _UInt _Ap, size_t _Up, _UInt _Dp, size_t _Sp,
          _UInt _Bp, size_t _Tp, _UInt _Cp, size_t _Lp, _UInt _Fp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator!=(const mersenne_twister_engine<_UInt, _Wp, _Np, _Mp, _Rp, _Ap, _Up, _Dp, _Sp,
                                         _Bp, _Tp, _Cp, _Lp, _Fp>& __x,
           const mersenne_twister_engine<_UInt, _Wp, _Np, _Mp, _Rp, _Ap, _Up, _Dp, _Sp,
                                         _Bp, _Tp, _Cp, _Lp, _Fp>& __y)
{
    return !(__x == __y);
}

template <class _CharT, class _Traits,
          class _UInt, size_t _Wp, size_t _Np, size_t _Mp, size_t _Rp,
          _UInt _Ap, size_t _Up, _UInt _Dp, size_t _Sp,
          _UInt _Bp, size_t _Tp, _UInt _Cp, size_t _Lp, _UInt _Fp>
basic_ostream<_CharT, _Traits>&
operator<<(basic_ostream<_CharT, _Traits>& __os,
           const mersenne_twister_engine<_UInt, _Wp, _Np, _Mp, _Rp, _Ap, _Up, _Dp, _Sp,
                                         _Bp, _Tp, _Cp, _Lp, _Fp>& __x)
{
    __save_flags<_CharT, _Traits> __lx(__os);
    typedef basic_ostream<_CharT, _Traits> _Ostream;
    __os.flags(_Ostream::dec | _Ostream::left);
    _CharT __sp = __os.widen(' ');
    __os.fill(__sp);
    __os << __x.__x_[__x.__i_];
    for (size_t __j = __x.__i_ + 1; __j < _Np; ++__j)
        __os << __sp << __x.__x_[__j];
    for (size_t __j = 0; __j < __x.__i_; ++__j)
        __os << __sp << __x.__x_[__j];
    return __os;
}

template <class _CharT, class _Traits,
          class _UInt, size_t _Wp, size_t _Np, size_t _Mp, size_t _Rp,
          _UInt _Ap, size_t _Up, _UInt _Dp, size_t _Sp,
          _UInt _Bp, size_t _Tp, _UInt _Cp, size_t _Lp, _UInt _Fp>
basic_istream<_CharT, _Traits>&
operator>>(basic_istream<_CharT, _Traits>& __is,
           mersenne_twister_engine<_UInt, _Wp, _Np, _Mp, _Rp, _Ap, _Up, _Dp, _Sp,
                                   _Bp, _Tp, _Cp, _Lp, _Fp>& __x)
{
    __save_flags<_CharT, _Traits> __lx(__is);
    typedef basic_istream<_CharT, _Traits> _Istream;
    __is.flags(_Istream::dec | _Istream::skipws);
    _UInt __t[_Np];
    for (size_t __i = 0; __i < _Np; ++__i)
        __is >> __t[__i];
    if (!__is.fail())
    {
        for (size_t __i = 0; __i < _Np; ++__i)
            __x.__x_[__i] = __t[__i];
        __x.__i_ = 0;
    }
    return __is;
}

typedef mersenne_twister_engine<uint_fast32_t, 32, 624, 397, 31,
                                0x9908b0df, 11, 0xffffffff,
                                7, 0x9d2c5680,
                                15, 0xefc60000,
                                18, 1812433253> mt19937;
typedef mersenne_twister_engine<uint_fast64_t, 64, 312, 156, 31,
                                0xb5026f5aa96619e9ULL, 29, 0x5555555555555555ULL,
                                17, 0x71d67fffeda60000ULL,
                                37, 0xfff7eee000000000ULL,
                                43, 6364136223846793005ULL> mt19937_64;



template<class _UIntType, size_t __w, size_t __s, size_t __r>
class __attribute__ ((__type_visibility__("default"))) subtract_with_carry_engine;

template<class _UInt, size_t _Wp, size_t _Sp, size_t _Rp>
bool
operator==(
    const subtract_with_carry_engine<_UInt, _Wp, _Sp, _Rp>& __x,
    const subtract_with_carry_engine<_UInt, _Wp, _Sp, _Rp>& __y);

template<class _UInt, size_t _Wp, size_t _Sp, size_t _Rp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator!=(
    const subtract_with_carry_engine<_UInt, _Wp, _Sp, _Rp>& __x,
    const subtract_with_carry_engine<_UInt, _Wp, _Sp, _Rp>& __y);

template <class _CharT, class _Traits,
          class _UInt, size_t _Wp, size_t _Sp, size_t _Rp>
basic_ostream<_CharT, _Traits>&
operator<<(basic_ostream<_CharT, _Traits>& __os,
           const subtract_with_carry_engine<_UInt, _Wp, _Sp, _Rp>& __x);

template <class _CharT, class _Traits,
          class _UInt, size_t _Wp, size_t _Sp, size_t _Rp>
basic_istream<_CharT, _Traits>&
operator>>(basic_istream<_CharT, _Traits>& __is,
           subtract_with_carry_engine<_UInt, _Wp, _Sp, _Rp>& __x);

template<class _UIntType, size_t __w, size_t __s, size_t __r>
class __attribute__ ((__type_visibility__("default"))) subtract_with_carry_engine
{
public:

    typedef _UIntType result_type;

private:
    result_type __x_[__r];
    result_type __c_;
    size_t __i_;

    static constexpr const result_type _Dt = numeric_limits<result_type>::digits;
    static_assert( 0 < __w, "subtract_with_carry_engine invalid parameters");
    static_assert(__w <= _Dt, "subtract_with_carry_engine invalid parameters");
    static_assert( 0 < __s, "subtract_with_carry_engine invalid parameters");
    static_assert(__s < __r, "subtract_with_carry_engine invalid parameters");
public:
    static constexpr const result_type _Min = 0;
    static constexpr const result_type _Max = __w == _Dt ? result_type(~0) :
                                                      (result_type(1) << __w) - result_type(1);
    static_assert(_Min < _Max, "subtract_with_carry_engine invalid parameters");


    static constexpr const size_t word_size = __w;
    static constexpr const size_t short_lag = __s;
    static constexpr const size_t long_lag = __r;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    static constexpr result_type min() { return _Min; }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    static constexpr result_type max() { return _Max; }
    static constexpr const result_type default_seed = 19780503u;



    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    subtract_with_carry_engine() : subtract_with_carry_engine(default_seed) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit subtract_with_carry_engine(result_type __sd) { seed(__sd); }






    template<class _Sseq>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        explicit subtract_with_carry_engine(_Sseq& __q,
        typename enable_if<__is_seed_sequence<_Sseq, subtract_with_carry_engine>::value>::type* = 0)
        {seed(__q);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void seed(result_type __sd = default_seed)
        {seed(__sd, integral_constant<unsigned, 1 + (__w - 1) / 32>());}
    template<class _Sseq>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        typename enable_if
        <
            __is_seed_sequence<_Sseq, subtract_with_carry_engine>::value,
            void
        >::type
        seed(_Sseq& __q)
            {__seed(__q, integral_constant<unsigned, 1 + (__w - 1) / 32>());}


    result_type operator()();
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void discard(unsigned long long __z) {for (; __z; --__z) operator()();}

    template<class _UInt, size_t _Wp, size_t _Sp, size_t _Rp>
    friend
    bool
    operator==(
        const subtract_with_carry_engine<_UInt, _Wp, _Sp, _Rp>& __x,
        const subtract_with_carry_engine<_UInt, _Wp, _Sp, _Rp>& __y);

    template<class _UInt, size_t _Wp, size_t _Sp, size_t _Rp>
    friend
    bool
    operator!=(
        const subtract_with_carry_engine<_UInt, _Wp, _Sp, _Rp>& __x,
        const subtract_with_carry_engine<_UInt, _Wp, _Sp, _Rp>& __y);

    template <class _CharT, class _Traits,
              class _UInt, size_t _Wp, size_t _Sp, size_t _Rp>
    friend
    basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __os,
               const subtract_with_carry_engine<_UInt, _Wp, _Sp, _Rp>& __x);

    template <class _CharT, class _Traits,
              class _UInt, size_t _Wp, size_t _Sp, size_t _Rp>
    friend
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __is,
               subtract_with_carry_engine<_UInt, _Wp, _Sp, _Rp>& __x);

private:

    void seed(result_type __sd, integral_constant<unsigned, 1>);
    void seed(result_type __sd, integral_constant<unsigned, 2>);
    template<class _Sseq>
        void __seed(_Sseq& __q, integral_constant<unsigned, 1>);
    template<class _Sseq>
        void __seed(_Sseq& __q, integral_constant<unsigned, 2>);
};

template<class _UIntType, size_t __w, size_t __s, size_t __r>
    constexpr const size_t subtract_with_carry_engine<_UIntType, __w, __s, __r>::word_size;

template<class _UIntType, size_t __w, size_t __s, size_t __r>
    constexpr const size_t subtract_with_carry_engine<_UIntType, __w, __s, __r>::short_lag;

template<class _UIntType, size_t __w, size_t __s, size_t __r>
    constexpr const size_t subtract_with_carry_engine<_UIntType, __w, __s, __r>::long_lag;

template<class _UIntType, size_t __w, size_t __s, size_t __r>
    constexpr const typename subtract_with_carry_engine<_UIntType, __w, __s, __r>::result_type
    subtract_with_carry_engine<_UIntType, __w, __s, __r>::default_seed;

template<class _UIntType, size_t __w, size_t __s, size_t __r>
void
subtract_with_carry_engine<_UIntType, __w, __s, __r>::seed(result_type __sd,
        integral_constant<unsigned, 1>)
{
    linear_congruential_engine<result_type, 40014u, 0u, 2147483563u>
        __e(__sd == 0u ? default_seed : __sd);
    for (size_t __i = 0; __i < __r; ++__i)
        __x_[__i] = static_cast<result_type>(__e() & _Max);
    __c_ = __x_[__r-1] == 0;
    __i_ = 0;
}

template<class _UIntType, size_t __w, size_t __s, size_t __r>
void
subtract_with_carry_engine<_UIntType, __w, __s, __r>::seed(result_type __sd,
        integral_constant<unsigned, 2>)
{
    linear_congruential_engine<result_type, 40014u, 0u, 2147483563u>
        __e(__sd == 0u ? default_seed : __sd);
    for (size_t __i = 0; __i < __r; ++__i)
    {
        result_type __e0 = __e();
        __x_[__i] = static_cast<result_type>(
                                    (__e0 + ((uint64_t)__e() << 32)) & _Max);
    }
    __c_ = __x_[__r-1] == 0;
    __i_ = 0;
}

template<class _UIntType, size_t __w, size_t __s, size_t __r>
template<class _Sseq>
void
subtract_with_carry_engine<_UIntType, __w, __s, __r>::__seed(_Sseq& __q,
        integral_constant<unsigned, 1>)
{
    const unsigned __k = 1;
    uint32_t __ar[__r * __k];
    __q.generate(__ar, __ar + __r * __k);
    for (size_t __i = 0; __i < __r; ++__i)
        __x_[__i] = static_cast<result_type>(__ar[__i] & _Max);
    __c_ = __x_[__r-1] == 0;
    __i_ = 0;
}

template<class _UIntType, size_t __w, size_t __s, size_t __r>
template<class _Sseq>
void
subtract_with_carry_engine<_UIntType, __w, __s, __r>::__seed(_Sseq& __q,
        integral_constant<unsigned, 2>)
{
    const unsigned __k = 2;
    uint32_t __ar[__r * __k];
    __q.generate(__ar, __ar + __r * __k);
    for (size_t __i = 0; __i < __r; ++__i)
        __x_[__i] = static_cast<result_type>(
                  (__ar[2 * __i] + ((uint64_t)__ar[2 * __i + 1] << 32)) & _Max);
    __c_ = __x_[__r-1] == 0;
    __i_ = 0;
}

template<class _UIntType, size_t __w, size_t __s, size_t __r>
_UIntType
subtract_with_carry_engine<_UIntType, __w, __s, __r>::operator()()
{
    const result_type& __xs = __x_[(__i_ + (__r - __s)) % __r];
    result_type& __xr = __x_[__i_];
    result_type __new_c = __c_ == 0 ? __xs < __xr : __xs != 0 ? __xs <= __xr : 1;
    __xr = (__xs - __xr - __c_) & _Max;
    __c_ = __new_c;
    __i_ = (__i_ + 1) % __r;
    return __xr;
}

template<class _UInt, size_t _Wp, size_t _Sp, size_t _Rp>
bool
operator==(
    const subtract_with_carry_engine<_UInt, _Wp, _Sp, _Rp>& __x,
    const subtract_with_carry_engine<_UInt, _Wp, _Sp, _Rp>& __y)
{
    if (__x.__c_ != __y.__c_)
        return false;
    if (__x.__i_ == __y.__i_)
        return std::__1::equal(__x.__x_, __x.__x_ + _Rp, __y.__x_);
    if (__x.__i_ == 0 || __y.__i_ == 0)
    {
        size_t __j = std::__1::min(_Rp - __x.__i_, _Rp - __y.__i_);
        if (!std::__1::equal(__x.__x_ + __x.__i_, __x.__x_ + __x.__i_ + __j,
                         __y.__x_ + __y.__i_))
            return false;
        if (__x.__i_ == 0)
            return std::__1::equal(__x.__x_ + __j, __x.__x_ + _Rp, __y.__x_);
        return std::__1::equal(__x.__x_, __x.__x_ + (_Rp - __j), __y.__x_ + __j);
    }
    if (__x.__i_ < __y.__i_)
    {
        size_t __j = _Rp - __y.__i_;
        if (!std::__1::equal(__x.__x_ + __x.__i_, __x.__x_ + (__x.__i_ + __j),
                         __y.__x_ + __y.__i_))
            return false;
        if (!std::__1::equal(__x.__x_ + (__x.__i_ + __j), __x.__x_ + _Rp,
                         __y.__x_))
            return false;
        return std::__1::equal(__x.__x_, __x.__x_ + __x.__i_,
                           __y.__x_ + (_Rp - (__x.__i_ + __j)));
    }
    size_t __j = _Rp - __x.__i_;
    if (!std::__1::equal(__y.__x_ + __y.__i_, __y.__x_ + (__y.__i_ + __j),
                     __x.__x_ + __x.__i_))
        return false;
    if (!std::__1::equal(__y.__x_ + (__y.__i_ + __j), __y.__x_ + _Rp,
                     __x.__x_))
        return false;
    return std::__1::equal(__y.__x_, __y.__x_ + __y.__i_,
                       __x.__x_ + (_Rp - (__y.__i_ + __j)));
}

template<class _UInt, size_t _Wp, size_t _Sp, size_t _Rp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator!=(
    const subtract_with_carry_engine<_UInt, _Wp, _Sp, _Rp>& __x,
    const subtract_with_carry_engine<_UInt, _Wp, _Sp, _Rp>& __y)
{
    return !(__x == __y);
}

template <class _CharT, class _Traits,
          class _UInt, size_t _Wp, size_t _Sp, size_t _Rp>
basic_ostream<_CharT, _Traits>&
operator<<(basic_ostream<_CharT, _Traits>& __os,
           const subtract_with_carry_engine<_UInt, _Wp, _Sp, _Rp>& __x)
{
    __save_flags<_CharT, _Traits> __lx(__os);
    typedef basic_ostream<_CharT, _Traits> _Ostream;
    __os.flags(_Ostream::dec | _Ostream::left);
    _CharT __sp = __os.widen(' ');
    __os.fill(__sp);
    __os << __x.__x_[__x.__i_];
    for (size_t __j = __x.__i_ + 1; __j < _Rp; ++__j)
        __os << __sp << __x.__x_[__j];
    for (size_t __j = 0; __j < __x.__i_; ++__j)
        __os << __sp << __x.__x_[__j];
    __os << __sp << __x.__c_;
    return __os;
}

template <class _CharT, class _Traits,
          class _UInt, size_t _Wp, size_t _Sp, size_t _Rp>
basic_istream<_CharT, _Traits>&
operator>>(basic_istream<_CharT, _Traits>& __is,
           subtract_with_carry_engine<_UInt, _Wp, _Sp, _Rp>& __x)
{
    __save_flags<_CharT, _Traits> __lx(__is);
    typedef basic_istream<_CharT, _Traits> _Istream;
    __is.flags(_Istream::dec | _Istream::skipws);
    _UInt __t[_Rp+1];
    for (size_t __i = 0; __i < _Rp+1; ++__i)
        __is >> __t[__i];
    if (!__is.fail())
    {
        for (size_t __i = 0; __i < _Rp; ++__i)
            __x.__x_[__i] = __t[__i];
        __x.__c_ = __t[_Rp];
        __x.__i_ = 0;
    }
    return __is;
}

typedef subtract_with_carry_engine<uint_fast32_t, 24, 10, 24> ranlux24_base;
typedef subtract_with_carry_engine<uint_fast64_t, 48, 5, 12> ranlux48_base;



template<class _Engine, size_t __p, size_t __r>
class __attribute__ ((__type_visibility__("default"))) discard_block_engine
{
    _Engine __e_;
    int __n_;

    static_assert( 0 < __r, "discard_block_engine invalid parameters");
    static_assert(__r <= __p, "discard_block_engine invalid parameters");
    static_assert(__r <= 2147483647, "discard_block_engine invalid parameters");
public:

    typedef typename _Engine::result_type result_type;


    static constexpr const size_t block_size = __p;
    static constexpr const size_t used_block = __r;





    static constexpr const result_type _Min = _Engine::min();
    static constexpr const result_type _Max = _Engine::max();


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    static constexpr result_type min() { return _Engine::min(); }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    static constexpr result_type max() { return _Engine::max(); }


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    discard_block_engine() : __n_(0) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit discard_block_engine(const _Engine& __e)
        : __e_(__e), __n_(0) {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit discard_block_engine(_Engine&& __e)
        : __e_(std::__1::move(__e)), __n_(0) {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit discard_block_engine(result_type __sd) : __e_(__sd), __n_(0) {}
    template<class _Sseq>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        explicit discard_block_engine(_Sseq& __q,
        typename enable_if<__is_seed_sequence<_Sseq, discard_block_engine>::value &&
                           !is_convertible<_Sseq, _Engine>::value>::type* = 0)
        : __e_(__q), __n_(0) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void seed() {__e_.seed(); __n_ = 0;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void seed(result_type __sd) {__e_.seed(__sd); __n_ = 0;}
    template<class _Sseq>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        typename enable_if
        <
            __is_seed_sequence<_Sseq, discard_block_engine>::value,
            void
        >::type
        seed(_Sseq& __q) {__e_.seed(__q); __n_ = 0;}


    result_type operator()();
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void discard(unsigned long long __z) {for (; __z; --__z) operator()();}


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const _Engine& base() const noexcept {return __e_;}

    template<class _Eng, size_t _Pp, size_t _Rp>
    friend
    bool
    operator==(
        const discard_block_engine<_Eng, _Pp, _Rp>& __x,
        const discard_block_engine<_Eng, _Pp, _Rp>& __y);

    template<class _Eng, size_t _Pp, size_t _Rp>
    friend
    bool
    operator!=(
        const discard_block_engine<_Eng, _Pp, _Rp>& __x,
        const discard_block_engine<_Eng, _Pp, _Rp>& __y);

    template <class _CharT, class _Traits,
              class _Eng, size_t _Pp, size_t _Rp>
    friend
    basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __os,
               const discard_block_engine<_Eng, _Pp, _Rp>& __x);

    template <class _CharT, class _Traits,
              class _Eng, size_t _Pp, size_t _Rp>
    friend
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __is,
               discard_block_engine<_Eng, _Pp, _Rp>& __x);
};

template<class _Engine, size_t __p, size_t __r>
    constexpr const size_t discard_block_engine<_Engine, __p, __r>::block_size;

template<class _Engine, size_t __p, size_t __r>
    constexpr const size_t discard_block_engine<_Engine, __p, __r>::used_block;

template<class _Engine, size_t __p, size_t __r>
typename discard_block_engine<_Engine, __p, __r>::result_type
discard_block_engine<_Engine, __p, __r>::operator()()
{
    if (__n_ >= static_cast<int>(__r))
    {
        __e_.discard(__p - __r);
        __n_ = 0;
    }
    ++__n_;
    return __e_();
}

template<class _Eng, size_t _Pp, size_t _Rp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator==(const discard_block_engine<_Eng, _Pp, _Rp>& __x,
           const discard_block_engine<_Eng, _Pp, _Rp>& __y)
{
    return __x.__n_ == __y.__n_ && __x.__e_ == __y.__e_;
}

template<class _Eng, size_t _Pp, size_t _Rp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator!=(const discard_block_engine<_Eng, _Pp, _Rp>& __x,
           const discard_block_engine<_Eng, _Pp, _Rp>& __y)
{
    return !(__x == __y);
}

template <class _CharT, class _Traits,
          class _Eng, size_t _Pp, size_t _Rp>
basic_ostream<_CharT, _Traits>&
operator<<(basic_ostream<_CharT, _Traits>& __os,
           const discard_block_engine<_Eng, _Pp, _Rp>& __x)
{
    __save_flags<_CharT, _Traits> __lx(__os);
    typedef basic_ostream<_CharT, _Traits> _Ostream;
    __os.flags(_Ostream::dec | _Ostream::left);
    _CharT __sp = __os.widen(' ');
    __os.fill(__sp);
    return __os << __x.__e_ << __sp << __x.__n_;
}

template <class _CharT, class _Traits,
          class _Eng, size_t _Pp, size_t _Rp>
basic_istream<_CharT, _Traits>&
operator>>(basic_istream<_CharT, _Traits>& __is,
           discard_block_engine<_Eng, _Pp, _Rp>& __x)
{
    __save_flags<_CharT, _Traits> __lx(__is);
    typedef basic_istream<_CharT, _Traits> _Istream;
    __is.flags(_Istream::dec | _Istream::skipws);
    _Eng __e;
    int __n;
    __is >> __e >> __n;
    if (!__is.fail())
    {
        __x.__e_ = __e;
        __x.__n_ = __n;
    }
    return __is;
}

typedef discard_block_engine<ranlux24_base, 223, 23> ranlux24;
typedef discard_block_engine<ranlux48_base, 389, 11> ranlux48;



template<class _Engine, size_t __w, class _UIntType>
class __attribute__ ((__type_visibility__("default"))) independent_bits_engine
{
    template <class _UInt, _UInt _R0, size_t _Wp, size_t _Mp>
    class __get_n
    {
        static constexpr const size_t _Dt = numeric_limits<_UInt>::digits;
        static constexpr const size_t _Np = _Wp / _Mp + (_Wp % _Mp != 0);
        static constexpr const size_t _W0 = _Wp / _Np;
        static constexpr const _UInt _Y0 = _W0 >= _Dt ? 0 : (_R0 >> _W0) << _W0;
    public:
        static constexpr const size_t value = _R0 - _Y0 > _Y0 / _Np ? _Np + 1 : _Np;
    };
public:

    typedef _UIntType result_type;

private:
    _Engine __e_;

    static constexpr const result_type _Dt = numeric_limits<result_type>::digits;
    static_assert( 0 < __w, "independent_bits_engine invalid parameters");
    static_assert(__w <= _Dt, "independent_bits_engine invalid parameters");

    typedef typename _Engine::result_type _Engine_result_type;
    typedef typename conditional
        <
            sizeof(_Engine_result_type) <= sizeof(result_type),
                result_type,
                _Engine_result_type
        >::type _Working_result_type;




    static constexpr const _Working_result_type _Rp = _Engine::max() - _Engine::min()
                                                            + _Working_result_type(1);

    static constexpr const size_t __m = __log2<_Working_result_type, _Rp>::value;
    static constexpr const size_t __n = __get_n<_Working_result_type, _Rp, __w, __m>::value;
    static constexpr const size_t __w0 = __w / __n;
    static constexpr const size_t __n0 = __n - __w % __n;
    static constexpr const size_t _WDt = numeric_limits<_Working_result_type>::digits;
    static constexpr const size_t _EDt = numeric_limits<_Engine_result_type>::digits;
    static constexpr const _Working_result_type __y0 = __w0 >= _WDt ? 0 :
                                                               (_Rp >> __w0) << __w0;
    static constexpr const _Working_result_type __y1 = __w0 >= _WDt - 1 ? 0 :
                                                               (_Rp >> (__w0+1)) << (__w0+1);
    static constexpr const _Engine_result_type __mask0 = __w0 > 0 ?
                                _Engine_result_type(~0) >> (_EDt - __w0) :
                                _Engine_result_type(0);
    static constexpr const _Engine_result_type __mask1 = __w0 < _EDt - 1 ?
                                _Engine_result_type(~0) >> (_EDt - (__w0 + 1)) :
                                _Engine_result_type(~0);
public:
    static constexpr const result_type _Min = 0;
    static constexpr const result_type _Max = __w == _Dt ? result_type(~0) :
                                                      (result_type(1) << __w) - result_type(1);
    static_assert(_Min < _Max, "independent_bits_engine invalid parameters");


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    static constexpr result_type min() { return _Min; }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    static constexpr result_type max() { return _Max; }


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    independent_bits_engine() {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit independent_bits_engine(const _Engine& __e)
        : __e_(__e) {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit independent_bits_engine(_Engine&& __e)
        : __e_(std::__1::move(__e)) {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit independent_bits_engine(result_type __sd) : __e_(__sd) {}
    template<class _Sseq>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        explicit independent_bits_engine(_Sseq& __q,
        typename enable_if<__is_seed_sequence<_Sseq, independent_bits_engine>::value &&
                           !is_convertible<_Sseq, _Engine>::value>::type* = 0)
         : __e_(__q) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void seed() {__e_.seed();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void seed(result_type __sd) {__e_.seed(__sd);}
    template<class _Sseq>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        typename enable_if
        <
            __is_seed_sequence<_Sseq, independent_bits_engine>::value,
            void
        >::type
        seed(_Sseq& __q) {__e_.seed(__q);}


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    result_type operator()() {return __eval(integral_constant<bool, _Rp != 0>());}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void discard(unsigned long long __z) {for (; __z; --__z) operator()();}


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const _Engine& base() const noexcept {return __e_;}

    template<class _Eng, size_t _Wp, class _UInt>
    friend
    bool
    operator==(
        const independent_bits_engine<_Eng, _Wp, _UInt>& __x,
        const independent_bits_engine<_Eng, _Wp, _UInt>& __y);

    template<class _Eng, size_t _Wp, class _UInt>
    friend
    bool
    operator!=(
        const independent_bits_engine<_Eng, _Wp, _UInt>& __x,
        const independent_bits_engine<_Eng, _Wp, _UInt>& __y);

    template <class _CharT, class _Traits,
              class _Eng, size_t _Wp, class _UInt>
    friend
    basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __os,
               const independent_bits_engine<_Eng, _Wp, _UInt>& __x);

    template <class _CharT, class _Traits,
              class _Eng, size_t _Wp, class _UInt>
    friend
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __is,
               independent_bits_engine<_Eng, _Wp, _UInt>& __x);

private:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    result_type __eval(false_type);
    result_type __eval(true_type);

    template <size_t __count>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        static
        typename enable_if
        <
            __count < _Dt,
            result_type
        >::type
        __lshift(result_type __x) {return __x << __count;}

    template <size_t __count>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        static
        typename enable_if
        <
            (__count >= _Dt),
            result_type
        >::type
        __lshift(result_type) {return result_type(0);}
};

template<class _Engine, size_t __w, class _UIntType>
inline
_UIntType
independent_bits_engine<_Engine, __w, _UIntType>::__eval(false_type)
{
    return static_cast<result_type>(__e_() & __mask0);
}

template<class _Engine, size_t __w, class _UIntType>
_UIntType
independent_bits_engine<_Engine, __w, _UIntType>::__eval(true_type)
{
    result_type _Sp = 0;
    for (size_t __k = 0; __k < __n0; ++__k)
    {
        _Engine_result_type __u;
        do
        {
            __u = __e_() - _Engine::min();
        } while (__u >= __y0);
        _Sp = static_cast<result_type>(__lshift<__w0>(_Sp) + (__u & __mask0));
    }
    for (size_t __k = __n0; __k < __n; ++__k)
    {
        _Engine_result_type __u;
        do
        {
            __u = __e_() - _Engine::min();
        } while (__u >= __y1);
        _Sp = static_cast<result_type>(__lshift<__w0+1>(_Sp) + (__u & __mask1));
    }
    return _Sp;
}

template<class _Eng, size_t _Wp, class _UInt>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator==(
    const independent_bits_engine<_Eng, _Wp, _UInt>& __x,
    const independent_bits_engine<_Eng, _Wp, _UInt>& __y)
{
    return __x.base() == __y.base();
}

template<class _Eng, size_t _Wp, class _UInt>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator!=(
    const independent_bits_engine<_Eng, _Wp, _UInt>& __x,
    const independent_bits_engine<_Eng, _Wp, _UInt>& __y)
{
    return !(__x == __y);
}

template <class _CharT, class _Traits,
          class _Eng, size_t _Wp, class _UInt>
basic_ostream<_CharT, _Traits>&
operator<<(basic_ostream<_CharT, _Traits>& __os,
           const independent_bits_engine<_Eng, _Wp, _UInt>& __x)
{
    return __os << __x.base();
}

template <class _CharT, class _Traits,
          class _Eng, size_t _Wp, class _UInt>
basic_istream<_CharT, _Traits>&
operator>>(basic_istream<_CharT, _Traits>& __is,
           independent_bits_engine<_Eng, _Wp, _UInt>& __x)
{
    _Eng __e;
    __is >> __e;
    if (!__is.fail())
        __x.__e_ = __e;
    return __is;
}



template <uint64_t _Xp, uint64_t _Yp>
struct __ugcd
{
    static constexpr const uint64_t value = __ugcd<_Yp, _Xp % _Yp>::value;
};

template <uint64_t _Xp>
struct __ugcd<_Xp, 0>
{
    static constexpr const uint64_t value = _Xp;
};

template <uint64_t _Np, uint64_t _Dp>
class __uratio
{
    static_assert(_Dp != 0, "__uratio divide by 0");
    static constexpr const uint64_t __gcd = __ugcd<_Np, _Dp>::value;
public:
    static constexpr const uint64_t num = _Np / __gcd;
    static constexpr const uint64_t den = _Dp / __gcd;

    typedef __uratio<num, den> type;
};

template<class _Engine, size_t __k>
class __attribute__ ((__type_visibility__("default"))) shuffle_order_engine
{
    static_assert(0 < __k, "shuffle_order_engine invalid parameters");
public:

    typedef typename _Engine::result_type result_type;

private:
    _Engine __e_;
    result_type _V_[__k];
    result_type _Y_;

public:

    static constexpr const size_t table_size = __k;





    static constexpr const result_type _Min = _Engine::min();
    static constexpr const result_type _Max = _Engine::max();

    static_assert(_Min < _Max, "shuffle_order_engine invalid parameters");
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    static constexpr result_type min() { return _Min; }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    static constexpr result_type max() { return _Max; }

    static constexpr const unsigned long long _Rp = _Max - _Min + 1ull;


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    shuffle_order_engine() {__init();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit shuffle_order_engine(const _Engine& __e)
        : __e_(__e) {__init();}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit shuffle_order_engine(_Engine&& __e)
        : __e_(std::__1::move(__e)) {__init();}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit shuffle_order_engine(result_type __sd) : __e_(__sd) {__init();}
    template<class _Sseq>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        explicit shuffle_order_engine(_Sseq& __q,
        typename enable_if<__is_seed_sequence<_Sseq, shuffle_order_engine>::value &&
                           !is_convertible<_Sseq, _Engine>::value>::type* = 0)
         : __e_(__q) {__init();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void seed() {__e_.seed(); __init();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void seed(result_type __sd) {__e_.seed(__sd); __init();}
    template<class _Sseq>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        typename enable_if
        <
            __is_seed_sequence<_Sseq, shuffle_order_engine>::value,
            void
        >::type
        seed(_Sseq& __q) {__e_.seed(__q); __init();}


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    result_type operator()() {return __eval(integral_constant<bool, _Rp != 0>());}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void discard(unsigned long long __z) {for (; __z; --__z) operator()();}


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const _Engine& base() const noexcept {return __e_;}

private:
    template<class _Eng, size_t _Kp>
    friend
    bool
    operator==(
        const shuffle_order_engine<_Eng, _Kp>& __x,
        const shuffle_order_engine<_Eng, _Kp>& __y);

    template<class _Eng, size_t _Kp>
    friend
    bool
    operator!=(
        const shuffle_order_engine<_Eng, _Kp>& __x,
        const shuffle_order_engine<_Eng, _Kp>& __y);

    template <class _CharT, class _Traits,
              class _Eng, size_t _Kp>
    friend
    basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __os,
               const shuffle_order_engine<_Eng, _Kp>& __x);

    template <class _CharT, class _Traits,
              class _Eng, size_t _Kp>
    friend
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __is,
               shuffle_order_engine<_Eng, _Kp>& __x);

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void __init()
    {
        for (size_t __i = 0; __i < __k; ++__i)
            _V_[__i] = __e_();
        _Y_ = __e_();
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    result_type __eval(false_type) {return __eval2(integral_constant<bool, __k & 1>());}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    result_type __eval(true_type) {return __eval(__uratio<__k, _Rp>());}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    result_type __eval2(false_type) {return __eval(__uratio<__k/2, 0x8000000000000000ull>());}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    result_type __eval2(true_type) {return __evalf<__k, 0>();}

    template <uint64_t _Np, uint64_t _Dp>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        typename enable_if
        <
            (__uratio<_Np, _Dp>::num > 0xFFFFFFFFFFFFFFFFull / (_Max - _Min)),
            result_type
        >::type
        __eval(__uratio<_Np, _Dp>)
            {return __evalf<__uratio<_Np, _Dp>::num, __uratio<_Np, _Dp>::den>();}

    template <uint64_t _Np, uint64_t _Dp>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        typename enable_if
        <
            __uratio<_Np, _Dp>::num <= 0xFFFFFFFFFFFFFFFFull / (_Max - _Min),
            result_type
        >::type
        __eval(__uratio<_Np, _Dp>)
        {
            const size_t __j = static_cast<size_t>(__uratio<_Np, _Dp>::num * (_Y_ - _Min)
                                                   / __uratio<_Np, _Dp>::den);
            _Y_ = _V_[__j];
            _V_[__j] = __e_();
            return _Y_;
        }

    template <uint64_t __n, uint64_t __d>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        result_type __evalf()
        {
            const double _Fp = __d == 0 ?
                __n / (2. * 0x8000000000000000ull) :
                __n / (double)__d;
            const size_t __j = static_cast<size_t>(_Fp * (_Y_ - _Min));
            _Y_ = _V_[__j];
            _V_[__j] = __e_();
            return _Y_;
        }
};

template<class _Engine, size_t __k>
    constexpr const size_t shuffle_order_engine<_Engine, __k>::table_size;

template<class _Eng, size_t _Kp>
bool
operator==(
    const shuffle_order_engine<_Eng, _Kp>& __x,
    const shuffle_order_engine<_Eng, _Kp>& __y)
{
    return __x._Y_ == __y._Y_ && std::__1::equal(__x._V_, __x._V_ + _Kp, __y._V_) &&
           __x.__e_ == __y.__e_;
}

template<class _Eng, size_t _Kp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator!=(
    const shuffle_order_engine<_Eng, _Kp>& __x,
    const shuffle_order_engine<_Eng, _Kp>& __y)
{
    return !(__x == __y);
}

template <class _CharT, class _Traits,
          class _Eng, size_t _Kp>
basic_ostream<_CharT, _Traits>&
operator<<(basic_ostream<_CharT, _Traits>& __os,
           const shuffle_order_engine<_Eng, _Kp>& __x)
{
    __save_flags<_CharT, _Traits> __lx(__os);
    typedef basic_ostream<_CharT, _Traits> _Ostream;
    __os.flags(_Ostream::dec | _Ostream::left);
    _CharT __sp = __os.widen(' ');
    __os.fill(__sp);
    __os << __x.__e_ << __sp << __x._V_[0];
    for (size_t __i = 1; __i < _Kp; ++__i)
        __os << __sp << __x._V_[__i];
    return __os << __sp << __x._Y_;
}

template <class _CharT, class _Traits,
          class _Eng, size_t _Kp>
basic_istream<_CharT, _Traits>&
operator>>(basic_istream<_CharT, _Traits>& __is,
           shuffle_order_engine<_Eng, _Kp>& __x)
{
    typedef typename shuffle_order_engine<_Eng, _Kp>::result_type result_type;
    __save_flags<_CharT, _Traits> __lx(__is);
    typedef basic_istream<_CharT, _Traits> _Istream;
    __is.flags(_Istream::dec | _Istream::skipws);
    _Eng __e;
    result_type _Vp[_Kp+1];
    __is >> __e;
    for (size_t __i = 0; __i < _Kp+1; ++__i)
        __is >> _Vp[__i];
    if (!__is.fail())
    {
        __x.__e_ = __e;
        for (size_t __i = 0; __i < _Kp; ++__i)
            __x._V_[__i] = _Vp[__i];
        __x._Y_ = _Vp[_Kp];
    }
    return __is;
}

typedef shuffle_order_engine<minstd_rand0, 256> knuth_b;





class __attribute__ ((__visibility__("default"))) random_device
{

    int __f_;

public:

    typedef unsigned result_type;


    static constexpr const result_type _Min = 0;
    static constexpr const result_type _Max = 0xFFFFFFFFu;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    static constexpr result_type min() { return _Min;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    static constexpr result_type max() { return _Max;}



    random_device() : random_device("/dev/urandom") {}
    explicit random_device(const string& __token);



    ~random_device();


    result_type operator()();


    double entropy() const noexcept;

private:

    random_device(const random_device&);
    random_device& operator=(const random_device&);
};





class __attribute__ ((__type_visibility__("default"))) seed_seq
{
public:

    typedef uint32_t result_type;

private:
    vector<result_type> __v_;

    template<class _InputIterator>
        void init(_InputIterator __first, _InputIterator __last);
public:

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    seed_seq() noexcept {}

    template<class _Tp>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        seed_seq(initializer_list<_Tp> __il) {init(__il.begin(), __il.end());}


    template<class _InputIterator>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        seed_seq(_InputIterator __first, _InputIterator __last)
             {init(__first, __last);}


    template<class _RandomAccessIterator>
        void generate(_RandomAccessIterator __first, _RandomAccessIterator __last);


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_t size() const noexcept {return __v_.size();}
    template<class _OutputIterator>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        void param(_OutputIterator __dest) const
            {std::__1::copy(__v_.begin(), __v_.end(), __dest);}

private:

    seed_seq(const seed_seq&);
    void operator=(const seed_seq&);

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    static result_type _Tp(result_type __x) {return __x ^ (__x >> 27);}
};

template<class _InputIterator>
void
seed_seq::init(_InputIterator __first, _InputIterator __last)
{
    for (_InputIterator __s = __first; __s != __last; ++__s)
        __v_.push_back(*__s & 0xFFFFFFFF);
}

template<class _RandomAccessIterator>
void
seed_seq::generate(_RandomAccessIterator __first, _RandomAccessIterator __last)
{
    if (__first != __last)
    {
        std::__1::fill(__first, __last, 0x8b8b8b8b);
        const size_t __n = static_cast<size_t>(__last - __first);
        const size_t __s = __v_.size();
        const size_t __t = (__n >= 623) ? 11
                         : (__n >= 68) ? 7
                         : (__n >= 39) ? 5
                         : (__n >= 7) ? 3
                         : (__n - 1) / 2;
        const size_t __p = (__n - __t) / 2;
        const size_t __q = __p + __t;
        const size_t __m = std::__1::max(__s + 1, __n);

        {
            result_type __r = 1664525 * _Tp(__first[0] ^ __first[__p]
                                                      ^ __first[__n - 1]);
            __first[__p] += __r;
            __r += __s;
            __first[__q] += __r;
            __first[0] = __r;
        }
        for (size_t __k = 1; __k <= __s; ++__k)
        {
            const size_t __kmodn = __k % __n;
            const size_t __kpmodn = (__k + __p) % __n;
            result_type __r = 1664525 * _Tp(__first[__kmodn] ^ __first[__kpmodn]
                                           ^ __first[(__k - 1) % __n]);
            __first[__kpmodn] += __r;
            __r += __kmodn + __v_[__k-1];
            __first[(__k + __q) % __n] += __r;
            __first[__kmodn] = __r;
        }
        for (size_t __k = __s + 1; __k < __m; ++__k)
        {
            const size_t __kmodn = __k % __n;
            const size_t __kpmodn = (__k + __p) % __n;
            result_type __r = 1664525 * _Tp(__first[__kmodn] ^ __first[__kpmodn]
                                           ^ __first[(__k - 1) % __n]);
            __first[__kpmodn] += __r;
            __r += __kmodn;
            __first[(__k + __q) % __n] += __r;
            __first[__kmodn] = __r;
        }
        for (size_t __k = __m; __k < __m + __n; ++__k)
        {
            const size_t __kmodn = __k % __n;
            const size_t __kpmodn = (__k + __p) % __n;
            result_type __r = 1566083941 * _Tp(__first[__kmodn] +
                                              __first[__kpmodn] +
                                              __first[(__k - 1) % __n]);
            __first[__kpmodn] ^= __r;
            __r -= __kmodn;
            __first[(__k + __q) % __n] ^= __r;
            __first[__kmodn] = __r;
        }
    }
}



template<class _RealType, size_t __bits, class _URNG>
_RealType
generate_canonical(_URNG& __g)
{
    const size_t _Dt = numeric_limits<_RealType>::digits;
    const size_t __b = _Dt < __bits ? _Dt : __bits;



    const size_t __logR = __log2<uint64_t, _URNG::max() - _URNG::min() + uint64_t(1)>::value;

    const size_t __k = __b / __logR + (__b % __logR != 0) + (__b == 0);
    const _RealType _Rp = static_cast<_RealType>(_URNG::max() - _URNG::min()) + _RealType(1);
    _RealType __base = _Rp;
    _RealType _Sp = __g() - _URNG::min();
    for (size_t __i = 1; __i < __k; ++__i, __base *= _Rp)
        _Sp += (__g() - _URNG::min()) * __base;
    return _Sp / __base;
}



template<class _RealType = double>
class __attribute__ ((__type_visibility__("default"))) uniform_real_distribution
{
public:

    typedef _RealType result_type;

    class __attribute__ ((__type_visibility__("default"))) param_type
    {
        result_type __a_;
        result_type __b_;
    public:
        typedef uniform_real_distribution distribution_type;

        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        explicit param_type(result_type __a = 0,
                            result_type __b = 1)
            : __a_(__a), __b_(__b) {}

        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        result_type a() const {return __a_;}
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        result_type b() const {return __b_;}

        friend __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        bool operator==(const param_type& __x, const param_type& __y)
            {return __x.__a_ == __y.__a_ && __x.__b_ == __y.__b_;}
        friend __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        bool operator!=(const param_type& __x, const param_type& __y)
            {return !(__x == __y);}
    };

private:
    param_type __p_;

public:


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    uniform_real_distribution() : uniform_real_distribution(0) {}
    explicit uniform_real_distribution(result_type __a, result_type __b = 1)
        : __p_(param_type(__a, __b)) {}





    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit uniform_real_distribution(const param_type& __p) : __p_(__p) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void reset() {}


    template<class _URNG>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        result_type operator()(_URNG& __g)
        {return (*this)(__g, __p_);}
    template<class _URNG> __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) result_type operator()(_URNG& __g, const param_type& __p);


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    result_type a() const {return __p_.a();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    result_type b() const {return __p_.b();}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    param_type param() const {return __p_;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void param(const param_type& __p) {__p_ = __p;}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    result_type min() const {return a();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    result_type max() const {return b();}

    friend __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        bool operator==(const uniform_real_distribution& __x,
                        const uniform_real_distribution& __y)
        {return __x.__p_ == __y.__p_;}
    friend __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        bool operator!=(const uniform_real_distribution& __x,
                        const uniform_real_distribution& __y)
        {return !(__x == __y);}
};

template<class _RealType>
template<class _URNG>
inline
typename uniform_real_distribution<_RealType>::result_type
uniform_real_distribution<_RealType>::operator()(_URNG& __g, const param_type& __p)
{
    return (__p.b() - __p.a())
        * std::__1::generate_canonical<_RealType, numeric_limits<_RealType>::digits>(__g)
        + __p.a();
}

template <class _CharT, class _Traits, class _RT>
basic_ostream<_CharT, _Traits>&
operator<<(basic_ostream<_CharT, _Traits>& __os,
           const uniform_real_distribution<_RT>& __x)
{
    __save_flags<_CharT, _Traits> __lx(__os);
    typedef basic_ostream<_CharT, _Traits> _OStream;
    __os.flags(_OStream::dec | _OStream::left | _OStream::fixed |
               _OStream::scientific);
    _CharT __sp = __os.widen(' ');
    __os.fill(__sp);
    return __os << __x.a() << __sp << __x.b();
}

template <class _CharT, class _Traits, class _RT>
basic_istream<_CharT, _Traits>&
operator>>(basic_istream<_CharT, _Traits>& __is,
           uniform_real_distribution<_RT>& __x)
{
    typedef uniform_real_distribution<_RT> _Eng;
    typedef typename _Eng::result_type result_type;
    typedef typename _Eng::param_type param_type;
    __save_flags<_CharT, _Traits> __lx(__is);
    typedef basic_istream<_CharT, _Traits> _Istream;
    __is.flags(_Istream::dec | _Istream::skipws);
    result_type __a;
    result_type __b;
    __is >> __a >> __b;
    if (!__is.fail())
        __x.param(param_type(__a, __b));
    return __is;
}



class __attribute__ ((__type_visibility__("default"))) bernoulli_distribution
{
public:

    typedef bool result_type;

    class __attribute__ ((__type_visibility__("default"))) param_type
    {
        double __p_;
    public:
        typedef bernoulli_distribution distribution_type;

        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        explicit param_type(double __p = 0.5) : __p_(__p) {}

        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        double p() const {return __p_;}

        friend __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
            bool operator==(const param_type& __x, const param_type& __y)
            {return __x.__p_ == __y.__p_;}
        friend __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
            bool operator!=(const param_type& __x, const param_type& __y)
            {return !(__x == __y);}
    };

private:
    param_type __p_;

public:


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    bernoulli_distribution() : bernoulli_distribution(0.5) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit bernoulli_distribution(double __p) : __p_(param_type(__p)) {}




    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit bernoulli_distribution(const param_type& __p) : __p_(__p) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void reset() {}


    template<class _URNG>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        result_type operator()(_URNG& __g)
        {return (*this)(__g, __p_);}
    template<class _URNG> __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) result_type operator()(_URNG& __g, const param_type& __p);


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    double p() const {return __p_.p();}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    param_type param() const {return __p_;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void param(const param_type& __p) {__p_ = __p;}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    result_type min() const {return false;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    result_type max() const {return true;}

    friend __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        bool operator==(const bernoulli_distribution& __x,
                        const bernoulli_distribution& __y)
        {return __x.__p_ == __y.__p_;}
    friend __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        bool operator!=(const bernoulli_distribution& __x,
                        const bernoulli_distribution& __y)
        {return !(__x == __y);}
};

template<class _URNG>
inline
bernoulli_distribution::result_type
bernoulli_distribution::operator()(_URNG& __g, const param_type& __p)
{
    uniform_real_distribution<double> __gen;
    return __gen(__g) < __p.p();
}

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>&
operator<<(basic_ostream<_CharT, _Traits>& __os, const bernoulli_distribution& __x)
{
    __save_flags<_CharT, _Traits> __lx(__os);
    typedef basic_ostream<_CharT, _Traits> _OStream;
    __os.flags(_OStream::dec | _OStream::left | _OStream::fixed |
               _OStream::scientific);
    _CharT __sp = __os.widen(' ');
    __os.fill(__sp);
    return __os << __x.p();
}

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
operator>>(basic_istream<_CharT, _Traits>& __is, bernoulli_distribution& __x)
{
    typedef bernoulli_distribution _Eng;
    typedef typename _Eng::param_type param_type;
    __save_flags<_CharT, _Traits> __lx(__is);
    typedef basic_istream<_CharT, _Traits> _Istream;
    __is.flags(_Istream::dec | _Istream::skipws);
    double __p;
    __is >> __p;
    if (!__is.fail())
        __x.param(param_type(__p));
    return __is;
}



template<class _IntType = int>
class __attribute__ ((__type_visibility__("default"))) binomial_distribution
{
public:

    typedef _IntType result_type;

    class __attribute__ ((__type_visibility__("default"))) param_type
    {
        result_type __t_;
        double __p_;
        double __pr_;
        double __odds_ratio_;
        result_type __r0_;
    public:
        typedef binomial_distribution distribution_type;

        explicit param_type(result_type __t = 1, double __p = 0.5);

        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        result_type t() const {return __t_;}
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        double p() const {return __p_;}

        friend __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
            bool operator==(const param_type& __x, const param_type& __y)
            {return __x.__t_ == __y.__t_ && __x.__p_ == __y.__p_;}
        friend __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
            bool operator!=(const param_type& __x, const param_type& __y)
            {return !(__x == __y);}

        friend class binomial_distribution;
    };

private:
    param_type __p_;

public:


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    binomial_distribution() : binomial_distribution(1) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit binomial_distribution(result_type __t, double __p = 0.5)
        : __p_(param_type(__t, __p)) {}





    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit binomial_distribution(const param_type& __p) : __p_(__p) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void reset() {}


    template<class _URNG>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        result_type operator()(_URNG& __g)
        {return (*this)(__g, __p_);}
    template<class _URNG> result_type operator()(_URNG& __g, const param_type& __p);


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    result_type t() const {return __p_.t();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    double p() const {return __p_.p();}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    param_type param() const {return __p_;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void param(const param_type& __p) {__p_ = __p;}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    result_type min() const {return 0;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    result_type max() const {return t();}

    friend __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        bool operator==(const binomial_distribution& __x,
                        const binomial_distribution& __y)
        {return __x.__p_ == __y.__p_;}
    friend __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        bool operator!=(const binomial_distribution& __x,
                        const binomial_distribution& __y)
        {return !(__x == __y);}
};


extern "C" double lgamma_r(double, int *);


inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) double __libcpp_lgamma(double __d) {



  int __sign;
  return lgamma_r(__d, &__sign);

}

template<class _IntType>
binomial_distribution<_IntType>::param_type::param_type(result_type __t, double __p)
    : __t_(__t), __p_(__p)
{
    if (0 < __p_ && __p_ < 1)
    {
        __r0_ = static_cast<result_type>((__t_ + 1) * __p_);
        __pr_ = std::__1::exp(__libcpp_lgamma(__t_ + 1.) -
                           __libcpp_lgamma(__r0_ + 1.) -
                           __libcpp_lgamma(__t_ - __r0_ + 1.) + __r0_ * std::__1::log(__p_) +
                           (__t_ - __r0_) * std::__1::log(1 - __p_));
        __odds_ratio_ = __p_ / (1 - __p_);
    }
}



template<class _IntType>
template<class _URNG>
_IntType
binomial_distribution<_IntType>::operator()(_URNG& __g, const param_type& __pr)
{
    if (__pr.__t_ == 0 || __pr.__p_ == 0)
        return 0;
    if (__pr.__p_ == 1)
        return __pr.__t_;
    uniform_real_distribution<double> __gen;
    double __u = __gen(__g) - __pr.__pr_;
    if (__u < 0)
        return __pr.__r0_;
    double __pu = __pr.__pr_;
    double __pd = __pu;
    result_type __ru = __pr.__r0_;
    result_type __rd = __ru;
    while (true)
    {
        bool __break = true;
        if (__rd >= 1)
        {
            __pd *= __rd / (__pr.__odds_ratio_ * (__pr.__t_ - __rd + 1));
            __u -= __pd;
            __break = false;
            if (__u < 0)
                return __rd - 1;
        }
        if ( __rd != 0 )
            --__rd;
        ++__ru;
        if (__ru <= __pr.__t_)
        {
            __pu *= (__pr.__t_ - __ru + 1) * __pr.__odds_ratio_ / __ru;
            __u -= __pu;
            __break = false;
            if (__u < 0)
                return __ru;
        }
        if (__break)
            return 0;
    }
}

template <class _CharT, class _Traits, class _IntType>
basic_ostream<_CharT, _Traits>&
operator<<(basic_ostream<_CharT, _Traits>& __os,
           const binomial_distribution<_IntType>& __x)
{
    __save_flags<_CharT, _Traits> __lx(__os);
    typedef basic_ostream<_CharT, _Traits> _OStream;
    __os.flags(_OStream::dec | _OStream::left | _OStream::fixed |
               _OStream::scientific);
    _CharT __sp = __os.widen(' ');
    __os.fill(__sp);
    return __os << __x.t() << __sp << __x.p();
}

template <class _CharT, class _Traits, class _IntType>
basic_istream<_CharT, _Traits>&
operator>>(basic_istream<_CharT, _Traits>& __is,
           binomial_distribution<_IntType>& __x)
{
    typedef binomial_distribution<_IntType> _Eng;
    typedef typename _Eng::result_type result_type;
    typedef typename _Eng::param_type param_type;
    __save_flags<_CharT, _Traits> __lx(__is);
    typedef basic_istream<_CharT, _Traits> _Istream;
    __is.flags(_Istream::dec | _Istream::skipws);
    result_type __t;
    double __p;
    __is >> __t >> __p;
    if (!__is.fail())
        __x.param(param_type(__t, __p));
    return __is;
}



template<class _RealType = double>
class __attribute__ ((__type_visibility__("default"))) exponential_distribution
{
public:

    typedef _RealType result_type;

    class __attribute__ ((__type_visibility__("default"))) param_type
    {
        result_type __lambda_;
    public:
        typedef exponential_distribution distribution_type;

        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        explicit param_type(result_type __lambda = 1) : __lambda_(__lambda) {}

        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        result_type lambda() const {return __lambda_;}

        friend __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
            bool operator==(const param_type& __x, const param_type& __y)
            {return __x.__lambda_ == __y.__lambda_;}
        friend __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
            bool operator!=(const param_type& __x, const param_type& __y)
            {return !(__x == __y);}
    };

private:
    param_type __p_;

public:


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    exponential_distribution() : exponential_distribution(1) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit exponential_distribution(result_type __lambda)
        : __p_(param_type(__lambda)) {}





    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit exponential_distribution(const param_type& __p) : __p_(__p) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void reset() {}


    template<class _URNG>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        result_type operator()(_URNG& __g)
        {return (*this)(__g, __p_);}
    template<class _URNG> result_type operator()(_URNG& __g, const param_type& __p);


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    result_type lambda() const {return __p_.lambda();}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    param_type param() const {return __p_;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void param(const param_type& __p) {__p_ = __p;}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    result_type min() const {return 0;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    result_type max() const {return numeric_limits<result_type>::infinity();}

    friend __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        bool operator==(const exponential_distribution& __x,
                        const exponential_distribution& __y)
        {return __x.__p_ == __y.__p_;}
    friend __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        bool operator!=(const exponential_distribution& __x,
                        const exponential_distribution& __y)
        {return !(__x == __y);}
};

template <class _RealType>
template<class _URNG>
_RealType
exponential_distribution<_RealType>::operator()(_URNG& __g, const param_type& __p)
{
    return -std::__1::log
                  (
                      result_type(1) -
                      std::__1::generate_canonical<result_type,
                                       numeric_limits<result_type>::digits>(__g)
                  )
                  / __p.lambda();
}

template <class _CharT, class _Traits, class _RealType>
basic_ostream<_CharT, _Traits>&
operator<<(basic_ostream<_CharT, _Traits>& __os,
           const exponential_distribution<_RealType>& __x)
{
    __save_flags<_CharT, _Traits> __lx(__os);
    typedef basic_ostream<_CharT, _Traits> _OStream;
    __os.flags(_OStream::dec | _OStream::left | _OStream::fixed |
               _OStream::scientific);
    return __os << __x.lambda();
}

template <class _CharT, class _Traits, class _RealType>
basic_istream<_CharT, _Traits>&
operator>>(basic_istream<_CharT, _Traits>& __is,
           exponential_distribution<_RealType>& __x)
{
    typedef exponential_distribution<_RealType> _Eng;
    typedef typename _Eng::result_type result_type;
    typedef typename _Eng::param_type param_type;
    __save_flags<_CharT, _Traits> __lx(__is);
    typedef basic_istream<_CharT, _Traits> _Istream;
    __is.flags(_Istream::dec | _Istream::skipws);
    result_type __lambda;
    __is >> __lambda;
    if (!__is.fail())
        __x.param(param_type(__lambda));
    return __is;
}



template<class _RealType = double>
class __attribute__ ((__type_visibility__("default"))) normal_distribution
{
public:

    typedef _RealType result_type;

    class __attribute__ ((__type_visibility__("default"))) param_type
    {
        result_type __mean_;
        result_type __stddev_;
    public:
        typedef normal_distribution distribution_type;

        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        explicit param_type(result_type __mean = 0, result_type __stddev = 1)
            : __mean_(__mean), __stddev_(__stddev) {}

        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        result_type mean() const {return __mean_;}
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        result_type stddev() const {return __stddev_;}

        friend __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
            bool operator==(const param_type& __x, const param_type& __y)
            {return __x.__mean_ == __y.__mean_ && __x.__stddev_ == __y.__stddev_;}
        friend __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
            bool operator!=(const param_type& __x, const param_type& __y)
            {return !(__x == __y);}
    };

private:
    param_type __p_;
    result_type _V_;
    bool _V_hot_;

public:


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    normal_distribution() : normal_distribution(0) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit normal_distribution(result_type __mean, result_type __stddev = 1)
        : __p_(param_type(__mean, __stddev)), _V_hot_(false) {}






    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit normal_distribution(const param_type& __p)
        : __p_(__p), _V_hot_(false) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void reset() {_V_hot_ = false;}


    template<class _URNG>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        result_type operator()(_URNG& __g)
        {return (*this)(__g, __p_);}
    template<class _URNG> result_type operator()(_URNG& __g, const param_type& __p);


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    result_type mean() const {return __p_.mean();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    result_type stddev() const {return __p_.stddev();}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    param_type param() const {return __p_;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void param(const param_type& __p) {__p_ = __p;}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    result_type min() const {return -numeric_limits<result_type>::infinity();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    result_type max() const {return numeric_limits<result_type>::infinity();}

    friend __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        bool operator==(const normal_distribution& __x,
                        const normal_distribution& __y)
        {return __x.__p_ == __y.__p_ && __x._V_hot_ == __y._V_hot_ &&
                (!__x._V_hot_ || __x._V_ == __y._V_);}
    friend __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        bool operator!=(const normal_distribution& __x,
                        const normal_distribution& __y)
        {return !(__x == __y);}

    template <class _CharT, class _Traits, class _RT>
    friend
    basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __os,
               const normal_distribution<_RT>& __x);

    template <class _CharT, class _Traits, class _RT>
    friend
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __is,
               normal_distribution<_RT>& __x);
};

template <class _RealType>
template<class _URNG>
_RealType
normal_distribution<_RealType>::operator()(_URNG& __g, const param_type& __p)
{
    result_type _Up;
    if (_V_hot_)
    {
        _V_hot_ = false;
        _Up = _V_;
    }
    else
    {
        uniform_real_distribution<result_type> _Uni(-1, 1);
        result_type __u;
        result_type __v;
        result_type __s;
        do
        {
            __u = _Uni(__g);
            __v = _Uni(__g);
            __s = __u * __u + __v * __v;
        } while (__s > 1 || __s == 0);
        result_type _Fp = std::__1::sqrt(-2 * std::__1::log(__s) / __s);
        _V_ = __v * _Fp;
        _V_hot_ = true;
        _Up = __u * _Fp;
    }
    return _Up * __p.stddev() + __p.mean();
}

template <class _CharT, class _Traits, class _RT>
basic_ostream<_CharT, _Traits>&
operator<<(basic_ostream<_CharT, _Traits>& __os,
           const normal_distribution<_RT>& __x)
{
    __save_flags<_CharT, _Traits> __lx(__os);
    typedef basic_ostream<_CharT, _Traits> _OStream;
    __os.flags(_OStream::dec | _OStream::left | _OStream::fixed |
               _OStream::scientific);
    _CharT __sp = __os.widen(' ');
    __os.fill(__sp);
    __os << __x.mean() << __sp << __x.stddev() << __sp << __x._V_hot_;
    if (__x._V_hot_)
        __os << __sp << __x._V_;
    return __os;
}

template <class _CharT, class _Traits, class _RT>
basic_istream<_CharT, _Traits>&
operator>>(basic_istream<_CharT, _Traits>& __is,
           normal_distribution<_RT>& __x)
{
    typedef normal_distribution<_RT> _Eng;
    typedef typename _Eng::result_type result_type;
    typedef typename _Eng::param_type param_type;
    __save_flags<_CharT, _Traits> __lx(__is);
    typedef basic_istream<_CharT, _Traits> _Istream;
    __is.flags(_Istream::dec | _Istream::skipws);
    result_type __mean;
    result_type __stddev;
    result_type _Vp = 0;
    bool _V_hot = false;
    __is >> __mean >> __stddev >> _V_hot;
    if (_V_hot)
        __is >> _Vp;
    if (!__is.fail())
    {
        __x.param(param_type(__mean, __stddev));
        __x._V_hot_ = _V_hot;
        __x._V_ = _Vp;
    }
    return __is;
}



template<class _RealType = double>
class __attribute__ ((__type_visibility__("default"))) lognormal_distribution
{
public:

    typedef _RealType result_type;

    class __attribute__ ((__type_visibility__("default"))) param_type
    {
        normal_distribution<result_type> __nd_;
    public:
        typedef lognormal_distribution distribution_type;

        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        explicit param_type(result_type __m = 0, result_type __s = 1)
            : __nd_(__m, __s) {}

        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        result_type m() const {return __nd_.mean();}
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        result_type s() const {return __nd_.stddev();}

        friend __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
            bool operator==(const param_type& __x, const param_type& __y)
            {return __x.__nd_ == __y.__nd_;}
        friend __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
            bool operator!=(const param_type& __x, const param_type& __y)
            {return !(__x == __y);}
        friend class lognormal_distribution;

        template <class _CharT, class _Traits, class _RT>
        friend
        basic_ostream<_CharT, _Traits>&
        operator<<(basic_ostream<_CharT, _Traits>& __os,
                   const lognormal_distribution<_RT>& __x);

        template <class _CharT, class _Traits, class _RT>
        friend
        basic_istream<_CharT, _Traits>&
        operator>>(basic_istream<_CharT, _Traits>& __is,
                   lognormal_distribution<_RT>& __x);
    };

private:
    param_type __p_;

public:


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    lognormal_distribution() : lognormal_distribution(0) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit lognormal_distribution(result_type __m, result_type __s = 1)
        : __p_(param_type(__m, __s)) {}






    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit lognormal_distribution(const param_type& __p)
        : __p_(__p) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void reset() {__p_.__nd_.reset();}


    template<class _URNG>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        result_type operator()(_URNG& __g)
        {return (*this)(__g, __p_);}
    template<class _URNG>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        result_type operator()(_URNG& __g, const param_type& __p)
        {return std::__1::exp(const_cast<normal_distribution<result_type>&>(__p.__nd_)(__g));}


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    result_type m() const {return __p_.m();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    result_type s() const {return __p_.s();}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    param_type param() const {return __p_;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void param(const param_type& __p) {__p_ = __p;}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    result_type min() const {return 0;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    result_type max() const {return numeric_limits<result_type>::infinity();}

    friend __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        bool operator==(const lognormal_distribution& __x,
                        const lognormal_distribution& __y)
        {return __x.__p_ == __y.__p_;}
    friend __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        bool operator!=(const lognormal_distribution& __x,
                        const lognormal_distribution& __y)
        {return !(__x == __y);}

    template <class _CharT, class _Traits, class _RT>
    friend
    basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __os,
               const lognormal_distribution<_RT>& __x);

    template <class _CharT, class _Traits, class _RT>
    friend
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __is,
               lognormal_distribution<_RT>& __x);
};

template <class _CharT, class _Traits, class _RT>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
basic_ostream<_CharT, _Traits>&
operator<<(basic_ostream<_CharT, _Traits>& __os,
           const lognormal_distribution<_RT>& __x)
{
    return __os << __x.__p_.__nd_;
}

template <class _CharT, class _Traits, class _RT>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
basic_istream<_CharT, _Traits>&
operator>>(basic_istream<_CharT, _Traits>& __is,
           lognormal_distribution<_RT>& __x)
{
    return __is >> __x.__p_.__nd_;
}



template<class _IntType = int>
class __attribute__ ((__type_visibility__("default"))) poisson_distribution
{
public:

    typedef _IntType result_type;

    class __attribute__ ((__type_visibility__("default"))) param_type
    {
        double __mean_;
        double __s_;
        double __d_;
        double __l_;
        double __omega_;
        double __c0_;
        double __c1_;
        double __c2_;
        double __c3_;
        double __c_;

    public:
        typedef poisson_distribution distribution_type;

        explicit param_type(double __mean = 1.0);

        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        double mean() const {return __mean_;}

        friend __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
            bool operator==(const param_type& __x, const param_type& __y)
            {return __x.__mean_ == __y.__mean_;}
        friend __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
            bool operator!=(const param_type& __x, const param_type& __y)
            {return !(__x == __y);}

        friend class poisson_distribution;
    };

private:
    param_type __p_;

public:


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    poisson_distribution() : poisson_distribution(1.0) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit poisson_distribution(double __mean)
        : __p_(__mean) {}





    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit poisson_distribution(const param_type& __p) : __p_(__p) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void reset() {}


    template<class _URNG>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        result_type operator()(_URNG& __g)
        {return (*this)(__g, __p_);}
    template<class _URNG> result_type operator()(_URNG& __g, const param_type& __p);


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    double mean() const {return __p_.mean();}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    param_type param() const {return __p_;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void param(const param_type& __p) {__p_ = __p;}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    result_type min() const {return 0;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    result_type max() const {return numeric_limits<result_type>::max();}

    friend __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        bool operator==(const poisson_distribution& __x,
                        const poisson_distribution& __y)
        {return __x.__p_ == __y.__p_;}
    friend __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        bool operator!=(const poisson_distribution& __x,
                        const poisson_distribution& __y)
        {return !(__x == __y);}
};

template<class _IntType>
poisson_distribution<_IntType>::param_type::param_type(double __mean)



    : __mean_(isinf(__mean) ? numeric_limits<double>::max() : __mean)
{
    if (__mean_ < 10)
    {
        __s_ = 0;
        __d_ = 0;
        __l_ = std::__1::exp(-__mean_);
        __omega_ = 0;
        __c3_ = 0;
        __c2_ = 0;
        __c1_ = 0;
        __c0_ = 0;
        __c_ = 0;
    }
    else
    {
        __s_ = std::__1::sqrt(__mean_);
        __d_ = 6 * __mean_ * __mean_;
        __l_ = std::__1::trunc(__mean_ - 1.1484);
        __omega_ = .3989423 / __s_;
        double __b1_ = .4166667E-1 / __mean_;
        double __b2_ = .3 * __b1_ * __b1_;
        __c3_ = .1428571 * __b1_ * __b2_;
        __c2_ = __b2_ - 15. * __c3_;
        __c1_ = __b1_ - 6. * __b2_ + 45. * __c3_;
        __c0_ = 1. - __b1_ + 3. * __b2_ - 15. * __c3_;
        __c_ = .1069 / __mean_;
    }
}

template <class _IntType>
template<class _URNG>
_IntType
poisson_distribution<_IntType>::operator()(_URNG& __urng, const param_type& __pr)
{
    double __tx;
    uniform_real_distribution<double> __urd;
    if (__pr.__mean_ < 10)
    {
         __tx = 0;
        for (double __p = __urd(__urng); __p > __pr.__l_; ++__tx)
            __p *= __urd(__urng);
    }
    else
    {
        double __difmuk;
        double __g = __pr.__mean_ + __pr.__s_ * normal_distribution<double>()(__urng);
        double __u;
        if (__g > 0)
        {
            __tx = std::__1::trunc(__g);
            if (__tx >= __pr.__l_)
                return std::__1::__clamp_to_integral<result_type>(__tx);
            __difmuk = __pr.__mean_ - __tx;
            __u = __urd(__urng);
            if (__pr.__d_ * __u >= __difmuk * __difmuk * __difmuk)
                return std::__1::__clamp_to_integral<result_type>(__tx);
        }
        exponential_distribution<double> __edist;
        for (bool __using_exp_dist = false; true; __using_exp_dist = true)
        {
            double __e;
            if (__using_exp_dist || __g <= 0)
            {
                double __t;
                do
                {
                    __e = __edist(__urng);
                    __u = __urd(__urng);
                    __u += __u - 1;
                    __t = 1.8 + (__u < 0 ? -__e : __e);
                } while (__t <= -.6744);
                __tx = std::__1::trunc(__pr.__mean_ + __pr.__s_ * __t);
                __difmuk = __pr.__mean_ - __tx;
                __using_exp_dist = true;
            }
            double __px;
            double __py;
            if (__tx < 10 && __tx >= 0)
            {
                const double __fac[] = {1, 1, 2, 6, 24, 120, 720, 5040,
                                             40320, 362880};
                __px = -__pr.__mean_;
                __py = std::__1::pow(__pr.__mean_, (double)__tx) / __fac[static_cast<int>(__tx)];
            }
            else
            {
                double __del = .8333333E-1 / __tx;
                __del -= 4.8 * __del * __del * __del;
                double __v = __difmuk / __tx;
                if (std::__1::abs(__v) > 0.25)
                    __px = __tx * std::__1::log(1 + __v) - __difmuk - __del;
                else
                    __px = __tx * __v * __v * (((((((.1250060 * __v + -.1384794) *
                           __v + .1421878) * __v + -.1661269) * __v + .2000118) *
                           __v + -.2500068) * __v + .3333333) * __v + -.5) - __del;
                __py = .3989423 / std::__1::sqrt(__tx);
            }
            double __r = (0.5 - __difmuk) / __pr.__s_;
            double __r2 = __r * __r;
            double __fx = -0.5 * __r2;
            double __fy = __pr.__omega_ * (((__pr.__c3_ * __r2 + __pr.__c2_) *
                                        __r2 + __pr.__c1_) * __r2 + __pr.__c0_);
            if (__using_exp_dist)
            {
                if (__pr.__c_ * std::__1::abs(__u) <= __py * std::__1::exp(__px + __e) -
                                                   __fy * std::__1::exp(__fx + __e))
                    break;
            }
            else
            {
                if (__fy - __u * __fy <= __py * std::__1::exp(__px - __fx))
                    break;
            }
        }
    }
    return std::__1::__clamp_to_integral<result_type>(__tx);
}

template <class _CharT, class _Traits, class _IntType>
basic_ostream<_CharT, _Traits>&
operator<<(basic_ostream<_CharT, _Traits>& __os,
           const poisson_distribution<_IntType>& __x)
{
    __save_flags<_CharT, _Traits> __lx(__os);
    typedef basic_ostream<_CharT, _Traits> _OStream;
    __os.flags(_OStream::dec | _OStream::left | _OStream::fixed |
               _OStream::scientific);
    return __os << __x.mean();
}

template <class _CharT, class _Traits, class _IntType>
basic_istream<_CharT, _Traits>&
operator>>(basic_istream<_CharT, _Traits>& __is,
           poisson_distribution<_IntType>& __x)
{
    typedef poisson_distribution<_IntType> _Eng;
    typedef typename _Eng::param_type param_type;
    __save_flags<_CharT, _Traits> __lx(__is);
    typedef basic_istream<_CharT, _Traits> _Istream;
    __is.flags(_Istream::dec | _Istream::skipws);
    double __mean;
    __is >> __mean;
    if (!__is.fail())
        __x.param(param_type(__mean));
    return __is;
}



template<class _RealType = double>
class __attribute__ ((__type_visibility__("default"))) weibull_distribution
{
public:

    typedef _RealType result_type;

    class __attribute__ ((__type_visibility__("default"))) param_type
    {
        result_type __a_;
        result_type __b_;
    public:
        typedef weibull_distribution distribution_type;

        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        explicit param_type(result_type __a = 1, result_type __b = 1)
            : __a_(__a), __b_(__b) {}

        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        result_type a() const {return __a_;}
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        result_type b() const {return __b_;}

        friend __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
            bool operator==(const param_type& __x, const param_type& __y)
            {return __x.__a_ == __y.__a_ && __x.__b_ == __y.__b_;}
        friend __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
            bool operator!=(const param_type& __x, const param_type& __y)
            {return !(__x == __y);}
    };

private:
    param_type __p_;

public:


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    weibull_distribution() : weibull_distribution(1) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit weibull_distribution(result_type __a, result_type __b = 1)
        : __p_(param_type(__a, __b)) {}





    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit weibull_distribution(const param_type& __p)
        : __p_(__p) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void reset() {}


    template<class _URNG>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        result_type operator()(_URNG& __g)
        {return (*this)(__g, __p_);}
    template<class _URNG>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        result_type operator()(_URNG& __g, const param_type& __p)
        {return __p.b() *
            std::__1::pow(exponential_distribution<result_type>()(__g), 1/__p.a());}


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    result_type a() const {return __p_.a();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    result_type b() const {return __p_.b();}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    param_type param() const {return __p_;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void param(const param_type& __p) {__p_ = __p;}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    result_type min() const {return 0;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    result_type max() const {return numeric_limits<result_type>::infinity();}

    friend __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        bool operator==(const weibull_distribution& __x,
                        const weibull_distribution& __y)
        {return __x.__p_ == __y.__p_;}
    friend __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        bool operator!=(const weibull_distribution& __x,
                        const weibull_distribution& __y)
        {return !(__x == __y);}
};

template <class _CharT, class _Traits, class _RT>
basic_ostream<_CharT, _Traits>&
operator<<(basic_ostream<_CharT, _Traits>& __os,
           const weibull_distribution<_RT>& __x)
{
    __save_flags<_CharT, _Traits> __lx(__os);
    typedef basic_ostream<_CharT, _Traits> _OStream;
    __os.flags(_OStream::dec | _OStream::left | _OStream::fixed |
               _OStream::scientific);
    _CharT __sp = __os.widen(' ');
    __os.fill(__sp);
    __os << __x.a() << __sp << __x.b();
    return __os;
}

template <class _CharT, class _Traits, class _RT>
basic_istream<_CharT, _Traits>&
operator>>(basic_istream<_CharT, _Traits>& __is,
           weibull_distribution<_RT>& __x)
{
    typedef weibull_distribution<_RT> _Eng;
    typedef typename _Eng::result_type result_type;
    typedef typename _Eng::param_type param_type;
    __save_flags<_CharT, _Traits> __lx(__is);
    typedef basic_istream<_CharT, _Traits> _Istream;
    __is.flags(_Istream::dec | _Istream::skipws);
    result_type __a;
    result_type __b;
    __is >> __a >> __b;
    if (!__is.fail())
        __x.param(param_type(__a, __b));
    return __is;
}

template<class _RealType = double>
class __attribute__ ((__type_visibility__("default"))) extreme_value_distribution
{
public:

    typedef _RealType result_type;

    class __attribute__ ((__type_visibility__("default"))) param_type
    {
        result_type __a_;
        result_type __b_;
    public:
        typedef extreme_value_distribution distribution_type;

        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        explicit param_type(result_type __a = 0, result_type __b = 1)
            : __a_(__a), __b_(__b) {}

        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        result_type a() const {return __a_;}
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        result_type b() const {return __b_;}

        friend __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
            bool operator==(const param_type& __x, const param_type& __y)
            {return __x.__a_ == __y.__a_ && __x.__b_ == __y.__b_;}
        friend __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
            bool operator!=(const param_type& __x, const param_type& __y)
            {return !(__x == __y);}
    };

private:
    param_type __p_;

public:


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    extreme_value_distribution() : extreme_value_distribution(0) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit extreme_value_distribution(result_type __a, result_type __b = 1)
        : __p_(param_type(__a, __b)) {}






    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit extreme_value_distribution(const param_type& __p)
        : __p_(__p) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void reset() {}


    template<class _URNG>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        result_type operator()(_URNG& __g)
        {return (*this)(__g, __p_);}
    template<class _URNG> result_type operator()(_URNG& __g, const param_type& __p);


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    result_type a() const {return __p_.a();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    result_type b() const {return __p_.b();}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    param_type param() const {return __p_;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void param(const param_type& __p) {__p_ = __p;}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    result_type min() const {return -numeric_limits<result_type>::infinity();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    result_type max() const {return numeric_limits<result_type>::infinity();}

    friend __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        bool operator==(const extreme_value_distribution& __x,
                        const extreme_value_distribution& __y)
        {return __x.__p_ == __y.__p_;}
    friend __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        bool operator!=(const extreme_value_distribution& __x,
                        const extreme_value_distribution& __y)
        {return !(__x == __y);}
};

template<class _RealType>
template<class _URNG>
_RealType
extreme_value_distribution<_RealType>::operator()(_URNG& __g, const param_type& __p)
{
    return __p.a() - __p.b() *
         std::__1::log(-std::__1::log(1-uniform_real_distribution<result_type>()(__g)));
}

template <class _CharT, class _Traits, class _RT>
basic_ostream<_CharT, _Traits>&
operator<<(basic_ostream<_CharT, _Traits>& __os,
           const extreme_value_distribution<_RT>& __x)
{
    __save_flags<_CharT, _Traits> __lx(__os);
    typedef basic_ostream<_CharT, _Traits> _OStream;
    __os.flags(_OStream::dec | _OStream::left | _OStream::fixed |
               _OStream::scientific);
    _CharT __sp = __os.widen(' ');
    __os.fill(__sp);
    __os << __x.a() << __sp << __x.b();
    return __os;
}

template <class _CharT, class _Traits, class _RT>
basic_istream<_CharT, _Traits>&
operator>>(basic_istream<_CharT, _Traits>& __is,
           extreme_value_distribution<_RT>& __x)
{
    typedef extreme_value_distribution<_RT> _Eng;
    typedef typename _Eng::result_type result_type;
    typedef typename _Eng::param_type param_type;
    __save_flags<_CharT, _Traits> __lx(__is);
    typedef basic_istream<_CharT, _Traits> _Istream;
    __is.flags(_Istream::dec | _Istream::skipws);
    result_type __a;
    result_type __b;
    __is >> __a >> __b;
    if (!__is.fail())
        __x.param(param_type(__a, __b));
    return __is;
}



template<class _RealType = double>
class __attribute__ ((__type_visibility__("default"))) gamma_distribution
{
public:

    typedef _RealType result_type;

    class __attribute__ ((__type_visibility__("default"))) param_type
    {
        result_type __alpha_;
        result_type __beta_;
    public:
        typedef gamma_distribution distribution_type;

        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        explicit param_type(result_type __alpha = 1, result_type __beta = 1)
            : __alpha_(__alpha), __beta_(__beta) {}

        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        result_type alpha() const {return __alpha_;}
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        result_type beta() const {return __beta_;}

        friend __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
            bool operator==(const param_type& __x, const param_type& __y)
            {return __x.__alpha_ == __y.__alpha_ && __x.__beta_ == __y.__beta_;}
        friend __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
            bool operator!=(const param_type& __x, const param_type& __y)
            {return !(__x == __y);}
    };

private:
    param_type __p_;

public:


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    gamma_distribution() : gamma_distribution(1) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit gamma_distribution(result_type __alpha, result_type __beta = 1)
        : __p_(param_type(__alpha, __beta)) {}






    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit gamma_distribution(const param_type& __p)
        : __p_(__p) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void reset() {}


    template<class _URNG>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        result_type operator()(_URNG& __g)
        {return (*this)(__g, __p_);}
    template<class _URNG> result_type operator()(_URNG& __g, const param_type& __p);


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    result_type alpha() const {return __p_.alpha();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    result_type beta() const {return __p_.beta();}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    param_type param() const {return __p_;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void param(const param_type& __p) {__p_ = __p;}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    result_type min() const {return 0;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    result_type max() const {return numeric_limits<result_type>::infinity();}

    friend __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        bool operator==(const gamma_distribution& __x,
                        const gamma_distribution& __y)
        {return __x.__p_ == __y.__p_;}
    friend __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        bool operator!=(const gamma_distribution& __x,
                        const gamma_distribution& __y)
        {return !(__x == __y);}
};

template <class _RealType>
template<class _URNG>
_RealType
gamma_distribution<_RealType>::operator()(_URNG& __g, const param_type& __p)
{
    result_type __a = __p.alpha();
    uniform_real_distribution<result_type> __gen(0, 1);
    exponential_distribution<result_type> __egen;
    result_type __x;
    if (__a == 1)
        __x = __egen(__g);
    else if (__a > 1)
    {
        const result_type __b = __a - 1;
        const result_type __c = 3 * __a - result_type(0.75);
        while (true)
        {
            const result_type __u = __gen(__g);
            const result_type __v = __gen(__g);
            const result_type __w = __u * (1 - __u);
            if (__w != 0)
            {
                const result_type __y = std::__1::sqrt(__c / __w) *
                                        (__u - result_type(0.5));
                __x = __b + __y;
                if (__x >= 0)
                {
                    const result_type __z = 64 * __w * __w * __w * __v * __v;
                    if (__z <= 1 - 2 * __y * __y / __x)
                        break;
                    if (std::__1::log(__z) <= 2 * (__b * std::__1::log(__x / __b) - __y))
                        break;
                }
            }
        }
    }
    else
    {
        while (true)
        {
            const result_type __u = __gen(__g);
            const result_type __es = __egen(__g);
            if (__u <= 1 - __a)
            {
                __x = std::__1::pow(__u, 1 / __a);
                if (__x <= __es)
                    break;
            }
            else
            {
                const result_type __e = -std::__1::log((1-__u)/__a);
                __x = std::__1::pow(1 - __a + __a * __e, 1 / __a);
                if (__x <= __e + __es)
                    break;
            }
        }
    }
    return __x * __p.beta();
}

template <class _CharT, class _Traits, class _RT>
basic_ostream<_CharT, _Traits>&
operator<<(basic_ostream<_CharT, _Traits>& __os,
           const gamma_distribution<_RT>& __x)
{
    __save_flags<_CharT, _Traits> __lx(__os);
    typedef basic_ostream<_CharT, _Traits> _OStream;
    __os.flags(_OStream::dec | _OStream::left | _OStream::fixed |
               _OStream::scientific);
    _CharT __sp = __os.widen(' ');
    __os.fill(__sp);
    __os << __x.alpha() << __sp << __x.beta();
    return __os;
}

template <class _CharT, class _Traits, class _RT>
basic_istream<_CharT, _Traits>&
operator>>(basic_istream<_CharT, _Traits>& __is,
           gamma_distribution<_RT>& __x)
{
    typedef gamma_distribution<_RT> _Eng;
    typedef typename _Eng::result_type result_type;
    typedef typename _Eng::param_type param_type;
    __save_flags<_CharT, _Traits> __lx(__is);
    typedef basic_istream<_CharT, _Traits> _Istream;
    __is.flags(_Istream::dec | _Istream::skipws);
    result_type __alpha;
    result_type __beta;
    __is >> __alpha >> __beta;
    if (!__is.fail())
        __x.param(param_type(__alpha, __beta));
    return __is;
}



template<class _IntType = int>
class __attribute__ ((__type_visibility__("default"))) negative_binomial_distribution
{
public:

    typedef _IntType result_type;

    class __attribute__ ((__type_visibility__("default"))) param_type
    {
        result_type __k_;
        double __p_;
    public:
        typedef negative_binomial_distribution distribution_type;

        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        explicit param_type(result_type __k = 1, double __p = 0.5)
            : __k_(__k), __p_(__p) {}

        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        result_type k() const {return __k_;}
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        double p() const {return __p_;}

        friend __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
            bool operator==(const param_type& __x, const param_type& __y)
            {return __x.__k_ == __y.__k_ && __x.__p_ == __y.__p_;}
        friend __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
            bool operator!=(const param_type& __x, const param_type& __y)
            {return !(__x == __y);}
    };

private:
    param_type __p_;

public:


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    negative_binomial_distribution() : negative_binomial_distribution(1) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit negative_binomial_distribution(result_type __k, double __p = 0.5)
        : __p_(__k, __p) {}






    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit negative_binomial_distribution(const param_type& __p) : __p_(__p) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void reset() {}


    template<class _URNG>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        result_type operator()(_URNG& __g)
        {return (*this)(__g, __p_);}
    template<class _URNG> result_type operator()(_URNG& __g, const param_type& __p);


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    result_type k() const {return __p_.k();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    double p() const {return __p_.p();}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    param_type param() const {return __p_;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void param(const param_type& __p) {__p_ = __p;}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    result_type min() const {return 0;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    result_type max() const {return numeric_limits<result_type>::max();}

    friend __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        bool operator==(const negative_binomial_distribution& __x,
                        const negative_binomial_distribution& __y)
        {return __x.__p_ == __y.__p_;}
    friend __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        bool operator!=(const negative_binomial_distribution& __x,
                        const negative_binomial_distribution& __y)
        {return !(__x == __y);}
};

template <class _IntType>
template<class _URNG>
_IntType
negative_binomial_distribution<_IntType>::operator()(_URNG& __urng, const param_type& __pr)
{
    result_type __k = __pr.k();
    double __p = __pr.p();
    if (__k <= 21 * __p)
    {
        bernoulli_distribution __gen(__p);
        result_type __f = 0;
        result_type __s = 0;
        while (__s < __k)
        {
            if (__gen(__urng))
                ++__s;
            else
                ++__f;
        }
        return __f;
    }
    return poisson_distribution<result_type>(gamma_distribution<double>
                                            (__k, (1-__p)/__p)(__urng))(__urng);
}

template <class _CharT, class _Traits, class _IntType>
basic_ostream<_CharT, _Traits>&
operator<<(basic_ostream<_CharT, _Traits>& __os,
           const negative_binomial_distribution<_IntType>& __x)
{
    __save_flags<_CharT, _Traits> __lx(__os);
    typedef basic_ostream<_CharT, _Traits> _OStream;
    __os.flags(_OStream::dec | _OStream::left | _OStream::fixed |
               _OStream::scientific);
    _CharT __sp = __os.widen(' ');
    __os.fill(__sp);
    return __os << __x.k() << __sp << __x.p();
}

template <class _CharT, class _Traits, class _IntType>
basic_istream<_CharT, _Traits>&
operator>>(basic_istream<_CharT, _Traits>& __is,
           negative_binomial_distribution<_IntType>& __x)
{
    typedef negative_binomial_distribution<_IntType> _Eng;
    typedef typename _Eng::result_type result_type;
    typedef typename _Eng::param_type param_type;
    __save_flags<_CharT, _Traits> __lx(__is);
    typedef basic_istream<_CharT, _Traits> _Istream;
    __is.flags(_Istream::dec | _Istream::skipws);
    result_type __k;
    double __p;
    __is >> __k >> __p;
    if (!__is.fail())
        __x.param(param_type(__k, __p));
    return __is;
}



template<class _IntType = int>
class __attribute__ ((__type_visibility__("default"))) geometric_distribution
{
public:

    typedef _IntType result_type;

    class __attribute__ ((__type_visibility__("default"))) param_type
    {
        double __p_;
    public:
        typedef geometric_distribution distribution_type;

        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        explicit param_type(double __p = 0.5) : __p_(__p) {}

        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        double p() const {return __p_;}

        friend __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
            bool operator==(const param_type& __x, const param_type& __y)
            {return __x.__p_ == __y.__p_;}
        friend __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
            bool operator!=(const param_type& __x, const param_type& __y)
            {return !(__x == __y);}
    };

private:
    param_type __p_;

public:


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    geometric_distribution() : geometric_distribution(0.5) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit geometric_distribution(double __p)
        : __p_(__p) {}





    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit geometric_distribution(const param_type& __p) : __p_(__p) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void reset() {}


    template<class _URNG>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        result_type operator()(_URNG& __g)
        {return (*this)(__g, __p_);}
    template<class _URNG>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        result_type operator()(_URNG& __g, const param_type& __p)
        {return negative_binomial_distribution<result_type>(1, __p.p())(__g);}


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    double p() const {return __p_.p();}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    param_type param() const {return __p_;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void param(const param_type& __p) {__p_ = __p;}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    result_type min() const {return 0;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    result_type max() const {return numeric_limits<result_type>::max();}

    friend __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        bool operator==(const geometric_distribution& __x,
                        const geometric_distribution& __y)
        {return __x.__p_ == __y.__p_;}
    friend __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        bool operator!=(const geometric_distribution& __x,
                        const geometric_distribution& __y)
        {return !(__x == __y);}
};

template <class _CharT, class _Traits, class _IntType>
basic_ostream<_CharT, _Traits>&
operator<<(basic_ostream<_CharT, _Traits>& __os,
           const geometric_distribution<_IntType>& __x)
{
    __save_flags<_CharT, _Traits> __lx(__os);
    typedef basic_ostream<_CharT, _Traits> _OStream;
    __os.flags(_OStream::dec | _OStream::left | _OStream::fixed |
               _OStream::scientific);
    return __os << __x.p();
}

template <class _CharT, class _Traits, class _IntType>
basic_istream<_CharT, _Traits>&
operator>>(basic_istream<_CharT, _Traits>& __is,
           geometric_distribution<_IntType>& __x)
{
    typedef geometric_distribution<_IntType> _Eng;
    typedef typename _Eng::param_type param_type;
    __save_flags<_CharT, _Traits> __lx(__is);
    typedef basic_istream<_CharT, _Traits> _Istream;
    __is.flags(_Istream::dec | _Istream::skipws);
    double __p;
    __is >> __p;
    if (!__is.fail())
        __x.param(param_type(__p));
    return __is;
}



template<class _RealType = double>
class __attribute__ ((__type_visibility__("default"))) chi_squared_distribution
{
public:

    typedef _RealType result_type;

    class __attribute__ ((__type_visibility__("default"))) param_type
    {
        result_type __n_;
    public:
        typedef chi_squared_distribution distribution_type;

        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        explicit param_type(result_type __n = 1) : __n_(__n) {}

        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        result_type n() const {return __n_;}

        friend __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
            bool operator==(const param_type& __x, const param_type& __y)
            {return __x.__n_ == __y.__n_;}
        friend __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
            bool operator!=(const param_type& __x, const param_type& __y)
            {return !(__x == __y);}
    };

private:
    param_type __p_;

public:


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    chi_squared_distribution() : chi_squared_distribution(1) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit chi_squared_distribution(result_type __n)
        : __p_(param_type(__n)) {}





    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit chi_squared_distribution(const param_type& __p)
        : __p_(__p) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void reset() {}


    template<class _URNG>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        result_type operator()(_URNG& __g)
        {return (*this)(__g, __p_);}
    template<class _URNG>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        result_type operator()(_URNG& __g, const param_type& __p)
        {return gamma_distribution<result_type>(__p.n() / 2, 2)(__g);}


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    result_type n() const {return __p_.n();}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    param_type param() const {return __p_;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void param(const param_type& __p) {__p_ = __p;}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    result_type min() const {return 0;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    result_type max() const {return numeric_limits<result_type>::infinity();}

    friend __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        bool operator==(const chi_squared_distribution& __x,
                        const chi_squared_distribution& __y)
        {return __x.__p_ == __y.__p_;}
    friend __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        bool operator!=(const chi_squared_distribution& __x,
                        const chi_squared_distribution& __y)
        {return !(__x == __y);}
};

template <class _CharT, class _Traits, class _RT>
basic_ostream<_CharT, _Traits>&
operator<<(basic_ostream<_CharT, _Traits>& __os,
           const chi_squared_distribution<_RT>& __x)
{
    __save_flags<_CharT, _Traits> __lx(__os);
    typedef basic_ostream<_CharT, _Traits> _OStream;
    __os.flags(_OStream::dec | _OStream::left | _OStream::fixed |
               _OStream::scientific);
    __os << __x.n();
    return __os;
}

template <class _CharT, class _Traits, class _RT>
basic_istream<_CharT, _Traits>&
operator>>(basic_istream<_CharT, _Traits>& __is,
           chi_squared_distribution<_RT>& __x)
{
    typedef chi_squared_distribution<_RT> _Eng;
    typedef typename _Eng::result_type result_type;
    typedef typename _Eng::param_type param_type;
    __save_flags<_CharT, _Traits> __lx(__is);
    typedef basic_istream<_CharT, _Traits> _Istream;
    __is.flags(_Istream::dec | _Istream::skipws);
    result_type __n;
    __is >> __n;
    if (!__is.fail())
        __x.param(param_type(__n));
    return __is;
}



template<class _RealType = double>
class __attribute__ ((__type_visibility__("default"))) cauchy_distribution
{
public:

    typedef _RealType result_type;

    class __attribute__ ((__type_visibility__("default"))) param_type
    {
        result_type __a_;
        result_type __b_;
    public:
        typedef cauchy_distribution distribution_type;

        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        explicit param_type(result_type __a = 0, result_type __b = 1)
            : __a_(__a), __b_(__b) {}

        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        result_type a() const {return __a_;}
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        result_type b() const {return __b_;}

        friend __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
            bool operator==(const param_type& __x, const param_type& __y)
            {return __x.__a_ == __y.__a_ && __x.__b_ == __y.__b_;}
        friend __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
            bool operator!=(const param_type& __x, const param_type& __y)
            {return !(__x == __y);}
    };

private:
    param_type __p_;

public:


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    cauchy_distribution() : cauchy_distribution(0) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit cauchy_distribution(result_type __a, result_type __b = 1)
        : __p_(param_type(__a, __b)) {}





    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit cauchy_distribution(const param_type& __p)
        : __p_(__p) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void reset() {}


    template<class _URNG>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        result_type operator()(_URNG& __g)
        {return (*this)(__g, __p_);}
    template<class _URNG> __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) result_type operator()(_URNG& __g, const param_type& __p);


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    result_type a() const {return __p_.a();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    result_type b() const {return __p_.b();}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    param_type param() const {return __p_;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void param(const param_type& __p) {__p_ = __p;}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    result_type min() const {return -numeric_limits<result_type>::infinity();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    result_type max() const {return numeric_limits<result_type>::infinity();}

    friend __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        bool operator==(const cauchy_distribution& __x,
                        const cauchy_distribution& __y)
        {return __x.__p_ == __y.__p_;}
    friend __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        bool operator!=(const cauchy_distribution& __x,
                        const cauchy_distribution& __y)
        {return !(__x == __y);}
};

template <class _RealType>
template<class _URNG>
inline
_RealType
cauchy_distribution<_RealType>::operator()(_URNG& __g, const param_type& __p)
{
    uniform_real_distribution<result_type> __gen;

    return __p.a() + __p.b() * std::__1::tan(3.1415926535897932384626433832795 * __gen(__g));
}

template <class _CharT, class _Traits, class _RT>
basic_ostream<_CharT, _Traits>&
operator<<(basic_ostream<_CharT, _Traits>& __os,
           const cauchy_distribution<_RT>& __x)
{
    __save_flags<_CharT, _Traits> __lx(__os);
    typedef basic_ostream<_CharT, _Traits> _OStream;
    __os.flags(_OStream::dec | _OStream::left | _OStream::fixed |
               _OStream::scientific);
    _CharT __sp = __os.widen(' ');
    __os.fill(__sp);
    __os << __x.a() << __sp << __x.b();
    return __os;
}

template <class _CharT, class _Traits, class _RT>
basic_istream<_CharT, _Traits>&
operator>>(basic_istream<_CharT, _Traits>& __is,
           cauchy_distribution<_RT>& __x)
{
    typedef cauchy_distribution<_RT> _Eng;
    typedef typename _Eng::result_type result_type;
    typedef typename _Eng::param_type param_type;
    __save_flags<_CharT, _Traits> __lx(__is);
    typedef basic_istream<_CharT, _Traits> _Istream;
    __is.flags(_Istream::dec | _Istream::skipws);
    result_type __a;
    result_type __b;
    __is >> __a >> __b;
    if (!__is.fail())
        __x.param(param_type(__a, __b));
    return __is;
}



template<class _RealType = double>
class __attribute__ ((__type_visibility__("default"))) fisher_f_distribution
{
public:

    typedef _RealType result_type;

    class __attribute__ ((__type_visibility__("default"))) param_type
    {
        result_type __m_;
        result_type __n_;
    public:
        typedef fisher_f_distribution distribution_type;

        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        explicit param_type(result_type __m = 1, result_type __n = 1)
            : __m_(__m), __n_(__n) {}

        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        result_type m() const {return __m_;}
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        result_type n() const {return __n_;}

        friend __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
            bool operator==(const param_type& __x, const param_type& __y)
            {return __x.__m_ == __y.__m_ && __x.__n_ == __y.__n_;}
        friend __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
            bool operator!=(const param_type& __x, const param_type& __y)
            {return !(__x == __y);}
    };

private:
    param_type __p_;

public:


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    fisher_f_distribution() : fisher_f_distribution(1) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit fisher_f_distribution(result_type __m, result_type __n = 1)
        : __p_(param_type(__m, __n)) {}





    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit fisher_f_distribution(const param_type& __p)
        : __p_(__p) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void reset() {}


    template<class _URNG>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        result_type operator()(_URNG& __g)
        {return (*this)(__g, __p_);}
    template<class _URNG> result_type operator()(_URNG& __g, const param_type& __p);


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    result_type m() const {return __p_.m();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    result_type n() const {return __p_.n();}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    param_type param() const {return __p_;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void param(const param_type& __p) {__p_ = __p;}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    result_type min() const {return 0;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    result_type max() const {return numeric_limits<result_type>::infinity();}

    friend __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        bool operator==(const fisher_f_distribution& __x,
                        const fisher_f_distribution& __y)
        {return __x.__p_ == __y.__p_;}
    friend __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        bool operator!=(const fisher_f_distribution& __x,
                        const fisher_f_distribution& __y)
        {return !(__x == __y);}
};

template <class _RealType>
template<class _URNG>
_RealType
fisher_f_distribution<_RealType>::operator()(_URNG& __g, const param_type& __p)
{
    gamma_distribution<result_type> __gdm(__p.m() * result_type(.5));
    gamma_distribution<result_type> __gdn(__p.n() * result_type(.5));
    return __p.n() * __gdm(__g) / (__p.m() * __gdn(__g));
}

template <class _CharT, class _Traits, class _RT>
basic_ostream<_CharT, _Traits>&
operator<<(basic_ostream<_CharT, _Traits>& __os,
           const fisher_f_distribution<_RT>& __x)
{
    __save_flags<_CharT, _Traits> __lx(__os);
    typedef basic_ostream<_CharT, _Traits> _OStream;
    __os.flags(_OStream::dec | _OStream::left | _OStream::fixed |
               _OStream::scientific);
    _CharT __sp = __os.widen(' ');
    __os.fill(__sp);
    __os << __x.m() << __sp << __x.n();
    return __os;
}

template <class _CharT, class _Traits, class _RT>
basic_istream<_CharT, _Traits>&
operator>>(basic_istream<_CharT, _Traits>& __is,
           fisher_f_distribution<_RT>& __x)
{
    typedef fisher_f_distribution<_RT> _Eng;
    typedef typename _Eng::result_type result_type;
    typedef typename _Eng::param_type param_type;
    __save_flags<_CharT, _Traits> __lx(__is);
    typedef basic_istream<_CharT, _Traits> _Istream;
    __is.flags(_Istream::dec | _Istream::skipws);
    result_type __m;
    result_type __n;
    __is >> __m >> __n;
    if (!__is.fail())
        __x.param(param_type(__m, __n));
    return __is;
}



template<class _RealType = double>
class __attribute__ ((__type_visibility__("default"))) student_t_distribution
{
public:

    typedef _RealType result_type;

    class __attribute__ ((__type_visibility__("default"))) param_type
    {
        result_type __n_;
    public:
        typedef student_t_distribution distribution_type;

        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        explicit param_type(result_type __n = 1) : __n_(__n) {}

        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        result_type n() const {return __n_;}

        friend __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
            bool operator==(const param_type& __x, const param_type& __y)
            {return __x.__n_ == __y.__n_;}
        friend __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
            bool operator!=(const param_type& __x, const param_type& __y)
            {return !(__x == __y);}
    };

private:
    param_type __p_;
    normal_distribution<result_type> __nd_;

public:


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    student_t_distribution() : student_t_distribution(1) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit student_t_distribution(result_type __n)
        : __p_(param_type(__n)) {}





    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit student_t_distribution(const param_type& __p)
        : __p_(__p) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void reset() {__nd_.reset();}


    template<class _URNG>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        result_type operator()(_URNG& __g)
        {return (*this)(__g, __p_);}
    template<class _URNG> result_type operator()(_URNG& __g, const param_type& __p);


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    result_type n() const {return __p_.n();}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    param_type param() const {return __p_;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void param(const param_type& __p) {__p_ = __p;}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    result_type min() const {return -numeric_limits<result_type>::infinity();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    result_type max() const {return numeric_limits<result_type>::infinity();}

    friend __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        bool operator==(const student_t_distribution& __x,
                        const student_t_distribution& __y)
        {return __x.__p_ == __y.__p_;}
    friend __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        bool operator!=(const student_t_distribution& __x,
                        const student_t_distribution& __y)
        {return !(__x == __y);}
};

template <class _RealType>
template<class _URNG>
_RealType
student_t_distribution<_RealType>::operator()(_URNG& __g, const param_type& __p)
{
    gamma_distribution<result_type> __gd(__p.n() * .5, 2);
    return __nd_(__g) * std::__1::sqrt(__p.n()/__gd(__g));
}

template <class _CharT, class _Traits, class _RT>
basic_ostream<_CharT, _Traits>&
operator<<(basic_ostream<_CharT, _Traits>& __os,
           const student_t_distribution<_RT>& __x)
{
    __save_flags<_CharT, _Traits> __lx(__os);
    typedef basic_ostream<_CharT, _Traits> _OStream;
    __os.flags(_OStream::dec | _OStream::left | _OStream::fixed |
               _OStream::scientific);
    __os << __x.n();
    return __os;
}

template <class _CharT, class _Traits, class _RT>
basic_istream<_CharT, _Traits>&
operator>>(basic_istream<_CharT, _Traits>& __is,
           student_t_distribution<_RT>& __x)
{
    typedef student_t_distribution<_RT> _Eng;
    typedef typename _Eng::result_type result_type;
    typedef typename _Eng::param_type param_type;
    __save_flags<_CharT, _Traits> __lx(__is);
    typedef basic_istream<_CharT, _Traits> _Istream;
    __is.flags(_Istream::dec | _Istream::skipws);
    result_type __n;
    __is >> __n;
    if (!__is.fail())
        __x.param(param_type(__n));
    return __is;
}



template<class _IntType = int>
class __attribute__ ((__type_visibility__("default"))) discrete_distribution
{
public:

    typedef _IntType result_type;

    class __attribute__ ((__type_visibility__("default"))) param_type
    {
        vector<double> __p_;
    public:
        typedef discrete_distribution distribution_type;

        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        param_type() {}
        template<class _InputIterator>
            __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
            param_type(_InputIterator __f, _InputIterator __l)
            : __p_(__f, __l) {__init();}

        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        param_type(initializer_list<double> __wl)
            : __p_(__wl.begin(), __wl.end()) {__init();}

        template<class _UnaryOperation>
            param_type(size_t __nw, double __xmin, double __xmax,
                       _UnaryOperation __fw);

        vector<double> probabilities() const;

        friend __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
            bool operator==(const param_type& __x, const param_type& __y)
            {return __x.__p_ == __y.__p_;}
        friend __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
            bool operator!=(const param_type& __x, const param_type& __y)
            {return !(__x == __y);}

    private:
        void __init();

        friend class discrete_distribution;

        template <class _CharT, class _Traits, class _IT>
        friend
        basic_ostream<_CharT, _Traits>&
        operator<<(basic_ostream<_CharT, _Traits>& __os,
                   const discrete_distribution<_IT>& __x);

        template <class _CharT, class _Traits, class _IT>
        friend
        basic_istream<_CharT, _Traits>&
        operator>>(basic_istream<_CharT, _Traits>& __is,
                   discrete_distribution<_IT>& __x);
    };

private:
    param_type __p_;

public:

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    discrete_distribution() {}
    template<class _InputIterator>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        discrete_distribution(_InputIterator __f, _InputIterator __l)
            : __p_(__f, __l) {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    discrete_distribution(initializer_list<double> __wl)
        : __p_(__wl) {}

    template<class _UnaryOperation>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        discrete_distribution(size_t __nw, double __xmin, double __xmax,
                              _UnaryOperation __fw)
        : __p_(__nw, __xmin, __xmax, __fw) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit discrete_distribution(const param_type& __p)
        : __p_(__p) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void reset() {}


    template<class _URNG>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        result_type operator()(_URNG& __g)
        {return (*this)(__g, __p_);}
    template<class _URNG> result_type operator()(_URNG& __g, const param_type& __p);


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    vector<double> probabilities() const {return __p_.probabilities();}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    param_type param() const {return __p_;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void param(const param_type& __p) {__p_ = __p;}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    result_type min() const {return 0;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    result_type max() const {return __p_.__p_.size();}

    friend __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        bool operator==(const discrete_distribution& __x,
                        const discrete_distribution& __y)
        {return __x.__p_ == __y.__p_;}
    friend __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        bool operator!=(const discrete_distribution& __x,
                        const discrete_distribution& __y)
        {return !(__x == __y);}

    template <class _CharT, class _Traits, class _IT>
    friend
    basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __os,
               const discrete_distribution<_IT>& __x);

    template <class _CharT, class _Traits, class _IT>
    friend
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __is,
               discrete_distribution<_IT>& __x);
};

template<class _IntType>
template<class _UnaryOperation>
discrete_distribution<_IntType>::param_type::param_type(size_t __nw,
                                                        double __xmin,
                                                        double __xmax,
                                                        _UnaryOperation __fw)
{
    if (__nw > 1)
    {
        __p_.reserve(__nw - 1);
        double __d = (__xmax - __xmin) / __nw;
        double __d2 = __d / 2;
        for (size_t __k = 0; __k < __nw; ++__k)
            __p_.push_back(__fw(__xmin + __k * __d + __d2));
        __init();
    }
}

template<class _IntType>
void
discrete_distribution<_IntType>::param_type::__init()
{
    if (!__p_.empty())
    {
        if (__p_.size() > 1)
        {
            double __s = std::__1::accumulate(__p_.begin(), __p_.end(), 0.0);
            for (vector<double>::iterator __i = __p_.begin(), __e = __p_.end(); __i < __e; ++__i)
                *__i /= __s;
            vector<double> __t(__p_.size() - 1);
            std::__1::partial_sum(__p_.begin(), __p_.end() - 1, __t.begin());
            swap(__p_, __t);
        }
        else
        {
            __p_.clear();
            __p_.shrink_to_fit();
        }
    }
}

template<class _IntType>
vector<double>
discrete_distribution<_IntType>::param_type::probabilities() const
{
    size_t __n = __p_.size();
    vector<double> __p(__n+1);
    std::__1::adjacent_difference(__p_.begin(), __p_.end(), __p.begin());
    if (__n > 0)
        __p[__n] = 1 - __p_[__n-1];
    else
        __p[0] = 1;
    return __p;
}

template<class _IntType>
template<class _URNG>
_IntType
discrete_distribution<_IntType>::operator()(_URNG& __g, const param_type& __p)
{
    uniform_real_distribution<double> __gen;
    return static_cast<_IntType>(
           std::__1::upper_bound(__p.__p_.begin(), __p.__p_.end(), __gen(__g)) -
                                                              __p.__p_.begin());
}

template <class _CharT, class _Traits, class _IT>
basic_ostream<_CharT, _Traits>&
operator<<(basic_ostream<_CharT, _Traits>& __os,
           const discrete_distribution<_IT>& __x)
{
    __save_flags<_CharT, _Traits> __lx(__os);
    typedef basic_ostream<_CharT, _Traits> _OStream;
    __os.flags(_OStream::dec | _OStream::left | _OStream::fixed |
               _OStream::scientific);
    _CharT __sp = __os.widen(' ');
    __os.fill(__sp);
    size_t __n = __x.__p_.__p_.size();
    __os << __n;
    for (size_t __i = 0; __i < __n; ++__i)
        __os << __sp << __x.__p_.__p_[__i];
    return __os;
}

template <class _CharT, class _Traits, class _IT>
basic_istream<_CharT, _Traits>&
operator>>(basic_istream<_CharT, _Traits>& __is,
           discrete_distribution<_IT>& __x)
{
    __save_flags<_CharT, _Traits> __lx(__is);
    typedef basic_istream<_CharT, _Traits> _Istream;
    __is.flags(_Istream::dec | _Istream::skipws);
    size_t __n;
    __is >> __n;
    vector<double> __p(__n);
    for (size_t __i = 0; __i < __n; ++__i)
        __is >> __p[__i];
    if (!__is.fail())
        swap(__x.__p_.__p_, __p);
    return __is;
}



template<class _RealType = double>
class __attribute__ ((__type_visibility__("default"))) piecewise_constant_distribution
{
public:

    typedef _RealType result_type;

    class __attribute__ ((__type_visibility__("default"))) param_type
    {
        vector<result_type> __b_;
        vector<result_type> __densities_;
        vector<result_type> __areas_;
    public:
        typedef piecewise_constant_distribution distribution_type;

        param_type();
        template<class _InputIteratorB, class _InputIteratorW>
            param_type(_InputIteratorB __fB, _InputIteratorB __lB,
                       _InputIteratorW __fW);

        template<class _UnaryOperation>
            param_type(initializer_list<result_type> __bl, _UnaryOperation __fw);

        template<class _UnaryOperation>
            param_type(size_t __nw, result_type __xmin, result_type __xmax,
                       _UnaryOperation __fw);
        param_type(param_type const&) = default;
        param_type & operator=(const param_type& __rhs);

        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        vector<result_type> intervals() const {return __b_;}
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        vector<result_type> densities() const {return __densities_;}

        friend __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
            bool operator==(const param_type& __x, const param_type& __y)
            {return __x.__densities_ == __y.__densities_ && __x.__b_ == __y.__b_;}
        friend __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
            bool operator!=(const param_type& __x, const param_type& __y)
            {return !(__x == __y);}

    private:
        void __init();

        friend class piecewise_constant_distribution;

        template <class _CharT, class _Traits, class _RT>
        friend
        basic_ostream<_CharT, _Traits>&
        operator<<(basic_ostream<_CharT, _Traits>& __os,
                   const piecewise_constant_distribution<_RT>& __x);

        template <class _CharT, class _Traits, class _RT>
        friend
        basic_istream<_CharT, _Traits>&
        operator>>(basic_istream<_CharT, _Traits>& __is,
                   piecewise_constant_distribution<_RT>& __x);
    };

private:
    param_type __p_;

public:

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    piecewise_constant_distribution() {}
    template<class _InputIteratorB, class _InputIteratorW>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        piecewise_constant_distribution(_InputIteratorB __fB,
                                        _InputIteratorB __lB,
                                        _InputIteratorW __fW)
        : __p_(__fB, __lB, __fW) {}


    template<class _UnaryOperation>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        piecewise_constant_distribution(initializer_list<result_type> __bl,
                                        _UnaryOperation __fw)
        : __p_(__bl, __fw) {}


    template<class _UnaryOperation>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        piecewise_constant_distribution(size_t __nw, result_type __xmin,
                                        result_type __xmax, _UnaryOperation __fw)
        : __p_(__nw, __xmin, __xmax, __fw) {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit piecewise_constant_distribution(const param_type& __p)
        : __p_(__p) {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void reset() {}


    template<class _URNG>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        result_type operator()(_URNG& __g)
        {return (*this)(__g, __p_);}
    template<class _URNG> result_type operator()(_URNG& __g, const param_type& __p);


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    vector<result_type> intervals() const {return __p_.intervals();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    vector<result_type> densities() const {return __p_.densities();}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    param_type param() const {return __p_;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void param(const param_type& __p) {__p_ = __p;}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    result_type min() const {return __p_.__b_.front();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    result_type max() const {return __p_.__b_.back();}

    friend __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        bool operator==(const piecewise_constant_distribution& __x,
                        const piecewise_constant_distribution& __y)
        {return __x.__p_ == __y.__p_;}
    friend __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        bool operator!=(const piecewise_constant_distribution& __x,
                           const piecewise_constant_distribution& __y)
        {return !(__x == __y);}

    template <class _CharT, class _Traits, class _RT>
    friend
    basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __os,
               const piecewise_constant_distribution<_RT>& __x);

    template <class _CharT, class _Traits, class _RT>
    friend
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __is,
               piecewise_constant_distribution<_RT>& __x);
};

template<class _RealType>
typename piecewise_constant_distribution<_RealType>::param_type &
piecewise_constant_distribution<_RealType>::param_type::operator=
                                                       (const param_type& __rhs)
{

    __b_.reserve (__rhs.__b_.size ());
    __densities_.reserve(__rhs.__densities_.size());
    __areas_.reserve (__rhs.__areas_.size());


    __b_ = __rhs.__b_;
    __densities_ = __rhs.__densities_;
    __areas_ = __rhs.__areas_;
    return *this;
}

template<class _RealType>
void
piecewise_constant_distribution<_RealType>::param_type::__init()
{

    result_type __total_area = std::__1::accumulate(__densities_.begin(),
                                                __densities_.end(),
                                                result_type());
    for (size_t __i = 0; __i < __densities_.size(); ++__i)
        __densities_[__i] /= __total_area;

    __areas_.assign(__densities_.size(), result_type());
    std::__1::partial_sum(__densities_.begin(), __densities_.end() - 1,
                                                          __areas_.begin() + 1);

    __densities_.back() = 1 - __areas_.back();
    for (size_t __i = 0; __i < __densities_.size(); ++__i)
        __densities_[__i] /= (__b_[__i+1] - __b_[__i]);

}

template<class _RealType>
piecewise_constant_distribution<_RealType>::param_type::param_type()
    : __b_(2),
      __densities_(1, 1.0),
      __areas_(1, 0.0)
{
    __b_[1] = 1;
}

template<class _RealType>
template<class _InputIteratorB, class _InputIteratorW>
piecewise_constant_distribution<_RealType>::param_type::param_type(
        _InputIteratorB __fB, _InputIteratorB __lB, _InputIteratorW __fW)
    : __b_(__fB, __lB)
{
    if (__b_.size() < 2)
    {
        __b_.resize(2);
        __b_[0] = 0;
        __b_[1] = 1;
        __densities_.assign(1, 1.0);
        __areas_.assign(1, 0.0);
    }
    else
    {
        __densities_.reserve(__b_.size() - 1);
        for (size_t __i = 0; __i < __b_.size() - 1; ++__i, ++__fW)
            __densities_.push_back(*__fW);
        __init();
    }
}



template<class _RealType>
template<class _UnaryOperation>
piecewise_constant_distribution<_RealType>::param_type::param_type(
        initializer_list<result_type> __bl, _UnaryOperation __fw)
    : __b_(__bl.begin(), __bl.end())
{
    if (__b_.size() < 2)
    {
        __b_.resize(2);
        __b_[0] = 0;
        __b_[1] = 1;
        __densities_.assign(1, 1.0);
        __areas_.assign(1, 0.0);
    }
    else
    {
        __densities_.reserve(__b_.size() - 1);
        for (size_t __i = 0; __i < __b_.size() - 1; ++__i)
            __densities_.push_back(__fw((__b_[__i+1] + __b_[__i])*.5));
        __init();
    }
}



template<class _RealType>
template<class _UnaryOperation>
piecewise_constant_distribution<_RealType>::param_type::param_type(
        size_t __nw, result_type __xmin, result_type __xmax, _UnaryOperation __fw)
    : __b_(__nw == 0 ? 2 : __nw + 1)
{
    size_t __n = __b_.size() - 1;
    result_type __d = (__xmax - __xmin) / __n;
    __densities_.reserve(__n);
    for (size_t __i = 0; __i < __n; ++__i)
    {
        __b_[__i] = __xmin + __i * __d;
        __densities_.push_back(__fw(__b_[__i] + __d*.5));
    }
    __b_[__n] = __xmax;
    __init();
}

template<class _RealType>
template<class _URNG>
_RealType
piecewise_constant_distribution<_RealType>::operator()(_URNG& __g, const param_type& __p)
{
    typedef uniform_real_distribution<result_type> _Gen;
    result_type __u = _Gen()(__g);
    ptrdiff_t __k = std::__1::upper_bound(__p.__areas_.begin(), __p.__areas_.end(),
                                      __u) - __p.__areas_.begin() - 1;
    return (__u - __p.__areas_[__k]) / __p.__densities_[__k] + __p.__b_[__k];
}

template <class _CharT, class _Traits, class _RT>
basic_ostream<_CharT, _Traits>&
operator<<(basic_ostream<_CharT, _Traits>& __os,
           const piecewise_constant_distribution<_RT>& __x)
{
    __save_flags<_CharT, _Traits> __lx(__os);
    typedef basic_ostream<_CharT, _Traits> _OStream;
    __os.flags(_OStream::dec | _OStream::left | _OStream::fixed |
               _OStream::scientific);
    _CharT __sp = __os.widen(' ');
    __os.fill(__sp);
    size_t __n = __x.__p_.__b_.size();
    __os << __n;
    for (size_t __i = 0; __i < __n; ++__i)
        __os << __sp << __x.__p_.__b_[__i];
    __n = __x.__p_.__densities_.size();
    __os << __sp << __n;
    for (size_t __i = 0; __i < __n; ++__i)
        __os << __sp << __x.__p_.__densities_[__i];
    __n = __x.__p_.__areas_.size();
    __os << __sp << __n;
    for (size_t __i = 0; __i < __n; ++__i)
        __os << __sp << __x.__p_.__areas_[__i];
    return __os;
}

template <class _CharT, class _Traits, class _RT>
basic_istream<_CharT, _Traits>&
operator>>(basic_istream<_CharT, _Traits>& __is,
           piecewise_constant_distribution<_RT>& __x)
{
    typedef piecewise_constant_distribution<_RT> _Eng;
    typedef typename _Eng::result_type result_type;
    __save_flags<_CharT, _Traits> __lx(__is);
    typedef basic_istream<_CharT, _Traits> _Istream;
    __is.flags(_Istream::dec | _Istream::skipws);
    size_t __n;
    __is >> __n;
    vector<result_type> __b(__n);
    for (size_t __i = 0; __i < __n; ++__i)
        __is >> __b[__i];
    __is >> __n;
    vector<result_type> __densities(__n);
    for (size_t __i = 0; __i < __n; ++__i)
        __is >> __densities[__i];
    __is >> __n;
    vector<result_type> __areas(__n);
    for (size_t __i = 0; __i < __n; ++__i)
        __is >> __areas[__i];
    if (!__is.fail())
    {
        swap(__x.__p_.__b_, __b);
        swap(__x.__p_.__densities_, __densities);
        swap(__x.__p_.__areas_, __areas);
    }
    return __is;
}



template<class _RealType = double>
class __attribute__ ((__type_visibility__("default"))) piecewise_linear_distribution
{
public:

    typedef _RealType result_type;

    class __attribute__ ((__type_visibility__("default"))) param_type
    {
        vector<result_type> __b_;
        vector<result_type> __densities_;
        vector<result_type> __areas_;
    public:
        typedef piecewise_linear_distribution distribution_type;

        param_type();
        template<class _InputIteratorB, class _InputIteratorW>
            param_type(_InputIteratorB __fB, _InputIteratorB __lB,
                       _InputIteratorW __fW);

        template<class _UnaryOperation>
            param_type(initializer_list<result_type> __bl, _UnaryOperation __fw);

        template<class _UnaryOperation>
            param_type(size_t __nw, result_type __xmin, result_type __xmax,
                       _UnaryOperation __fw);
        param_type(param_type const&) = default;
        param_type & operator=(const param_type& __rhs);

        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        vector<result_type> intervals() const {return __b_;}
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        vector<result_type> densities() const {return __densities_;}

        friend __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
            bool operator==(const param_type& __x, const param_type& __y)
            {return __x.__densities_ == __y.__densities_ && __x.__b_ == __y.__b_;}
        friend __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
            bool operator!=(const param_type& __x, const param_type& __y)
            {return !(__x == __y);}

    private:
        void __init();

        friend class piecewise_linear_distribution;

        template <class _CharT, class _Traits, class _RT>
        friend
        basic_ostream<_CharT, _Traits>&
        operator<<(basic_ostream<_CharT, _Traits>& __os,
                   const piecewise_linear_distribution<_RT>& __x);

        template <class _CharT, class _Traits, class _RT>
        friend
        basic_istream<_CharT, _Traits>&
        operator>>(basic_istream<_CharT, _Traits>& __is,
                   piecewise_linear_distribution<_RT>& __x);
    };

private:
    param_type __p_;

public:

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    piecewise_linear_distribution() {}
    template<class _InputIteratorB, class _InputIteratorW>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        piecewise_linear_distribution(_InputIteratorB __fB,
                                      _InputIteratorB __lB,
                                      _InputIteratorW __fW)
        : __p_(__fB, __lB, __fW) {}


    template<class _UnaryOperation>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        piecewise_linear_distribution(initializer_list<result_type> __bl,
                                      _UnaryOperation __fw)
        : __p_(__bl, __fw) {}


    template<class _UnaryOperation>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        piecewise_linear_distribution(size_t __nw, result_type __xmin,
                                      result_type __xmax, _UnaryOperation __fw)
        : __p_(__nw, __xmin, __xmax, __fw) {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit piecewise_linear_distribution(const param_type& __p)
        : __p_(__p) {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void reset() {}


    template<class _URNG>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        result_type operator()(_URNG& __g)
        {return (*this)(__g, __p_);}
    template<class _URNG> result_type operator()(_URNG& __g, const param_type& __p);


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    vector<result_type> intervals() const {return __p_.intervals();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    vector<result_type> densities() const {return __p_.densities();}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    param_type param() const {return __p_;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void param(const param_type& __p) {__p_ = __p;}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    result_type min() const {return __p_.__b_.front();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    result_type max() const {return __p_.__b_.back();}

    friend __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        bool operator==(const piecewise_linear_distribution& __x,
                        const piecewise_linear_distribution& __y)
        {return __x.__p_ == __y.__p_;}
    friend __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        bool operator!=(const piecewise_linear_distribution& __x,
                        const piecewise_linear_distribution& __y)
        {return !(__x == __y);}

    template <class _CharT, class _Traits, class _RT>
    friend
    basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __os,
               const piecewise_linear_distribution<_RT>& __x);

    template <class _CharT, class _Traits, class _RT>
    friend
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __is,
               piecewise_linear_distribution<_RT>& __x);
};

template<class _RealType>
typename piecewise_linear_distribution<_RealType>::param_type &
piecewise_linear_distribution<_RealType>::param_type::operator=
                                                       (const param_type& __rhs)
{

    __b_.reserve (__rhs.__b_.size ());
    __densities_.reserve(__rhs.__densities_.size());
    __areas_.reserve (__rhs.__areas_.size());


    __b_ = __rhs.__b_;
    __densities_ = __rhs.__densities_;
    __areas_ = __rhs.__areas_;
    return *this;
}


template<class _RealType>
void
piecewise_linear_distribution<_RealType>::param_type::__init()
{
    __areas_.assign(__densities_.size() - 1, result_type());
    result_type _Sp = 0;
    for (size_t __i = 0; __i < __areas_.size(); ++__i)
    {
        __areas_[__i] = (__densities_[__i+1] + __densities_[__i]) *
                        (__b_[__i+1] - __b_[__i]) * .5;
        _Sp += __areas_[__i];
    }
    for (size_t __i = __areas_.size(); __i > 1;)
    {
        --__i;
        __areas_[__i] = __areas_[__i-1] / _Sp;
    }
    __areas_[0] = 0;
    for (size_t __i = 1; __i < __areas_.size(); ++__i)
        __areas_[__i] += __areas_[__i-1];
    for (size_t __i = 0; __i < __densities_.size(); ++__i)
        __densities_[__i] /= _Sp;
}

template<class _RealType>
piecewise_linear_distribution<_RealType>::param_type::param_type()
    : __b_(2),
      __densities_(2, 1.0),
      __areas_(1, 0.0)
{
    __b_[1] = 1;
}

template<class _RealType>
template<class _InputIteratorB, class _InputIteratorW>
piecewise_linear_distribution<_RealType>::param_type::param_type(
        _InputIteratorB __fB, _InputIteratorB __lB, _InputIteratorW __fW)
    : __b_(__fB, __lB)
{
    if (__b_.size() < 2)
    {
        __b_.resize(2);
        __b_[0] = 0;
        __b_[1] = 1;
        __densities_.assign(2, 1.0);
        __areas_.assign(1, 0.0);
    }
    else
    {
        __densities_.reserve(__b_.size());
        for (size_t __i = 0; __i < __b_.size(); ++__i, ++__fW)
            __densities_.push_back(*__fW);
        __init();
    }
}



template<class _RealType>
template<class _UnaryOperation>
piecewise_linear_distribution<_RealType>::param_type::param_type(
        initializer_list<result_type> __bl, _UnaryOperation __fw)
    : __b_(__bl.begin(), __bl.end())
{
    if (__b_.size() < 2)
    {
        __b_.resize(2);
        __b_[0] = 0;
        __b_[1] = 1;
        __densities_.assign(2, 1.0);
        __areas_.assign(1, 0.0);
    }
    else
    {
        __densities_.reserve(__b_.size());
        for (size_t __i = 0; __i < __b_.size(); ++__i)
            __densities_.push_back(__fw(__b_[__i]));
        __init();
    }
}



template<class _RealType>
template<class _UnaryOperation>
piecewise_linear_distribution<_RealType>::param_type::param_type(
        size_t __nw, result_type __xmin, result_type __xmax, _UnaryOperation __fw)
    : __b_(__nw == 0 ? 2 : __nw + 1)
{
    size_t __n = __b_.size() - 1;
    result_type __d = (__xmax - __xmin) / __n;
    __densities_.reserve(__b_.size());
    for (size_t __i = 0; __i < __n; ++__i)
    {
        __b_[__i] = __xmin + __i * __d;
        __densities_.push_back(__fw(__b_[__i]));
    }
    __b_[__n] = __xmax;
    __densities_.push_back(__fw(__b_[__n]));
    __init();
}

template<class _RealType>
template<class _URNG>
_RealType
piecewise_linear_distribution<_RealType>::operator()(_URNG& __g, const param_type& __p)
{
    typedef uniform_real_distribution<result_type> _Gen;
    result_type __u = _Gen()(__g);
    ptrdiff_t __k = std::__1::upper_bound(__p.__areas_.begin(), __p.__areas_.end(),
                                      __u) - __p.__areas_.begin() - 1;
    __u -= __p.__areas_[__k];
    const result_type __dk = __p.__densities_[__k];
    const result_type __dk1 = __p.__densities_[__k+1];
    const result_type __deltad = __dk1 - __dk;
    const result_type __bk = __p.__b_[__k];
    if (__deltad == 0)
        return __u / __dk + __bk;
    const result_type __bk1 = __p.__b_[__k+1];
    const result_type __deltab = __bk1 - __bk;
    return (__bk * __dk1 - __bk1 * __dk +
        std::__1::sqrt(__deltab * (__deltab * __dk * __dk + 2 * __deltad * __u))) /
        __deltad;
}

template <class _CharT, class _Traits, class _RT>
basic_ostream<_CharT, _Traits>&
operator<<(basic_ostream<_CharT, _Traits>& __os,
           const piecewise_linear_distribution<_RT>& __x)
{
    __save_flags<_CharT, _Traits> __lx(__os);
    typedef basic_ostream<_CharT, _Traits> _OStream;
    __os.flags(_OStream::dec | _OStream::left | _OStream::fixed |
               _OStream::scientific);
    _CharT __sp = __os.widen(' ');
    __os.fill(__sp);
    size_t __n = __x.__p_.__b_.size();
    __os << __n;
    for (size_t __i = 0; __i < __n; ++__i)
        __os << __sp << __x.__p_.__b_[__i];
    __n = __x.__p_.__densities_.size();
    __os << __sp << __n;
    for (size_t __i = 0; __i < __n; ++__i)
        __os << __sp << __x.__p_.__densities_[__i];
    __n = __x.__p_.__areas_.size();
    __os << __sp << __n;
    for (size_t __i = 0; __i < __n; ++__i)
        __os << __sp << __x.__p_.__areas_[__i];
    return __os;
}

template <class _CharT, class _Traits, class _RT>
basic_istream<_CharT, _Traits>&
operator>>(basic_istream<_CharT, _Traits>& __is,
           piecewise_linear_distribution<_RT>& __x)
{
    typedef piecewise_linear_distribution<_RT> _Eng;
    typedef typename _Eng::result_type result_type;
    __save_flags<_CharT, _Traits> __lx(__is);
    typedef basic_istream<_CharT, _Traits> _Istream;
    __is.flags(_Istream::dec | _Istream::skipws);
    size_t __n;
    __is >> __n;
    vector<result_type> __b(__n);
    for (size_t __i = 0; __i < __n; ++__i)
        __is >> __b[__i];
    __is >> __n;
    vector<result_type> __densities(__n);
    for (size_t __i = 0; __i < __n; ++__i)
        __is >> __densities[__i];
    __is >> __n;
    vector<result_type> __areas(__n);
    for (size_t __i = 0; __i < __n; ++__i)
        __is >> __areas[__i];
    if (!__is.fail())
    {
        swap(__x.__p_.__b_, __b);
        swap(__x.__p_.__densities_, __densities);
        swap(__x.__p_.__areas_, __areas);
    }
    return __is;
}

} }
# 244 "/usr/local/include/bits/stdc++.h" 2





# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/regex" 1 3
# 773 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/regex" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/memory" 1 3
# 974 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/memory" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 1 3
# 20 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/assert.h" 1 3 4
# 44 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/assert.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/stdlib.h" 1 3 4
# 45 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/assert.h" 2 3 4
# 81 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/assert.h" 3 4
extern "C" {
void __assert_rtn(const char *, const char *, int, const char *) __attribute__((__noreturn__)) __attribute__((__cold__)) __attribute__((__disable_tail_calls__));



}
# 21 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 2 3
# 24 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 3
# 975 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/memory" 2 3
# 774 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/regex" 2 3
# 782 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/regex" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 786 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/regex" 2 3




namespace std { inline namespace __1 {

namespace regex_constants
{



enum syntax_option_type
{
    icase = 1 << 0,
    nosubs = 1 << 1,
    optimize = 1 << 2,
    collate = 1 << 3,



    ECMAScript = 0,

    basic = 1 << 4,
    extended = 1 << 5,
    awk = 1 << 6,
    grep = 1 << 7,
    egrep = 1 << 8,

    multiline = 1 << 10
};

inline constexpr
syntax_option_type __get_grammar(syntax_option_type __g)
{



    return static_cast<syntax_option_type>(__g & 0x1F0);

}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
constexpr
syntax_option_type
operator~(syntax_option_type __x)
{
    return syntax_option_type(~int(__x) & 0x1FF);
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
constexpr
syntax_option_type
operator&(syntax_option_type __x, syntax_option_type __y)
{
    return syntax_option_type(int(__x) & int(__y));
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
constexpr
syntax_option_type
operator|(syntax_option_type __x, syntax_option_type __y)
{
    return syntax_option_type(int(__x) | int(__y));
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
constexpr
syntax_option_type
operator^(syntax_option_type __x, syntax_option_type __y)
{
    return syntax_option_type(int(__x) ^ int(__y));
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
syntax_option_type&
operator&=(syntax_option_type& __x, syntax_option_type __y)
{
    __x = __x & __y;
    return __x;
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
syntax_option_type&
operator|=(syntax_option_type& __x, syntax_option_type __y)
{
    __x = __x | __y;
    return __x;
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
syntax_option_type&
operator^=(syntax_option_type& __x, syntax_option_type __y)
{
    __x = __x ^ __y;
    return __x;
}



enum match_flag_type
{
    match_default = 0,
    match_not_bol = 1 << 0,
    match_not_eol = 1 << 1,
    match_not_bow = 1 << 2,
    match_not_eow = 1 << 3,
    match_any = 1 << 4,
    match_not_null = 1 << 5,
    match_continuous = 1 << 6,
    match_prev_avail = 1 << 7,
    format_default = 0,
    format_sed = 1 << 8,
    format_no_copy = 1 << 9,
    format_first_only = 1 << 10,
    __no_update_pos = 1 << 11,
    __full_match = 1 << 12
};

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
constexpr
match_flag_type
operator~(match_flag_type __x)
{
    return match_flag_type(~int(__x) & 0x0FFF);
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
constexpr
match_flag_type
operator&(match_flag_type __x, match_flag_type __y)
{
    return match_flag_type(int(__x) & int(__y));
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
constexpr
match_flag_type
operator|(match_flag_type __x, match_flag_type __y)
{
    return match_flag_type(int(__x) | int(__y));
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
constexpr
match_flag_type
operator^(match_flag_type __x, match_flag_type __y)
{
    return match_flag_type(int(__x) ^ int(__y));
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
match_flag_type&
operator&=(match_flag_type& __x, match_flag_type __y)
{
    __x = __x & __y;
    return __x;
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
match_flag_type&
operator|=(match_flag_type& __x, match_flag_type __y)
{
    __x = __x | __y;
    return __x;
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
match_flag_type&
operator^=(match_flag_type& __x, match_flag_type __y)
{
    __x = __x ^ __y;
    return __x;
}

enum error_type
{
    error_collate = 1,
    error_ctype,
    error_escape,
    error_backref,
    error_brack,
    error_paren,
    error_brace,
    error_badbrace,
    error_range,
    error_space,
    error_badrepeat,
    error_complexity,
    error_stack,
    __re_err_grammar,
    __re_err_empty,
    __re_err_unknown,
    __re_err_parse
};

}

class __attribute__ ((__visibility__("default"))) regex_error
    : public runtime_error
{
    regex_constants::error_type __code_;
public:
    explicit regex_error(regex_constants::error_type __ecode);
    regex_error(const regex_error&) noexcept = default;
    virtual ~regex_error() noexcept;
     __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    regex_constants::error_type code() const {return __code_;}
};

template <regex_constants::error_type _Ev>
[[noreturn]] inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void __throw_regex_error()
{

    throw regex_error(_Ev);



}

template <class _CharT>
struct __attribute__ ((__type_visibility__("default"))) regex_traits
{
public:
    typedef _CharT char_type;
    typedef basic_string<char_type> string_type;
    typedef locale locale_type;
# 1024 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/regex" 3
    typedef ctype_base::mask char_class_type;


    static const char_class_type __regex_word = ctype_base::__regex_word;
private:
    locale __loc_;
    const ctype<char_type>* __ct_;
    const collate<char_type>* __col_;

public:
    regex_traits();

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    static size_t length(const char_type* __p)
        {return char_traits<char_type>::length(__p);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    char_type translate(char_type __c) const {return __c;}
    char_type translate_nocase(char_type __c) const;
    template <class _ForwardIterator>
        string_type
        transform(_ForwardIterator __f, _ForwardIterator __l) const;
    template <class _ForwardIterator>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        string_type
        transform_primary( _ForwardIterator __f, _ForwardIterator __l) const
            {return __transform_primary(__f, __l, char_type());}
    template <class _ForwardIterator>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        string_type
        lookup_collatename(_ForwardIterator __f, _ForwardIterator __l) const
            {return __lookup_collatename(__f, __l, char_type());}
    template <class _ForwardIterator>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        char_class_type
        lookup_classname(_ForwardIterator __f, _ForwardIterator __l,
                         bool __icase = false) const
            {return __lookup_classname(__f, __l, __icase, char_type());}
    bool isctype(char_type __c, char_class_type __m) const;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    int value(char_type __ch, int __radix) const
        {return __regex_traits_value(__ch, __radix);}
    locale_type imbue(locale_type __l);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    locale_type getloc()const {return __loc_;}

private:
    void __init();

    template <class _ForwardIterator>
        string_type
        __transform_primary(_ForwardIterator __f, _ForwardIterator __l, char) const;

    template <class _ForwardIterator>
        string_type
        __transform_primary(_ForwardIterator __f, _ForwardIterator __l, wchar_t) const;

    template <class _ForwardIterator>
        string_type
        __lookup_collatename(_ForwardIterator __f, _ForwardIterator __l, char) const;

    template <class _ForwardIterator>
        string_type
        __lookup_collatename(_ForwardIterator __f, _ForwardIterator __l, wchar_t) const;

    template <class _ForwardIterator>
        char_class_type
        __lookup_classname(_ForwardIterator __f, _ForwardIterator __l,
                           bool __icase, char) const;

    template <class _ForwardIterator>
        char_class_type
        __lookup_classname(_ForwardIterator __f, _ForwardIterator __l,
                           bool __icase, wchar_t) const;


    static int __regex_traits_value(unsigned char __ch, int __radix);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    int __regex_traits_value(char __ch, int __radix) const
        {return __regex_traits_value(static_cast<unsigned char>(__ch), __radix);}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    int __regex_traits_value(wchar_t __ch, int __radix) const;

};

template <class _CharT>
const typename regex_traits<_CharT>::char_class_type
regex_traits<_CharT>::__regex_word;

template <class _CharT>
regex_traits<_CharT>::regex_traits()
{
    __init();
}

template <class _CharT>
typename regex_traits<_CharT>::char_type
regex_traits<_CharT>::translate_nocase(char_type __c) const
{
    return __ct_->tolower(__c);
}

template <class _CharT>
template <class _ForwardIterator>
typename regex_traits<_CharT>::string_type
regex_traits<_CharT>::transform(_ForwardIterator __f, _ForwardIterator __l) const
{
    string_type __s(__f, __l);
    return __col_->transform(__s.data(), __s.data() + __s.size());
}

template <class _CharT>
void
regex_traits<_CharT>::__init()
{
    __ct_ = &use_facet<ctype<char_type> >(__loc_);
    __col_ = &use_facet<collate<char_type> >(__loc_);
}

template <class _CharT>
typename regex_traits<_CharT>::locale_type
regex_traits<_CharT>::imbue(locale_type __l)
{
    locale __r = __loc_;
    __loc_ = __l;
    __init();
    return __r;
}



template <class _CharT>
template <class _ForwardIterator>
typename regex_traits<_CharT>::string_type
regex_traits<_CharT>::__transform_primary(_ForwardIterator __f,
                                          _ForwardIterator __l, char) const
{
    const string_type __s(__f, __l);
    string_type __d = __col_->transform(__s.data(), __s.data() + __s.size());
    switch (__d.size())
    {
    case 1:
        break;
    case 12:
        __d[11] = __d[3];
        break;
    default:
        __d.clear();
        break;
    }
    return __d;
}


template <class _CharT>
template <class _ForwardIterator>
typename regex_traits<_CharT>::string_type
regex_traits<_CharT>::__transform_primary(_ForwardIterator __f,
                                          _ForwardIterator __l, wchar_t) const
{
    const string_type __s(__f, __l);
    string_type __d = __col_->transform(__s.data(), __s.data() + __s.size());
    switch (__d.size())
    {
    case 1:
        break;
    case 3:
        __d[2] = __d[0];
        break;
    default:
        __d.clear();
        break;
    }
    return __d;
}




__attribute__ ((__visibility__("default"))) string __get_collation_name(const char* __s);

template <class _CharT>
template <class _ForwardIterator>
typename regex_traits<_CharT>::string_type
regex_traits<_CharT>::__lookup_collatename(_ForwardIterator __f,
                                           _ForwardIterator __l, char) const
{
    string_type __s(__f, __l);
    string_type __r;
    if (!__s.empty())
    {
        __r = __get_collation_name(__s.c_str());
        if (__r.empty() && __s.size() <= 2)
        {
            __r = __col_->transform(__s.data(), __s.data() + __s.size());
            if (__r.size() == 1 || __r.size() == 12)
                __r = __s;
            else
                __r.clear();
        }
    }
    return __r;
}


template <class _CharT>
template <class _ForwardIterator>
typename regex_traits<_CharT>::string_type
regex_traits<_CharT>::__lookup_collatename(_ForwardIterator __f,
                                           _ForwardIterator __l, wchar_t) const
{
    string_type __s(__f, __l);
    string __n;
    __n.reserve(__s.size());
    for (typename string_type::const_iterator __i = __s.begin(), __e = __s.end();
                                                              __i != __e; ++__i)
    {
        if (static_cast<unsigned>(*__i) >= 127)
            return string_type();
        __n.push_back(char(*__i));
    }
    string_type __r;
    if (!__s.empty())
    {
        __n = __get_collation_name(__n.c_str());
        if (!__n.empty())
            __r.assign(__n.begin(), __n.end());
        else if (__s.size() <= 2)
        {
            __r = __col_->transform(__s.data(), __s.data() + __s.size());
            if (__r.size() == 1 || __r.size() == 3)
                __r = __s;
            else
                __r.clear();
        }
    }
    return __r;
}




regex_traits<char>::char_class_type __attribute__ ((__visibility__("default")))
__get_classname(const char* __s, bool __icase);

template <class _CharT>
template <class _ForwardIterator>
typename regex_traits<_CharT>::char_class_type
regex_traits<_CharT>::__lookup_classname(_ForwardIterator __f,
                                         _ForwardIterator __l,
                                         bool __icase, char) const
{
    string_type __s(__f, __l);
    __ct_->tolower(&__s[0], &__s[0] + __s.size());
    return __get_classname(__s.c_str(), __icase);
}


template <class _CharT>
template <class _ForwardIterator>
typename regex_traits<_CharT>::char_class_type
regex_traits<_CharT>::__lookup_classname(_ForwardIterator __f,
                                         _ForwardIterator __l,
                                         bool __icase, wchar_t) const
{
    string_type __s(__f, __l);
    __ct_->tolower(&__s[0], &__s[0] + __s.size());
    string __n;
    __n.reserve(__s.size());
    for (typename string_type::const_iterator __i = __s.begin(), __e = __s.end();
                                                              __i != __e; ++__i)
    {
        if (static_cast<unsigned>(*__i) >= 127)
            return char_class_type();
        __n.push_back(char(*__i));
    }
    return __get_classname(__n.c_str(), __icase);
}


template <class _CharT>
bool
regex_traits<_CharT>::isctype(char_type __c, char_class_type __m) const
{
    if (__ct_->is(__m, __c))
        return true;
    return (__c == '_' && (__m & __regex_word));
}

template <class _CharT>
int
regex_traits<_CharT>::__regex_traits_value(unsigned char __ch, int __radix)
{
    if ((__ch & 0xF8u) == 0x30)
        return __ch - '0';
    if (__radix != 8)
    {
        if ((__ch & 0xFEu) == 0x38)
            return __ch - '0';
        if (__radix == 16)
        {
            __ch |= 0x20;
            if ('a' <= __ch && __ch <= 'f')
                return __ch - ('a' - 10);
        }
    }
    return -1;
}


template <class _CharT>
inline
int
regex_traits<_CharT>::__regex_traits_value(wchar_t __ch, int __radix) const
{
    return __regex_traits_value(static_cast<unsigned char>(__ct_->narrow(__ch, char_type())), __radix);
}


template <class _CharT> class __node;

template <class _BidirectionalIterator> class __attribute__ ((__type_visibility__("default"))) sub_match;

template <class _BidirectionalIterator,
          class _Allocator = allocator<sub_match<_BidirectionalIterator> > >
class __attribute__ ((__type_visibility__("default"))) match_results;

template <class _CharT>
struct __state
{
    enum
    {
        __end_state = -1000,
        __consume_input,
        __begin_marked_expr,
        __end_marked_expr,
        __pop_state,
        __accept_and_consume,
        __accept_but_not_consume,
        __reject,
        __split,
        __repeat
    };

    int __do_;
    const _CharT* __first_;
    const _CharT* __current_;
    const _CharT* __last_;
    vector<sub_match<const _CharT*> > __sub_matches_;
    vector<pair<size_t, const _CharT*> > __loop_data_;
    const __node<_CharT>* __node_;
    regex_constants::match_flag_type __flags_;
    bool __at_first_;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __state()
        : __do_(0), __first_(nullptr), __current_(nullptr), __last_(nullptr),
          __node_(nullptr), __flags_() {}
};



template <class _CharT>
class __node
{
    __node(const __node&);
    __node& operator=(const __node&);
public:
    typedef std::__1::__state<_CharT> __state;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __node() {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    virtual ~__node() {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    virtual void __exec(__state&) const {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    virtual void __exec_split(bool, __state&) const {}
};



template <class _CharT>
class __end_state
    : public __node<_CharT>
{
public:
    typedef std::__1::__state<_CharT> __state;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __end_state() {}

    virtual void __exec(__state&) const;
};

template <class _CharT>
void
__end_state<_CharT>::__exec(__state& __s) const
{
    __s.__do_ = __state::__end_state;
}



template <class _CharT>
class __has_one_state
    : public __node<_CharT>
{
    __node<_CharT>* __first_;

public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit __has_one_state(__node<_CharT>* __s)
        : __first_(__s) {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __node<_CharT>* first() const {return __first_;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __node<_CharT>*& first() {return __first_;}
};



template <class _CharT>
class __owns_one_state
    : public __has_one_state<_CharT>
{
    typedef __has_one_state<_CharT> base;

public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit __owns_one_state(__node<_CharT>* __s)
        : base(__s) {}

    virtual ~__owns_one_state();
};

template <class _CharT>
__owns_one_state<_CharT>::~__owns_one_state()
{
    delete this->first();
}



template <class _CharT>
class __empty_state
    : public __owns_one_state<_CharT>
{
    typedef __owns_one_state<_CharT> base;

public:
    typedef std::__1::__state<_CharT> __state;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit __empty_state(__node<_CharT>* __s)
        : base(__s) {}

    virtual void __exec(__state&) const;
};

template <class _CharT>
void
__empty_state<_CharT>::__exec(__state& __s) const
{
    __s.__do_ = __state::__accept_but_not_consume;
    __s.__node_ = this->first();
}



template <class _CharT>
class __empty_non_own_state
    : public __has_one_state<_CharT>
{
    typedef __has_one_state<_CharT> base;

public:
    typedef std::__1::__state<_CharT> __state;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit __empty_non_own_state(__node<_CharT>* __s)
        : base(__s) {}

    virtual void __exec(__state&) const;
};

template <class _CharT>
void
__empty_non_own_state<_CharT>::__exec(__state& __s) const
{
    __s.__do_ = __state::__accept_but_not_consume;
    __s.__node_ = this->first();
}



template <class _CharT>
class __repeat_one_loop
    : public __has_one_state<_CharT>
{
    typedef __has_one_state<_CharT> base;

public:
    typedef std::__1::__state<_CharT> __state;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit __repeat_one_loop(__node<_CharT>* __s)
        : base(__s) {}

    virtual void __exec(__state&) const;
};

template <class _CharT>
void
__repeat_one_loop<_CharT>::__exec(__state& __s) const
{
    __s.__do_ = __state::__repeat;
    __s.__node_ = this->first();
}



template <class _CharT>
class __owns_two_states
    : public __owns_one_state<_CharT>
{
    typedef __owns_one_state<_CharT> base;

    base* __second_;

public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit __owns_two_states(__node<_CharT>* __s1, base* __s2)
        : base(__s1), __second_(__s2) {}

    virtual ~__owns_two_states();

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    base* second() const {return __second_;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    base*& second() {return __second_;}
};

template <class _CharT>
__owns_two_states<_CharT>::~__owns_two_states()
{
    delete __second_;
}



template <class _CharT>
class __loop
    : public __owns_two_states<_CharT>
{
    typedef __owns_two_states<_CharT> base;

    size_t __min_;
    size_t __max_;
    unsigned __loop_id_;
    unsigned __mexp_begin_;
    unsigned __mexp_end_;
    bool __greedy_;

public:
    typedef std::__1::__state<_CharT> __state;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit __loop(unsigned __loop_id,
                          __node<_CharT>* __s1, __owns_one_state<_CharT>* __s2,
                          unsigned __mexp_begin, unsigned __mexp_end,
                          bool __greedy = true,
                          size_t __min = 0,
                          size_t __max = numeric_limits<size_t>::max())
        : base(__s1, __s2), __min_(__min), __max_(__max), __loop_id_(__loop_id),
          __mexp_begin_(__mexp_begin), __mexp_end_(__mexp_end),
          __greedy_(__greedy) {}

    virtual void __exec(__state& __s) const;
    virtual void __exec_split(bool __second, __state& __s) const;

private:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void __init_repeat(__state& __s) const
    {
        __s.__loop_data_[__loop_id_].second = __s.__current_;
        for (size_t __i = __mexp_begin_-1; __i != __mexp_end_-1; ++__i)
        {
            __s.__sub_matches_[__i].first = __s.__last_;
            __s.__sub_matches_[__i].second = __s.__last_;
            __s.__sub_matches_[__i].matched = false;
        }
    }
};

template <class _CharT>
void
__loop<_CharT>::__exec(__state& __s) const
{
    if (__s.__do_ == __state::__repeat)
    {
        bool __do_repeat = ++__s.__loop_data_[__loop_id_].first < __max_;
        bool __do_alt = __s.__loop_data_[__loop_id_].first >= __min_;
        if (__do_repeat && __do_alt &&
                               __s.__loop_data_[__loop_id_].second == __s.__current_)
            __do_repeat = false;
        if (__do_repeat && __do_alt)
            __s.__do_ = __state::__split;
        else if (__do_repeat)
        {
            __s.__do_ = __state::__accept_but_not_consume;
            __s.__node_ = this->first();
            __init_repeat(__s);
        }
        else
        {
            __s.__do_ = __state::__accept_but_not_consume;
            __s.__node_ = this->second();
        }
    }
    else
    {
        __s.__loop_data_[__loop_id_].first = 0;
        bool __do_repeat = 0 < __max_;
        bool __do_alt = 0 >= __min_;
        if (__do_repeat && __do_alt)
            __s.__do_ = __state::__split;
        else if (__do_repeat)
        {
            __s.__do_ = __state::__accept_but_not_consume;
            __s.__node_ = this->first();
            __init_repeat(__s);
        }
        else
        {
            __s.__do_ = __state::__accept_but_not_consume;
            __s.__node_ = this->second();
        }
    }
}

template <class _CharT>
void
__loop<_CharT>::__exec_split(bool __second, __state& __s) const
{
    __s.__do_ = __state::__accept_but_not_consume;
    if (__greedy_ != __second)
    {
        __s.__node_ = this->first();
        __init_repeat(__s);
    }
    else
        __s.__node_ = this->second();
}



template <class _CharT>
class __alternate
    : public __owns_two_states<_CharT>
{
    typedef __owns_two_states<_CharT> base;

public:
    typedef std::__1::__state<_CharT> __state;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit __alternate(__owns_one_state<_CharT>* __s1,
                         __owns_one_state<_CharT>* __s2)
        : base(__s1, __s2) {}

    virtual void __exec(__state& __s) const;
    virtual void __exec_split(bool __second, __state& __s) const;
};

template <class _CharT>
void
__alternate<_CharT>::__exec(__state& __s) const
{
    __s.__do_ = __state::__split;
}

template <class _CharT>
void
__alternate<_CharT>::__exec_split(bool __second, __state& __s) const
{
    __s.__do_ = __state::__accept_but_not_consume;
    if (__second)
        __s.__node_ = this->second();
    else
        __s.__node_ = this->first();
}



template <class _CharT>
class __begin_marked_subexpression
    : public __owns_one_state<_CharT>
{
    typedef __owns_one_state<_CharT> base;

    unsigned __mexp_;
public:
    typedef std::__1::__state<_CharT> __state;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit __begin_marked_subexpression(unsigned __mexp, __node<_CharT>* __s)
        : base(__s), __mexp_(__mexp) {}

    virtual void __exec(__state&) const;
};

template <class _CharT>
void
__begin_marked_subexpression<_CharT>::__exec(__state& __s) const
{
    __s.__do_ = __state::__accept_but_not_consume;
    __s.__sub_matches_[__mexp_-1].first = __s.__current_;
    __s.__node_ = this->first();
}



template <class _CharT>
class __end_marked_subexpression
    : public __owns_one_state<_CharT>
{
    typedef __owns_one_state<_CharT> base;

    unsigned __mexp_;
public:
    typedef std::__1::__state<_CharT> __state;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit __end_marked_subexpression(unsigned __mexp, __node<_CharT>* __s)
        : base(__s), __mexp_(__mexp) {}

    virtual void __exec(__state&) const;
};

template <class _CharT>
void
__end_marked_subexpression<_CharT>::__exec(__state& __s) const
{
    __s.__do_ = __state::__accept_but_not_consume;
    __s.__sub_matches_[__mexp_-1].second = __s.__current_;
    __s.__sub_matches_[__mexp_-1].matched = true;
    __s.__node_ = this->first();
}



template <class _CharT>
class __back_ref
    : public __owns_one_state<_CharT>
{
    typedef __owns_one_state<_CharT> base;

    unsigned __mexp_;
public:
    typedef std::__1::__state<_CharT> __state;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit __back_ref(unsigned __mexp, __node<_CharT>* __s)
        : base(__s), __mexp_(__mexp) {}

    virtual void __exec(__state&) const;
};

template <class _CharT>
void
__back_ref<_CharT>::__exec(__state& __s) const
{
    if (__mexp_ > __s.__sub_matches_.size())
        __throw_regex_error<regex_constants::error_backref>();
    sub_match<const _CharT*>& __sm = __s.__sub_matches_[__mexp_-1];
    if (__sm.matched)
    {
        ptrdiff_t __len = __sm.second - __sm.first;
        if (__s.__last_ - __s.__current_ >= __len &&
            std::__1::equal(__sm.first, __sm.second, __s.__current_))
        {
            __s.__do_ = __state::__accept_but_not_consume;
            __s.__current_ += __len;
            __s.__node_ = this->first();
        }
        else
        {
            __s.__do_ = __state::__reject;
            __s.__node_ = nullptr;
        }
    }
    else
    {
        __s.__do_ = __state::__reject;
        __s.__node_ = nullptr;
    }
}



template <class _CharT, class _Traits>
class __back_ref_icase
    : public __owns_one_state<_CharT>
{
    typedef __owns_one_state<_CharT> base;

    _Traits __traits_;
    unsigned __mexp_;
public:
    typedef std::__1::__state<_CharT> __state;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit __back_ref_icase(const _Traits& __traits, unsigned __mexp,
                              __node<_CharT>* __s)
        : base(__s), __traits_(__traits), __mexp_(__mexp) {}

    virtual void __exec(__state&) const;
};

template <class _CharT, class _Traits>
void
__back_ref_icase<_CharT, _Traits>::__exec(__state& __s) const
{
    sub_match<const _CharT*>& __sm = __s.__sub_matches_[__mexp_-1];
    if (__sm.matched)
    {
        ptrdiff_t __len = __sm.second - __sm.first;
        if (__s.__last_ - __s.__current_ >= __len)
        {
            for (ptrdiff_t __i = 0; __i < __len; ++__i)
            {
                if (__traits_.translate_nocase(__sm.first[__i]) !=
                                __traits_.translate_nocase(__s.__current_[__i]))
                    goto __not_equal;
            }
            __s.__do_ = __state::__accept_but_not_consume;
            __s.__current_ += __len;
            __s.__node_ = this->first();
        }
        else
        {
            __s.__do_ = __state::__reject;
            __s.__node_ = nullptr;
        }
    }
    else
    {
__not_equal:
        __s.__do_ = __state::__reject;
        __s.__node_ = nullptr;
    }
}



template <class _CharT, class _Traits>
class __back_ref_collate
    : public __owns_one_state<_CharT>
{
    typedef __owns_one_state<_CharT> base;

    _Traits __traits_;
    unsigned __mexp_;
public:
    typedef std::__1::__state<_CharT> __state;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit __back_ref_collate(const _Traits& __traits, unsigned __mexp,
                              __node<_CharT>* __s)
        : base(__s), __traits_(__traits), __mexp_(__mexp) {}

    virtual void __exec(__state&) const;
};

template <class _CharT, class _Traits>
void
__back_ref_collate<_CharT, _Traits>::__exec(__state& __s) const
{
    sub_match<const _CharT*>& __sm = __s.__sub_matches_[__mexp_-1];
    if (__sm.matched)
    {
        ptrdiff_t __len = __sm.second - __sm.first;
        if (__s.__last_ - __s.__current_ >= __len)
        {
            for (ptrdiff_t __i = 0; __i < __len; ++__i)
            {
                if (__traits_.translate(__sm.first[__i]) !=
                                       __traits_.translate(__s.__current_[__i]))
                    goto __not_equal;
            }
            __s.__do_ = __state::__accept_but_not_consume;
            __s.__current_ += __len;
            __s.__node_ = this->first();
        }
        else
        {
            __s.__do_ = __state::__reject;
            __s.__node_ = nullptr;
        }
    }
    else
    {
__not_equal:
        __s.__do_ = __state::__reject;
        __s.__node_ = nullptr;
    }
}



template <class _CharT, class _Traits>
class __word_boundary
    : public __owns_one_state<_CharT>
{
    typedef __owns_one_state<_CharT> base;

    _Traits __traits_;
    bool __invert_;
public:
    typedef std::__1::__state<_CharT> __state;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit __word_boundary(const _Traits& __traits, bool __invert,
                             __node<_CharT>* __s)
        : base(__s), __traits_(__traits), __invert_(__invert) {}

    virtual void __exec(__state&) const;
};

template <class _CharT, class _Traits>
void
__word_boundary<_CharT, _Traits>::__exec(__state& __s) const
{
    bool __is_word_b = false;
    if (__s.__first_ != __s.__last_)
    {
        if (__s.__current_ == __s.__last_)
        {
            if (!(__s.__flags_ & regex_constants::match_not_eow))
            {
                _CharT __c = __s.__current_[-1];
                __is_word_b = __c == '_' ||
                              __traits_.isctype(__c, ctype_base::alnum);
            }
        }
        else if (__s.__current_ == __s.__first_ &&
                !(__s.__flags_ & regex_constants::match_prev_avail))
        {
            if (!(__s.__flags_ & regex_constants::match_not_bow))
            {
                _CharT __c = *__s.__current_;
                __is_word_b = __c == '_' ||
                              __traits_.isctype(__c, ctype_base::alnum);
            }
        }
        else
        {
            _CharT __c1 = __s.__current_[-1];
            _CharT __c2 = *__s.__current_;
            bool __is_c1_b = __c1 == '_' ||
                             __traits_.isctype(__c1, ctype_base::alnum);
            bool __is_c2_b = __c2 == '_' ||
                             __traits_.isctype(__c2, ctype_base::alnum);
            __is_word_b = __is_c1_b != __is_c2_b;
        }
    }
    if (__is_word_b != __invert_)
    {
        __s.__do_ = __state::__accept_but_not_consume;
        __s.__node_ = this->first();
    }
    else
    {
        __s.__do_ = __state::__reject;
        __s.__node_ = nullptr;
    }
}



template <class _CharT>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
bool __is_eol(_CharT c)
{
    return c == '\r' || c == '\n';
}

template <class _CharT>
class __l_anchor_multiline
    : public __owns_one_state<_CharT>
{
    typedef __owns_one_state<_CharT> base;

    bool __multiline_;

public:
    typedef std::__1::__state<_CharT> __state;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __l_anchor_multiline(bool __multiline, __node<_CharT>* __s)
        : base(__s), __multiline_(__multiline) {}

    virtual void __exec(__state&) const;
};

template <class _CharT>
void
__l_anchor_multiline<_CharT>::__exec(__state& __s) const
{
    if (__s.__at_first_ && __s.__current_ == __s.__first_ &&
        !(__s.__flags_ & regex_constants::match_not_bol))
    {
        __s.__do_ = __state::__accept_but_not_consume;
        __s.__node_ = this->first();
    }
    else if (__multiline_ &&
             !__s.__at_first_ &&
             __is_eol(*std::__1::prev(__s.__current_)))
    {
        __s.__do_ = __state::__accept_but_not_consume;
        __s.__node_ = this->first();
    }
    else
    {
        __s.__do_ = __state::__reject;
        __s.__node_ = nullptr;
    }
}



template <class _CharT>
class __r_anchor_multiline
    : public __owns_one_state<_CharT>
{
    typedef __owns_one_state<_CharT> base;

    bool __multiline;

public:
    typedef std::__1::__state<_CharT> __state;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __r_anchor_multiline(bool __multiline, __node<_CharT>* __s)
        : base(__s), __multiline(__multiline) {}

    virtual void __exec(__state&) const;
};

template <class _CharT>
void
__r_anchor_multiline<_CharT>::__exec(__state& __s) const
{
    if (__s.__current_ == __s.__last_ &&
        !(__s.__flags_ & regex_constants::match_not_eol))
    {
        __s.__do_ = __state::__accept_but_not_consume;
        __s.__node_ = this->first();
    }
    else if (__multiline && __is_eol(*__s.__current_))
    {
        __s.__do_ = __state::__accept_but_not_consume;
        __s.__node_ = this->first();
    }
    else
    {
        __s.__do_ = __state::__reject;
        __s.__node_ = nullptr;
    }
}



template <class _CharT>
class __match_any
    : public __owns_one_state<_CharT>
{
    typedef __owns_one_state<_CharT> base;

public:
    typedef std::__1::__state<_CharT> __state;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __match_any(__node<_CharT>* __s)
        : base(__s) {}

    virtual void __exec(__state&) const;
};

template <class _CharT>
void
__match_any<_CharT>::__exec(__state& __s) const
{
    if (__s.__current_ != __s.__last_ && *__s.__current_ != 0)
    {
        __s.__do_ = __state::__accept_and_consume;
        ++__s.__current_;
        __s.__node_ = this->first();
    }
    else
    {
        __s.__do_ = __state::__reject;
        __s.__node_ = nullptr;
    }
}



template <class _CharT>
class __match_any_but_newline
    : public __owns_one_state<_CharT>
{
    typedef __owns_one_state<_CharT> base;

public:
    typedef std::__1::__state<_CharT> __state;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __match_any_but_newline(__node<_CharT>* __s)
        : base(__s) {}

    virtual void __exec(__state&) const;
};

template <> __attribute__ ((__visibility__("default"))) void __match_any_but_newline<char>::__exec(__state&) const;

template <> __attribute__ ((__visibility__("default"))) void __match_any_but_newline<wchar_t>::__exec(__state&) const;




template <class _CharT>
class __match_char
    : public __owns_one_state<_CharT>
{
    typedef __owns_one_state<_CharT> base;

    _CharT __c_;

    __match_char(const __match_char&);
    __match_char& operator=(const __match_char&);
public:
    typedef std::__1::__state<_CharT> __state;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __match_char(_CharT __c, __node<_CharT>* __s)
        : base(__s), __c_(__c) {}

    virtual void __exec(__state&) const;
};

template <class _CharT>
void
__match_char<_CharT>::__exec(__state& __s) const
{
    if (__s.__current_ != __s.__last_ && *__s.__current_ == __c_)
    {
        __s.__do_ = __state::__accept_and_consume;
        ++__s.__current_;
        __s.__node_ = this->first();
    }
    else
    {
        __s.__do_ = __state::__reject;
        __s.__node_ = nullptr;
    }
}



template <class _CharT, class _Traits>
class __match_char_icase
    : public __owns_one_state<_CharT>
{
    typedef __owns_one_state<_CharT> base;

    _Traits __traits_;
    _CharT __c_;

    __match_char_icase(const __match_char_icase&);
    __match_char_icase& operator=(const __match_char_icase&);
public:
    typedef std::__1::__state<_CharT> __state;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __match_char_icase(const _Traits& __traits, _CharT __c, __node<_CharT>* __s)
        : base(__s), __traits_(__traits), __c_(__traits.translate_nocase(__c)) {}

    virtual void __exec(__state&) const;
};

template <class _CharT, class _Traits>
void
__match_char_icase<_CharT, _Traits>::__exec(__state& __s) const
{
    if (__s.__current_ != __s.__last_ &&
        __traits_.translate_nocase(*__s.__current_) == __c_)
    {
        __s.__do_ = __state::__accept_and_consume;
        ++__s.__current_;
        __s.__node_ = this->first();
    }
    else
    {
        __s.__do_ = __state::__reject;
        __s.__node_ = nullptr;
    }
}



template <class _CharT, class _Traits>
class __match_char_collate
    : public __owns_one_state<_CharT>
{
    typedef __owns_one_state<_CharT> base;

    _Traits __traits_;
    _CharT __c_;

    __match_char_collate(const __match_char_collate&);
    __match_char_collate& operator=(const __match_char_collate&);
public:
    typedef std::__1::__state<_CharT> __state;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __match_char_collate(const _Traits& __traits, _CharT __c, __node<_CharT>* __s)
        : base(__s), __traits_(__traits), __c_(__traits.translate(__c)) {}

    virtual void __exec(__state&) const;
};

template <class _CharT, class _Traits>
void
__match_char_collate<_CharT, _Traits>::__exec(__state& __s) const
{
    if (__s.__current_ != __s.__last_ &&
        __traits_.translate(*__s.__current_) == __c_)
    {
        __s.__do_ = __state::__accept_and_consume;
        ++__s.__current_;
        __s.__node_ = this->first();
    }
    else
    {
        __s.__do_ = __state::__reject;
        __s.__node_ = nullptr;
    }
}



template <class _CharT, class _Traits>
class __bracket_expression
    : public __owns_one_state<_CharT>
{
    typedef __owns_one_state<_CharT> base;
    typedef typename _Traits::string_type string_type;

    _Traits __traits_;
    vector<_CharT> __chars_;
    vector<_CharT> __neg_chars_;
    vector<pair<string_type, string_type> > __ranges_;
    vector<pair<_CharT, _CharT> > __digraphs_;
    vector<string_type> __equivalences_;
    typename regex_traits<_CharT>::char_class_type __mask_;
    typename regex_traits<_CharT>::char_class_type __neg_mask_;
    bool __negate_;
    bool __icase_;
    bool __collate_;
    bool __might_have_digraph_;

    __bracket_expression(const __bracket_expression&);
    __bracket_expression& operator=(const __bracket_expression&);
public:
    typedef std::__1::__state<_CharT> __state;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __bracket_expression(const _Traits& __traits, __node<_CharT>* __s,
                                 bool __negate, bool __icase, bool __collate)
        : base(__s), __traits_(__traits), __mask_(), __neg_mask_(),
          __negate_(__negate), __icase_(__icase), __collate_(__collate),
          __might_have_digraph_(__traits_.getloc().name() != "C") {}

    virtual void __exec(__state&) const;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    bool __negated() const {return __negate_;}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void __add_char(_CharT __c)
        {
            if (__icase_)
                __chars_.push_back(__traits_.translate_nocase(__c));
            else if (__collate_)
                __chars_.push_back(__traits_.translate(__c));
            else
                __chars_.push_back(__c);
        }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void __add_neg_char(_CharT __c)
        {
            if (__icase_)
                __neg_chars_.push_back(__traits_.translate_nocase(__c));
            else if (__collate_)
                __neg_chars_.push_back(__traits_.translate(__c));
            else
                __neg_chars_.push_back(__c);
        }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void __add_range(string_type __b, string_type __e)
        {
            if (__collate_)
            {
                if (__icase_)
                {
                    for (size_t __i = 0; __i < __b.size(); ++__i)
                        __b[__i] = __traits_.translate_nocase(__b[__i]);
                    for (size_t __i = 0; __i < __e.size(); ++__i)
                        __e[__i] = __traits_.translate_nocase(__e[__i]);
                }
                else
                {
                    for (size_t __i = 0; __i < __b.size(); ++__i)
                        __b[__i] = __traits_.translate(__b[__i]);
                    for (size_t __i = 0; __i < __e.size(); ++__i)
                        __e[__i] = __traits_.translate(__e[__i]);
                }
                __ranges_.push_back(make_pair(
                                  __traits_.transform(__b.begin(), __b.end()),
                                  __traits_.transform(__e.begin(), __e.end())));
            }
            else
            {
                if (__b.size() != 1 || __e.size() != 1)
                    __throw_regex_error<regex_constants::error_range>();
                if (__icase_)
                {
                    __b[0] = __traits_.translate_nocase(__b[0]);
                    __e[0] = __traits_.translate_nocase(__e[0]);
                }
                __ranges_.push_back(make_pair(std::__1::move(__b), std::__1::move(__e)));
            }
        }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void __add_digraph(_CharT __c1, _CharT __c2)
        {
            if (__icase_)
                __digraphs_.push_back(make_pair(__traits_.translate_nocase(__c1),
                                                __traits_.translate_nocase(__c2)));
            else if (__collate_)
                __digraphs_.push_back(make_pair(__traits_.translate(__c1),
                                                __traits_.translate(__c2)));
            else
                __digraphs_.push_back(make_pair(__c1, __c2));
        }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void __add_equivalence(const string_type& __s)
        {__equivalences_.push_back(__s);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void __add_class(typename regex_traits<_CharT>::char_class_type __mask)
        {__mask_ |= __mask;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void __add_neg_class(typename regex_traits<_CharT>::char_class_type __mask)
        {__neg_mask_ |= __mask;}
};

template <class _CharT, class _Traits>
void
__bracket_expression<_CharT, _Traits>::__exec(__state& __s) const
{
    bool __found = false;
    unsigned __consumed = 0;
    if (__s.__current_ != __s.__last_)
    {
        ++__consumed;
        if (__might_have_digraph_)
        {
            const _CharT* __next = std::__1::next(__s.__current_);
            if (__next != __s.__last_)
            {
                pair<_CharT, _CharT> __ch2(*__s.__current_, *__next);
                if (__icase_)
                {
                    __ch2.first = __traits_.translate_nocase(__ch2.first);
                    __ch2.second = __traits_.translate_nocase(__ch2.second);
                }
                else if (__collate_)
                {
                    __ch2.first = __traits_.translate(__ch2.first);
                    __ch2.second = __traits_.translate(__ch2.second);
                }
                if (!__traits_.lookup_collatename(&__ch2.first, &__ch2.first+2).empty())
                {

                    ++__consumed;
                    for (size_t __i = 0; __i < __digraphs_.size(); ++__i)
                    {
                        if (__ch2 == __digraphs_[__i])
                        {
                            __found = true;
                            goto __exit;
                        }
                    }
                    if (__collate_ && !__ranges_.empty())
                    {
                        string_type __s2 = __traits_.transform(&__ch2.first,
                                                               &__ch2.first + 2);
                        for (size_t __i = 0; __i < __ranges_.size(); ++__i)
                        {
                            if (__ranges_[__i].first <= __s2 &&
                                __s2 <= __ranges_[__i].second)
                            {
                                __found = true;
                                goto __exit;
                            }
                        }
                    }
                    if (!__equivalences_.empty())
                    {
                        string_type __s2 = __traits_.transform_primary(&__ch2.first,
                                                                       &__ch2.first + 2);
                        for (size_t __i = 0; __i < __equivalences_.size(); ++__i)
                        {
                            if (__s2 == __equivalences_[__i])
                            {
                                __found = true;
                                goto __exit;
                            }
                        }
                    }
                    if (__traits_.isctype(__ch2.first, __mask_) &&
                        __traits_.isctype(__ch2.second, __mask_))
                    {
                        __found = true;
                        goto __exit;
                    }
                    if (!__traits_.isctype(__ch2.first, __neg_mask_) &&
                        !__traits_.isctype(__ch2.second, __neg_mask_))
                    {
                        __found = true;
                        goto __exit;
                    }
                    goto __exit;
                }
            }
        }

        _CharT __ch = *__s.__current_;
        if (__icase_)
            __ch = __traits_.translate_nocase(__ch);
        else if (__collate_)
            __ch = __traits_.translate(__ch);
        for (size_t __i = 0; __i < __chars_.size(); ++__i)
        {
            if (__ch == __chars_[__i])
            {
                __found = true;
                goto __exit;
            }
        }







        if (!(__neg_mask_ == 0 && __neg_chars_.empty()))
        {
            const bool __in_neg_mask = __traits_.isctype(__ch, __neg_mask_);
          const bool __in_neg_chars =
              std::__1::find(__neg_chars_.begin(), __neg_chars_.end(), __ch) !=
              __neg_chars_.end();
          if (!(__in_neg_mask || __in_neg_chars))
          {
            __found = true;
            goto __exit;
          }
        }
        if (!__ranges_.empty())
        {
            string_type __s2 = __collate_ ?
                                   __traits_.transform(&__ch, &__ch + 1) :
                                   string_type(1, __ch);
            for (size_t __i = 0; __i < __ranges_.size(); ++__i)
            {
                if (__ranges_[__i].first <= __s2 && __s2 <= __ranges_[__i].second)
                {
                    __found = true;
                    goto __exit;
                }
            }
        }
        if (!__equivalences_.empty())
        {
            string_type __s2 = __traits_.transform_primary(&__ch, &__ch + 1);
            for (size_t __i = 0; __i < __equivalences_.size(); ++__i)
            {
                if (__s2 == __equivalences_[__i])
                {
                    __found = true;
                    goto __exit;
                }
            }
        }
        if (__traits_.isctype(__ch, __mask_))
        {
            __found = true;
            goto __exit;
        }
    }
    else
        __found = __negate_;
__exit:
    if (__found != __negate_)
    {
        __s.__do_ = __state::__accept_and_consume;
        __s.__current_ += __consumed;
        __s.__node_ = this->first();
    }
    else
    {
        __s.__do_ = __state::__reject;
        __s.__node_ = nullptr;
    }
}

template <class _CharT, class _Traits> class __lookahead;

template <class _CharT, class _Traits = regex_traits<_CharT> >
    class __attribute__ ((__type_visibility__("default"))) basic_regex;

typedef basic_regex<char> regex;

typedef basic_regex<wchar_t> wregex;


template <class _CharT, class _Traits>
class
    __attribute__ ((__type_visibility__("default")))
    __attribute__((__preferred_name__(regex)))
    __attribute__((__preferred_name__(wregex)))
    basic_regex
{
public:

    typedef _CharT value_type;
    typedef _Traits traits_type;
    typedef typename _Traits::string_type string_type;
    typedef regex_constants::syntax_option_type flag_type;
    typedef typename _Traits::locale_type locale_type;

private:
    _Traits __traits_;
    flag_type __flags_;
    unsigned __marked_count_;
    unsigned __loop_count_;
    int __open_count_;
    shared_ptr<__empty_state<_CharT> > __start_;
    __owns_one_state<_CharT>* __end_;

    typedef std::__1::__state<_CharT> __state;
    typedef std::__1::__node<_CharT> __node;

public:

    static const regex_constants::syntax_option_type icase = regex_constants::icase;
    static const regex_constants::syntax_option_type nosubs = regex_constants::nosubs;
    static const regex_constants::syntax_option_type optimize = regex_constants::optimize;
    static const regex_constants::syntax_option_type collate = regex_constants::collate;
    static const regex_constants::syntax_option_type ECMAScript = regex_constants::ECMAScript;
    static const regex_constants::syntax_option_type basic = regex_constants::basic;
    static const regex_constants::syntax_option_type extended = regex_constants::extended;
    static const regex_constants::syntax_option_type awk = regex_constants::awk;
    static const regex_constants::syntax_option_type grep = regex_constants::grep;
    static const regex_constants::syntax_option_type egrep = regex_constants::egrep;
    static const regex_constants::syntax_option_type multiline = regex_constants::multiline;


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    basic_regex()
        : __flags_(regex_constants::ECMAScript), __marked_count_(0), __loop_count_(0), __open_count_(0),
          __end_(nullptr)
        {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit basic_regex(const value_type* __p, flag_type __f = regex_constants::ECMAScript)
        : __flags_(__f), __marked_count_(0), __loop_count_(0), __open_count_(0),
          __end_(nullptr)
        {
        __init(__p, __p + __traits_.length(__p));
        }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    basic_regex(const value_type* __p, size_t __len, flag_type __f = regex_constants::ECMAScript)
        : __flags_(__f), __marked_count_(0), __loop_count_(0), __open_count_(0),
          __end_(nullptr)
        {
        __init(__p, __p + __len);
        }



    template <class _ST, class _SA>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        explicit basic_regex(const basic_string<value_type, _ST, _SA>& __p,
                             flag_type __f = regex_constants::ECMAScript)
        : __flags_(__f), __marked_count_(0), __loop_count_(0), __open_count_(0),
          __end_(nullptr)
        {
        __init(__p.begin(), __p.end());
        }

    template <class _ForwardIterator>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        basic_regex(_ForwardIterator __first, _ForwardIterator __last,
                    flag_type __f = regex_constants::ECMAScript)
        : __flags_(__f), __marked_count_(0), __loop_count_(0), __open_count_(0),
          __end_(nullptr)
        {
        __init(__first, __last);
        }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    basic_regex(initializer_list<value_type> __il,
                flag_type __f = regex_constants::ECMAScript)
        : __flags_(__f), __marked_count_(0), __loop_count_(0), __open_count_(0),
          __end_(nullptr)
        {
        __init(__il.begin(), __il.end());
        }






    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    basic_regex& operator=(const value_type* __p)
        {return assign(__p);}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    basic_regex& operator=(initializer_list<value_type> __il)
        {return assign(__il);}

    template <class _ST, class _SA>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        basic_regex& operator=(const basic_string<value_type, _ST, _SA>& __p)
        {return assign(__p);}


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    basic_regex& assign(const basic_regex& __that)
        {return *this = __that;}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    basic_regex& assign(basic_regex&& __that) noexcept
        {return *this = std::__1::move(__that);}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    basic_regex& assign(const value_type* __p, flag_type __f = regex_constants::ECMAScript)
        {return assign(__p, __p + __traits_.length(__p), __f);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    basic_regex& assign(const value_type* __p, size_t __len, flag_type __f = regex_constants::ECMAScript)
        {return assign(__p, __p + __len, __f);}
    template <class _ST, class _SA>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        basic_regex& assign(const basic_string<value_type, _ST, _SA>& __s,
                            flag_type __f = regex_constants::ECMAScript)
            {return assign(__s.begin(), __s.end(), __f);}

    template <class _InputIterator>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        typename enable_if
        <
             __is_cpp17_input_iterator <_InputIterator>::value &&
            !__is_cpp17_forward_iterator<_InputIterator>::value,
            basic_regex&
        >::type
        assign(_InputIterator __first, _InputIterator __last,
                            flag_type __f = regex_constants::ECMAScript)
        {
            basic_string<_CharT> __t(__first, __last);
            return assign(__t.begin(), __t.end(), __f);
        }

private:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void __member_init(flag_type __f)
    {
        __flags_ = __f;
        __marked_count_ = 0;
        __loop_count_ = 0;
        __open_count_ = 0;
        __end_ = nullptr;
    }
public:

    template <class _ForwardIterator>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        typename enable_if
        <
            __is_cpp17_forward_iterator<_ForwardIterator>::value,
            basic_regex&
        >::type
        assign(_ForwardIterator __first, _ForwardIterator __last,
                            flag_type __f = regex_constants::ECMAScript)
        {
            return assign(basic_regex(__first, __last, __f));
        }



    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    basic_regex& assign(initializer_list<value_type> __il,
                        flag_type __f = regex_constants::ECMAScript)
        {return assign(__il.begin(), __il.end(), __f);}




    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    unsigned mark_count() const {return __marked_count_;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    flag_type flags() const {return __flags_;}


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    locale_type imbue(locale_type __loc)
    {
        __member_init(ECMAScript);
        __start_.reset();
        return __traits_.imbue(__loc);
    }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    locale_type getloc() const {return __traits_.getloc();}


    void swap(basic_regex& __r);

private:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    unsigned __loop_count() const {return __loop_count_;}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    bool __use_multiline() const
    {
        return __get_grammar(__flags_) == ECMAScript && (__flags_ & multiline);
    }

    template <class _ForwardIterator>
        void
        __init(_ForwardIterator __first, _ForwardIterator __last);
    template <class _ForwardIterator>
        _ForwardIterator
        __parse(_ForwardIterator __first, _ForwardIterator __last);
    template <class _ForwardIterator>
        _ForwardIterator
        __parse_basic_reg_exp(_ForwardIterator __first, _ForwardIterator __last);
    template <class _ForwardIterator>
        _ForwardIterator
        __parse_RE_expression(_ForwardIterator __first, _ForwardIterator __last);
    template <class _ForwardIterator>
        _ForwardIterator
        __parse_simple_RE(_ForwardIterator __first, _ForwardIterator __last);
    template <class _ForwardIterator>
        _ForwardIterator
        __parse_nondupl_RE(_ForwardIterator __first, _ForwardIterator __last);
    template <class _ForwardIterator>
        _ForwardIterator
        __parse_one_char_or_coll_elem_RE(_ForwardIterator __first, _ForwardIterator __last);
    template <class _ForwardIterator>
        _ForwardIterator
        __parse_Back_open_paren(_ForwardIterator __first, _ForwardIterator __last);
    template <class _ForwardIterator>
        _ForwardIterator
        __parse_Back_close_paren(_ForwardIterator __first, _ForwardIterator __last);
    template <class _ForwardIterator>
        _ForwardIterator
        __parse_Back_open_brace(_ForwardIterator __first, _ForwardIterator __last);
    template <class _ForwardIterator>
        _ForwardIterator
        __parse_Back_close_brace(_ForwardIterator __first, _ForwardIterator __last);
    template <class _ForwardIterator>
        _ForwardIterator
        __parse_BACKREF(_ForwardIterator __first, _ForwardIterator __last);
    template <class _ForwardIterator>
        _ForwardIterator
        __parse_ORD_CHAR(_ForwardIterator __first, _ForwardIterator __last);
    template <class _ForwardIterator>
        _ForwardIterator
        __parse_QUOTED_CHAR(_ForwardIterator __first, _ForwardIterator __last);
    template <class _ForwardIterator>
        _ForwardIterator
        __parse_RE_dupl_symbol(_ForwardIterator __first, _ForwardIterator __last,
                               __owns_one_state<_CharT>* __s,
                               unsigned __mexp_begin, unsigned __mexp_end);
    template <class _ForwardIterator>
        _ForwardIterator
        __parse_ERE_dupl_symbol(_ForwardIterator __first, _ForwardIterator __last,
                                __owns_one_state<_CharT>* __s,
                                unsigned __mexp_begin, unsigned __mexp_end);
    template <class _ForwardIterator>
        _ForwardIterator
        __parse_bracket_expression(_ForwardIterator __first, _ForwardIterator __last);
    template <class _ForwardIterator>
        _ForwardIterator
        __parse_follow_list(_ForwardIterator __first, _ForwardIterator __last,
                            __bracket_expression<_CharT, _Traits>* __ml);
    template <class _ForwardIterator>
        _ForwardIterator
        __parse_expression_term(_ForwardIterator __first, _ForwardIterator __last,
                                __bracket_expression<_CharT, _Traits>* __ml);
    template <class _ForwardIterator>
        _ForwardIterator
        __parse_equivalence_class(_ForwardIterator __first, _ForwardIterator __last,
                                  __bracket_expression<_CharT, _Traits>* __ml);
    template <class _ForwardIterator>
        _ForwardIterator
        __parse_character_class(_ForwardIterator __first, _ForwardIterator __last,
                                __bracket_expression<_CharT, _Traits>* __ml);
    template <class _ForwardIterator>
        _ForwardIterator
        __parse_collating_symbol(_ForwardIterator __first, _ForwardIterator __last,
                                 basic_string<_CharT>& __col_sym);
    template <class _ForwardIterator>
        _ForwardIterator
        __parse_DUP_COUNT(_ForwardIterator __first, _ForwardIterator __last, int& __c);
    template <class _ForwardIterator>
        _ForwardIterator
        __parse_extended_reg_exp(_ForwardIterator __first, _ForwardIterator __last);
    template <class _ForwardIterator>
        _ForwardIterator
        __parse_ERE_branch(_ForwardIterator __first, _ForwardIterator __last);
    template <class _ForwardIterator>
        _ForwardIterator
        __parse_ERE_expression(_ForwardIterator __first, _ForwardIterator __last);
    template <class _ForwardIterator>
        _ForwardIterator
        __parse_one_char_or_coll_elem_ERE(_ForwardIterator __first, _ForwardIterator __last);
    template <class _ForwardIterator>
        _ForwardIterator
        __parse_ORD_CHAR_ERE(_ForwardIterator __first, _ForwardIterator __last);
    template <class _ForwardIterator>
        _ForwardIterator
        __parse_QUOTED_CHAR_ERE(_ForwardIterator __first, _ForwardIterator __last);
    template <class _ForwardIterator>
        _ForwardIterator
        __parse_ecma_exp(_ForwardIterator __first, _ForwardIterator __last);
    template <class _ForwardIterator>
        _ForwardIterator
        __parse_alternative(_ForwardIterator __first, _ForwardIterator __last);
    template <class _ForwardIterator>
        _ForwardIterator
        __parse_term(_ForwardIterator __first, _ForwardIterator __last);
    template <class _ForwardIterator>
        _ForwardIterator
        __parse_assertion(_ForwardIterator __first, _ForwardIterator __last);
    template <class _ForwardIterator>
        _ForwardIterator
        __parse_atom(_ForwardIterator __first, _ForwardIterator __last);
    template <class _ForwardIterator>
        _ForwardIterator
        __parse_atom_escape(_ForwardIterator __first, _ForwardIterator __last);
    template <class _ForwardIterator>
        _ForwardIterator
        __parse_decimal_escape(_ForwardIterator __first, _ForwardIterator __last);
    template <class _ForwardIterator>
        _ForwardIterator
        __parse_character_class_escape(_ForwardIterator __first, _ForwardIterator __last);
    template <class _ForwardIterator>
        _ForwardIterator
        __parse_character_escape(_ForwardIterator __first, _ForwardIterator __last,
                                 basic_string<_CharT>* __str = nullptr);
    template <class _ForwardIterator>
        _ForwardIterator
        __parse_pattern_character(_ForwardIterator __first, _ForwardIterator __last);
    template <class _ForwardIterator>
        _ForwardIterator
        __parse_grep(_ForwardIterator __first, _ForwardIterator __last);
    template <class _ForwardIterator>
        _ForwardIterator
        __parse_egrep(_ForwardIterator __first, _ForwardIterator __last);
    template <class _ForwardIterator>
        _ForwardIterator
        __parse_class_escape(_ForwardIterator __first, _ForwardIterator __last,
                          basic_string<_CharT>& __str,
                          __bracket_expression<_CharT, _Traits>* __ml);
    template <class _ForwardIterator>
        _ForwardIterator
        __parse_awk_escape(_ForwardIterator __first, _ForwardIterator __last,
                          basic_string<_CharT>* __str = nullptr);

    bool __test_back_ref(_CharT c);

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void __push_l_anchor();
    void __push_r_anchor();
    void __push_match_any();
    void __push_match_any_but_newline();
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void __push_greedy_inf_repeat(size_t __min, __owns_one_state<_CharT>* __s,
                                  unsigned __mexp_begin = 0, unsigned __mexp_end = 0)
        {__push_loop(__min, numeric_limits<size_t>::max(), __s,
                     __mexp_begin, __mexp_end);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void __push_nongreedy_inf_repeat(size_t __min, __owns_one_state<_CharT>* __s,
                                  unsigned __mexp_begin = 0, unsigned __mexp_end = 0)
        {__push_loop(__min, numeric_limits<size_t>::max(), __s,
                     __mexp_begin, __mexp_end, false);}
    void __push_loop(size_t __min, size_t __max, __owns_one_state<_CharT>* __s,
                     size_t __mexp_begin = 0, size_t __mexp_end = 0,
                     bool __greedy = true);
    __bracket_expression<_CharT, _Traits>* __start_matching_list(bool __negate);
    void __push_char(value_type __c);
    void __push_back_ref(int __i);
    void __push_alternation(__owns_one_state<_CharT>* __sa,
                            __owns_one_state<_CharT>* __sb);
    void __push_begin_marked_subexpression();
    void __push_end_marked_subexpression(unsigned);
    void __push_empty();
    void __push_word_boundary(bool);
    void __push_lookahead(const basic_regex&, bool, unsigned);

    template <class _Allocator>
        bool
        __search(const _CharT* __first, const _CharT* __last,
                 match_results<const _CharT*, _Allocator>& __m,
                 regex_constants::match_flag_type __flags) const;

    template <class _Allocator>
        bool
        __match_at_start(const _CharT* __first, const _CharT* __last,
                 match_results<const _CharT*, _Allocator>& __m,
                 regex_constants::match_flag_type __flags, bool) const;
    template <class _Allocator>
        bool
        __match_at_start_ecma(const _CharT* __first, const _CharT* __last,
                 match_results<const _CharT*, _Allocator>& __m,
                 regex_constants::match_flag_type __flags, bool) const;
    template <class _Allocator>
        bool
        __match_at_start_posix_nosubs(const _CharT* __first, const _CharT* __last,
                 match_results<const _CharT*, _Allocator>& __m,
                 regex_constants::match_flag_type __flags, bool) const;
    template <class _Allocator>
        bool
        __match_at_start_posix_subs(const _CharT* __first, const _CharT* __last,
                 match_results<const _CharT*, _Allocator>& __m,
                 regex_constants::match_flag_type __flags, bool) const;

    template <class _Bp, class _Ap, class _Cp, class _Tp>
    friend
    bool
    regex_search(_Bp, _Bp, match_results<_Bp, _Ap>&, const basic_regex<_Cp, _Tp>&,
                 regex_constants::match_flag_type);

    template <class _Ap, class _Cp, class _Tp>
    friend
    bool
    regex_search(const _Cp*, const _Cp*, match_results<const _Cp*, _Ap>&,
                 const basic_regex<_Cp, _Tp>&, regex_constants::match_flag_type);

    template <class _Bp, class _Cp, class _Tp>
    friend
    bool
    regex_search(_Bp, _Bp, const basic_regex<_Cp, _Tp>&,
                 regex_constants::match_flag_type);

    template <class _Cp, class _Tp>
    friend
    bool
    regex_search(const _Cp*, const _Cp*,
                 const basic_regex<_Cp, _Tp>&, regex_constants::match_flag_type);

    template <class _Cp, class _Ap, class _Tp>
    friend
    bool
    regex_search(const _Cp*, match_results<const _Cp*, _Ap>&, const basic_regex<_Cp, _Tp>&,
                 regex_constants::match_flag_type);

    template <class _ST, class _SA, class _Cp, class _Tp>
    friend
    bool
    regex_search(const basic_string<_Cp, _ST, _SA>& __s,
                 const basic_regex<_Cp, _Tp>& __e,
                 regex_constants::match_flag_type __flags);

    template <class _ST, class _SA, class _Ap, class _Cp, class _Tp>
    friend
    bool
    regex_search(const basic_string<_Cp, _ST, _SA>& __s,
                 match_results<typename basic_string<_Cp, _ST, _SA>::const_iterator, _Ap>&,
                 const basic_regex<_Cp, _Tp>& __e,
                 regex_constants::match_flag_type __flags);

    template <class _Iter, class _Ap, class _Cp, class _Tp>
    friend
    bool
    regex_search(__wrap_iter<_Iter> __first,
                 __wrap_iter<_Iter> __last,
                 match_results<__wrap_iter<_Iter>, _Ap>& __m,
                 const basic_regex<_Cp, _Tp>& __e,
                 regex_constants::match_flag_type __flags);

    template <class, class> friend class __lookahead;
};


template <class _ForwardIterator,
          class = typename enable_if<__is_cpp17_forward_iterator<_ForwardIterator>::value, nullptr_t>::type
>
basic_regex(_ForwardIterator, _ForwardIterator,
            regex_constants::syntax_option_type = regex_constants::ECMAScript)
    -> basic_regex<typename iterator_traits<_ForwardIterator>::value_type>;


template <class _CharT, class _Traits>
    const regex_constants::syntax_option_type basic_regex<_CharT, _Traits>::icase;
template <class _CharT, class _Traits>
    const regex_constants::syntax_option_type basic_regex<_CharT, _Traits>::nosubs;
template <class _CharT, class _Traits>
    const regex_constants::syntax_option_type basic_regex<_CharT, _Traits>::optimize;
template <class _CharT, class _Traits>
    const regex_constants::syntax_option_type basic_regex<_CharT, _Traits>::collate;
template <class _CharT, class _Traits>
    const regex_constants::syntax_option_type basic_regex<_CharT, _Traits>::ECMAScript;
template <class _CharT, class _Traits>
    const regex_constants::syntax_option_type basic_regex<_CharT, _Traits>::basic;
template <class _CharT, class _Traits>
    const regex_constants::syntax_option_type basic_regex<_CharT, _Traits>::extended;
template <class _CharT, class _Traits>
    const regex_constants::syntax_option_type basic_regex<_CharT, _Traits>::awk;
template <class _CharT, class _Traits>
    const regex_constants::syntax_option_type basic_regex<_CharT, _Traits>::grep;
template <class _CharT, class _Traits>
    const regex_constants::syntax_option_type basic_regex<_CharT, _Traits>::egrep;

template <class _CharT, class _Traits>
void
basic_regex<_CharT, _Traits>::swap(basic_regex& __r)
{
    using std::__1::swap;
    swap(__traits_, __r.__traits_);
    swap(__flags_, __r.__flags_);
    swap(__marked_count_, __r.__marked_count_);
    swap(__loop_count_, __r.__loop_count_);
    swap(__open_count_, __r.__open_count_);
    swap(__start_, __r.__start_);
    swap(__end_, __r.__end_);
}

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void
swap(basic_regex<_CharT, _Traits>& __x, basic_regex<_CharT, _Traits>& __y)
{
    return __x.swap(__y);
}



template <class _CharT, class _Traits>
class __lookahead
    : public __owns_one_state<_CharT>
{
    typedef __owns_one_state<_CharT> base;

    basic_regex<_CharT, _Traits> __exp_;
    unsigned __mexp_;
    bool __invert_;

    __lookahead(const __lookahead&);
    __lookahead& operator=(const __lookahead&);
public:
    typedef std::__1::__state<_CharT> __state;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __lookahead(const basic_regex<_CharT, _Traits>& __exp, bool __invert, __node<_CharT>* __s, unsigned __mexp)
        : base(__s), __exp_(__exp), __mexp_(__mexp), __invert_(__invert) {}

    virtual void __exec(__state&) const;
};

template <class _CharT, class _Traits>
void
__lookahead<_CharT, _Traits>::__exec(__state& __s) const
{
    match_results<const _CharT*> __m;
    __m.__init(1 + __exp_.mark_count(), __s.__current_, __s.__last_);
    bool __matched = __exp_.__match_at_start_ecma(
        __s.__current_, __s.__last_,
        __m,
        (__s.__flags_ | regex_constants::match_continuous) &
        ~regex_constants::__full_match,
        __s.__at_first_ && __s.__current_ == __s.__first_);
    if (__matched != __invert_)
    {
        __s.__do_ = __state::__accept_but_not_consume;
        __s.__node_ = this->first();
        for (unsigned __i = 1; __i < __m.size(); ++__i) {
            __s.__sub_matches_[__mexp_ + __i - 1] = __m.__matches_[__i];
        }
    }
    else
    {
        __s.__do_ = __state::__reject;
        __s.__node_ = nullptr;
    }
}

template <class _CharT, class _Traits>
template <class _ForwardIterator>
void
basic_regex<_CharT, _Traits>::__init(_ForwardIterator __first, _ForwardIterator __last)
{
    if (__get_grammar(__flags_) == 0) __flags_ |= regex_constants::ECMAScript;
    _ForwardIterator __temp = __parse(__first, __last);
    if ( __temp != __last)
        __throw_regex_error<regex_constants::__re_err_parse>();
}

template <class _CharT, class _Traits>
template <class _ForwardIterator>
_ForwardIterator
basic_regex<_CharT, _Traits>::__parse(_ForwardIterator __first,
                                      _ForwardIterator __last)
{
    {
        unique_ptr<__node> __h(new __end_state<_CharT>);
        __start_.reset(new __empty_state<_CharT>(__h.get()));
        __h.release();
        __end_ = __start_.get();
    }
    switch (__get_grammar(__flags_))
    {
    case ECMAScript:
        __first = __parse_ecma_exp(__first, __last);
        break;
    case basic:
        __first = __parse_basic_reg_exp(__first, __last);
        break;
    case extended:
    case awk:
        __first = __parse_extended_reg_exp(__first, __last);
        break;
    case grep:
        __first = __parse_grep(__first, __last);
        break;
    case egrep:
        __first = __parse_egrep(__first, __last);
        break;
    default:
        __throw_regex_error<regex_constants::__re_err_grammar>();
    }
    return __first;
}

template <class _CharT, class _Traits>
template <class _ForwardIterator>
_ForwardIterator
basic_regex<_CharT, _Traits>::__parse_basic_reg_exp(_ForwardIterator __first,
                                                    _ForwardIterator __last)
{
    if (__first != __last)
    {
        if (*__first == '^')
        {
            __push_l_anchor();
            ++__first;
        }
        if (__first != __last)
        {
            __first = __parse_RE_expression(__first, __last);
            if (__first != __last)
            {
                _ForwardIterator __temp = std::__1::next(__first);
                if (__temp == __last && *__first == '$')
                {
                    __push_r_anchor();
                    ++__first;
                }
            }
        }
        if (__first != __last)
            __throw_regex_error<regex_constants::__re_err_empty>();
    }
    return __first;
}

template <class _CharT, class _Traits>
template <class _ForwardIterator>
_ForwardIterator
basic_regex<_CharT, _Traits>::__parse_extended_reg_exp(_ForwardIterator __first,
                                                       _ForwardIterator __last)
{
    __owns_one_state<_CharT>* __sa = __end_;
    _ForwardIterator __temp = __parse_ERE_branch(__first, __last);
    if (__temp == __first)
        __throw_regex_error<regex_constants::__re_err_empty>();
    __first = __temp;
    while (__first != __last && *__first == '|')
    {
        __owns_one_state<_CharT>* __sb = __end_;
        __temp = __parse_ERE_branch(++__first, __last);
        if (__temp == __first)
            __throw_regex_error<regex_constants::__re_err_empty>();
        __push_alternation(__sa, __sb);
        __first = __temp;
    }
    return __first;
}

template <class _CharT, class _Traits>
template <class _ForwardIterator>
_ForwardIterator
basic_regex<_CharT, _Traits>::__parse_ERE_branch(_ForwardIterator __first,
                                                 _ForwardIterator __last)
{
    _ForwardIterator __temp = __parse_ERE_expression(__first, __last);
    if (__temp == __first)
        __throw_regex_error<regex_constants::__re_err_empty>();
    do
    {
        __first = __temp;
        __temp = __parse_ERE_expression(__first, __last);
    } while (__temp != __first);
    return __first;
}

template <class _CharT, class _Traits>
template <class _ForwardIterator>
_ForwardIterator
basic_regex<_CharT, _Traits>::__parse_ERE_expression(_ForwardIterator __first,
                                                     _ForwardIterator __last)
{
    __owns_one_state<_CharT>* __e = __end_;
    unsigned __mexp_begin = __marked_count_;
    _ForwardIterator __temp = __parse_one_char_or_coll_elem_ERE(__first, __last);
    if (__temp == __first && __temp != __last)
    {
        switch (*__temp)
        {
        case '^':
            __push_l_anchor();
            ++__temp;
            break;
        case '$':
            __push_r_anchor();
            ++__temp;
            break;
        case '(':
            __push_begin_marked_subexpression();
            unsigned __temp_count = __marked_count_;
            ++__open_count_;
            __temp = __parse_extended_reg_exp(++__temp, __last);
            if (__temp == __last || *__temp != ')')
                __throw_regex_error<regex_constants::error_paren>();
            __push_end_marked_subexpression(__temp_count);
            --__open_count_;
            ++__temp;
            break;
        }
    }
    if (__temp != __first)
        __temp = __parse_ERE_dupl_symbol(__temp, __last, __e, __mexp_begin+1,
                                         __marked_count_+1);
    __first = __temp;
    return __first;
}

template <class _CharT, class _Traits>
template <class _ForwardIterator>
_ForwardIterator
basic_regex<_CharT, _Traits>::__parse_RE_expression(_ForwardIterator __first,
                                                    _ForwardIterator __last)
{
    while (true)
    {
        _ForwardIterator __temp = __parse_simple_RE(__first, __last);
        if (__temp == __first)
            break;
        __first = __temp;
    }
    return __first;
}

template <class _CharT, class _Traits>
template <class _ForwardIterator>
_ForwardIterator
basic_regex<_CharT, _Traits>::__parse_simple_RE(_ForwardIterator __first,
                                                _ForwardIterator __last)
{
    if (__first != __last)
    {
        __owns_one_state<_CharT>* __e = __end_;
        unsigned __mexp_begin = __marked_count_;
        _ForwardIterator __temp = __parse_nondupl_RE(__first, __last);
        if (__temp != __first)
            __first = __parse_RE_dupl_symbol(__temp, __last, __e,
                                             __mexp_begin+1, __marked_count_+1);
    }
    return __first;
}

template <class _CharT, class _Traits>
template <class _ForwardIterator>
_ForwardIterator
basic_regex<_CharT, _Traits>::__parse_nondupl_RE(_ForwardIterator __first,
                                                 _ForwardIterator __last)
{
    _ForwardIterator __temp = __first;
    __first = __parse_one_char_or_coll_elem_RE(__first, __last);
    if (__temp == __first)
    {
        __temp = __parse_Back_open_paren(__first, __last);
        if (__temp != __first)
        {
            __push_begin_marked_subexpression();
            unsigned __temp_count = __marked_count_;
            __first = __parse_RE_expression(__temp, __last);
            __temp = __parse_Back_close_paren(__first, __last);
            if (__temp == __first)
                __throw_regex_error<regex_constants::error_paren>();
            __push_end_marked_subexpression(__temp_count);
            __first = __temp;
        }
        else
            __first = __parse_BACKREF(__first, __last);
    }
    return __first;
}

template <class _CharT, class _Traits>
template <class _ForwardIterator>
_ForwardIterator
basic_regex<_CharT, _Traits>::__parse_one_char_or_coll_elem_RE(
                                                       _ForwardIterator __first,
                                                       _ForwardIterator __last)
{
    _ForwardIterator __temp = __parse_ORD_CHAR(__first, __last);
    if (__temp == __first)
    {
        __temp = __parse_QUOTED_CHAR(__first, __last);
        if (__temp == __first)
        {
            if (__temp != __last && *__temp == '.')
            {
                __push_match_any();
                ++__temp;
            }
            else
                __temp = __parse_bracket_expression(__first, __last);
        }
    }
    __first = __temp;
    return __first;
}

template <class _CharT, class _Traits>
template <class _ForwardIterator>
_ForwardIterator
basic_regex<_CharT, _Traits>::__parse_one_char_or_coll_elem_ERE(
                                                       _ForwardIterator __first,
                                                       _ForwardIterator __last)
{
    _ForwardIterator __temp = __parse_ORD_CHAR_ERE(__first, __last);
    if (__temp == __first)
    {
        __temp = __parse_QUOTED_CHAR_ERE(__first, __last);
        if (__temp == __first)
        {
            if (__temp != __last && *__temp == '.')
            {
                __push_match_any();
                ++__temp;
            }
            else
                __temp = __parse_bracket_expression(__first, __last);
        }
    }
    __first = __temp;
    return __first;
}

template <class _CharT, class _Traits>
template <class _ForwardIterator>
_ForwardIterator
basic_regex<_CharT, _Traits>::__parse_Back_open_paren(_ForwardIterator __first,
                                                      _ForwardIterator __last)
{
    if (__first != __last)
    {
        _ForwardIterator __temp = std::__1::next(__first);
        if (__temp != __last)
        {
            if (*__first == '\\' && *__temp == '(')
                __first = ++__temp;
        }
    }
    return __first;
}

template <class _CharT, class _Traits>
template <class _ForwardIterator>
_ForwardIterator
basic_regex<_CharT, _Traits>::__parse_Back_close_paren(_ForwardIterator __first,
                                                       _ForwardIterator __last)
{
    if (__first != __last)
    {
        _ForwardIterator __temp = std::__1::next(__first);
        if (__temp != __last)
        {
            if (*__first == '\\' && *__temp == ')')
                __first = ++__temp;
        }
    }
    return __first;
}

template <class _CharT, class _Traits>
template <class _ForwardIterator>
_ForwardIterator
basic_regex<_CharT, _Traits>::__parse_Back_open_brace(_ForwardIterator __first,
                                                      _ForwardIterator __last)
{
    if (__first != __last)
    {
        _ForwardIterator __temp = std::__1::next(__first);
        if (__temp != __last)
        {
            if (*__first == '\\' && *__temp == '{')
                __first = ++__temp;
        }
    }
    return __first;
}

template <class _CharT, class _Traits>
template <class _ForwardIterator>
_ForwardIterator
basic_regex<_CharT, _Traits>::__parse_Back_close_brace(_ForwardIterator __first,
                                                       _ForwardIterator __last)
{
    if (__first != __last)
    {
        _ForwardIterator __temp = std::__1::next(__first);
        if (__temp != __last)
        {
            if (*__first == '\\' && *__temp == '}')
                __first = ++__temp;
        }
    }
    return __first;
}

template <class _CharT, class _Traits>
template <class _ForwardIterator>
_ForwardIterator
basic_regex<_CharT, _Traits>::__parse_BACKREF(_ForwardIterator __first,
                                              _ForwardIterator __last)
{
    if (__first != __last)
    {
        _ForwardIterator __temp = std::__1::next(__first);
        if (__temp != __last && *__first == '\\' && __test_back_ref(*__temp))
            __first = ++__temp;
    }
    return __first;
}

template <class _CharT, class _Traits>
template <class _ForwardIterator>
_ForwardIterator
basic_regex<_CharT, _Traits>::__parse_ORD_CHAR(_ForwardIterator __first,
                                               _ForwardIterator __last)
{
    if (__first != __last)
    {
        _ForwardIterator __temp = std::__1::next(__first);
        if (__temp == __last && *__first == '$')
            return __first;

        if (*__first == '.' || *__first == '\\' || *__first == '[')
            return __first;
        __push_char(*__first);
        ++__first;
    }
    return __first;
}

template <class _CharT, class _Traits>
template <class _ForwardIterator>
_ForwardIterator
basic_regex<_CharT, _Traits>::__parse_ORD_CHAR_ERE(_ForwardIterator __first,
                                                   _ForwardIterator __last)
{
    if (__first != __last)
    {
        switch (*__first)
        {
        case '^':
        case '.':
        case '[':
        case '$':
        case '(':
        case '|':
        case '*':
        case '+':
        case '?':
        case '{':
        case '\\':
            break;
        case ')':
            if (__open_count_ == 0)
            {
                __push_char(*__first);
                ++__first;
            }
            break;
        default:
            __push_char(*__first);
            ++__first;
            break;
        }
    }
    return __first;
}

template <class _CharT, class _Traits>
template <class _ForwardIterator>
_ForwardIterator
basic_regex<_CharT, _Traits>::__parse_QUOTED_CHAR(_ForwardIterator __first,
                                                  _ForwardIterator __last)
{
    if (__first != __last)
    {
        _ForwardIterator __temp = std::__1::next(__first);
        if (__temp != __last)
        {
            if (*__first == '\\')
            {
                switch (*__temp)
                {
                case '^':
                case '.':
                case '*':
                case '[':
                case '$':
                case '\\':
                    __push_char(*__temp);
                    __first = ++__temp;
                    break;
                }
            }
        }
    }
    return __first;
}

template <class _CharT, class _Traits>
template <class _ForwardIterator>
_ForwardIterator
basic_regex<_CharT, _Traits>::__parse_QUOTED_CHAR_ERE(_ForwardIterator __first,
                                                      _ForwardIterator __last)
{
    if (__first != __last)
    {
        _ForwardIterator __temp = std::__1::next(__first);
        if (__temp != __last)
        {
            if (*__first == '\\')
            {
                switch (*__temp)
                {
                case '^':
                case '.':
                case '*':
                case '[':
                case '$':
                case '\\':
                case '(':
                case ')':
                case '|':
                case '+':
                case '?':
                case '{':
                case '}':
                    __push_char(*__temp);
                    __first = ++__temp;
                    break;
                default:
                    if (__get_grammar(__flags_) == awk)
                        __first = __parse_awk_escape(++__first, __last);
                    else if(__test_back_ref(*__temp))
                        __first = ++__temp;
                    break;
                }
            }
        }
    }
    return __first;
}

template <class _CharT, class _Traits>
template <class _ForwardIterator>
_ForwardIterator
basic_regex<_CharT, _Traits>::__parse_RE_dupl_symbol(_ForwardIterator __first,
                                                     _ForwardIterator __last,
                                                     __owns_one_state<_CharT>* __s,
                                                     unsigned __mexp_begin,
                                                     unsigned __mexp_end)
{
    if (__first != __last)
    {
        if (*__first == '*')
        {
            __push_greedy_inf_repeat(0, __s, __mexp_begin, __mexp_end);
            ++__first;
        }
        else
        {
            _ForwardIterator __temp = __parse_Back_open_brace(__first, __last);
            if (__temp != __first)
            {
                int __min = 0;
                __first = __temp;
                __temp = __parse_DUP_COUNT(__first, __last, __min);
                if (__temp == __first)
                    __throw_regex_error<regex_constants::error_badbrace>();
                __first = __temp;
                if (__first == __last)
                    __throw_regex_error<regex_constants::error_brace>();
                if (*__first != ',')
                {
                    __temp = __parse_Back_close_brace(__first, __last);
                    if (__temp == __first)
                        __throw_regex_error<regex_constants::error_brace>();
                    __push_loop(__min, __min, __s, __mexp_begin, __mexp_end,
                                    true);
                    __first = __temp;
                }
                else
                {
                    ++__first;
                    int __max = -1;
                    __first = __parse_DUP_COUNT(__first, __last, __max);
                    __temp = __parse_Back_close_brace(__first, __last);
                    if (__temp == __first)
                        __throw_regex_error<regex_constants::error_brace>();
                    if (__max == -1)
                        __push_greedy_inf_repeat(__min, __s, __mexp_begin, __mexp_end);
                    else
                    {
                        if (__max < __min)
                            __throw_regex_error<regex_constants::error_badbrace>();
                        __push_loop(__min, __max, __s, __mexp_begin, __mexp_end,
                                    true);
                    }
                    __first = __temp;
                }
            }
        }
    }
    return __first;
}

template <class _CharT, class _Traits>
template <class _ForwardIterator>
_ForwardIterator
basic_regex<_CharT, _Traits>::__parse_ERE_dupl_symbol(_ForwardIterator __first,
                                                      _ForwardIterator __last,
                                                      __owns_one_state<_CharT>* __s,
                                                      unsigned __mexp_begin,
                                                      unsigned __mexp_end)
{
    if (__first != __last)
    {
        unsigned __grammar = __get_grammar(__flags_);
        switch (*__first)
        {
        case '*':
            ++__first;
            if (__grammar == ECMAScript && __first != __last && *__first == '?')
            {
                ++__first;
                __push_nongreedy_inf_repeat(0, __s, __mexp_begin, __mexp_end);
            }
            else
                __push_greedy_inf_repeat(0, __s, __mexp_begin, __mexp_end);
            break;
        case '+':
            ++__first;
            if (__grammar == ECMAScript && __first != __last && *__first == '?')
            {
                ++__first;
                __push_nongreedy_inf_repeat(1, __s, __mexp_begin, __mexp_end);
            }
            else
                __push_greedy_inf_repeat(1, __s, __mexp_begin, __mexp_end);
            break;
        case '?':
            ++__first;
            if (__grammar == ECMAScript && __first != __last && *__first == '?')
            {
                ++__first;
                __push_loop(0, 1, __s, __mexp_begin, __mexp_end, false);
            }
            else
                __push_loop(0, 1, __s, __mexp_begin, __mexp_end);
            break;
        case '{':
            {
                int __min;
                _ForwardIterator __temp = __parse_DUP_COUNT(++__first, __last, __min);
                if (__temp == __first)
                    __throw_regex_error<regex_constants::error_badbrace>();
                __first = __temp;
                if (__first == __last)
                    __throw_regex_error<regex_constants::error_brace>();
                switch (*__first)
                {
                case '}':
                    ++__first;
                    if (__grammar == ECMAScript && __first != __last && *__first == '?')
                    {
                        ++__first;
                        __push_loop(__min, __min, __s, __mexp_begin, __mexp_end, false);
                    }
                    else
                        __push_loop(__min, __min, __s, __mexp_begin, __mexp_end);
                    break;
                case ',':
                    ++__first;
                    if (__first == __last)
                        __throw_regex_error<regex_constants::error_badbrace>();
                    if (*__first == '}')
                    {
                        ++__first;
                        if (__grammar == ECMAScript && __first != __last && *__first == '?')
                        {
                            ++__first;
                            __push_nongreedy_inf_repeat(__min, __s, __mexp_begin, __mexp_end);
                        }
                        else
                            __push_greedy_inf_repeat(__min, __s, __mexp_begin, __mexp_end);
                    }
                    else
                    {
                        int __max = -1;
                        __temp = __parse_DUP_COUNT(__first, __last, __max);
                        if (__temp == __first)
                            __throw_regex_error<regex_constants::error_brace>();
                        __first = __temp;
                        if (__first == __last || *__first != '}')
                            __throw_regex_error<regex_constants::error_brace>();
                        ++__first;
                        if (__max < __min)
                            __throw_regex_error<regex_constants::error_badbrace>();
                        if (__grammar == ECMAScript && __first != __last && *__first == '?')
                        {
                            ++__first;
                            __push_loop(__min, __max, __s, __mexp_begin, __mexp_end, false);
                        }
                        else
                            __push_loop(__min, __max, __s, __mexp_begin, __mexp_end);
                    }
                    break;
                default:
                    __throw_regex_error<regex_constants::error_badbrace>();
                }
            }
            break;
        }
    }
    return __first;
}

template <class _CharT, class _Traits>
template <class _ForwardIterator>
_ForwardIterator
basic_regex<_CharT, _Traits>::__parse_bracket_expression(_ForwardIterator __first,
                                                         _ForwardIterator __last)
{
    if (__first != __last && *__first == '[')
    {
        ++__first;
        if (__first == __last)
            __throw_regex_error<regex_constants::error_brack>();
        bool __negate = false;
        if (*__first == '^')
        {
            ++__first;
            __negate = true;
        }
        __bracket_expression<_CharT, _Traits>* __ml = __start_matching_list(__negate);

        if (__first == __last)
            __throw_regex_error<regex_constants::error_brack>();
        if (__get_grammar(__flags_) != ECMAScript && *__first == ']')
        {
            __ml->__add_char(']');
            ++__first;
        }
        __first = __parse_follow_list(__first, __last, __ml);
        if (__first == __last)
            __throw_regex_error<regex_constants::error_brack>();
        if (*__first == '-')
        {
            __ml->__add_char('-');
            ++__first;
        }
        if (__first == __last || *__first != ']')
            __throw_regex_error<regex_constants::error_brack>();
        ++__first;
    }
    return __first;
}

template <class _CharT, class _Traits>
template <class _ForwardIterator>
_ForwardIterator
basic_regex<_CharT, _Traits>::__parse_follow_list(_ForwardIterator __first,
                                    _ForwardIterator __last,
                                    __bracket_expression<_CharT, _Traits>* __ml)
{
    if (__first != __last)
    {
        while (true)
        {
            _ForwardIterator __temp = __parse_expression_term(__first, __last,
                                                              __ml);
            if (__temp == __first)
                break;
            __first = __temp;
        }
    }
    return __first;
}

template <class _CharT, class _Traits>
template <class _ForwardIterator>
_ForwardIterator
basic_regex<_CharT, _Traits>::__parse_expression_term(_ForwardIterator __first,
                                    _ForwardIterator __last,
                                    __bracket_expression<_CharT, _Traits>* __ml)
{
    if (__first != __last && *__first != ']')
    {
        _ForwardIterator __temp = std::__1::next(__first);
        basic_string<_CharT> __start_range;
        if (__temp != __last && *__first == '[')
        {
            if (*__temp == '=')
                return __parse_equivalence_class(++__temp, __last, __ml);
            else if (*__temp == ':')
                return __parse_character_class(++__temp, __last, __ml);
            else if (*__temp == '.')
                __first = __parse_collating_symbol(++__temp, __last, __start_range);
        }
        unsigned __grammar = __get_grammar(__flags_);
        if (__start_range.empty())
        {
            if ((__grammar == ECMAScript || __grammar == awk) && *__first == '\\')
            {
                if (__grammar == ECMAScript)
                    __first = __parse_class_escape(++__first, __last, __start_range, __ml);
                else
                    __first = __parse_awk_escape(++__first, __last, &__start_range);
            }
            else
            {
                __start_range = *__first;
                ++__first;
            }
        }
        if (__first != __last && *__first != ']')
        {
            __temp = std::__1::next(__first);
            if (__temp != __last && *__first == '-' && *__temp != ']')
            {

                basic_string<_CharT> __end_range;
                __first = __temp;
                ++__temp;
                if (__temp != __last && *__first == '[' && *__temp == '.')
                    __first = __parse_collating_symbol(++__temp, __last, __end_range);
                else
                {
                    if ((__grammar == ECMAScript || __grammar == awk) && *__first == '\\')
                    {
                        if (__grammar == ECMAScript)
                            __first = __parse_class_escape(++__first, __last,
                                                           __end_range, __ml);
                        else
                            __first = __parse_awk_escape(++__first, __last,
                                                         &__end_range);
                    }
                    else
                    {
                        __end_range = *__first;
                        ++__first;
                    }
                }
                __ml->__add_range(std::__1::move(__start_range), std::__1::move(__end_range));
            }
            else if (!__start_range.empty())
            {
                if (__start_range.size() == 1)
                    __ml->__add_char(__start_range[0]);
                else
                    __ml->__add_digraph(__start_range[0], __start_range[1]);
            }
        }
        else if (!__start_range.empty())
        {
            if (__start_range.size() == 1)
                __ml->__add_char(__start_range[0]);
            else
                __ml->__add_digraph(__start_range[0], __start_range[1]);
        }
    }
    return __first;
}

template <class _CharT, class _Traits>
template <class _ForwardIterator>
_ForwardIterator
basic_regex<_CharT, _Traits>::__parse_class_escape(_ForwardIterator __first,
                          _ForwardIterator __last,
                          basic_string<_CharT>& __str,
                          __bracket_expression<_CharT, _Traits>* __ml)
{
    if (__first == __last)
        __throw_regex_error<regex_constants::error_escape>();
    switch (*__first)
    {
    case 0:
        __str = *__first;
        return ++__first;
    case 'b':
        __str = _CharT(8);
        return ++__first;
    case 'd':
        __ml->__add_class(ctype_base::digit);
        return ++__first;
    case 'D':
        __ml->__add_neg_class(ctype_base::digit);
        return ++__first;
    case 's':
        __ml->__add_class(ctype_base::space);
        return ++__first;
    case 'S':
        __ml->__add_neg_class(ctype_base::space);
        return ++__first;
    case 'w':
        __ml->__add_class(ctype_base::alnum);
        __ml->__add_char('_');
        return ++__first;
    case 'W':
        __ml->__add_neg_class(ctype_base::alnum);
        __ml->__add_neg_char('_');
        return ++__first;
    }
    __first = __parse_character_escape(__first, __last, &__str);
    return __first;
}

template <class _CharT, class _Traits>
template <class _ForwardIterator>
_ForwardIterator
basic_regex<_CharT, _Traits>::__parse_awk_escape(_ForwardIterator __first,
                          _ForwardIterator __last,
                          basic_string<_CharT>* __str)
{
    if (__first == __last)
        __throw_regex_error<regex_constants::error_escape>();
    switch (*__first)
    {
    case '\\':
    case '"':
    case '/':
        if (__str)
            *__str = *__first;
        else
            __push_char(*__first);
        return ++__first;
    case 'a':
        if (__str)
            *__str = _CharT(7);
        else
            __push_char(_CharT(7));
        return ++__first;
    case 'b':
        if (__str)
            *__str = _CharT(8);
        else
            __push_char(_CharT(8));
        return ++__first;
    case 'f':
        if (__str)
            *__str = _CharT(0xC);
        else
            __push_char(_CharT(0xC));
        return ++__first;
    case 'n':
        if (__str)
            *__str = _CharT(0xA);
        else
            __push_char(_CharT(0xA));
        return ++__first;
    case 'r':
        if (__str)
            *__str = _CharT(0xD);
        else
            __push_char(_CharT(0xD));
        return ++__first;
    case 't':
        if (__str)
            *__str = _CharT(0x9);
        else
            __push_char(_CharT(0x9));
        return ++__first;
    case 'v':
        if (__str)
            *__str = _CharT(0xB);
        else
            __push_char(_CharT(0xB));
        return ++__first;
    }
    if ('0' <= *__first && *__first <= '7')
    {
        unsigned __val = *__first - '0';
        if (++__first != __last && ('0' <= *__first && *__first <= '7'))
        {
            __val = 8 * __val + *__first - '0';
            if (++__first != __last && ('0' <= *__first && *__first <= '7'))
                __val = 8 * __val + *__first++ - '0';
        }
        if (__str)
            *__str = _CharT(__val);
        else
            __push_char(_CharT(__val));
    }
    else
        __throw_regex_error<regex_constants::error_escape>();
    return __first;
}

template <class _CharT, class _Traits>
template <class _ForwardIterator>
_ForwardIterator
basic_regex<_CharT, _Traits>::__parse_equivalence_class(_ForwardIterator __first,
                                    _ForwardIterator __last,
                                    __bracket_expression<_CharT, _Traits>* __ml)
{


    value_type _Equal_close[2] = {'=', ']'};
    _ForwardIterator __temp = std::__1::search(__first, __last, _Equal_close,
                                                            _Equal_close+2);
    if (__temp == __last)
        __throw_regex_error<regex_constants::error_brack>();

    string_type __collate_name =
        __traits_.lookup_collatename(__first, __temp);
    if (__collate_name.empty())
        __throw_regex_error<regex_constants::error_collate>();
    string_type __equiv_name =
        __traits_.transform_primary(__collate_name.begin(),
                                    __collate_name.end());
    if (!__equiv_name.empty())
        __ml->__add_equivalence(__equiv_name);
    else
    {
        switch (__collate_name.size())
        {
        case 1:
            __ml->__add_char(__collate_name[0]);
            break;
        case 2:
            __ml->__add_digraph(__collate_name[0], __collate_name[1]);
            break;
        default:
            __throw_regex_error<regex_constants::error_collate>();
        }
    }
    __first = std::__1::next(__temp, 2);
    return __first;
}

template <class _CharT, class _Traits>
template <class _ForwardIterator>
_ForwardIterator
basic_regex<_CharT, _Traits>::__parse_character_class(_ForwardIterator __first,
                                    _ForwardIterator __last,
                                    __bracket_expression<_CharT, _Traits>* __ml)
{


    value_type _Colon_close[2] = {':', ']'};
    _ForwardIterator __temp = std::__1::search(__first, __last, _Colon_close,
                                                            _Colon_close+2);
    if (__temp == __last)
        __throw_regex_error<regex_constants::error_brack>();

    typedef typename _Traits::char_class_type char_class_type;
    char_class_type __class_type =
        __traits_.lookup_classname(__first, __temp, __flags_ & icase);
    if (__class_type == 0)
        __throw_regex_error<regex_constants::error_ctype>();
    __ml->__add_class(__class_type);
    __first = std::__1::next(__temp, 2);
    return __first;
}

template <class _CharT, class _Traits>
template <class _ForwardIterator>
_ForwardIterator
basic_regex<_CharT, _Traits>::__parse_collating_symbol(_ForwardIterator __first,
                                                _ForwardIterator __last,
                                                basic_string<_CharT>& __col_sym)
{


    value_type _Dot_close[2] = {'.', ']'};
    _ForwardIterator __temp = std::__1::search(__first, __last, _Dot_close,
                                                            _Dot_close+2);
    if (__temp == __last)
        __throw_regex_error<regex_constants::error_brack>();

    __col_sym = __traits_.lookup_collatename(__first, __temp);
    switch (__col_sym.size())
    {
    case 1:
    case 2:
        break;
    default:
        __throw_regex_error<regex_constants::error_collate>();
    }
    __first = std::__1::next(__temp, 2);
    return __first;
}

template <class _CharT, class _Traits>
template <class _ForwardIterator>
_ForwardIterator
basic_regex<_CharT, _Traits>::__parse_DUP_COUNT(_ForwardIterator __first,
                                                _ForwardIterator __last,
                                                int& __c)
{
    if (__first != __last )
    {
        int __val = __traits_.value(*__first, 10);
        if ( __val != -1 )
        {
            __c = __val;
            for (++__first;
                 __first != __last && ( __val = __traits_.value(*__first, 10)) != -1;
                 ++__first)
            {
                if (__c >= numeric_limits<int>::max() / 10)
                    __throw_regex_error<regex_constants::error_badbrace>();
                __c *= 10;
                __c += __val;
            }
        }
    }
    return __first;
}

template <class _CharT, class _Traits>
template <class _ForwardIterator>
_ForwardIterator
basic_regex<_CharT, _Traits>::__parse_ecma_exp(_ForwardIterator __first,
                                               _ForwardIterator __last)
{
    __owns_one_state<_CharT>* __sa = __end_;
    _ForwardIterator __temp = __parse_alternative(__first, __last);
    if (__temp == __first)
        __push_empty();
    __first = __temp;
    while (__first != __last && *__first == '|')
    {
        __owns_one_state<_CharT>* __sb = __end_;
        __temp = __parse_alternative(++__first, __last);
        if (__temp == __first)
            __push_empty();
        __push_alternation(__sa, __sb);
        __first = __temp;
    }
    return __first;
}

template <class _CharT, class _Traits>
template <class _ForwardIterator>
_ForwardIterator
basic_regex<_CharT, _Traits>::__parse_alternative(_ForwardIterator __first,
                                                  _ForwardIterator __last)
{
    while (true)
    {
        _ForwardIterator __temp = __parse_term(__first, __last);
        if (__temp == __first)
            break;
        __first = __temp;
    }
    return __first;
}

template <class _CharT, class _Traits>
template <class _ForwardIterator>
_ForwardIterator
basic_regex<_CharT, _Traits>::__parse_term(_ForwardIterator __first,
                                           _ForwardIterator __last)
{
    _ForwardIterator __temp = __parse_assertion(__first, __last);
    if (__temp == __first)
    {
        __owns_one_state<_CharT>* __e = __end_;
        unsigned __mexp_begin = __marked_count_;
        __temp = __parse_atom(__first, __last);
        if (__temp != __first)
            __first = __parse_ERE_dupl_symbol(__temp, __last, __e,
                                              __mexp_begin+1, __marked_count_+1);
    }
    else
        __first = __temp;
    return __first;
}

template <class _CharT, class _Traits>
template <class _ForwardIterator>
_ForwardIterator
basic_regex<_CharT, _Traits>::__parse_assertion(_ForwardIterator __first,
                                                _ForwardIterator __last)
{
    if (__first != __last)
    {
        switch (*__first)
        {
        case '^':
            __push_l_anchor();
            ++__first;
            break;
        case '$':
            __push_r_anchor();
            ++__first;
            break;
        case '\\':
            {
                _ForwardIterator __temp = std::__1::next(__first);
                if (__temp != __last)
                {
                    if (*__temp == 'b')
                    {
                        __push_word_boundary(false);
                        __first = ++__temp;
                    }
                    else if (*__temp == 'B')
                    {
                        __push_word_boundary(true);
                        __first = ++__temp;
                    }
                }
            }
            break;
        case '(':
            {
                _ForwardIterator __temp = std::__1::next(__first);
                if (__temp != __last && *__temp == '?')
                {
                    if (++__temp != __last)
                    {
                        switch (*__temp)
                        {
                        case '=':
                            {
                                basic_regex __exp;
                                __exp.__flags_ = __flags_;
                                __temp = __exp.__parse(++__temp, __last);
                                unsigned __mexp = __exp.__marked_count_;
                                __push_lookahead(std::__1::move(__exp), false, __marked_count_);
                                __marked_count_ += __mexp;
                                if (__temp == __last || *__temp != ')')
                                    __throw_regex_error<regex_constants::error_paren>();
                                __first = ++__temp;
                            }
                            break;
                        case '!':
                            {
                                basic_regex __exp;
                                __exp.__flags_ = __flags_;
                                __temp = __exp.__parse(++__temp, __last);
                                unsigned __mexp = __exp.__marked_count_;
                                __push_lookahead(std::__1::move(__exp), true, __marked_count_);
                                __marked_count_ += __mexp;
                                if (__temp == __last || *__temp != ')')
                                    __throw_regex_error<regex_constants::error_paren>();
                                __first = ++__temp;
                            }
                            break;
                        }
                    }
                }
            }
            break;
        }
    }
    return __first;
}

template <class _CharT, class _Traits>
template <class _ForwardIterator>
_ForwardIterator
basic_regex<_CharT, _Traits>::__parse_atom(_ForwardIterator __first,
                                           _ForwardIterator __last)
{
    if (__first != __last)
    {
        switch (*__first)
        {
        case '.':
            __push_match_any_but_newline();
            ++__first;
            break;
        case '\\':
            __first = __parse_atom_escape(__first, __last);
            break;
        case '[':
            __first = __parse_bracket_expression(__first, __last);
            break;
        case '(':
            {
                ++__first;
                if (__first == __last)
                    __throw_regex_error<regex_constants::error_paren>();
                _ForwardIterator __temp = std::__1::next(__first);
                if (__temp != __last && *__first == '?' && *__temp == ':')
                {
                    ++__open_count_;
                    __first = __parse_ecma_exp(++__temp, __last);
                    if (__first == __last || *__first != ')')
                        __throw_regex_error<regex_constants::error_paren>();
                    --__open_count_;
                    ++__first;
                }
                else
                {
                    __push_begin_marked_subexpression();
                    unsigned __temp_count = __marked_count_;
                    ++__open_count_;
                    __first = __parse_ecma_exp(__first, __last);
                    if (__first == __last || *__first != ')')
                        __throw_regex_error<regex_constants::error_paren>();
                    __push_end_marked_subexpression(__temp_count);
                    --__open_count_;
                    ++__first;
                }
            }
            break;
        case '*':
        case '+':
        case '?':
        case '{':
            __throw_regex_error<regex_constants::error_badrepeat>();
            break;
        default:
            __first = __parse_pattern_character(__first, __last);
            break;
        }
    }
    return __first;
}

template <class _CharT, class _Traits>
template <class _ForwardIterator>
_ForwardIterator
basic_regex<_CharT, _Traits>::__parse_atom_escape(_ForwardIterator __first,
                                                  _ForwardIterator __last)
{
    if (__first != __last && *__first == '\\')
    {
        _ForwardIterator __t1 = std::__1::next(__first);
        if (__t1 == __last)
            __throw_regex_error<regex_constants::error_escape>();

        _ForwardIterator __t2 = __parse_decimal_escape(__t1, __last);
        if (__t2 != __t1)
            __first = __t2;
        else
        {
            __t2 = __parse_character_class_escape(__t1, __last);
            if (__t2 != __t1)
                __first = __t2;
            else
            {
                __t2 = __parse_character_escape(__t1, __last);
                if (__t2 != __t1)
                    __first = __t2;
            }
        }
    }
    return __first;
}

template <class _CharT, class _Traits>
template <class _ForwardIterator>
_ForwardIterator
basic_regex<_CharT, _Traits>::__parse_decimal_escape(_ForwardIterator __first,
                                                     _ForwardIterator __last)
{
    if (__first != __last)
    {
        if (*__first == '0')
        {
            __push_char(_CharT());
            ++__first;
        }
        else if ('1' <= *__first && *__first <= '9')
        {
            unsigned __v = *__first - '0';
            for (++__first;
                    __first != __last && '0' <= *__first && *__first <= '9'; ++__first)
                {
                if (__v >= numeric_limits<unsigned>::max() / 10)
                    __throw_regex_error<regex_constants::error_backref>();
                __v = 10 * __v + *__first - '0';
                }
            if (__v == 0 || __v > mark_count())
                __throw_regex_error<regex_constants::error_backref>();
            __push_back_ref(__v);
        }
    }
    return __first;
}

template <class _CharT, class _Traits>
template <class _ForwardIterator>
_ForwardIterator
basic_regex<_CharT, _Traits>::__parse_character_class_escape(_ForwardIterator __first,
                                                             _ForwardIterator __last)
{
    if (__first != __last)
    {
        __bracket_expression<_CharT, _Traits>* __ml;
        switch (*__first)
        {
        case 'd':
            __ml = __start_matching_list(false);
            __ml->__add_class(ctype_base::digit);
            ++__first;
            break;
        case 'D':
            __ml = __start_matching_list(true);
            __ml->__add_class(ctype_base::digit);
            ++__first;
            break;
        case 's':
            __ml = __start_matching_list(false);
            __ml->__add_class(ctype_base::space);
            ++__first;
            break;
        case 'S':
            __ml = __start_matching_list(true);
            __ml->__add_class(ctype_base::space);
            ++__first;
            break;
        case 'w':
            __ml = __start_matching_list(false);
            __ml->__add_class(ctype_base::alnum);
            __ml->__add_char('_');
            ++__first;
            break;
        case 'W':
            __ml = __start_matching_list(true);
            __ml->__add_class(ctype_base::alnum);
            __ml->__add_char('_');
            ++__first;
            break;
        }
    }
    return __first;
}

template <class _CharT, class _Traits>
template <class _ForwardIterator>
_ForwardIterator
basic_regex<_CharT, _Traits>::__parse_character_escape(_ForwardIterator __first,
                                                    _ForwardIterator __last,
                                                    basic_string<_CharT>* __str)
{
    if (__first != __last)
    {
        _ForwardIterator __t;
        unsigned __sum = 0;
        int __hd;
        switch (*__first)
        {
        case 'f':
            if (__str)
                *__str = _CharT(0xC);
            else
                __push_char(_CharT(0xC));
            ++__first;
            break;
        case 'n':
            if (__str)
                *__str = _CharT(0xA);
            else
                __push_char(_CharT(0xA));
            ++__first;
            break;
        case 'r':
            if (__str)
                *__str = _CharT(0xD);
            else
                __push_char(_CharT(0xD));
            ++__first;
            break;
        case 't':
            if (__str)
                *__str = _CharT(0x9);
            else
                __push_char(_CharT(0x9));
            ++__first;
            break;
        case 'v':
            if (__str)
                *__str = _CharT(0xB);
            else
                __push_char(_CharT(0xB));
            ++__first;
            break;
        case 'c':
            if ((__t = std::__1::next(__first)) != __last)
            {
                if (('A' <= *__t && *__t <= 'Z') ||
                    ('a' <= *__t && *__t <= 'z'))
                {
                    if (__str)
                        *__str = _CharT(*__t % 32);
                    else
                        __push_char(_CharT(*__t % 32));
                    __first = ++__t;
                }
                else
                    __throw_regex_error<regex_constants::error_escape>();
            }
            else
                __throw_regex_error<regex_constants::error_escape>();
            break;
        case 'u':
            ++__first;
            if (__first == __last)
                __throw_regex_error<regex_constants::error_escape>();
            __hd = __traits_.value(*__first, 16);
            if (__hd == -1)
                __throw_regex_error<regex_constants::error_escape>();
            __sum = 16 * __sum + static_cast<unsigned>(__hd);
            ++__first;
            if (__first == __last)
                __throw_regex_error<regex_constants::error_escape>();
            __hd = __traits_.value(*__first, 16);
            if (__hd == -1)
                __throw_regex_error<regex_constants::error_escape>();
            __sum = 16 * __sum + static_cast<unsigned>(__hd);

        case 'x':
            ++__first;
            if (__first == __last)
                __throw_regex_error<regex_constants::error_escape>();
            __hd = __traits_.value(*__first, 16);
            if (__hd == -1)
                __throw_regex_error<regex_constants::error_escape>();
            __sum = 16 * __sum + static_cast<unsigned>(__hd);
            ++__first;
            if (__first == __last)
                __throw_regex_error<regex_constants::error_escape>();
            __hd = __traits_.value(*__first, 16);
            if (__hd == -1)
                __throw_regex_error<regex_constants::error_escape>();
            __sum = 16 * __sum + static_cast<unsigned>(__hd);
            if (__str)
                *__str = _CharT(__sum);
            else
                __push_char(_CharT(__sum));
            ++__first;
            break;
        case '0':
            if (__str)
                *__str = _CharT(0);
            else
                __push_char(_CharT(0));
            ++__first;
            break;
        default:
            if (*__first != '_' && !__traits_.isctype(*__first, ctype_base::alnum))
            {
                if (__str)
                    *__str = *__first;
                else
                    __push_char(*__first);
                ++__first;
            }
            else
                __throw_regex_error<regex_constants::error_escape>();
            break;
        }
    }
    return __first;
}

template <class _CharT, class _Traits>
template <class _ForwardIterator>
_ForwardIterator
basic_regex<_CharT, _Traits>::__parse_pattern_character(_ForwardIterator __first,
                                                        _ForwardIterator __last)
{
    if (__first != __last)
    {
        switch (*__first)
        {
        case '^':
        case '$':
        case '\\':
        case '.':
        case '*':
        case '+':
        case '?':
        case '(':
        case ')':
        case '[':
        case ']':
        case '{':
        case '}':
        case '|':
            break;
        default:
            __push_char(*__first);
            ++__first;
            break;
        }
    }
    return __first;
}

template <class _CharT, class _Traits>
template <class _ForwardIterator>
_ForwardIterator
basic_regex<_CharT, _Traits>::__parse_grep(_ForwardIterator __first,
                                           _ForwardIterator __last)
{
    __owns_one_state<_CharT>* __sa = __end_;
    _ForwardIterator __t1 = std::__1::find(__first, __last, _CharT('\n'));
    if (__t1 != __first)
        __parse_basic_reg_exp(__first, __t1);
    else
        __push_empty();
    __first = __t1;
    if (__first != __last)
        ++__first;
    while (__first != __last)
    {
        __t1 = std::__1::find(__first, __last, _CharT('\n'));
        __owns_one_state<_CharT>* __sb = __end_;
        if (__t1 != __first)
            __parse_basic_reg_exp(__first, __t1);
        else
            __push_empty();
        __push_alternation(__sa, __sb);
        __first = __t1;
        if (__first != __last)
            ++__first;
    }
    return __first;
}

template <class _CharT, class _Traits>
template <class _ForwardIterator>
_ForwardIterator
basic_regex<_CharT, _Traits>::__parse_egrep(_ForwardIterator __first,
                                            _ForwardIterator __last)
{
    __owns_one_state<_CharT>* __sa = __end_;
    _ForwardIterator __t1 = std::__1::find(__first, __last, _CharT('\n'));
    if (__t1 != __first)
        __parse_extended_reg_exp(__first, __t1);
    else
        __push_empty();
    __first = __t1;
    if (__first != __last)
        ++__first;
    while (__first != __last)
    {
        __t1 = std::__1::find(__first, __last, _CharT('\n'));
        __owns_one_state<_CharT>* __sb = __end_;
        if (__t1 != __first)
            __parse_extended_reg_exp(__first, __t1);
        else
            __push_empty();
        __push_alternation(__sa, __sb);
        __first = __t1;
        if (__first != __last)
            ++__first;
    }
    return __first;
}

template <class _CharT, class _Traits>
bool
basic_regex<_CharT, _Traits>::__test_back_ref(_CharT c)
{
    unsigned __val = __traits_.value(c, 10);
    if (__val >= 1 && __val <= 9)
    {
        if (__val > mark_count())
            __throw_regex_error<regex_constants::error_backref>();
        __push_back_ref(__val);
        return true;
    }

    return false;
}

template <class _CharT, class _Traits>
void
basic_regex<_CharT, _Traits>::__push_loop(size_t __min, size_t __max,
        __owns_one_state<_CharT>* __s, size_t __mexp_begin, size_t __mexp_end,
        bool __greedy)
{
    unique_ptr<__empty_state<_CharT> > __e1(new __empty_state<_CharT>(__end_->first()));
    __end_->first() = nullptr;
    unique_ptr<__loop<_CharT> > __e2(new __loop<_CharT>(__loop_count_,
                __s->first(), __e1.get(), __mexp_begin, __mexp_end, __greedy,
                __min, __max));
    __s->first() = nullptr;
    __e1.release();
    __end_->first() = new __repeat_one_loop<_CharT>(__e2.get());
    __end_ = __e2->second();
    __s->first() = __e2.release();
    ++__loop_count_;
}

template <class _CharT, class _Traits>
void
basic_regex<_CharT, _Traits>::__push_char(value_type __c)
{
    if (flags() & icase)
        __end_->first() = new __match_char_icase<_CharT, _Traits>
                                              (__traits_, __c, __end_->first());
    else if (flags() & collate)
        __end_->first() = new __match_char_collate<_CharT, _Traits>
                                              (__traits_, __c, __end_->first());
    else
        __end_->first() = new __match_char<_CharT>(__c, __end_->first());
    __end_ = static_cast<__owns_one_state<_CharT>*>(__end_->first());
}

template <class _CharT, class _Traits>
void
basic_regex<_CharT, _Traits>::__push_begin_marked_subexpression()
{
    if (!(__flags_ & nosubs))
    {
        __end_->first() =
                new __begin_marked_subexpression<_CharT>(++__marked_count_,
                                                         __end_->first());
        __end_ = static_cast<__owns_one_state<_CharT>*>(__end_->first());
    }
}

template <class _CharT, class _Traits>
void
basic_regex<_CharT, _Traits>::__push_end_marked_subexpression(unsigned __sub)
{
    if (!(__flags_ & nosubs))
    {
        __end_->first() =
                new __end_marked_subexpression<_CharT>(__sub, __end_->first());
        __end_ = static_cast<__owns_one_state<_CharT>*>(__end_->first());
    }
}

template <class _CharT, class _Traits>
void
basic_regex<_CharT, _Traits>::__push_l_anchor()
{
    __end_->first() = new __l_anchor_multiline<_CharT>(__use_multiline(), __end_->first());
    __end_ = static_cast<__owns_one_state<_CharT>*>(__end_->first());
}

template <class _CharT, class _Traits>
void
basic_regex<_CharT, _Traits>::__push_r_anchor()
{
    __end_->first() = new __r_anchor_multiline<_CharT>(__use_multiline(), __end_->first());
    __end_ = static_cast<__owns_one_state<_CharT>*>(__end_->first());
}

template <class _CharT, class _Traits>
void
basic_regex<_CharT, _Traits>::__push_match_any()
{
    __end_->first() = new __match_any<_CharT>(__end_->first());
    __end_ = static_cast<__owns_one_state<_CharT>*>(__end_->first());
}

template <class _CharT, class _Traits>
void
basic_regex<_CharT, _Traits>::__push_match_any_but_newline()
{
    __end_->first() = new __match_any_but_newline<_CharT>(__end_->first());
    __end_ = static_cast<__owns_one_state<_CharT>*>(__end_->first());
}

template <class _CharT, class _Traits>
void
basic_regex<_CharT, _Traits>::__push_empty()
{
    __end_->first() = new __empty_state<_CharT>(__end_->first());
    __end_ = static_cast<__owns_one_state<_CharT>*>(__end_->first());
}

template <class _CharT, class _Traits>
void
basic_regex<_CharT, _Traits>::__push_word_boundary(bool __invert)
{
    __end_->first() = new __word_boundary<_CharT, _Traits>(__traits_, __invert,
                                                           __end_->first());
    __end_ = static_cast<__owns_one_state<_CharT>*>(__end_->first());
}

template <class _CharT, class _Traits>
void
basic_regex<_CharT, _Traits>::__push_back_ref(int __i)
{
    if (flags() & icase)
        __end_->first() = new __back_ref_icase<_CharT, _Traits>
                                              (__traits_, __i, __end_->first());
    else if (flags() & collate)
        __end_->first() = new __back_ref_collate<_CharT, _Traits>
                                              (__traits_, __i, __end_->first());
    else
        __end_->first() = new __back_ref<_CharT>(__i, __end_->first());
    __end_ = static_cast<__owns_one_state<_CharT>*>(__end_->first());
}

template <class _CharT, class _Traits>
void
basic_regex<_CharT, _Traits>::__push_alternation(__owns_one_state<_CharT>* __sa,
                                                 __owns_one_state<_CharT>* __ea)
{
    __sa->first() = new __alternate<_CharT>(
                         static_cast<__owns_one_state<_CharT>*>(__sa->first()),
                         static_cast<__owns_one_state<_CharT>*>(__ea->first()));
    __ea->first() = nullptr;
    __ea->first() = new __empty_state<_CharT>(__end_->first());
    __end_->first() = nullptr;
    __end_->first() = new __empty_non_own_state<_CharT>(__ea->first());
    __end_ = static_cast<__owns_one_state<_CharT>*>(__ea->first());
}

template <class _CharT, class _Traits>
__bracket_expression<_CharT, _Traits>*
basic_regex<_CharT, _Traits>::__start_matching_list(bool __negate)
{
    __bracket_expression<_CharT, _Traits>* __r =
        new __bracket_expression<_CharT, _Traits>(__traits_, __end_->first(),
                                                  __negate, __flags_ & icase,
                                                  __flags_ & collate);
    __end_->first() = __r;
    __end_ = __r;
    return __r;
}

template <class _CharT, class _Traits>
void
basic_regex<_CharT, _Traits>::__push_lookahead(const basic_regex& __exp,
                                               bool __invert,
                                               unsigned __mexp)
{
    __end_->first() = new __lookahead<_CharT, _Traits>(__exp, __invert,
                                                           __end_->first(), __mexp);
    __end_ = static_cast<__owns_one_state<_CharT>*>(__end_->first());
}



typedef sub_match<const char*> csub_match;
typedef sub_match<string::const_iterator> ssub_match;

typedef sub_match<const wchar_t*> wcsub_match;
typedef sub_match<wstring::const_iterator> wssub_match;


template <class _BidirectionalIterator>
class
    __attribute__ ((__type_visibility__("default")))
    __attribute__((__preferred_name__(csub_match)))
    __attribute__((__preferred_name__(wcsub_match)))
    __attribute__((__preferred_name__(ssub_match)))
    __attribute__((__preferred_name__(wssub_match)))
    sub_match
    : public pair<_BidirectionalIterator, _BidirectionalIterator>
{
public:
    typedef _BidirectionalIterator iterator;
    typedef typename iterator_traits<iterator>::value_type value_type;
    typedef typename iterator_traits<iterator>::difference_type difference_type;
    typedef basic_string<value_type> string_type;

    bool matched;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    constexpr sub_match() : matched() {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    difference_type length() const
        {return matched ? std::__1::distance(this->first, this->second) : 0;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    string_type str() const
        {return matched ? string_type(this->first, this->second) : string_type();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    operator string_type() const
        {return str();}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    int compare(const sub_match& __s) const
        {return str().compare(__s.str());}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    int compare(const string_type& __s) const
        {return str().compare(__s);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    int compare(const value_type* __s) const
        {return str().compare(__s);}
};

template <class _BiIter>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator==(const sub_match<_BiIter>& __x, const sub_match<_BiIter>& __y)
{
    return __x.compare(__y) == 0;
}

template <class _BiIter>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator!=(const sub_match<_BiIter>& __x, const sub_match<_BiIter>& __y)
{
    return !(__x == __y);
}

template <class _BiIter>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator<(const sub_match<_BiIter>& __x, const sub_match<_BiIter>& __y)
{
    return __x.compare(__y) < 0;
}

template <class _BiIter>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator<=(const sub_match<_BiIter>& __x, const sub_match<_BiIter>& __y)
{
    return !(__y < __x);
}

template <class _BiIter>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator>=(const sub_match<_BiIter>& __x, const sub_match<_BiIter>& __y)
{
    return !(__x < __y);
}

template <class _BiIter>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator>(const sub_match<_BiIter>& __x, const sub_match<_BiIter>& __y)
{
    return __y < __x;
}

template <class _BiIter, class _ST, class _SA>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator==(const basic_string<typename iterator_traits<_BiIter>::value_type, _ST, _SA>& __x,
           const sub_match<_BiIter>& __y)
{
    return __y.compare(typename sub_match<_BiIter>::string_type(__x.data(), __x.size())) == 0;
}

template <class _BiIter, class _ST, class _SA>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator!=(const basic_string<typename iterator_traits<_BiIter>::value_type, _ST, _SA>& __x,
           const sub_match<_BiIter>& __y)
{
    return !(__x == __y);
}

template <class _BiIter, class _ST, class _SA>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator<(const basic_string<typename iterator_traits<_BiIter>::value_type, _ST, _SA>& __x,
          const sub_match<_BiIter>& __y)
{
    return __y.compare(typename sub_match<_BiIter>::string_type(__x.data(), __x.size())) > 0;
}

template <class _BiIter, class _ST, class _SA>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator>(const basic_string<typename iterator_traits<_BiIter>::value_type, _ST, _SA>& __x,
          const sub_match<_BiIter>& __y)
{
    return __y < __x;
}

template <class _BiIter, class _ST, class _SA>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool operator>=(const basic_string<typename iterator_traits<_BiIter>::value_type, _ST, _SA>& __x,
                const sub_match<_BiIter>& __y)
{
    return !(__x < __y);
}

template <class _BiIter, class _ST, class _SA>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator<=(const basic_string<typename iterator_traits<_BiIter>::value_type, _ST, _SA>& __x,
           const sub_match<_BiIter>& __y)
{
    return !(__y < __x);
}

template <class _BiIter, class _ST, class _SA>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator==(const sub_match<_BiIter>& __x,
           const basic_string<typename iterator_traits<_BiIter>::value_type, _ST, _SA>& __y)
{
    return __x.compare(typename sub_match<_BiIter>::string_type(__y.data(), __y.size())) == 0;
}

template <class _BiIter, class _ST, class _SA>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator!=(const sub_match<_BiIter>& __x,
           const basic_string<typename iterator_traits<_BiIter>::value_type, _ST, _SA>& __y)
{
    return !(__x == __y);
}

template <class _BiIter, class _ST, class _SA>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator<(const sub_match<_BiIter>& __x,
          const basic_string<typename iterator_traits<_BiIter>::value_type, _ST, _SA>& __y)
{
    return __x.compare(typename sub_match<_BiIter>::string_type(__y.data(), __y.size())) < 0;
}

template <class _BiIter, class _ST, class _SA>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool operator>(const sub_match<_BiIter>& __x,
               const basic_string<typename iterator_traits<_BiIter>::value_type, _ST, _SA>& __y)
{
    return __y < __x;
}

template <class _BiIter, class _ST, class _SA>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator>=(const sub_match<_BiIter>& __x,
           const basic_string<typename iterator_traits<_BiIter>::value_type, _ST, _SA>& __y)
{
    return !(__x < __y);
}

template <class _BiIter, class _ST, class _SA>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator<=(const sub_match<_BiIter>& __x,
           const basic_string<typename iterator_traits<_BiIter>::value_type, _ST, _SA>& __y)
{
    return !(__y < __x);
}

template <class _BiIter>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator==(typename iterator_traits<_BiIter>::value_type const* __x,
           const sub_match<_BiIter>& __y)
{
    return __y.compare(__x) == 0;
}

template <class _BiIter>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator!=(typename iterator_traits<_BiIter>::value_type const* __x,
           const sub_match<_BiIter>& __y)
{
    return !(__x == __y);
}

template <class _BiIter>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator<(typename iterator_traits<_BiIter>::value_type const* __x,
          const sub_match<_BiIter>& __y)
{
    return __y.compare(__x) > 0;
}

template <class _BiIter>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator>(typename iterator_traits<_BiIter>::value_type const* __x,
          const sub_match<_BiIter>& __y)
{
    return __y < __x;
}

template <class _BiIter>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator>=(typename iterator_traits<_BiIter>::value_type const* __x,
           const sub_match<_BiIter>& __y)
{
    return !(__x < __y);
}

template <class _BiIter>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator<=(typename iterator_traits<_BiIter>::value_type const* __x,
           const sub_match<_BiIter>& __y)
{
    return !(__y < __x);
}

template <class _BiIter>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator==(const sub_match<_BiIter>& __x,
           typename iterator_traits<_BiIter>::value_type const* __y)
{
    return __x.compare(__y) == 0;
}

template <class _BiIter>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator!=(const sub_match<_BiIter>& __x,
           typename iterator_traits<_BiIter>::value_type const* __y)
{
    return !(__x == __y);
}

template <class _BiIter>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator<(const sub_match<_BiIter>& __x,
          typename iterator_traits<_BiIter>::value_type const* __y)
{
    return __x.compare(__y) < 0;
}

template <class _BiIter>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator>(const sub_match<_BiIter>& __x,
          typename iterator_traits<_BiIter>::value_type const* __y)
{
    return __y < __x;
}

template <class _BiIter>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator>=(const sub_match<_BiIter>& __x,
           typename iterator_traits<_BiIter>::value_type const* __y)
{
    return !(__x < __y);
}

template <class _BiIter>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator<=(const sub_match<_BiIter>& __x,
           typename iterator_traits<_BiIter>::value_type const* __y)
{
    return !(__y < __x);
}

template <class _BiIter>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator==(typename iterator_traits<_BiIter>::value_type const& __x,
           const sub_match<_BiIter>& __y)
{
    typedef basic_string<typename iterator_traits<_BiIter>::value_type> string_type;
    return __y.compare(string_type(1, __x)) == 0;
}

template <class _BiIter>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator!=(typename iterator_traits<_BiIter>::value_type const& __x,
           const sub_match<_BiIter>& __y)
{
    return !(__x == __y);
}

template <class _BiIter>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator<(typename iterator_traits<_BiIter>::value_type const& __x,
          const sub_match<_BiIter>& __y)
{
    typedef basic_string<typename iterator_traits<_BiIter>::value_type> string_type;
    return __y.compare(string_type(1, __x)) > 0;
}

template <class _BiIter>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator>(typename iterator_traits<_BiIter>::value_type const& __x,
          const sub_match<_BiIter>& __y)
{
    return __y < __x;
}

template <class _BiIter>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator>=(typename iterator_traits<_BiIter>::value_type const& __x,
           const sub_match<_BiIter>& __y)
{
    return !(__x < __y);
}

template <class _BiIter>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator<=(typename iterator_traits<_BiIter>::value_type const& __x,
           const sub_match<_BiIter>& __y)
{
    return !(__y < __x);
}

template <class _BiIter>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator==(const sub_match<_BiIter>& __x,
           typename iterator_traits<_BiIter>::value_type const& __y)
{
    typedef basic_string<typename iterator_traits<_BiIter>::value_type> string_type;
    return __x.compare(string_type(1, __y)) == 0;
}

template <class _BiIter>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator!=(const sub_match<_BiIter>& __x,
           typename iterator_traits<_BiIter>::value_type const& __y)
{
    return !(__x == __y);
}

template <class _BiIter>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator<(const sub_match<_BiIter>& __x,
          typename iterator_traits<_BiIter>::value_type const& __y)
{
    typedef basic_string<typename iterator_traits<_BiIter>::value_type> string_type;
    return __x.compare(string_type(1, __y)) < 0;
}

template <class _BiIter>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator>(const sub_match<_BiIter>& __x,
          typename iterator_traits<_BiIter>::value_type const& __y)
{
    return __y < __x;
}

template <class _BiIter>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator>=(const sub_match<_BiIter>& __x,
           typename iterator_traits<_BiIter>::value_type const& __y)
{
    return !(__x < __y);
}

template <class _BiIter>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator<=(const sub_match<_BiIter>& __x,
           typename iterator_traits<_BiIter>::value_type const& __y)
{
    return !(__y < __x);
}

template <class _CharT, class _ST, class _BiIter>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
basic_ostream<_CharT, _ST>&
operator<<(basic_ostream<_CharT, _ST>& __os, const sub_match<_BiIter>& __m)
{
    return __os << __m.str();
}

typedef match_results<const char*> cmatch;
typedef match_results<string::const_iterator> smatch;

typedef match_results<const wchar_t*> wcmatch;
typedef match_results<wstring::const_iterator> wsmatch;


template <class _BidirectionalIterator, class _Allocator>
class
    __attribute__ ((__type_visibility__("default")))
    __attribute__((__preferred_name__(cmatch)))
    __attribute__((__preferred_name__(wcmatch)))
    __attribute__((__preferred_name__(smatch)))
    __attribute__((__preferred_name__(wsmatch)))
    match_results
{
public:
    typedef _Allocator allocator_type;
    typedef sub_match<_BidirectionalIterator> value_type;
private:
    typedef vector<value_type, allocator_type> __container_type;

    __container_type __matches_;
    value_type __unmatched_;
    value_type __prefix_;
    value_type __suffix_;
    bool __ready_;
public:
    _BidirectionalIterator __position_start_;
    typedef const value_type& const_reference;
    typedef value_type& reference;
    typedef typename __container_type::const_iterator const_iterator;
    typedef const_iterator iterator;
    typedef typename iterator_traits<_BidirectionalIterator>::difference_type difference_type;
    typedef typename allocator_traits<allocator_type>::size_type size_type;
    typedef typename iterator_traits<_BidirectionalIterator>::value_type char_type;
    typedef basic_string<char_type> string_type;



    match_results() : match_results(allocator_type()) {}
    explicit match_results(const allocator_type& __a);
# 5400 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/regex" 3
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    bool ready() const {return __ready_;}


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_type size() const noexcept {return __matches_.size();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_type max_size() const noexcept {return __matches_.max_size();}
                                  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    bool empty() const noexcept {return size() == 0;}


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    difference_type length(size_type __sub = 0) const
        {
        ((void)0);
        return (*this)[__sub].length();
        }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    difference_type position(size_type __sub = 0) const
        {
        ((void)0);
        return std::__1::distance(__position_start_, (*this)[__sub].first);
        }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    string_type str(size_type __sub = 0) const
        {
        ((void)0);
        return (*this)[__sub].str();
        }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_reference operator[](size_type __n) const
        {
        ((void)0);
        return __n < __matches_.size() ? __matches_[__n] : __unmatched_;
        }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_reference prefix() const
        {
        ((void)0);
        return __prefix_;
        }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_reference suffix() const
        {
        ((void)0);
        return __suffix_;
        }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_iterator begin() const {return empty() ? __matches_.end() : __matches_.begin();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_iterator end() const {return __matches_.end();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_iterator cbegin() const {return empty() ? __matches_.end() : __matches_.begin();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_iterator cend() const {return __matches_.end();}


    template <class _OutputIter>
        _OutputIter
        format(_OutputIter __output_iter, const char_type* __fmt_first,
               const char_type* __fmt_last,
               regex_constants::match_flag_type __flags = regex_constants::format_default) const;
    template <class _OutputIter, class _ST, class _SA>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        _OutputIter
        format(_OutputIter __output_iter, const basic_string<char_type, _ST, _SA>& __fmt,
               regex_constants::match_flag_type __flags = regex_constants::format_default) const
            {return format(__output_iter, __fmt.data(), __fmt.data() + __fmt.size(), __flags);}
    template <class _ST, class _SA>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        basic_string<char_type, _ST, _SA>
        format(const basic_string<char_type, _ST, _SA>& __fmt,
               regex_constants::match_flag_type __flags = regex_constants::format_default) const
        {
            basic_string<char_type, _ST, _SA> __r;
            format(back_inserter(__r), __fmt.data(), __fmt.data() + __fmt.size(),
                   __flags);
            return __r;
        }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    string_type
        format(const char_type* __fmt,
               regex_constants::match_flag_type __flags = regex_constants::format_default) const
        {
            string_type __r;
            format(back_inserter(__r), __fmt,
                   __fmt + char_traits<char_type>::length(__fmt), __flags);
            return __r;
        }


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    allocator_type get_allocator() const {return __matches_.get_allocator();}


    void swap(match_results& __m);

    template <class _Bp, class _Ap>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        void __assign(_BidirectionalIterator __f, _BidirectionalIterator __l,
                      const match_results<_Bp, _Ap>& __m, bool __no_update_pos)
    {
        _Bp __mf = __m.prefix().first;
        __matches_.resize(__m.size());
        for (size_type __i = 0; __i < __matches_.size(); ++__i)
        {
            __matches_[__i].first = std::__1::next(__f, std::__1::distance(__mf, __m[__i].first));
            __matches_[__i].second = std::__1::next(__f, std::__1::distance(__mf, __m[__i].second));
            __matches_[__i].matched = __m[__i].matched;
        }
        __unmatched_.first = __l;
        __unmatched_.second = __l;
        __unmatched_.matched = false;
        __prefix_.first = std::__1::next(__f, std::__1::distance(__mf, __m.prefix().first));
        __prefix_.second = std::__1::next(__f, std::__1::distance(__mf, __m.prefix().second));
        __prefix_.matched = __m.prefix().matched;
        __suffix_.first = std::__1::next(__f, std::__1::distance(__mf, __m.suffix().first));
        __suffix_.second = std::__1::next(__f, std::__1::distance(__mf, __m.suffix().second));
        __suffix_.matched = __m.suffix().matched;
        if (!__no_update_pos)
            __position_start_ = __prefix_.first;
        __ready_ = __m.ready();
    }

private:
    void __init(unsigned __s,
                _BidirectionalIterator __f, _BidirectionalIterator __l,
                bool __no_update_pos = false);

    template <class, class> friend class basic_regex;

    template <class _Bp, class _Ap, class _Cp, class _Tp>
    friend
    bool
    regex_match(_Bp, _Bp, match_results<_Bp, _Ap>&, const basic_regex<_Cp, _Tp>&,
                regex_constants::match_flag_type);

    template <class _Bp, class _Ap>
    friend
    bool
    operator==(const match_results<_Bp, _Ap>&, const match_results<_Bp, _Ap>&);

    template <class, class> friend class __lookahead;
};

template <class _BidirectionalIterator, class _Allocator>
match_results<_BidirectionalIterator, _Allocator>::match_results(
        const allocator_type& __a)
    : __matches_(__a),
      __unmatched_(),
      __prefix_(),
      __suffix_(),
      __ready_(false),
      __position_start_()
{
}

template <class _BidirectionalIterator, class _Allocator>
void
match_results<_BidirectionalIterator, _Allocator>::__init(unsigned __s,
                         _BidirectionalIterator __f, _BidirectionalIterator __l,
                         bool __no_update_pos)
{
    __unmatched_.first = __l;
    __unmatched_.second = __l;
    __unmatched_.matched = false;
    __matches_.assign(__s, __unmatched_);
    __prefix_.first = __f;
    __prefix_.second = __f;
    __prefix_.matched = false;
    __suffix_ = __unmatched_;
    if (!__no_update_pos)
        __position_start_ = __prefix_.first;
    __ready_ = true;
}

template <class _BidirectionalIterator, class _Allocator>
template <class _OutputIter>
_OutputIter
match_results<_BidirectionalIterator, _Allocator>::format(_OutputIter __output_iter,
        const char_type* __fmt_first, const char_type* __fmt_last,
        regex_constants::match_flag_type __flags) const
{
    ((void)0);
    if (__flags & regex_constants::format_sed)
    {
        for (; __fmt_first != __fmt_last; ++__fmt_first)
        {
            if (*__fmt_first == '&')
                __output_iter = std::__1::copy(__matches_[0].first, __matches_[0].second,
                                   __output_iter);
            else if (*__fmt_first == '\\' && __fmt_first + 1 != __fmt_last)
            {
                ++__fmt_first;
                if ('0' <= *__fmt_first && *__fmt_first <= '9')
                {
                    size_t __i = *__fmt_first - '0';
                    __output_iter = std::__1::copy((*this)[__i].first,
                                        (*this)[__i].second, __output_iter);
                }
                else
                {
                    *__output_iter = *__fmt_first;
                    ++__output_iter;
                }
            }
            else
            {
                *__output_iter = *__fmt_first;
                ++__output_iter;
            }
        }
    }
    else
    {
        for (; __fmt_first != __fmt_last; ++__fmt_first)
        {
            if (*__fmt_first == '$' && __fmt_first + 1 != __fmt_last)
            {
                switch (__fmt_first[1])
                {
                case '$':
                    *__output_iter = *++__fmt_first;
                    ++__output_iter;
                    break;
                case '&':
                    ++__fmt_first;
                    __output_iter = std::__1::copy(__matches_[0].first, __matches_[0].second,
                                       __output_iter);
                    break;
                case '`':
                    ++__fmt_first;
                    __output_iter = std::__1::copy(__prefix_.first, __prefix_.second, __output_iter);
                    break;
                case '\'':
                    ++__fmt_first;
                    __output_iter = std::__1::copy(__suffix_.first, __suffix_.second, __output_iter);
                    break;
                default:
                    if ('0' <= __fmt_first[1] && __fmt_first[1] <= '9')
                    {
                        ++__fmt_first;
                        size_t __idx = *__fmt_first - '0';
                        if (__fmt_first + 1 != __fmt_last &&
                            '0' <= __fmt_first[1] && __fmt_first[1] <= '9')
                        {
                            ++__fmt_first;
                            if (__idx >= numeric_limits<size_t>::max() / 10)
                                __throw_regex_error<regex_constants::error_escape>();
                            __idx = 10 * __idx + *__fmt_first - '0';
                        }
                        __output_iter = std::__1::copy((*this)[__idx].first,
                                            (*this)[__idx].second, __output_iter);
                    }
                    else
                    {
                        *__output_iter = *__fmt_first;
                        ++__output_iter;
                    }
                    break;
                }
            }
            else
            {
                *__output_iter = *__fmt_first;
                ++__output_iter;
            }
        }
    }
    return __output_iter;
}

template <class _BidirectionalIterator, class _Allocator>
void
match_results<_BidirectionalIterator, _Allocator>::swap(match_results& __m)
{
    using std::__1::swap;
    swap(__matches_, __m.__matches_);
    swap(__unmatched_, __m.__unmatched_);
    swap(__prefix_, __m.__prefix_);
    swap(__suffix_, __m.__suffix_);
    swap(__position_start_, __m.__position_start_);
    swap(__ready_, __m.__ready_);
}

template <class _BidirectionalIterator, class _Allocator>
bool
operator==(const match_results<_BidirectionalIterator, _Allocator>& __x,
           const match_results<_BidirectionalIterator, _Allocator>& __y)
{
    if (__x.__ready_ != __y.__ready_)
        return false;
    if (!__x.__ready_)
        return true;
    return __x.__matches_ == __y.__matches_ &&
           __x.__prefix_ == __y.__prefix_ &&
           __x.__suffix_ == __y.__suffix_;
}

template <class _BidirectionalIterator, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator!=(const match_results<_BidirectionalIterator, _Allocator>& __x,
           const match_results<_BidirectionalIterator, _Allocator>& __y)
{
    return !(__x == __y);
}

template <class _BidirectionalIterator, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void
swap(match_results<_BidirectionalIterator, _Allocator>& __x,
     match_results<_BidirectionalIterator, _Allocator>& __y)
{
    __x.swap(__y);
}



template <class _CharT, class _Traits>
template <class _Allocator>
bool
basic_regex<_CharT, _Traits>::__match_at_start_ecma(
        const _CharT* __first, const _CharT* __last,
        match_results<const _CharT*, _Allocator>& __m,
        regex_constants::match_flag_type __flags, bool __at_first) const
{
    vector<__state> __states;
    __node* __st = __start_.get();
    if (__st)
    {
        sub_match<const _CharT*> __unmatched;
        __unmatched.first = __last;
        __unmatched.second = __last;
        __unmatched.matched = false;

        __states.push_back(__state());
        __states.back().__do_ = 0;
        __states.back().__first_ = __first;
        __states.back().__current_ = __first;
        __states.back().__last_ = __last;
        __states.back().__sub_matches_.resize(mark_count(), __unmatched);
        __states.back().__loop_data_.resize(__loop_count());
        __states.back().__node_ = __st;
        __states.back().__flags_ = __flags;
        __states.back().__at_first_ = __at_first;
        int __counter = 0;
        int __length = __last - __first;
        do
        {
            ++__counter;
            if (__counter % 4096 == 0 &&
                __counter / 4096 >= __length)
              __throw_regex_error<regex_constants::error_complexity>();
            __state& __s = __states.back();
            if (__s.__node_)
                __s.__node_->__exec(__s);
            switch (__s.__do_)
            {
            case __state::__end_state:
                if ((__flags & regex_constants::match_not_null) &&
                    __s.__current_ == __first)
                {
                  __states.pop_back();
                  break;
                }
                if ((__flags & regex_constants::__full_match) &&
                    __s.__current_ != __last)
                {
                  __states.pop_back();
                  break;
                }
                __m.__matches_[0].first = __first;
                __m.__matches_[0].second = std::__1::next(__first, __s.__current_ - __first);
                __m.__matches_[0].matched = true;
                for (unsigned __i = 0; __i < __s.__sub_matches_.size(); ++__i)
                    __m.__matches_[__i+1] = __s.__sub_matches_[__i];
                return true;
            case __state::__accept_and_consume:
            case __state::__repeat:
            case __state::__accept_but_not_consume:
                break;
            case __state::__split:
                {
                __state __snext = __s;
                __s.__node_->__exec_split(true, __s);
                __snext.__node_->__exec_split(false, __snext);
                __states.push_back(std::__1::move(__snext));
                }
                break;
            case __state::__reject:
                __states.pop_back();
                break;
            default:
                __throw_regex_error<regex_constants::__re_err_unknown>();
                break;

            }
        } while (!__states.empty());
    }
    return false;
}

template <class _CharT, class _Traits>
template <class _Allocator>
bool
basic_regex<_CharT, _Traits>::__match_at_start_posix_nosubs(
        const _CharT* __first, const _CharT* __last,
        match_results<const _CharT*, _Allocator>& __m,
        regex_constants::match_flag_type __flags, bool __at_first) const
{
    deque<__state> __states;
    ptrdiff_t __highest_j = 0;
    ptrdiff_t _Np = std::__1::distance(__first, __last);
    __node* __st = __start_.get();
    if (__st)
    {
        __states.push_back(__state());
        __states.back().__do_ = 0;
        __states.back().__first_ = __first;
        __states.back().__current_ = __first;
        __states.back().__last_ = __last;
        __states.back().__loop_data_.resize(__loop_count());
        __states.back().__node_ = __st;
        __states.back().__flags_ = __flags;
        __states.back().__at_first_ = __at_first;
        bool __matched = false;
        int __counter = 0;
        int __length = __last - __first;
        do
        {
            ++__counter;
            if (__counter % 4096 == 0 &&
                __counter / 4096 >= __length)
              __throw_regex_error<regex_constants::error_complexity>();
            __state& __s = __states.back();
            if (__s.__node_)
                __s.__node_->__exec(__s);
            switch (__s.__do_)
            {
            case __state::__end_state:
                if ((__flags & regex_constants::match_not_null) &&
                    __s.__current_ == __first)
                {
                  __states.pop_back();
                  break;
                }
                if ((__flags & regex_constants::__full_match) &&
                    __s.__current_ != __last)
                {
                  __states.pop_back();
                  break;
                }
                if (!__matched || __highest_j < __s.__current_ - __s.__first_)
                    __highest_j = __s.__current_ - __s.__first_;
                __matched = true;
                if (__highest_j == _Np)
                    __states.clear();
                else
                    __states.pop_back();
                break;
            case __state::__consume_input:
                break;
            case __state::__accept_and_consume:
                __states.push_front(std::__1::move(__s));
                __states.pop_back();
                break;
            case __state::__repeat:
            case __state::__accept_but_not_consume:
                break;
            case __state::__split:
                {
                __state __snext = __s;
                __s.__node_->__exec_split(true, __s);
                __snext.__node_->__exec_split(false, __snext);
                __states.push_back(std::__1::move(__snext));
                }
                break;
            case __state::__reject:
                __states.pop_back();
                break;
            default:
                __throw_regex_error<regex_constants::__re_err_unknown>();
                break;
            }
        } while (!__states.empty());
        if (__matched)
        {
            __m.__matches_[0].first = __first;
            __m.__matches_[0].second = std::__1::next(__first, __highest_j);
            __m.__matches_[0].matched = true;
            return true;
        }
    }
    return false;
}

template <class _CharT, class _Traits>
template <class _Allocator>
bool
basic_regex<_CharT, _Traits>::__match_at_start_posix_subs(
        const _CharT* __first, const _CharT* __last,
        match_results<const _CharT*, _Allocator>& __m,
        regex_constants::match_flag_type __flags, bool __at_first) const
{
    vector<__state> __states;
    __state __best_state;
    ptrdiff_t __highest_j = 0;
    ptrdiff_t _Np = std::__1::distance(__first, __last);
    __node* __st = __start_.get();
    if (__st)
    {
        sub_match<const _CharT*> __unmatched;
        __unmatched.first = __last;
        __unmatched.second = __last;
        __unmatched.matched = false;

        __states.push_back(__state());
        __states.back().__do_ = 0;
        __states.back().__first_ = __first;
        __states.back().__current_ = __first;
        __states.back().__last_ = __last;
        __states.back().__sub_matches_.resize(mark_count(), __unmatched);
        __states.back().__loop_data_.resize(__loop_count());
        __states.back().__node_ = __st;
        __states.back().__flags_ = __flags;
        __states.back().__at_first_ = __at_first;
        bool __matched = false;
        int __counter = 0;
        int __length = __last - __first;
        do
        {
            ++__counter;
            if (__counter % 4096 == 0 &&
                __counter / 4096 >= __length)
              __throw_regex_error<regex_constants::error_complexity>();
            __state& __s = __states.back();
            if (__s.__node_)
                __s.__node_->__exec(__s);
            switch (__s.__do_)
            {
            case __state::__end_state:
                if ((__flags & regex_constants::match_not_null) &&
                    __s.__current_ == __first)
                {
                  __states.pop_back();
                  break;
                }
                if ((__flags & regex_constants::__full_match) &&
                    __s.__current_ != __last)
                {
                  __states.pop_back();
                  break;
                }
                if (!__matched || __highest_j < __s.__current_ - __s.__first_)
                {
                    __highest_j = __s.__current_ - __s.__first_;
                    __best_state = __s;
                }
                __matched = true;
                if (__highest_j == _Np)
                    __states.clear();
                else
                    __states.pop_back();
                break;
            case __state::__accept_and_consume:
            case __state::__repeat:
            case __state::__accept_but_not_consume:
                break;
            case __state::__split:
                {
                __state __snext = __s;
                __s.__node_->__exec_split(true, __s);
                __snext.__node_->__exec_split(false, __snext);
                __states.push_back(std::__1::move(__snext));
                }
                break;
            case __state::__reject:
                __states.pop_back();
                break;
            default:
                __throw_regex_error<regex_constants::__re_err_unknown>();
                break;
            }
        } while (!__states.empty());
        if (__matched)
        {
            __m.__matches_[0].first = __first;
            __m.__matches_[0].second = std::__1::next(__first, __highest_j);
            __m.__matches_[0].matched = true;
            for (unsigned __i = 0; __i < __best_state.__sub_matches_.size(); ++__i)
                __m.__matches_[__i+1] = __best_state.__sub_matches_[__i];
            return true;
        }
    }
    return false;
}

template <class _CharT, class _Traits>
template <class _Allocator>
bool
basic_regex<_CharT, _Traits>::__match_at_start(
        const _CharT* __first, const _CharT* __last,
        match_results<const _CharT*, _Allocator>& __m,
        regex_constants::match_flag_type __flags, bool __at_first) const
{
    if (__get_grammar(__flags_) == ECMAScript)
        return __match_at_start_ecma(__first, __last, __m, __flags, __at_first);
    if (mark_count() == 0)
        return __match_at_start_posix_nosubs(__first, __last, __m, __flags, __at_first);
    return __match_at_start_posix_subs(__first, __last, __m, __flags, __at_first);
}

template <class _CharT, class _Traits>
template <class _Allocator>
bool
basic_regex<_CharT, _Traits>::__search(
        const _CharT* __first, const _CharT* __last,
        match_results<const _CharT*, _Allocator>& __m,
        regex_constants::match_flag_type __flags) const
{
    if (__flags & regex_constants::match_prev_avail)
        __flags &= ~(regex_constants::match_not_bol | regex_constants::match_not_bow);

    __m.__init(1 + mark_count(), __first, __last,
                                    __flags & regex_constants::__no_update_pos);
    if (__match_at_start(__first, __last, __m, __flags,
                                    !(__flags & regex_constants::__no_update_pos)))
    {
        __m.__prefix_.second = __m[0].first;
        __m.__prefix_.matched = __m.__prefix_.first != __m.__prefix_.second;
        __m.__suffix_.first = __m[0].second;
        __m.__suffix_.matched = __m.__suffix_.first != __m.__suffix_.second;
        return true;
    }
    if (__first != __last && !(__flags & regex_constants::match_continuous))
    {
        __flags |= regex_constants::match_prev_avail;
        for (++__first; __first != __last; ++__first)
        {
            __m.__matches_.assign(__m.size(), __m.__unmatched_);
            if (__match_at_start(__first, __last, __m, __flags, false))
            {
                __m.__prefix_.second = __m[0].first;
                __m.__prefix_.matched = __m.__prefix_.first != __m.__prefix_.second;
                __m.__suffix_.first = __m[0].second;
                __m.__suffix_.matched = __m.__suffix_.first != __m.__suffix_.second;
                return true;
            }
            __m.__matches_.assign(__m.size(), __m.__unmatched_);
        }
    }
    __m.__matches_.clear();
    return false;
}

template <class _BidirectionalIterator, class _Allocator, class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
regex_search(_BidirectionalIterator __first, _BidirectionalIterator __last,
             match_results<_BidirectionalIterator, _Allocator>& __m,
             const basic_regex<_CharT, _Traits>& __e,
             regex_constants::match_flag_type __flags = regex_constants::match_default)
{
    int __offset = (__flags & regex_constants::match_prev_avail) ? 1 : 0;
    basic_string<_CharT> __s(std::__1::prev(__first, __offset), __last);
    match_results<const _CharT*> __mc;
    bool __r = __e.__search(__s.data() + __offset, __s.data() + __s.size(), __mc, __flags);
    __m.__assign(__first, __last, __mc, __flags & regex_constants::__no_update_pos);
    return __r;
}

template <class _Iter, class _Allocator, class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
regex_search(__wrap_iter<_Iter> __first,
             __wrap_iter<_Iter> __last,
             match_results<__wrap_iter<_Iter>, _Allocator>& __m,
             const basic_regex<_CharT, _Traits>& __e,
             regex_constants::match_flag_type __flags = regex_constants::match_default)
{
    match_results<const _CharT*> __mc;
    bool __r = __e.__search(__first.base(), __last.base(), __mc, __flags);
    __m.__assign(__first, __last, __mc, __flags & regex_constants::__no_update_pos);
    return __r;
}

template <class _Allocator, class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
regex_search(const _CharT* __first, const _CharT* __last,
             match_results<const _CharT*, _Allocator>& __m,
             const basic_regex<_CharT, _Traits>& __e,
             regex_constants::match_flag_type __flags = regex_constants::match_default)
{
    return __e.__search(__first, __last, __m, __flags);
}

template <class _BidirectionalIterator, class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
regex_search(_BidirectionalIterator __first, _BidirectionalIterator __last,
             const basic_regex<_CharT, _Traits>& __e,
             regex_constants::match_flag_type __flags = regex_constants::match_default)
{
    basic_string<_CharT> __s(__first, __last);
    match_results<const _CharT*> __mc;
    return __e.__search(__s.data(), __s.data() + __s.size(), __mc, __flags);
}

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
regex_search(const _CharT* __first, const _CharT* __last,
             const basic_regex<_CharT, _Traits>& __e,
             regex_constants::match_flag_type __flags = regex_constants::match_default)
{
    match_results<const _CharT*> __mc;
    return __e.__search(__first, __last, __mc, __flags);
}

template <class _CharT, class _Allocator, class _Traits>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
regex_search(const _CharT* __str, match_results<const _CharT*, _Allocator>& __m,
             const basic_regex<_CharT, _Traits>& __e,
             regex_constants::match_flag_type __flags = regex_constants::match_default)
{
    return __e.__search(__str, __str + _Traits::length(__str), __m, __flags);
}

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
regex_search(const _CharT* __str, const basic_regex<_CharT, _Traits>& __e,
             regex_constants::match_flag_type __flags = regex_constants::match_default)
{
    match_results<const _CharT*> __m;
    return std::__1::regex_search(__str, __m, __e, __flags);
}

template <class _ST, class _SA, class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
regex_search(const basic_string<_CharT, _ST, _SA>& __s,
             const basic_regex<_CharT, _Traits>& __e,
             regex_constants::match_flag_type __flags = regex_constants::match_default)
{
    match_results<const _CharT*> __mc;
    return __e.__search(__s.data(), __s.data() + __s.size(), __mc, __flags);
}

template <class _ST, class _SA, class _Allocator, class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
regex_search(const basic_string<_CharT, _ST, _SA>& __s,
             match_results<typename basic_string<_CharT, _ST, _SA>::const_iterator, _Allocator>& __m,
             const basic_regex<_CharT, _Traits>& __e,
             regex_constants::match_flag_type __flags = regex_constants::match_default)
{
    match_results<const _CharT*> __mc;
    bool __r = __e.__search(__s.data(), __s.data() + __s.size(), __mc, __flags);
    __m.__assign(__s.begin(), __s.end(), __mc, __flags & regex_constants::__no_update_pos);
    return __r;
}


template <class _ST, class _SA, class _Ap, class _Cp, class _Tp>
bool
regex_search(const basic_string<_Cp, _ST, _SA>&& __s,
             match_results<typename basic_string<_Cp, _ST, _SA>::const_iterator, _Ap>&,
             const basic_regex<_Cp, _Tp>& __e,
             regex_constants::match_flag_type __flags = regex_constants::match_default) = delete;




template <class _BidirectionalIterator, class _Allocator, class _CharT, class _Traits>
bool
regex_match(_BidirectionalIterator __first, _BidirectionalIterator __last,
            match_results<_BidirectionalIterator, _Allocator>& __m,
            const basic_regex<_CharT, _Traits>& __e,
            regex_constants::match_flag_type __flags = regex_constants::match_default)
{
    bool __r = std::__1::regex_search(
        __first, __last, __m, __e,
        __flags | regex_constants::match_continuous |
        regex_constants::__full_match);
    if (__r)
    {
        __r = !__m.suffix().matched;
        if (!__r)
            __m.__matches_.clear();
    }
    return __r;
}

template <class _BidirectionalIterator, class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
regex_match(_BidirectionalIterator __first, _BidirectionalIterator __last,
            const basic_regex<_CharT, _Traits>& __e,
            regex_constants::match_flag_type __flags = regex_constants::match_default)
{
    match_results<_BidirectionalIterator> __m;
    return std::__1::regex_match(__first, __last, __m, __e, __flags);
}

template <class _CharT, class _Allocator, class _Traits>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
regex_match(const _CharT* __str, match_results<const _CharT*, _Allocator>& __m,
            const basic_regex<_CharT, _Traits>& __e,
            regex_constants::match_flag_type __flags = regex_constants::match_default)
{
    return std::__1::regex_match(__str, __str + _Traits::length(__str), __m, __e, __flags);
}

template <class _ST, class _SA, class _Allocator, class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
regex_match(const basic_string<_CharT, _ST, _SA>& __s,
            match_results<typename basic_string<_CharT, _ST, _SA>::const_iterator, _Allocator>& __m,
            const basic_regex<_CharT, _Traits>& __e,
            regex_constants::match_flag_type __flags = regex_constants::match_default)
{
    return std::__1::regex_match(__s.begin(), __s.end(), __m, __e, __flags);
}


template <class _ST, class _SA, class _Allocator, class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
regex_match(const basic_string<_CharT, _ST, _SA>&& __s,
            match_results<typename basic_string<_CharT, _ST, _SA>::const_iterator, _Allocator>& __m,
            const basic_regex<_CharT, _Traits>& __e,
            regex_constants::match_flag_type __flags = regex_constants::match_default) = delete;


template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
regex_match(const _CharT* __str, const basic_regex<_CharT, _Traits>& __e,
            regex_constants::match_flag_type __flags = regex_constants::match_default)
{
    return std::__1::regex_match(__str, __str + _Traits::length(__str), __e, __flags);
}

template <class _ST, class _SA, class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
regex_match(const basic_string<_CharT, _ST, _SA>& __s,
            const basic_regex<_CharT, _Traits>& __e,
            regex_constants::match_flag_type __flags = regex_constants::match_default)
{
    return std::__1::regex_match(__s.begin(), __s.end(), __e, __flags);
}



template <class _BidirectionalIterator,
          class _CharT = typename iterator_traits<_BidirectionalIterator>::value_type,
          class _Traits = regex_traits<_CharT> >
    class __attribute__ ((__type_visibility__("default"))) regex_iterator;

typedef regex_iterator<const char*> cregex_iterator;
typedef regex_iterator<string::const_iterator> sregex_iterator;

typedef regex_iterator<const wchar_t*> wcregex_iterator;
typedef regex_iterator<wstring::const_iterator> wsregex_iterator;


template <class _BidirectionalIterator, class _CharT, class _Traits>
class
    __attribute__ ((__type_visibility__("default")))
    __attribute__((__preferred_name__(cregex_iterator)))
    __attribute__((__preferred_name__(wcregex_iterator)))
    __attribute__((__preferred_name__(sregex_iterator)))
    __attribute__((__preferred_name__(wsregex_iterator)))
    regex_iterator
{
public:
    typedef basic_regex<_CharT, _Traits> regex_type;
    typedef match_results<_BidirectionalIterator> value_type;
    typedef ptrdiff_t difference_type;
    typedef const value_type* pointer;
    typedef const value_type& reference;
    typedef forward_iterator_tag iterator_category;

private:
    _BidirectionalIterator __begin_;
    _BidirectionalIterator __end_;
    const regex_type* __pregex_;
    regex_constants::match_flag_type __flags_;
    value_type __match_;

public:
    regex_iterator();
    regex_iterator(_BidirectionalIterator __a, _BidirectionalIterator __b,
                   const regex_type& __re,
                   regex_constants::match_flag_type __m
                                              = regex_constants::match_default);

    regex_iterator(_BidirectionalIterator __a, _BidirectionalIterator __b,
                   const regex_type&& __re,
                   regex_constants::match_flag_type __m
                                     = regex_constants::match_default) = delete;


    bool operator==(const regex_iterator& __x) const;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    bool operator!=(const regex_iterator& __x) const {return !(*this == __x);}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    reference operator*() const {return __match_;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    pointer operator->() const {return std::__1::addressof(__match_);}

    regex_iterator& operator++();
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    regex_iterator operator++(int)
    {
        regex_iterator __t(*this);
        ++(*this);
        return __t;
    }
};

template <class _BidirectionalIterator, class _CharT, class _Traits>
regex_iterator<_BidirectionalIterator, _CharT, _Traits>::regex_iterator()
    : __begin_(), __end_(), __pregex_(nullptr), __flags_(), __match_()
{
}

template <class _BidirectionalIterator, class _CharT, class _Traits>
regex_iterator<_BidirectionalIterator, _CharT, _Traits>::
    regex_iterator(_BidirectionalIterator __a, _BidirectionalIterator __b,
                   const regex_type& __re, regex_constants::match_flag_type __m)
    : __begin_(__a),
      __end_(__b),
      __pregex_(std::__1::addressof(__re)),
      __flags_(__m)
{
    std::__1::regex_search(__begin_, __end_, __match_, *__pregex_, __flags_);
}

template <class _BidirectionalIterator, class _CharT, class _Traits>
bool
regex_iterator<_BidirectionalIterator, _CharT, _Traits>::
    operator==(const regex_iterator& __x) const
{
    if (__match_.empty() && __x.__match_.empty())
        return true;
    if (__match_.empty() || __x.__match_.empty())
        return false;
    return __begin_ == __x.__begin_ &&
           __end_ == __x.__end_ &&
           __pregex_ == __x.__pregex_ &&
           __flags_ == __x.__flags_ &&
           __match_[0] == __x.__match_[0];
}

template <class _BidirectionalIterator, class _CharT, class _Traits>
regex_iterator<_BidirectionalIterator, _CharT, _Traits>&
regex_iterator<_BidirectionalIterator, _CharT, _Traits>::operator++()
{
    __flags_ |= regex_constants::__no_update_pos;
    _BidirectionalIterator __start = __match_[0].second;
    if (__match_[0].first == __match_[0].second)
    {
        if (__start == __end_)
        {
            __match_ = value_type();
            return *this;
        }
        else if (std::__1::regex_search(__start, __end_, __match_, *__pregex_,
                                    __flags_ | regex_constants::match_not_null |
                                    regex_constants::match_continuous))
            return *this;
        else
            ++__start;
    }
    __flags_ |= regex_constants::match_prev_avail;
    if (!std::__1::regex_search(__start, __end_, __match_, *__pregex_, __flags_))
        __match_ = value_type();
    return *this;
}



template <class _BidirectionalIterator,
          class _CharT = typename iterator_traits<_BidirectionalIterator>::value_type,
          class _Traits = regex_traits<_CharT> >
    class __attribute__ ((__type_visibility__("default"))) regex_token_iterator;

typedef regex_token_iterator<const char*> cregex_token_iterator;
typedef regex_token_iterator<string::const_iterator> sregex_token_iterator;

typedef regex_token_iterator<const wchar_t*> wcregex_token_iterator;
typedef regex_token_iterator<wstring::const_iterator> wsregex_token_iterator;


template <class _BidirectionalIterator, class _CharT, class _Traits>
class
    __attribute__ ((__type_visibility__("default")))
    __attribute__((__preferred_name__(cregex_token_iterator)))
    __attribute__((__preferred_name__(wcregex_token_iterator)))
    __attribute__((__preferred_name__(sregex_token_iterator)))
    __attribute__((__preferred_name__(wsregex_token_iterator)))
    regex_token_iterator
{
public:
    typedef basic_regex<_CharT, _Traits> regex_type;
    typedef sub_match<_BidirectionalIterator> value_type;
    typedef ptrdiff_t difference_type;
    typedef const value_type* pointer;
    typedef const value_type& reference;
    typedef forward_iterator_tag iterator_category;

private:
    typedef regex_iterator<_BidirectionalIterator, _CharT, _Traits> _Position;

    _Position __position_;
    const value_type* __result_;
    value_type __suffix_;
    ptrdiff_t __n_;
    vector<int> __subs_;

public:
    regex_token_iterator();
    regex_token_iterator(_BidirectionalIterator __a, _BidirectionalIterator __b,
                         const regex_type& __re, int __submatch = 0,
                         regex_constants::match_flag_type __m =
                                                regex_constants::match_default);

    regex_token_iterator(_BidirectionalIterator __a, _BidirectionalIterator __b,
                         const regex_type&& __re, int __submatch = 0,
                         regex_constants::match_flag_type __m =
                                       regex_constants::match_default) = delete;


    regex_token_iterator(_BidirectionalIterator __a, _BidirectionalIterator __b,
                         const regex_type& __re, const vector<int>& __submatches,
                         regex_constants::match_flag_type __m =
                                                regex_constants::match_default);

    regex_token_iterator(_BidirectionalIterator __a, _BidirectionalIterator __b,
                         const regex_type&& __re, const vector<int>& __submatches,
                         regex_constants::match_flag_type __m =
                                     regex_constants::match_default) = delete;



    regex_token_iterator(_BidirectionalIterator __a, _BidirectionalIterator __b,
                         const regex_type& __re,
                         initializer_list<int> __submatches,
                         regex_constants::match_flag_type __m =
                                                regex_constants::match_default);


    regex_token_iterator(_BidirectionalIterator __a, _BidirectionalIterator __b,
                         const regex_type&& __re,
                         initializer_list<int> __submatches,
                         regex_constants::match_flag_type __m =
                                       regex_constants::match_default) = delete;


    template <size_t _Np>
        regex_token_iterator(_BidirectionalIterator __a,
                             _BidirectionalIterator __b,
                             const regex_type& __re,
                             const int (&__submatches)[_Np],
                             regex_constants::match_flag_type __m =
                                                regex_constants::match_default);

    template <size_t _Np>
        regex_token_iterator(_BidirectionalIterator __a,
                             _BidirectionalIterator __b,
                             const regex_type&& __re,
                             const int (&__submatches)[_Np],
                             regex_constants::match_flag_type __m =
                                      regex_constants::match_default) = delete;


    regex_token_iterator(const regex_token_iterator&);
    regex_token_iterator& operator=(const regex_token_iterator&);

    bool operator==(const regex_token_iterator& __x) const;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    bool operator!=(const regex_token_iterator& __x) const {return !(*this == __x);}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const value_type& operator*() const {return *__result_;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const value_type* operator->() const {return __result_;}

    regex_token_iterator& operator++();
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    regex_token_iterator operator++(int)
    {
        regex_token_iterator __t(*this);
        ++(*this);
        return __t;
    }

private:
    void __init(_BidirectionalIterator __a, _BidirectionalIterator __b);
    void __establish_result () {
        if (__subs_[__n_] == -1)
            __result_ = &__position_->prefix();
        else
            __result_ = &(*__position_)[__subs_[__n_]];
        }
};

template <class _BidirectionalIterator, class _CharT, class _Traits>
regex_token_iterator<_BidirectionalIterator, _CharT, _Traits>::
    regex_token_iterator()
    : __result_(nullptr),
      __suffix_(),
      __n_(0)
{
}

template <class _BidirectionalIterator, class _CharT, class _Traits>
void
regex_token_iterator<_BidirectionalIterator, _CharT, _Traits>::
    __init(_BidirectionalIterator __a, _BidirectionalIterator __b)
{
    if (__position_ != _Position())
        __establish_result ();
    else if (__subs_[__n_] == -1)
    {
        __suffix_.matched = true;
        __suffix_.first = __a;
        __suffix_.second = __b;
        __result_ = &__suffix_;
    }
    else
        __result_ = nullptr;
}

template <class _BidirectionalIterator, class _CharT, class _Traits>
regex_token_iterator<_BidirectionalIterator, _CharT, _Traits>::
    regex_token_iterator(_BidirectionalIterator __a, _BidirectionalIterator __b,
                         const regex_type& __re, int __submatch,
                         regex_constants::match_flag_type __m)
    : __position_(__a, __b, __re, __m),
      __n_(0),
      __subs_(1, __submatch)
{
    __init(__a, __b);
}

template <class _BidirectionalIterator, class _CharT, class _Traits>
regex_token_iterator<_BidirectionalIterator, _CharT, _Traits>::
    regex_token_iterator(_BidirectionalIterator __a, _BidirectionalIterator __b,
                         const regex_type& __re, const vector<int>& __submatches,
                         regex_constants::match_flag_type __m)
    : __position_(__a, __b, __re, __m),
      __n_(0),
      __subs_(__submatches)
{
    __init(__a, __b);
}



template <class _BidirectionalIterator, class _CharT, class _Traits>
regex_token_iterator<_BidirectionalIterator, _CharT, _Traits>::
    regex_token_iterator(_BidirectionalIterator __a, _BidirectionalIterator __b,
                         const regex_type& __re,
                         initializer_list<int> __submatches,
                         regex_constants::match_flag_type __m)
    : __position_(__a, __b, __re, __m),
      __n_(0),
      __subs_(__submatches)
{
    __init(__a, __b);
}



template <class _BidirectionalIterator, class _CharT, class _Traits>
template <size_t _Np>
regex_token_iterator<_BidirectionalIterator, _CharT, _Traits>::
    regex_token_iterator(_BidirectionalIterator __a, _BidirectionalIterator __b,
                             const regex_type& __re,
                             const int (&__submatches)[_Np],
                             regex_constants::match_flag_type __m)
    : __position_(__a, __b, __re, __m),
      __n_(0),
      __subs_(begin(__submatches), end(__submatches))
{
    __init(__a, __b);
}

template <class _BidirectionalIterator, class _CharT, class _Traits>
regex_token_iterator<_BidirectionalIterator, _CharT, _Traits>::
    regex_token_iterator(const regex_token_iterator& __x)
    : __position_(__x.__position_),
      __result_(__x.__result_),
      __suffix_(__x.__suffix_),
      __n_(__x.__n_),
      __subs_(__x.__subs_)
{
    if (__x.__result_ == &__x.__suffix_)
        __result_ = &__suffix_;
    else if ( __result_ != nullptr )
        __establish_result ();
}

template <class _BidirectionalIterator, class _CharT, class _Traits>
regex_token_iterator<_BidirectionalIterator, _CharT, _Traits>&
regex_token_iterator<_BidirectionalIterator, _CharT, _Traits>::
    operator=(const regex_token_iterator& __x)
{
    if (this != &__x)
    {
        __position_ = __x.__position_;
        if (__x.__result_ == &__x.__suffix_)
            __result_ = &__suffix_;
        else
            __result_ = __x.__result_;
        __suffix_ = __x.__suffix_;
        __n_ = __x.__n_;
        __subs_ = __x.__subs_;

        if ( __result_ != nullptr && __result_ != &__suffix_ )
            __establish_result();
    }
    return *this;
}

template <class _BidirectionalIterator, class _CharT, class _Traits>
bool
regex_token_iterator<_BidirectionalIterator, _CharT, _Traits>::
    operator==(const regex_token_iterator& __x) const
{
    if (__result_ == nullptr && __x.__result_ == nullptr)
        return true;
    if (__result_ == &__suffix_ && __x.__result_ == &__x.__suffix_ &&
            __suffix_ == __x.__suffix_)
        return true;
    if (__result_ == nullptr || __x.__result_ == nullptr)
        return false;
    if (__result_ == &__suffix_ || __x.__result_ == &__x.__suffix_)
        return false;
    return __position_ == __x.__position_ && __n_ == __x.__n_ &&
           __subs_ == __x.__subs_;
}

template <class _BidirectionalIterator, class _CharT, class _Traits>
regex_token_iterator<_BidirectionalIterator, _CharT, _Traits>&
regex_token_iterator<_BidirectionalIterator, _CharT, _Traits>::operator++()
{
    _Position __prev = __position_;
    if (__result_ == &__suffix_)
        __result_ = nullptr;
    else if (static_cast<size_t>(__n_ + 1) < __subs_.size())
    {
        ++__n_;
        __establish_result();
    }
    else
    {
        __n_ = 0;
        ++__position_;
        if (__position_ != _Position())
            __establish_result();
        else
        {
            if (std::__1::find(__subs_.begin(), __subs_.end(), -1) != __subs_.end()
                && __prev->suffix().length() != 0)
            {
                __suffix_.matched = true;
                __suffix_.first = __prev->suffix().first;
                __suffix_.second = __prev->suffix().second;
                __result_ = &__suffix_;
            }
            else
                __result_ = nullptr;
        }
    }
    return *this;
}



template <class _OutputIterator, class _BidirectionalIterator,
          class _Traits, class _CharT>
_OutputIterator
regex_replace(_OutputIterator __output_iter,
              _BidirectionalIterator __first, _BidirectionalIterator __last,
              const basic_regex<_CharT, _Traits>& __e, const _CharT* __fmt,
              regex_constants::match_flag_type __flags = regex_constants::match_default)
{
    typedef regex_iterator<_BidirectionalIterator, _CharT, _Traits> _Iter;
    _Iter __i(__first, __last, __e, __flags);
    _Iter __eof;
    if (__i == __eof)
    {
        if (!(__flags & regex_constants::format_no_copy))
            __output_iter = std::__1::copy(__first, __last, __output_iter);
    }
    else
    {
        sub_match<_BidirectionalIterator> __lm;
        for (size_t __len = char_traits<_CharT>::length(__fmt); __i != __eof; ++__i)
        {
            if (!(__flags & regex_constants::format_no_copy))
                __output_iter = std::__1::copy(__i->prefix().first, __i->prefix().second, __output_iter);
            __output_iter = __i->format(__output_iter, __fmt, __fmt + __len, __flags);
            __lm = __i->suffix();
            if (__flags & regex_constants::format_first_only)
                break;
        }
        if (!(__flags & regex_constants::format_no_copy))
            __output_iter = std::__1::copy(__lm.first, __lm.second, __output_iter);
    }
    return __output_iter;
}

template <class _OutputIterator, class _BidirectionalIterator,
          class _Traits, class _CharT, class _ST, class _SA>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
_OutputIterator
regex_replace(_OutputIterator __output_iter,
              _BidirectionalIterator __first, _BidirectionalIterator __last,
              const basic_regex<_CharT, _Traits>& __e,
              const basic_string<_CharT, _ST, _SA>& __fmt,
              regex_constants::match_flag_type __flags = regex_constants::match_default)
{
    return std::__1::regex_replace(__output_iter, __first, __last, __e, __fmt.c_str(), __flags);
}

template <class _Traits, class _CharT, class _ST, class _SA, class _FST,
          class _FSA>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
basic_string<_CharT, _ST, _SA>
regex_replace(const basic_string<_CharT, _ST, _SA>& __s,
              const basic_regex<_CharT, _Traits>& __e,
              const basic_string<_CharT, _FST, _FSA>& __fmt,
              regex_constants::match_flag_type __flags = regex_constants::match_default)
{
    basic_string<_CharT, _ST, _SA> __r;
    std::__1::regex_replace(back_inserter(__r), __s.begin(), __s.end(), __e,
                        __fmt.c_str(), __flags);
    return __r;
}

template <class _Traits, class _CharT, class _ST, class _SA>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
basic_string<_CharT, _ST, _SA>
regex_replace(const basic_string<_CharT, _ST, _SA>& __s,
              const basic_regex<_CharT, _Traits>& __e, const _CharT* __fmt,
              regex_constants::match_flag_type __flags = regex_constants::match_default)
{
    basic_string<_CharT, _ST, _SA> __r;
    std::__1::regex_replace(back_inserter(__r), __s.begin(), __s.end(), __e,
                        __fmt, __flags);
    return __r;
}

template <class _Traits, class _CharT, class _ST, class _SA>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
basic_string<_CharT>
regex_replace(const _CharT* __s,
              const basic_regex<_CharT, _Traits>& __e,
              const basic_string<_CharT, _ST, _SA>& __fmt,
              regex_constants::match_flag_type __flags = regex_constants::match_default)
{
    basic_string<_CharT> __r;
    std::__1::regex_replace(back_inserter(__r), __s,
                        __s + char_traits<_CharT>::length(__s), __e,
                        __fmt.c_str(), __flags);
    return __r;
}

template <class _Traits, class _CharT>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
basic_string<_CharT>
regex_replace(const _CharT* __s,
              const basic_regex<_CharT, _Traits>& __e,
              const _CharT* __fmt,
              regex_constants::match_flag_type __flags = regex_constants::match_default)
{
    basic_string<_CharT> __r;
    std::__1::regex_replace(back_inserter(__r), __s,
                        __s + char_traits<_CharT>::length(__s), __e,
                        __fmt, __flags);
    return __r;
}

} }
# 250 "/usr/local/include/bits/stdc++.h" 2


# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/scoped_allocator" 1 3
# 110 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/scoped_allocator" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/memory" 1 3
# 974 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/memory" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 1 3
# 20 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/assert.h" 1 3 4
# 44 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/assert.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/stdlib.h" 1 3 4
# 45 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/assert.h" 2 3 4
# 81 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/assert.h" 3 4
extern "C" {
void __assert_rtn(const char *, const char *, int, const char *) __attribute__((__noreturn__)) __attribute__((__cold__)) __attribute__((__disable_tail_calls__));



}
# 21 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 2 3
# 24 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 3
# 975 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/memory" 2 3
# 111 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/scoped_allocator" 2 3
# 115 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/scoped_allocator" 3


namespace std { inline namespace __1 {





template <class ..._Allocs>
class scoped_allocator_adaptor;

template <class ..._Allocs> struct __get_poc_copy_assignment;

template <class _A0>
struct __get_poc_copy_assignment<_A0>
{
    static const bool value = allocator_traits<_A0>::
                              propagate_on_container_copy_assignment::value;
};

template <class _A0, class ..._Allocs>
struct __get_poc_copy_assignment<_A0, _Allocs...>
{
    static const bool value =
        allocator_traits<_A0>::propagate_on_container_copy_assignment::value ||
        __get_poc_copy_assignment<_Allocs...>::value;
};

template <class ..._Allocs> struct __get_poc_move_assignment;

template <class _A0>
struct __get_poc_move_assignment<_A0>
{
    static const bool value = allocator_traits<_A0>::
                              propagate_on_container_move_assignment::value;
};

template <class _A0, class ..._Allocs>
struct __get_poc_move_assignment<_A0, _Allocs...>
{
    static const bool value =
        allocator_traits<_A0>::propagate_on_container_move_assignment::value ||
        __get_poc_move_assignment<_Allocs...>::value;
};

template <class ..._Allocs> struct __get_poc_swap;

template <class _A0>
struct __get_poc_swap<_A0>
{
    static const bool value = allocator_traits<_A0>::
                              propagate_on_container_swap::value;
};

template <class _A0, class ..._Allocs>
struct __get_poc_swap<_A0, _Allocs...>
{
    static const bool value =
        allocator_traits<_A0>::propagate_on_container_swap::value ||
        __get_poc_swap<_Allocs...>::value;
};

template <class ..._Allocs> struct __get_is_always_equal;

template <class _A0>
struct __get_is_always_equal<_A0>
{
    static const bool value = allocator_traits<_A0>::is_always_equal::value;
};

template <class _A0, class ..._Allocs>
struct __get_is_always_equal<_A0, _Allocs...>
{
    static const bool value =
        allocator_traits<_A0>::is_always_equal::value &&
        __get_is_always_equal<_Allocs...>::value;
};

template <class ..._Allocs>
class __scoped_allocator_storage;

template <class _OuterAlloc, class... _InnerAllocs>
class __scoped_allocator_storage<_OuterAlloc, _InnerAllocs...>
    : public _OuterAlloc
{
    typedef _OuterAlloc outer_allocator_type;
protected:
    typedef scoped_allocator_adaptor<_InnerAllocs...> inner_allocator_type;

private:
    inner_allocator_type __inner_;

protected:

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __scoped_allocator_storage() noexcept {}

    template <class _OuterA2,
              class = typename enable_if<
                        is_constructible<outer_allocator_type, _OuterA2>::value
                      >::type>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        __scoped_allocator_storage(_OuterA2&& __outerAlloc,
                                   const _InnerAllocs& ...__innerAllocs) noexcept
            : outer_allocator_type(std::__1::forward<_OuterA2>(__outerAlloc)),
              __inner_(__innerAllocs...) {}

    template <class _OuterA2,
              class = typename enable_if<
                        is_constructible<outer_allocator_type, const _OuterA2&>::value
                      >::type>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        __scoped_allocator_storage(
            const __scoped_allocator_storage<_OuterA2, _InnerAllocs...>& __other) noexcept
            : outer_allocator_type(__other.outer_allocator()),
              __inner_(__other.inner_allocator()) {}

    template <class _OuterA2,
              class = typename enable_if<
                        is_constructible<outer_allocator_type, _OuterA2>::value
                      >::type>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        __scoped_allocator_storage(
            __scoped_allocator_storage<_OuterA2, _InnerAllocs...>&& __other) noexcept
            : outer_allocator_type(std::__1::move(__other.outer_allocator())),
              __inner_(std::__1::move(__other.inner_allocator())) {}

    template <class _OuterA2,
              class = typename enable_if<
                        is_constructible<outer_allocator_type, _OuterA2>::value
                      >::type>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        __scoped_allocator_storage(_OuterA2&& __o,
                                   const inner_allocator_type& __i) noexcept
            : outer_allocator_type(std::__1::forward<_OuterA2>(__o)),
              __inner_(__i)
        {
        }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    inner_allocator_type& inner_allocator() noexcept {return __inner_;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const inner_allocator_type& inner_allocator() const noexcept {return __inner_;}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    outer_allocator_type& outer_allocator() noexcept
        {return static_cast<outer_allocator_type&>(*this);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const outer_allocator_type& outer_allocator() const noexcept
        {return static_cast<const outer_allocator_type&>(*this);}

    scoped_allocator_adaptor<outer_allocator_type, _InnerAllocs...>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    select_on_container_copy_construction() const noexcept
        {
            return scoped_allocator_adaptor<outer_allocator_type, _InnerAllocs...>
            (
                allocator_traits<outer_allocator_type>::
                    select_on_container_copy_construction(outer_allocator()),
                allocator_traits<inner_allocator_type>::
                    select_on_container_copy_construction(inner_allocator())
            );
        }

    template <class...> friend class __scoped_allocator_storage;
};

template <class _OuterAlloc>
class __scoped_allocator_storage<_OuterAlloc>
    : public _OuterAlloc
{
    typedef _OuterAlloc outer_allocator_type;
protected:
    typedef scoped_allocator_adaptor<_OuterAlloc> inner_allocator_type;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __scoped_allocator_storage() noexcept {}

    template <class _OuterA2,
              class = typename enable_if<
                        is_constructible<outer_allocator_type, _OuterA2>::value
                      >::type>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        __scoped_allocator_storage(_OuterA2&& __outerAlloc) noexcept
            : outer_allocator_type(std::__1::forward<_OuterA2>(__outerAlloc)) {}

    template <class _OuterA2,
              class = typename enable_if<
                        is_constructible<outer_allocator_type, const _OuterA2&>::value
                      >::type>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        __scoped_allocator_storage(
            const __scoped_allocator_storage<_OuterA2>& __other) noexcept
            : outer_allocator_type(__other.outer_allocator()) {}

    template <class _OuterA2,
              class = typename enable_if<
                        is_constructible<outer_allocator_type, _OuterA2>::value
                      >::type>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        __scoped_allocator_storage(
            __scoped_allocator_storage<_OuterA2>&& __other) noexcept
            : outer_allocator_type(std::__1::move(__other.outer_allocator())) {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    inner_allocator_type& inner_allocator() noexcept
        {return static_cast<inner_allocator_type&>(*this);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const inner_allocator_type& inner_allocator() const noexcept
        {return static_cast<const inner_allocator_type&>(*this);}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    outer_allocator_type& outer_allocator() noexcept
        {return static_cast<outer_allocator_type&>(*this);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const outer_allocator_type& outer_allocator() const noexcept
        {return static_cast<const outer_allocator_type&>(*this);}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    scoped_allocator_adaptor<outer_allocator_type>
    select_on_container_copy_construction() const noexcept
        {return scoped_allocator_adaptor<outer_allocator_type>(
            allocator_traits<outer_allocator_type>::
                select_on_container_copy_construction(outer_allocator())
        );}

    __scoped_allocator_storage(const outer_allocator_type& __o,
                               const inner_allocator_type& __i) noexcept;

    template <class...> friend class __scoped_allocator_storage;
};



template <class _Alloc>
decltype(declval<_Alloc>().outer_allocator(), true_type())
__has_outer_allocator_test(_Alloc&& __a);

template <class _Alloc>
false_type
__has_outer_allocator_test(const volatile _Alloc& __a);

template <class _Alloc>
struct __has_outer_allocator
    : public common_type
             <
                 decltype(__has_outer_allocator_test(declval<_Alloc&>()))
             >::type
{
};

template <class _Alloc, bool = __has_outer_allocator<_Alloc>::value>
struct __outermost
{
    typedef _Alloc type;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    type& operator()(type& __a) const noexcept {return __a;}
};

template <class _Alloc>
struct __outermost<_Alloc, true>
{
    typedef typename remove_reference
                     <
                        decltype(declval<_Alloc>().outer_allocator())
                     >::type _OuterAlloc;
    typedef typename __outermost<_OuterAlloc>::type type;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    type& operator()(_Alloc& __a) const noexcept
        {return __outermost<_OuterAlloc>()(__a.outer_allocator());}
};

template <class _OuterAlloc, class... _InnerAllocs>
class __attribute__ ((__type_visibility__("default"))) scoped_allocator_adaptor<_OuterAlloc, _InnerAllocs...>
    : public __scoped_allocator_storage<_OuterAlloc, _InnerAllocs...>
{
    typedef __scoped_allocator_storage<_OuterAlloc, _InnerAllocs...> base;
    typedef allocator_traits<_OuterAlloc> _OuterTraits;
public:
    typedef _OuterAlloc outer_allocator_type;
    typedef typename base::inner_allocator_type inner_allocator_type;
    typedef typename _OuterTraits::size_type size_type;
    typedef typename _OuterTraits::difference_type difference_type;
    typedef typename _OuterTraits::pointer pointer;
    typedef typename _OuterTraits::const_pointer const_pointer;
    typedef typename _OuterTraits::void_pointer void_pointer;
    typedef typename _OuterTraits::const_void_pointer const_void_pointer;

    typedef integral_constant
            <
                bool,
                __get_poc_copy_assignment<outer_allocator_type,
                                          _InnerAllocs...>::value
            > propagate_on_container_copy_assignment;
    typedef integral_constant
            <
                bool,
                __get_poc_move_assignment<outer_allocator_type,
                                          _InnerAllocs...>::value
            > propagate_on_container_move_assignment;
    typedef integral_constant
            <
                bool,
                __get_poc_swap<outer_allocator_type, _InnerAllocs...>::value
            > propagate_on_container_swap;
    typedef integral_constant
            <
                bool,
                __get_is_always_equal<outer_allocator_type, _InnerAllocs...>::value
            > is_always_equal;

    template <class _Tp>
    struct rebind
    {
        typedef scoped_allocator_adaptor
        <
            typename _OuterTraits::template rebind_alloc<_Tp>, _InnerAllocs...
        > other;
    };

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    scoped_allocator_adaptor() noexcept {}
    template <class _OuterA2,
              class = typename enable_if<
                        is_constructible<outer_allocator_type, _OuterA2>::value
                      >::type>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        scoped_allocator_adaptor(_OuterA2&& __outerAlloc,
                                 const _InnerAllocs& ...__innerAllocs) noexcept
            : base(std::__1::forward<_OuterA2>(__outerAlloc), __innerAllocs...) {}

    template <class _OuterA2,
              class = typename enable_if<
                        is_constructible<outer_allocator_type, const _OuterA2&>::value
                      >::type>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        scoped_allocator_adaptor(
            const scoped_allocator_adaptor<_OuterA2, _InnerAllocs...>& __other) noexcept
                : base(__other) {}
    template <class _OuterA2,
              class = typename enable_if<
                        is_constructible<outer_allocator_type, _OuterA2>::value
                      >::type>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        scoped_allocator_adaptor(
            scoped_allocator_adaptor<_OuterA2, _InnerAllocs...>&& __other) noexcept
                : base(std::__1::move(__other)) {}





    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    inner_allocator_type& inner_allocator() noexcept
        {return base::inner_allocator();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const inner_allocator_type& inner_allocator() const noexcept
        {return base::inner_allocator();}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    outer_allocator_type& outer_allocator() noexcept
        {return base::outer_allocator();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const outer_allocator_type& outer_allocator() const noexcept
        {return base::outer_allocator();}

                                  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    pointer allocate(size_type __n)
        {return allocator_traits<outer_allocator_type>::
            allocate(outer_allocator(), __n);}
                                  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    pointer allocate(size_type __n, const_void_pointer __hint)
        {return allocator_traits<outer_allocator_type>::
            allocate(outer_allocator(), __n, __hint);}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void deallocate(pointer __p, size_type __n) noexcept
        {allocator_traits<outer_allocator_type>::
            deallocate(outer_allocator(), __p, __n);}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_type max_size() const
        {return allocator_traits<outer_allocator_type>::max_size(outer_allocator());}

    template <class _Tp, class... _Args>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        void construct(_Tp* __p, _Args&& ...__args)
            {__construct(__uses_alloc_ctor<_Tp, inner_allocator_type&, _Args...>(),
                         __p, std::__1::forward<_Args>(__args)...);}

    template <class _T1, class _T2, class... _Args1, class... _Args2>
    void construct(pair<_T1, _T2>* __p, piecewise_construct_t,
                       tuple<_Args1...> __x, tuple<_Args2...> __y)
    {
        typedef __outermost<outer_allocator_type> _OM;
        allocator_traits<typename _OM::type>::construct(
            _OM()(outer_allocator()), __p, piecewise_construct
          , __transform_tuple(
              typename __uses_alloc_ctor<
                  _T1, inner_allocator_type&, _Args1...
              >::type()
            , std::__1::move(__x)
            , typename __make_tuple_indices<sizeof...(_Args1)>::type{}
          )
          , __transform_tuple(
              typename __uses_alloc_ctor<
                  _T2, inner_allocator_type&, _Args2...
              >::type()
            , std::__1::move(__y)
            , typename __make_tuple_indices<sizeof...(_Args2)>::type{}
          )
        );
    }

    template <class _T1, class _T2>
    void construct(pair<_T1, _T2>* __p)
    { construct(__p, piecewise_construct, tuple<>{}, tuple<>{}); }

    template <class _T1, class _T2, class _Up, class _Vp>
    void construct(pair<_T1, _T2>* __p, _Up&& __x, _Vp&& __y) {
        construct(__p, piecewise_construct,
                  std::__1::forward_as_tuple(std::__1::forward<_Up>(__x)),
                  std::__1::forward_as_tuple(std::__1::forward<_Vp>(__y)));
    }

    template <class _T1, class _T2, class _Up, class _Vp>
    void construct(pair<_T1, _T2>* __p, const pair<_Up, _Vp>& __x) {
        construct(__p, piecewise_construct,
                  std::__1::forward_as_tuple(__x.first),
                  std::__1::forward_as_tuple(__x.second));
    }

    template <class _T1, class _T2, class _Up, class _Vp>
    void construct(pair<_T1, _T2>* __p, pair<_Up, _Vp>&& __x) {
        construct(__p, piecewise_construct,
                  std::__1::forward_as_tuple(std::__1::forward<_Up>(__x.first)),
                  std::__1::forward_as_tuple(std::__1::forward<_Vp>(__x.second)));
    }

    template <class _Tp>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        void destroy(_Tp* __p)
            {
                typedef __outermost<outer_allocator_type> _OM;
                allocator_traits<typename _OM::type>::
                                         destroy(_OM()(outer_allocator()), __p);
            }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    scoped_allocator_adaptor select_on_container_copy_construction() const noexcept
        {return base::select_on_container_copy_construction();}

private:


    template <class _OuterA2,
              class = typename enable_if<
                        is_constructible<outer_allocator_type, _OuterA2>::value
                      >::type>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    scoped_allocator_adaptor(_OuterA2&& __o,
                             const inner_allocator_type& __i) noexcept
        : base(std::__1::forward<_OuterA2>(__o), __i) {}

    template <class _Tp, class... _Args>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        void __construct(integral_constant<int, 0>, _Tp* __p, _Args&& ...__args)
            {
                typedef __outermost<outer_allocator_type> _OM;
                allocator_traits<typename _OM::type>::construct
                (
                    _OM()(outer_allocator()),
                    __p,
                    std::__1::forward<_Args>(__args)...
                );
            }

    template <class _Tp, class... _Args>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        void __construct(integral_constant<int, 1>, _Tp* __p, _Args&& ...__args)
            {
                typedef __outermost<outer_allocator_type> _OM;
                allocator_traits<typename _OM::type>::construct
                (
                    _OM()(outer_allocator()),
                    __p, allocator_arg, inner_allocator(),
                    std::__1::forward<_Args>(__args)...
                );
            }

    template <class _Tp, class... _Args>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        void __construct(integral_constant<int, 2>, _Tp* __p, _Args&& ...__args)
            {
                typedef __outermost<outer_allocator_type> _OM;
                allocator_traits<typename _OM::type>::construct
                (
                    _OM()(outer_allocator()),
                    __p,
                    std::__1::forward<_Args>(__args)...,
                    inner_allocator()
                );
            }

    template <class ..._Args, size_t ..._Idx>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    tuple<_Args&&...>
    __transform_tuple(integral_constant<int, 0>, tuple<_Args...>&& __t,
                      __tuple_indices<_Idx...>)
    {
        return std::__1::forward_as_tuple(std::__1::get<_Idx>(std::__1::move(__t))...);
    }

    template <class ..._Args, size_t ..._Idx>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    tuple<allocator_arg_t, inner_allocator_type&, _Args&&...>
    __transform_tuple(integral_constant<int, 1>, tuple<_Args...> && __t,
                      __tuple_indices<_Idx...>)
    {
        using _Tup = tuple<allocator_arg_t, inner_allocator_type&, _Args&&...>;
        return _Tup(allocator_arg, inner_allocator(),
                    std::__1::get<_Idx>(std::__1::move(__t))...);
    }

    template <class ..._Args, size_t ..._Idx>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    tuple<_Args&&..., inner_allocator_type&>
    __transform_tuple(integral_constant<int, 2>, tuple<_Args...> && __t,
                      __tuple_indices<_Idx...>)
    {
        using _Tup = tuple<_Args&&..., inner_allocator_type&>;
        return _Tup(std::__1::get<_Idx>(std::__1::move(__t))..., inner_allocator());
    }

    template <class...> friend class __scoped_allocator_storage;
};

template <class _OuterA1, class _OuterA2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator==(const scoped_allocator_adaptor<_OuterA1>& __a,
           const scoped_allocator_adaptor<_OuterA2>& __b) noexcept
{
    return __a.outer_allocator() == __b.outer_allocator();
}

template <class _OuterA1, class _OuterA2, class _InnerA0, class... _InnerAllocs>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator==(const scoped_allocator_adaptor<_OuterA1, _InnerA0, _InnerAllocs...>& __a,
           const scoped_allocator_adaptor<_OuterA2, _InnerA0, _InnerAllocs...>& __b) noexcept
{
    return __a.outer_allocator() == __b.outer_allocator() &&
           __a.inner_allocator() == __b.inner_allocator();
}

template <class _OuterA1, class _OuterA2, class... _InnerAllocs>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator!=(const scoped_allocator_adaptor<_OuterA1, _InnerAllocs...>& __a,
           const scoped_allocator_adaptor<_OuterA2, _InnerAllocs...>& __b) noexcept
{
    return !(__a == __b);
}



} }
# 253 "/usr/local/include/bits/stdc++.h" 2
# 264 "/usr/local/include/bits/stdc++.h"
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/typeindex" 1 3
# 55 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/typeindex" 3


namespace std { inline namespace __1 {

class __attribute__ ((__type_visibility__("default"))) type_index
{
    const type_info* __t_;
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    type_index(const type_info& __y) noexcept : __t_(&__y) {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    bool operator==(const type_index& __y) const noexcept
        {return *__t_ == *__y.__t_;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    bool operator!=(const type_index& __y) const noexcept
        {return *__t_ != *__y.__t_;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    bool operator< (const type_index& __y) const noexcept
        {return __t_->before(*__y.__t_);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    bool operator<=(const type_index& __y) const noexcept
        {return !__y.__t_->before(*__t_);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    bool operator> (const type_index& __y) const noexcept
        {return __y.__t_->before(*__t_);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    bool operator>=(const type_index& __y) const noexcept
        {return !__t_->before(*__y.__t_);}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_t hash_code() const noexcept {return __t_->hash_code();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const char* name() const noexcept {return __t_->name();}
};

template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) hash;

template <>
struct __attribute__ ((__type_visibility__("default"))) hash<type_index>
    : public unary_function<type_index, size_t>
{
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_t operator()(type_index __index) const noexcept
        {return __index.hash_code();}
};

} }
# 265 "/usr/local/include/bits/stdc++.h" 2


# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 1 3
# 268 "/usr/local/include/bits/stdc++.h" 2


# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/unordered_map" 1 3
# 437 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/unordered_map" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__hash_table" 1 3
# 20 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__hash_table" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/memory" 1 3
# 974 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/memory" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 1 3
# 20 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/assert.h" 1 3 4
# 44 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/assert.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/stdlib.h" 1 3 4
# 45 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/assert.h" 2 3 4
# 81 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/assert.h" 3 4
extern "C" {
void __assert_rtn(const char *, const char *, int, const char *) __attribute__((__noreturn__)) __attribute__((__cold__)) __attribute__((__disable_tail_calls__));



}
# 21 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 2 3
# 24 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 3
# 975 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/memory" 2 3
# 21 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__hash_table" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 1 3
# 22 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__hash_table" 2 3
# 26 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__hash_table" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 30 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__hash_table" 2 3


namespace std { inline namespace __1 {

template <class _Key, class _Tp>
struct __hash_value_type;

template <class _Tp>
struct __is_hash_value_type_imp : false_type {};

template <class _Key, class _Value>
struct __is_hash_value_type_imp<__hash_value_type<_Key, _Value> > : true_type {};

template <class ..._Args>
struct __is_hash_value_type : false_type {};

template <class _One>
struct __is_hash_value_type<_One> : __is_hash_value_type_imp<typename __uncvref<_One>::type> {};

__attribute__ ((__visibility__("default")))
size_t __next_prime(size_t __n);

template <class _NodePtr>
struct __hash_node_base
{
    typedef typename pointer_traits<_NodePtr>::element_type __node_type;
    typedef __hash_node_base __first_node;
    typedef typename __rebind_pointer<_NodePtr, __first_node>::type __node_base_pointer;
    typedef _NodePtr __node_pointer;




  typedef typename conditional<
      is_pointer<__node_pointer>::value,
      __node_base_pointer,
      __node_pointer>::type __next_pointer;


    __next_pointer __next_;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __next_pointer __ptr() noexcept {
        return static_cast<__next_pointer>(
            pointer_traits<__node_base_pointer>::pointer_to(*this));
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __node_pointer __upcast() noexcept {
        return static_cast<__node_pointer>(
            pointer_traits<__node_base_pointer>::pointer_to(*this));
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_t __hash() const noexcept {
        return static_cast<__node_type const&>(*this).__hash_;
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) __hash_node_base() noexcept : __next_(nullptr) {}
};

template <class _Tp, class _VoidPtr>
struct __attribute__((__standalone_debug__)) __hash_node
    : public __hash_node_base
             <
                 typename __rebind_pointer<_VoidPtr, __hash_node<_Tp, _VoidPtr> >::type
             >
{
    typedef _Tp __node_value_type;

    size_t __hash_;
    __node_value_type __value_;
};

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
__is_hash_power2(size_t __bc)
{
    return __bc > 2 && !(__bc & (__bc - 1));
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
size_t
__constrain_hash(size_t __h, size_t __bc)
{
    return !(__bc & (__bc - 1)) ? __h & (__bc - 1) :
        (__h < __bc ? __h : __h % __bc);
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
size_t
__next_hash_pow2(size_t __n)
{
    return __n < 2 ? __n : (size_t(1) << (numeric_limits<size_t>::digits - __libcpp_clz(__n-1)));
}


template <class _Tp, class _Hash, class _Equal, class _Alloc> class __hash_table;

template <class _NodePtr> class __attribute__ ((__type_visibility__("default"))) __hash_iterator;
template <class _ConstNodePtr> class __attribute__ ((__type_visibility__("default"))) __hash_const_iterator;
template <class _NodePtr> class __attribute__ ((__type_visibility__("default"))) __hash_local_iterator;
template <class _ConstNodePtr> class __attribute__ ((__type_visibility__("default"))) __hash_const_local_iterator;
template <class _HashIterator> class __attribute__ ((__type_visibility__("default"))) __hash_map_iterator;
template <class _HashIterator> class __attribute__ ((__type_visibility__("default"))) __hash_map_const_iterator;

template <class _Tp>
struct __hash_key_value_types {
  static_assert(!is_reference<_Tp>::value && !is_const<_Tp>::value, "");
  typedef _Tp key_type;
  typedef _Tp __node_value_type;
  typedef _Tp __container_value_type;
  static const bool __is_map = false;

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  static key_type const& __get_key(_Tp const& __v) {
    return __v;
  }
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  static __container_value_type const& __get_value(__node_value_type const& __v) {
    return __v;
  }
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  static __container_value_type* __get_ptr(__node_value_type& __n) {
    return std::__1::addressof(__n);
  }
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  static __container_value_type&& __move(__node_value_type& __v) {
    return std::__1::move(__v);
  }
};

template <class _Key, class _Tp>
struct __hash_key_value_types<__hash_value_type<_Key, _Tp> > {
  typedef _Key key_type;
  typedef _Tp mapped_type;
  typedef __hash_value_type<_Key, _Tp> __node_value_type;
  typedef pair<const _Key, _Tp> __container_value_type;
  typedef __container_value_type __map_value_type;
  static const bool __is_map = true;

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  static key_type const& __get_key(__container_value_type const& __v) {
    return __v.first;
  }

  template <class _Up>
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  static typename enable_if<__is_same_uncvref<_Up, __node_value_type>::value,
      __container_value_type const&>::type
  __get_value(_Up& __t) {
    return __t.__get_value();
  }

  template <class _Up>
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  static typename enable_if<__is_same_uncvref<_Up, __container_value_type>::value,
      __container_value_type const&>::type
  __get_value(_Up& __t) {
    return __t;
  }

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  static __container_value_type* __get_ptr(__node_value_type& __n) {
    return std::__1::addressof(__n.__get_value());
  }
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  static pair<key_type&&, mapped_type&&> __move(__node_value_type& __v) {
    return __v.__move();
  }
};

template <class _Tp, class _AllocPtr, class _KVTypes = __hash_key_value_types<_Tp>,
          bool = _KVTypes::__is_map>
struct __hash_map_pointer_types {};

template <class _Tp, class _AllocPtr, class _KVTypes>
struct __hash_map_pointer_types<_Tp, _AllocPtr, _KVTypes, true> {
  typedef typename _KVTypes::__map_value_type _Mv;
  typedef typename __rebind_pointer<_AllocPtr, _Mv>::type
                                                       __map_value_type_pointer;
  typedef typename __rebind_pointer<_AllocPtr, const _Mv>::type
                                                 __const_map_value_type_pointer;
};

template <class _NodePtr, class _NodeT = typename pointer_traits<_NodePtr>::element_type>
struct __hash_node_types;

template <class _NodePtr, class _Tp, class _VoidPtr>
struct __hash_node_types<_NodePtr, __hash_node<_Tp, _VoidPtr> >
    : public __hash_key_value_types<_Tp>, __hash_map_pointer_types<_Tp, _VoidPtr>

{
  typedef __hash_key_value_types<_Tp> __base;

public:
  typedef ptrdiff_t difference_type;
  typedef size_t size_type;

  typedef typename __rebind_pointer<_NodePtr, void>::type __void_pointer;

  typedef typename pointer_traits<_NodePtr>::element_type __node_type;
  typedef _NodePtr __node_pointer;

  typedef __hash_node_base<__node_pointer> __node_base_type;
  typedef typename __rebind_pointer<_NodePtr, __node_base_type>::type
                                                             __node_base_pointer;

  typedef typename __node_base_type::__next_pointer __next_pointer;

  typedef _Tp __node_value_type;
  typedef typename __rebind_pointer<_VoidPtr, __node_value_type>::type
                                                      __node_value_type_pointer;
  typedef typename __rebind_pointer<_VoidPtr, const __node_value_type>::type
                                                __const_node_value_type_pointer;

private:
    static_assert(!is_const<__node_type>::value,
                "_NodePtr should never be a pointer to const");
    static_assert((is_same<typename pointer_traits<_VoidPtr>::element_type, void>::value),
                  "_VoidPtr does not point to unqualified void type");
    static_assert((is_same<typename __rebind_pointer<_VoidPtr, __node_type>::type,
                          _NodePtr>::value), "_VoidPtr does not rebind to _NodePtr.");
};

template <class _HashIterator>
struct __hash_node_types_from_iterator;
template <class _NodePtr>
struct __hash_node_types_from_iterator<__hash_iterator<_NodePtr> > : __hash_node_types<_NodePtr> {};
template <class _NodePtr>
struct __hash_node_types_from_iterator<__hash_const_iterator<_NodePtr> > : __hash_node_types<_NodePtr> {};
template <class _NodePtr>
struct __hash_node_types_from_iterator<__hash_local_iterator<_NodePtr> > : __hash_node_types<_NodePtr> {};
template <class _NodePtr>
struct __hash_node_types_from_iterator<__hash_const_local_iterator<_NodePtr> > : __hash_node_types<_NodePtr> {};


template <class _NodeValueTp, class _VoidPtr>
struct __make_hash_node_types {
  typedef __hash_node<_NodeValueTp, _VoidPtr> _NodeTp;
  typedef typename __rebind_pointer<_VoidPtr, _NodeTp>::type _NodePtr;
  typedef __hash_node_types<_NodePtr> type;
};

template <class _NodePtr>
class __attribute__ ((__type_visibility__("default"))) __hash_iterator
{
    typedef __hash_node_types<_NodePtr> _NodeTypes;
    typedef _NodePtr __node_pointer;
    typedef typename _NodeTypes::__next_pointer __next_pointer;

    __next_pointer __node_;

public:
    typedef forward_iterator_tag iterator_category;
    typedef typename _NodeTypes::__node_value_type value_type;
    typedef typename _NodeTypes::difference_type difference_type;
    typedef value_type& reference;
    typedef typename _NodeTypes::__node_value_type_pointer pointer;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) __hash_iterator() noexcept : __node_(nullptr) {



    }
# 322 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__hash_table" 3
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    reference operator*() const {
        ((void)0);

        return __node_->__upcast()->__value_;
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    pointer operator->() const {
        ((void)0);

        return pointer_traits<pointer>::pointer_to(__node_->__upcast()->__value_);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __hash_iterator& operator++() {
        ((void)0);

        __node_ = __node_->__next_;
        return *this;
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __hash_iterator operator++(int)
    {
        __hash_iterator __t(*this);
        ++(*this);
        return __t;
    }

    friend __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    bool operator==(const __hash_iterator& __x, const __hash_iterator& __y)
    {
        return __x.__node_ == __y.__node_;
    }
    friend __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    bool operator!=(const __hash_iterator& __x, const __hash_iterator& __y)
        {return !(__x == __y);}

private:
# 370 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__hash_table" 3
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __hash_iterator(__next_pointer __node) noexcept
        : __node_(__node)
        {}

    template <class, class, class, class> friend class __hash_table;
    template <class> friend class __attribute__ ((__type_visibility__("default"))) __hash_const_iterator;
    template <class> friend class __attribute__ ((__type_visibility__("default"))) __hash_map_iterator;
    template <class, class, class, class, class> friend class __attribute__ ((__type_visibility__("default"))) unordered_map;
    template <class, class, class, class, class> friend class __attribute__ ((__type_visibility__("default"))) unordered_multimap;
};

template <class _NodePtr>
class __attribute__ ((__type_visibility__("default"))) __hash_const_iterator
{
    static_assert(!is_const<typename pointer_traits<_NodePtr>::element_type>::value, "");
    typedef __hash_node_types<_NodePtr> _NodeTypes;
    typedef _NodePtr __node_pointer;
    typedef typename _NodeTypes::__next_pointer __next_pointer;

    __next_pointer __node_;

public:
    typedef __hash_iterator<_NodePtr> __non_const_iterator;

    typedef forward_iterator_tag iterator_category;
    typedef typename _NodeTypes::__node_value_type value_type;
    typedef typename _NodeTypes::difference_type difference_type;
    typedef const value_type& reference;
    typedef typename _NodeTypes::__const_node_value_type_pointer pointer;


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) __hash_const_iterator() noexcept : __node_(nullptr) {



    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __hash_const_iterator(const __non_const_iterator& __x) noexcept
        : __node_(__x.__node_)
    {



    }
# 443 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__hash_table" 3
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    reference operator*() const {
        ((void)0);

        return __node_->__upcast()->__value_;
    }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    pointer operator->() const {
        ((void)0);

        return pointer_traits<pointer>::pointer_to(__node_->__upcast()->__value_);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __hash_const_iterator& operator++() {
        ((void)0);

        __node_ = __node_->__next_;
        return *this;
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __hash_const_iterator operator++(int)
    {
        __hash_const_iterator __t(*this);
        ++(*this);
        return __t;
    }

    friend __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    bool operator==(const __hash_const_iterator& __x, const __hash_const_iterator& __y)
    {
        return __x.__node_ == __y.__node_;
    }
    friend __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    bool operator!=(const __hash_const_iterator& __x, const __hash_const_iterator& __y)
        {return !(__x == __y);}

private:
# 490 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__hash_table" 3
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __hash_const_iterator(__next_pointer __node) noexcept
        : __node_(__node)
        {}

    template <class, class, class, class> friend class __hash_table;
    template <class> friend class __attribute__ ((__type_visibility__("default"))) __hash_map_const_iterator;
    template <class, class, class, class, class> friend class __attribute__ ((__type_visibility__("default"))) unordered_map;
    template <class, class, class, class, class> friend class __attribute__ ((__type_visibility__("default"))) unordered_multimap;
};

template <class _NodePtr>
class __attribute__ ((__type_visibility__("default"))) __hash_local_iterator
{
    typedef __hash_node_types<_NodePtr> _NodeTypes;
    typedef _NodePtr __node_pointer;
    typedef typename _NodeTypes::__next_pointer __next_pointer;

    __next_pointer __node_;
    size_t __bucket_;
    size_t __bucket_count_;

public:
    typedef forward_iterator_tag iterator_category;
    typedef typename _NodeTypes::__node_value_type value_type;
    typedef typename _NodeTypes::difference_type difference_type;
    typedef value_type& reference;
    typedef typename _NodeTypes::__node_value_type_pointer pointer;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) __hash_local_iterator() noexcept : __node_(nullptr) {



    }
# 555 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__hash_table" 3
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    reference operator*() const {
        ((void)0);

        return __node_->__upcast()->__value_;
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    pointer operator->() const {
        ((void)0);

        return pointer_traits<pointer>::pointer_to(__node_->__upcast()->__value_);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __hash_local_iterator& operator++() {
        ((void)0);

        __node_ = __node_->__next_;
        if (__node_ != nullptr && __constrain_hash(__node_->__hash(), __bucket_count_) != __bucket_)
            __node_ = nullptr;
        return *this;
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __hash_local_iterator operator++(int)
    {
        __hash_local_iterator __t(*this);
        ++(*this);
        return __t;
    }

    friend __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    bool operator==(const __hash_local_iterator& __x, const __hash_local_iterator& __y)
    {
        return __x.__node_ == __y.__node_;
    }
    friend __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    bool operator!=(const __hash_local_iterator& __x, const __hash_local_iterator& __y)
        {return !(__x == __y);}

private:
# 610 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__hash_table" 3
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __hash_local_iterator(__next_pointer __node, size_t __bucket,
                          size_t __bucket_count) noexcept
        : __node_(__node),
          __bucket_(__bucket),
          __bucket_count_(__bucket_count)
        {
            if (__node_ != nullptr)
                __node_ = __node_->__next_;
        }

    template <class, class, class, class> friend class __hash_table;
    template <class> friend class __attribute__ ((__type_visibility__("default"))) __hash_const_local_iterator;
    template <class> friend class __attribute__ ((__type_visibility__("default"))) __hash_map_iterator;
};

template <class _ConstNodePtr>
class __attribute__ ((__type_visibility__("default"))) __hash_const_local_iterator
{
    typedef __hash_node_types<_ConstNodePtr> _NodeTypes;
    typedef _ConstNodePtr __node_pointer;
    typedef typename _NodeTypes::__next_pointer __next_pointer;

    __next_pointer __node_;
    size_t __bucket_;
    size_t __bucket_count_;

    typedef pointer_traits<__node_pointer> __pointer_traits;
    typedef typename __pointer_traits::element_type __node;
    typedef typename remove_const<__node>::type __non_const_node;
    typedef typename __rebind_pointer<__node_pointer, __non_const_node>::type
        __non_const_node_pointer;
public:
    typedef __hash_local_iterator<__non_const_node_pointer>
                                                    __non_const_iterator;

    typedef forward_iterator_tag iterator_category;
    typedef typename _NodeTypes::__node_value_type value_type;
    typedef typename _NodeTypes::difference_type difference_type;
    typedef const value_type& reference;
    typedef typename _NodeTypes::__const_node_value_type_pointer pointer;


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) __hash_const_local_iterator() noexcept : __node_(nullptr) {



    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __hash_const_local_iterator(const __non_const_iterator& __x) noexcept
        : __node_(__x.__node_),
          __bucket_(__x.__bucket_),
          __bucket_count_(__x.__bucket_count_)
    {



    }
# 700 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__hash_table" 3
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    reference operator*() const {
        ((void)0);

        return __node_->__upcast()->__value_;
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    pointer operator->() const {
        ((void)0);

        return pointer_traits<pointer>::pointer_to(__node_->__upcast()->__value_);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __hash_const_local_iterator& operator++() {
        ((void)0);

        __node_ = __node_->__next_;
        if (__node_ != nullptr && __constrain_hash(__node_->__hash(), __bucket_count_) != __bucket_)
            __node_ = nullptr;
        return *this;
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __hash_const_local_iterator operator++(int)
    {
        __hash_const_local_iterator __t(*this);
        ++(*this);
        return __t;
    }

    friend __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    bool operator==(const __hash_const_local_iterator& __x, const __hash_const_local_iterator& __y)
    {
        return __x.__node_ == __y.__node_;
    }
    friend __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    bool operator!=(const __hash_const_local_iterator& __x, const __hash_const_local_iterator& __y)
        {return !(__x == __y);}

private:
# 755 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__hash_table" 3
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __hash_const_local_iterator(__next_pointer __node_ptr, size_t __bucket,
                                size_t __bucket_count) noexcept
        : __node_(__node_ptr),
          __bucket_(__bucket),
          __bucket_count_(__bucket_count)
        {
            if (__node_ != nullptr)
                __node_ = __node_->__next_;
        }

    template <class, class, class, class> friend class __hash_table;
    template <class> friend class __attribute__ ((__type_visibility__("default"))) __hash_map_const_iterator;
};

template <class _Alloc>
class __bucket_list_deallocator
{
    typedef _Alloc allocator_type;
    typedef allocator_traits<allocator_type> __alloc_traits;
    typedef typename __alloc_traits::size_type size_type;

    __compressed_pair<size_type, allocator_type> __data_;
public:
    typedef typename __alloc_traits::pointer pointer;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __bucket_list_deallocator()
        noexcept(is_nothrow_default_constructible<allocator_type>::value)
        : __data_(0, __default_init_tag()) {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __bucket_list_deallocator(const allocator_type& __a, size_type __size)
        noexcept(is_nothrow_copy_constructible<allocator_type>::value)
        : __data_(__size, __a) {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __bucket_list_deallocator(__bucket_list_deallocator&& __x)
        noexcept(is_nothrow_move_constructible<allocator_type>::value)
        : __data_(std::__1::move(__x.__data_))
    {
        __x.size() = 0;
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_type& size() noexcept {return __data_.first();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_type size() const noexcept {return __data_.first();}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    allocator_type& __alloc() noexcept {return __data_.second();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const allocator_type& __alloc() const noexcept {return __data_.second();}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void operator()(pointer __p) noexcept
    {
        __alloc_traits::deallocate(__alloc(), __p, size());
    }
};

template <class _Alloc> class __hash_map_node_destructor;

template <class _Alloc>
class __hash_node_destructor
{
    typedef _Alloc allocator_type;
    typedef allocator_traits<allocator_type> __alloc_traits;

public:
    typedef typename __alloc_traits::pointer pointer;
private:
    typedef __hash_node_types<pointer> _NodeTypes;

    allocator_type& __na_;

public:
    bool __value_constructed;

    __hash_node_destructor(__hash_node_destructor const&) = default;
    __hash_node_destructor& operator=(const __hash_node_destructor&) = delete;


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit __hash_node_destructor(allocator_type& __na,
                                    bool __constructed = false) noexcept
        : __na_(__na),
          __value_constructed(__constructed)
        {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void operator()(pointer __p) noexcept
    {
        if (__value_constructed)
            __alloc_traits::destroy(__na_, _NodeTypes::__get_ptr(__p->__value_));
        if (__p)
            __alloc_traits::deallocate(__na_, __p, 1);
    }

    template <class> friend class __hash_map_node_destructor;
};


template <class _NodeType, class _Alloc>
struct __generic_container_node_destructor;

template <class _Tp, class _VoidPtr, class _Alloc>
struct __generic_container_node_destructor<__hash_node<_Tp, _VoidPtr>, _Alloc>
    : __hash_node_destructor<_Alloc>
{
    using __hash_node_destructor<_Alloc>::__hash_node_destructor;
};


template <class _Key, class _Hash, class _Equal>
struct __enforce_unordered_container_requirements {

    static_assert(__check_hash_requirements<_Key, _Hash>::value,
    "the specified hash does not meet the Hash requirements");
    static_assert(is_copy_constructible<_Equal>::value,
    "the specified comparator is required to be copy constructible");

    typedef int type;
};

template <class _Key, class _Hash, class _Equal>

    __attribute__((diagnose_if(!__invokable<_Equal const&, _Key const&, _Key const&>::value, "the specified comparator type does not provide a viable const call operator", "warning")))

    __attribute__((diagnose_if(!__invokable<_Hash const&, _Key const&>::value, "the specified hash functor does not provide a viable const call operator", "warning")))


typename __enforce_unordered_container_requirements<_Key, _Hash, _Equal>::type
__diagnose_unordered_container_requirements(int);




template <class _Key, class _Hash, class _Equal>
int __diagnose_unordered_container_requirements(void*);

template <class _Tp, class _Hash, class _Equal, class _Alloc>
class __hash_table
{
public:
    typedef _Tp value_type;
    typedef _Hash hasher;
    typedef _Equal key_equal;
    typedef _Alloc allocator_type;

private:
    typedef allocator_traits<allocator_type> __alloc_traits;
    typedef typename
      __make_hash_node_types<value_type, typename __alloc_traits::void_pointer>::type
                                                                     _NodeTypes;
public:

    typedef typename _NodeTypes::__node_value_type __node_value_type;
    typedef typename _NodeTypes::__container_value_type __container_value_type;
    typedef typename _NodeTypes::key_type key_type;
    typedef value_type& reference;
    typedef const value_type& const_reference;
    typedef typename __alloc_traits::pointer pointer;
    typedef typename __alloc_traits::const_pointer const_pointer;

    typedef typename __alloc_traits::size_type size_type;



    typedef typename _NodeTypes::difference_type difference_type;
public:


    typedef typename _NodeTypes::__node_type __node;
    typedef typename __rebind_alloc_helper<__alloc_traits, __node>::type __node_allocator;
    typedef allocator_traits<__node_allocator> __node_traits;
    typedef typename _NodeTypes::__void_pointer __void_pointer;
    typedef typename _NodeTypes::__node_pointer __node_pointer;
    typedef typename _NodeTypes::__node_pointer __node_const_pointer;
    typedef typename _NodeTypes::__node_base_type __first_node;
    typedef typename _NodeTypes::__node_base_pointer __node_base_pointer;
    typedef typename _NodeTypes::__next_pointer __next_pointer;

private:



    static_assert((is_same<__node_pointer, typename __node_traits::pointer>::value),
                  "Allocator does not rebind pointers in a sane manner.");
    typedef typename __rebind_alloc_helper<__node_traits, __first_node>::type
        __node_base_allocator;
    typedef allocator_traits<__node_base_allocator> __node_base_traits;
    static_assert((is_same<__node_base_pointer, typename __node_base_traits::pointer>::value),
                 "Allocator does not rebind pointers in a sane manner.");

private:

    typedef typename __rebind_alloc_helper<__node_traits, __next_pointer>::type __pointer_allocator;
    typedef __bucket_list_deallocator<__pointer_allocator> __bucket_list_deleter;
    typedef unique_ptr<__next_pointer[], __bucket_list_deleter> __bucket_list;
    typedef allocator_traits<__pointer_allocator> __pointer_alloc_traits;
    typedef typename __bucket_list_deleter::pointer __node_pointer_pointer;


    __bucket_list __bucket_list_;
    __compressed_pair<__first_node, __node_allocator> __p1_;
    __compressed_pair<size_type, hasher> __p2_;
    __compressed_pair<float, key_equal> __p3_;


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_type& size() noexcept {return __p2_.first();}
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_type size() const noexcept {return __p2_.first();}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    hasher& hash_function() noexcept {return __p2_.second();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const hasher& hash_function() const noexcept {return __p2_.second();}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    float& max_load_factor() noexcept {return __p3_.first();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    float max_load_factor() const noexcept {return __p3_.first();}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    key_equal& key_eq() noexcept {return __p3_.second();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const key_equal& key_eq() const noexcept {return __p3_.second();}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __node_allocator& __node_alloc() noexcept {return __p1_.second();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const __node_allocator& __node_alloc() const noexcept
        {return __p1_.second();}

public:
    typedef __hash_iterator<__node_pointer> iterator;
    typedef __hash_const_iterator<__node_pointer> const_iterator;
    typedef __hash_local_iterator<__node_pointer> local_iterator;
    typedef __hash_const_local_iterator<__node_pointer> const_local_iterator;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __hash_table()
        noexcept(is_nothrow_default_constructible<__bucket_list>::value && is_nothrow_default_constructible<__first_node>::value && is_nothrow_default_constructible<__node_allocator>::value && is_nothrow_default_constructible<hasher>::value && is_nothrow_default_constructible<key_equal>::value);





    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __hash_table(const hasher& __hf, const key_equal& __eql);
    __hash_table(const hasher& __hf, const key_equal& __eql,
                 const allocator_type& __a);
    explicit __hash_table(const allocator_type& __a);
    __hash_table(const __hash_table& __u);
    __hash_table(const __hash_table& __u, const allocator_type& __a);
    __hash_table(__hash_table&& __u)
        noexcept(is_nothrow_move_constructible<__bucket_list>::value && is_nothrow_move_constructible<__first_node>::value && is_nothrow_move_constructible<__node_allocator>::value && is_nothrow_move_constructible<hasher>::value && is_nothrow_move_constructible<key_equal>::value);





    __hash_table(__hash_table&& __u, const allocator_type& __a);
    ~__hash_table();

    __hash_table& operator=(const __hash_table& __u);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __hash_table& operator=(__hash_table&& __u)
        noexcept(__node_traits::propagate_on_container_move_assignment::value && is_nothrow_move_assignable<__node_allocator>::value && is_nothrow_move_assignable<hasher>::value && is_nothrow_move_assignable<key_equal>::value);




    template <class _InputIterator>
        void __assign_unique(_InputIterator __first, _InputIterator __last);
    template <class _InputIterator>
        void __assign_multi(_InputIterator __first, _InputIterator __last);

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_type max_size() const noexcept
    {
        return std::__1::min<size_type>(
            __node_traits::max_size(__node_alloc()),
            numeric_limits<difference_type >::max()
        );
    }

private:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __next_pointer __node_insert_multi_prepare(size_t __cp_hash,
                                               value_type& __cp_val);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void __node_insert_multi_perform(__node_pointer __cp,
                                     __next_pointer __pn) noexcept;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __next_pointer __node_insert_unique_prepare(size_t __nd_hash,
                                                value_type& __nd_val);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void __node_insert_unique_perform(__node_pointer __ptr) noexcept;

public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    pair<iterator, bool> __node_insert_unique(__node_pointer __nd);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iterator __node_insert_multi(__node_pointer __nd);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iterator __node_insert_multi(const_iterator __p,
                                             __node_pointer __nd);

    template <class _Key, class ..._Args>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    pair<iterator, bool> __emplace_unique_key_args(_Key const& __k, _Args&&... __args);

    template <class... _Args>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    pair<iterator, bool> __emplace_unique_impl(_Args&&... __args);

    template <class _Pp>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    pair<iterator, bool> __emplace_unique(_Pp&& __x) {
      return __emplace_unique_extract_key(std::__1::forward<_Pp>(__x),
                                          __can_extract_key<_Pp, key_type>());
    }

    template <class _First, class _Second>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    typename enable_if<
        __can_extract_map_key<_First, key_type, __container_value_type>::value,
        pair<iterator, bool>
    >::type __emplace_unique(_First&& __f, _Second&& __s) {
        return __emplace_unique_key_args(__f, std::__1::forward<_First>(__f),
                                              std::__1::forward<_Second>(__s));
    }

    template <class... _Args>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    pair<iterator, bool> __emplace_unique(_Args&&... __args) {
      return __emplace_unique_impl(std::__1::forward<_Args>(__args)...);
    }

    template <class _Pp>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    pair<iterator, bool>
    __emplace_unique_extract_key(_Pp&& __x, __extract_key_fail_tag) {
      return __emplace_unique_impl(std::__1::forward<_Pp>(__x));
    }
    template <class _Pp>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    pair<iterator, bool>
    __emplace_unique_extract_key(_Pp&& __x, __extract_key_self_tag) {
      return __emplace_unique_key_args(__x, std::__1::forward<_Pp>(__x));
    }
    template <class _Pp>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    pair<iterator, bool>
    __emplace_unique_extract_key(_Pp&& __x, __extract_key_first_tag) {
      return __emplace_unique_key_args(__x.first, std::__1::forward<_Pp>(__x));
    }

    template <class... _Args>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iterator __emplace_multi(_Args&&... __args);
    template <class... _Args>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iterator __emplace_hint_multi(const_iterator __p, _Args&&... __args);


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    pair<iterator, bool>
    __insert_unique(__container_value_type&& __x) {
      return __emplace_unique_key_args(_NodeTypes::__get_key(__x), std::__1::move(__x));
    }

    template <class _Pp, class = typename enable_if<
            !__is_same_uncvref<_Pp, __container_value_type>::value
        >::type>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    pair<iterator, bool> __insert_unique(_Pp&& __x) {
      return __emplace_unique(std::__1::forward<_Pp>(__x));
    }

    template <class _Pp>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iterator __insert_multi(_Pp&& __x) {
      return __emplace_multi(std::__1::forward<_Pp>(__x));
    }

    template <class _Pp>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iterator __insert_multi(const_iterator __p, _Pp&& __x) {
        return __emplace_hint_multi(__p, std::__1::forward<_Pp>(__x));
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    pair<iterator, bool> __insert_unique(const __container_value_type& __x) {
        return __emplace_unique_key_args(_NodeTypes::__get_key(__x), __x);
    }


    template <class _NodeHandle, class _InsertReturnType>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    _InsertReturnType __node_handle_insert_unique(_NodeHandle&& __nh);
    template <class _NodeHandle>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iterator __node_handle_insert_unique(const_iterator __hint,
                                         _NodeHandle&& __nh);
    template <class _Table>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void __node_handle_merge_unique(_Table& __source);

    template <class _NodeHandle>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iterator __node_handle_insert_multi(_NodeHandle&& __nh);
    template <class _NodeHandle>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iterator __node_handle_insert_multi(const_iterator __hint, _NodeHandle&& __nh);
    template <class _Table>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void __node_handle_merge_multi(_Table& __source);

    template <class _NodeHandle>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    _NodeHandle __node_handle_extract(key_type const& __key);
    template <class _NodeHandle>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    _NodeHandle __node_handle_extract(const_iterator __it);


    void clear() noexcept;
    void rehash(size_type __n);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) void reserve(size_type __n)
        {rehash(static_cast<size_type>(ceil(__n / max_load_factor())));}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_type bucket_count() const noexcept
    {
        return __bucket_list_.get_deleter().size();
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iterator begin() noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iterator end() noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_iterator begin() const noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_iterator end() const noexcept;

    template <class _Key>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        size_type bucket(const _Key& __k) const
        {
            ((void)0);

            return __constrain_hash(hash_function()(__k), bucket_count());
        }

    template <class _Key>
        iterator find(const _Key& __x);
    template <class _Key>
        const_iterator find(const _Key& __x) const;

    typedef __hash_node_destructor<__node_allocator> _Dp;
    typedef unique_ptr<__node, _Dp> __node_holder;

    iterator erase(const_iterator __p);
    iterator erase(const_iterator __first, const_iterator __last);
    template <class _Key>
        size_type __erase_unique(const _Key& __k);
    template <class _Key>
        size_type __erase_multi(const _Key& __k);
    __node_holder remove(const_iterator __p) noexcept;

    template <class _Key>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        size_type __count_unique(const _Key& __k) const;
    template <class _Key>
        size_type __count_multi(const _Key& __k) const;

    template <class _Key>
        pair<iterator, iterator>
        __equal_range_unique(const _Key& __k);
    template <class _Key>
        pair<const_iterator, const_iterator>
        __equal_range_unique(const _Key& __k) const;

    template <class _Key>
        pair<iterator, iterator>
        __equal_range_multi(const _Key& __k);
    template <class _Key>
        pair<const_iterator, const_iterator>
        __equal_range_multi(const _Key& __k) const;

    void swap(__hash_table& __u)
# 1262 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__hash_table" 3
     noexcept(__is_nothrow_swappable<hasher>::value && __is_nothrow_swappable<key_equal>::value);


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_type max_bucket_count() const noexcept
        {return max_size(); }
    size_type bucket_size(size_type __n) const;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) float load_factor() const noexcept
    {
        size_type __bc = bucket_count();
        return __bc != 0 ? (float)size() / __bc : 0.f;
    }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) void max_load_factor(float __mlf) noexcept
    {
        ((void)0);

        max_load_factor() = std::__1::max(__mlf, load_factor());
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    local_iterator
    begin(size_type __n)
    {
        ((void)0);




        return local_iterator(__bucket_list_[__n], __n, bucket_count());

    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    local_iterator
    end(size_type __n)
    {
        ((void)0);




        return local_iterator(nullptr, __n, bucket_count());

    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_local_iterator
    cbegin(size_type __n) const
    {
        ((void)0);




        return const_local_iterator(__bucket_list_[__n], __n, bucket_count());

    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_local_iterator
    cend(size_type __n) const
    {
        ((void)0);




        return const_local_iterator(nullptr, __n, bucket_count());

    }
# 1342 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__hash_table" 3
private:
    void __rehash(size_type __n);

    template <class ..._Args>
    __node_holder __construct_node(_Args&& ...__args);

    template <class _First, class ..._Rest>
    __node_holder __construct_node_hash(size_t __hash, _First&& __f, _Rest&&... __rest);


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void __copy_assign_alloc(const __hash_table& __u)
        {__copy_assign_alloc(__u, integral_constant<bool,
             __node_traits::propagate_on_container_copy_assignment::value>());}
    void __copy_assign_alloc(const __hash_table& __u, true_type);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        void __copy_assign_alloc(const __hash_table&, false_type) {}

    void __move_assign(__hash_table& __u, false_type);
    void __move_assign(__hash_table& __u, true_type)
        noexcept(is_nothrow_move_assignable<__node_allocator>::value && is_nothrow_move_assignable<hasher>::value && is_nothrow_move_assignable<key_equal>::value);



    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void __move_assign_alloc(__hash_table& __u)
        noexcept(!__node_traits::propagate_on_container_move_assignment::value || (is_nothrow_move_assignable<__pointer_allocator>::value && is_nothrow_move_assignable<__node_allocator>::value))



        {__move_assign_alloc(__u, integral_constant<bool,
             __node_traits::propagate_on_container_move_assignment::value>());}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void __move_assign_alloc(__hash_table& __u, true_type)
        noexcept(is_nothrow_move_assignable<__pointer_allocator>::value && is_nothrow_move_assignable<__node_allocator>::value)


    {
        __bucket_list_.get_deleter().__alloc() =
                std::__1::move(__u.__bucket_list_.get_deleter().__alloc());
        __node_alloc() = std::__1::move(__u.__node_alloc());
    }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        void __move_assign_alloc(__hash_table&, false_type) noexcept {}

    void __deallocate_node(__next_pointer __np) noexcept;
    __next_pointer __detach() noexcept;

    template <class, class, class, class, class> friend class __attribute__ ((__type_visibility__("default"))) unordered_map;
    template <class, class, class, class, class> friend class __attribute__ ((__type_visibility__("default"))) unordered_multimap;
};

template <class _Tp, class _Hash, class _Equal, class _Alloc>
inline
__hash_table<_Tp, _Hash, _Equal, _Alloc>::__hash_table()
    noexcept(is_nothrow_default_constructible<__bucket_list>::value && is_nothrow_default_constructible<__first_node>::value && is_nothrow_default_constructible<__node_allocator>::value && is_nothrow_default_constructible<hasher>::value && is_nothrow_default_constructible<key_equal>::value)





    : __p2_(0, __default_init_tag()),
      __p3_(1.0f, __default_init_tag())
{
}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
inline
__hash_table<_Tp, _Hash, _Equal, _Alloc>::__hash_table(const hasher& __hf,
                                                       const key_equal& __eql)
    : __bucket_list_(nullptr, __bucket_list_deleter()),
      __p1_(),
      __p2_(0, __hf),
      __p3_(1.0f, __eql)
{
}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
__hash_table<_Tp, _Hash, _Equal, _Alloc>::__hash_table(const hasher& __hf,
                                                       const key_equal& __eql,
                                                       const allocator_type& __a)
    : __bucket_list_(nullptr, __bucket_list_deleter(__pointer_allocator(__a), 0)),
      __p1_(__default_init_tag(), __node_allocator(__a)),
      __p2_(0, __hf),
      __p3_(1.0f, __eql)
{
}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
__hash_table<_Tp, _Hash, _Equal, _Alloc>::__hash_table(const allocator_type& __a)
    : __bucket_list_(nullptr, __bucket_list_deleter(__pointer_allocator(__a), 0)),
      __p1_(__default_init_tag(), __node_allocator(__a)),
      __p2_(0, __default_init_tag()),
      __p3_(1.0f, __default_init_tag())
{
}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
__hash_table<_Tp, _Hash, _Equal, _Alloc>::__hash_table(const __hash_table& __u)
    : __bucket_list_(nullptr,
          __bucket_list_deleter(allocator_traits<__pointer_allocator>::
              select_on_container_copy_construction(
                  __u.__bucket_list_.get_deleter().__alloc()), 0)),
      __p1_(__default_init_tag(), allocator_traits<__node_allocator>::
          select_on_container_copy_construction(__u.__node_alloc())),
      __p2_(0, __u.hash_function()),
      __p3_(__u.__p3_)
{
}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
__hash_table<_Tp, _Hash, _Equal, _Alloc>::__hash_table(const __hash_table& __u,
                                                       const allocator_type& __a)
    : __bucket_list_(nullptr, __bucket_list_deleter(__pointer_allocator(__a), 0)),
      __p1_(__default_init_tag(), __node_allocator(__a)),
      __p2_(0, __u.hash_function()),
      __p3_(__u.__p3_)
{
}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
__hash_table<_Tp, _Hash, _Equal, _Alloc>::__hash_table(__hash_table&& __u)
        noexcept(is_nothrow_move_constructible<__bucket_list>::value && is_nothrow_move_constructible<__first_node>::value && is_nothrow_move_constructible<__node_allocator>::value && is_nothrow_move_constructible<hasher>::value && is_nothrow_move_constructible<key_equal>::value)





    : __bucket_list_(std::__1::move(__u.__bucket_list_)),
      __p1_(std::__1::move(__u.__p1_)),
      __p2_(std::__1::move(__u.__p2_)),
      __p3_(std::__1::move(__u.__p3_))
{
    if (size() > 0)
    {
        __bucket_list_[__constrain_hash(__p1_.first().__next_->__hash(), bucket_count())] =
            __p1_.first().__ptr();
        __u.__p1_.first().__next_ = nullptr;
        __u.size() = 0;
    }
}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
__hash_table<_Tp, _Hash, _Equal, _Alloc>::__hash_table(__hash_table&& __u,
                                                       const allocator_type& __a)
    : __bucket_list_(nullptr, __bucket_list_deleter(__pointer_allocator(__a), 0)),
      __p1_(__default_init_tag(), __node_allocator(__a)),
      __p2_(0, std::__1::move(__u.hash_function())),
      __p3_(std::__1::move(__u.__p3_))
{
    if (__a == allocator_type(__u.__node_alloc()))
    {
        __bucket_list_.reset(__u.__bucket_list_.release());
        __bucket_list_.get_deleter().size() = __u.__bucket_list_.get_deleter().size();
        __u.__bucket_list_.get_deleter().size() = 0;
        if (__u.size() > 0)
        {
            __p1_.first().__next_ = __u.__p1_.first().__next_;
            __u.__p1_.first().__next_ = nullptr;
            __bucket_list_[__constrain_hash(__p1_.first().__next_->__hash(), bucket_count())] =
                __p1_.first().__ptr();
            size() = __u.size();
            __u.size() = 0;
        }
    }
}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
__hash_table<_Tp, _Hash, _Equal, _Alloc>::~__hash_table()
{







    __deallocate_node(__p1_.first().__next_);



}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
void
__hash_table<_Tp, _Hash, _Equal, _Alloc>::__copy_assign_alloc(
        const __hash_table& __u, true_type)
{
    if (__node_alloc() != __u.__node_alloc())
    {
        clear();
        __bucket_list_.reset();
        __bucket_list_.get_deleter().size() = 0;
    }
    __bucket_list_.get_deleter().__alloc() = __u.__bucket_list_.get_deleter().__alloc();
    __node_alloc() = __u.__node_alloc();
}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
__hash_table<_Tp, _Hash, _Equal, _Alloc>&
__hash_table<_Tp, _Hash, _Equal, _Alloc>::operator=(const __hash_table& __u)
{
    if (this != &__u)
    {
        __copy_assign_alloc(__u);
        hash_function() = __u.hash_function();
        key_eq() = __u.key_eq();
        max_load_factor() = __u.max_load_factor();
        __assign_multi(__u.begin(), __u.end());
    }
    return *this;
}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
void
__hash_table<_Tp, _Hash, _Equal, _Alloc>::__deallocate_node(__next_pointer __np)
    noexcept
{
    __node_allocator& __na = __node_alloc();
    while (__np != nullptr)
    {
        __next_pointer __next = __np->__next_;
# 1579 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__hash_table" 3
        __node_pointer __real_np = __np->__upcast();
        __node_traits::destroy(__na, _NodeTypes::__get_ptr(__real_np->__value_));
        __node_traits::deallocate(__na, __real_np, 1);
        __np = __next;
    }
}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::__next_pointer
__hash_table<_Tp, _Hash, _Equal, _Alloc>::__detach() noexcept
{
    size_type __bc = bucket_count();
    for (size_type __i = 0; __i < __bc; ++__i)
        __bucket_list_[__i] = nullptr;
    size() = 0;
    __next_pointer __cache = __p1_.first().__next_;
    __p1_.first().__next_ = nullptr;
    return __cache;
}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
void
__hash_table<_Tp, _Hash, _Equal, _Alloc>::__move_assign(
        __hash_table& __u, true_type)
    noexcept(is_nothrow_move_assignable<__node_allocator>::value && is_nothrow_move_assignable<hasher>::value && is_nothrow_move_assignable<key_equal>::value)



{
    clear();
    __bucket_list_.reset(__u.__bucket_list_.release());
    __bucket_list_.get_deleter().size() = __u.__bucket_list_.get_deleter().size();
    __u.__bucket_list_.get_deleter().size() = 0;
    __move_assign_alloc(__u);
    size() = __u.size();
    hash_function() = std::__1::move(__u.hash_function());
    max_load_factor() = __u.max_load_factor();
    key_eq() = std::__1::move(__u.key_eq());
    __p1_.first().__next_ = __u.__p1_.first().__next_;
    if (size() > 0)
    {
        __bucket_list_[__constrain_hash(__p1_.first().__next_->__hash(), bucket_count())] =
            __p1_.first().__ptr();
        __u.__p1_.first().__next_ = nullptr;
        __u.size() = 0;
    }



}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
void
__hash_table<_Tp, _Hash, _Equal, _Alloc>::__move_assign(
        __hash_table& __u, false_type)
{
    if (__node_alloc() == __u.__node_alloc())
        __move_assign(__u, true_type());
    else
    {
        hash_function() = std::__1::move(__u.hash_function());
        key_eq() = std::__1::move(__u.key_eq());
        max_load_factor() = __u.max_load_factor();
        if (bucket_count() != 0)
        {
            __next_pointer __cache = __detach();

            try
            {

                const_iterator __i = __u.begin();
                while (__cache != nullptr && __u.size() != 0)
                {
                    __cache->__upcast()->__value_ =
                        std::__1::move(__u.remove(__i++)->__value_);
                    __next_pointer __next = __cache->__next_;
                    __node_insert_multi(__cache->__upcast());
                    __cache = __next;
                }

            }
            catch (...)
            {
                __deallocate_node(__cache);
                throw;
            }

            __deallocate_node(__cache);
        }
        const_iterator __i = __u.begin();
        while (__u.size() != 0)
        {
            __node_holder __h = __construct_node(_NodeTypes::__move(__u.remove(__i++)->__value_));
            __node_insert_multi(__h.get());
            __h.release();
        }
    }
}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
inline
__hash_table<_Tp, _Hash, _Equal, _Alloc>&
__hash_table<_Tp, _Hash, _Equal, _Alloc>::operator=(__hash_table&& __u)
    noexcept(__node_traits::propagate_on_container_move_assignment::value && is_nothrow_move_assignable<__node_allocator>::value && is_nothrow_move_assignable<hasher>::value && is_nothrow_move_assignable<key_equal>::value)




{
    __move_assign(__u, integral_constant<bool,
                  __node_traits::propagate_on_container_move_assignment::value>());
    return *this;
}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
template <class _InputIterator>
void
__hash_table<_Tp, _Hash, _Equal, _Alloc>::__assign_unique(_InputIterator __first,
                                                          _InputIterator __last)
{
    typedef iterator_traits<_InputIterator> _ITraits;
    typedef typename _ITraits::value_type _ItValueType;
    static_assert((is_same<_ItValueType, __container_value_type>::value),
                  "__assign_unique may only be called with the containers value type");

    if (bucket_count() != 0)
    {
        __next_pointer __cache = __detach();

        try
        {

            for (; __cache != nullptr && __first != __last; ++__first)
            {
                __cache->__upcast()->__value_ = *__first;
                __next_pointer __next = __cache->__next_;
                __node_insert_unique(__cache->__upcast());
                __cache = __next;
            }

        }
        catch (...)
        {
            __deallocate_node(__cache);
            throw;
        }

        __deallocate_node(__cache);
    }
    for (; __first != __last; ++__first)
        __insert_unique(*__first);
}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
template <class _InputIterator>
void
__hash_table<_Tp, _Hash, _Equal, _Alloc>::__assign_multi(_InputIterator __first,
                                                         _InputIterator __last)
{
    typedef iterator_traits<_InputIterator> _ITraits;
    typedef typename _ITraits::value_type _ItValueType;
    static_assert((is_same<_ItValueType, __container_value_type>::value ||
                  is_same<_ItValueType, __node_value_type>::value),
                  "__assign_multi may only be called with the containers value type"
                  " or the nodes value type");
    if (bucket_count() != 0)
    {
        __next_pointer __cache = __detach();

        try
        {

            for (; __cache != nullptr && __first != __last; ++__first)
            {
                __cache->__upcast()->__value_ = *__first;
                __next_pointer __next = __cache->__next_;
                __node_insert_multi(__cache->__upcast());
                __cache = __next;
            }

        }
        catch (...)
        {
            __deallocate_node(__cache);
            throw;
        }

        __deallocate_node(__cache);
    }
    for (; __first != __last; ++__first)
        __insert_multi(_NodeTypes::__get_value(*__first));
}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
inline
typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::iterator
__hash_table<_Tp, _Hash, _Equal, _Alloc>::begin() noexcept
{



    return iterator(__p1_.first().__next_);

}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
inline
typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::iterator
__hash_table<_Tp, _Hash, _Equal, _Alloc>::end() noexcept
{



    return iterator(nullptr);

}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
inline
typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::const_iterator
__hash_table<_Tp, _Hash, _Equal, _Alloc>::begin() const noexcept
{



    return const_iterator(__p1_.first().__next_);

}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
inline
typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::const_iterator
__hash_table<_Tp, _Hash, _Equal, _Alloc>::end() const noexcept
{



    return const_iterator(nullptr);

}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
void
__hash_table<_Tp, _Hash, _Equal, _Alloc>::clear() noexcept
{
    if (size() > 0)
    {
        __deallocate_node(__p1_.first().__next_);
        __p1_.first().__next_ = nullptr;
        size_type __bc = bucket_count();
        for (size_type __i = 0; __i < __bc; ++__i)
            __bucket_list_[__i] = nullptr;
        size() = 0;
    }
}
# 1843 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__hash_table" 3
template <class _Tp, class _Hash, class _Equal, class _Alloc>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::__next_pointer
__hash_table<_Tp, _Hash, _Equal, _Alloc>::__node_insert_unique_prepare(
    size_t __hash, value_type& __value)
{
    size_type __bc = bucket_count();

    if (__bc != 0)
    {
        size_t __chash = __constrain_hash(__hash, __bc);
        __next_pointer __ndptr = __bucket_list_[__chash];
        if (__ndptr != nullptr)
        {
            for (__ndptr = __ndptr->__next_; __ndptr != nullptr &&
                                             __constrain_hash(__ndptr->__hash(), __bc) == __chash;
                                                     __ndptr = __ndptr->__next_)
            {
                if (key_eq()(__ndptr->__upcast()->__value_, __value))
                    return __ndptr;
            }
        }
    }
    if (size()+1 > __bc * max_load_factor() || __bc == 0)
    {
        rehash(std::__1::max<size_type>(2 * __bc + !__is_hash_power2(__bc),
                                     size_type(ceil(float(size() + 1) / max_load_factor()))));
    }
    return nullptr;
}





template <class _Tp, class _Hash, class _Equal, class _Alloc>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void
__hash_table<_Tp, _Hash, _Equal, _Alloc>::__node_insert_unique_perform(
    __node_pointer __nd) noexcept
{
    size_type __bc = bucket_count();
    size_t __chash = __constrain_hash(__nd->__hash(), __bc);

    __next_pointer __pn = __bucket_list_[__chash];
    if (__pn == nullptr)
    {
        __pn =__p1_.first().__ptr();
        __nd->__next_ = __pn->__next_;
        __pn->__next_ = __nd->__ptr();

        __bucket_list_[__chash] = __pn;
        if (__nd->__next_ != nullptr)
            __bucket_list_[__constrain_hash(__nd->__next_->__hash(), __bc)] = __nd->__ptr();
    }
    else
    {
        __nd->__next_ = __pn->__next_;
        __pn->__next_ = __nd->__ptr();
    }
    ++size();
}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
pair<typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::iterator, bool>
__hash_table<_Tp, _Hash, _Equal, _Alloc>::__node_insert_unique(__node_pointer __nd)
{
    __nd->__hash_ = hash_function()(__nd->__value_);
    __next_pointer __existing_node =
        __node_insert_unique_prepare(__nd->__hash(), __nd->__value_);


    bool __inserted = false;
    if (__existing_node == nullptr)
    {
        __node_insert_unique_perform(__nd);
        __existing_node = __nd->__ptr();
        __inserted = true;
    }



    return pair<iterator, bool>(iterator(__existing_node), __inserted);

}
# 1936 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__hash_table" 3
template <class _Tp, class _Hash, class _Equal, class _Alloc>
typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::__next_pointer
__hash_table<_Tp, _Hash, _Equal, _Alloc>::__node_insert_multi_prepare(
    size_t __cp_hash, value_type& __cp_val)
{
    size_type __bc = bucket_count();
    if (size()+1 > __bc * max_load_factor() || __bc == 0)
    {
        rehash(std::__1::max<size_type>(2 * __bc + !__is_hash_power2(__bc),
                       size_type(ceil(float(size() + 1) / max_load_factor()))));
        __bc = bucket_count();
    }
    size_t __chash = __constrain_hash(__cp_hash, __bc);
    __next_pointer __pn = __bucket_list_[__chash];
    if (__pn != nullptr)
    {
        for (bool __found = false; __pn->__next_ != nullptr &&
                                   __constrain_hash(__pn->__next_->__hash(), __bc) == __chash;
                                                           __pn = __pn->__next_)
        {





            if (__found != (__pn->__next_->__hash() == __cp_hash &&
                            key_eq()(__pn->__next_->__upcast()->__value_, __cp_val)))
            {
                if (!__found)
                    __found = true;
                else
                    break;
            }
        }
    }
    return __pn;
}






template <class _Tp, class _Hash, class _Equal, class _Alloc>
void
__hash_table<_Tp, _Hash, _Equal, _Alloc>::__node_insert_multi_perform(
    __node_pointer __cp, __next_pointer __pn) noexcept
{
    size_type __bc = bucket_count();
    size_t __chash = __constrain_hash(__cp->__hash_, __bc);
    if (__pn == nullptr)
    {
        __pn =__p1_.first().__ptr();
        __cp->__next_ = __pn->__next_;
        __pn->__next_ = __cp->__ptr();

        __bucket_list_[__chash] = __pn;
        if (__cp->__next_ != nullptr)
            __bucket_list_[__constrain_hash(__cp->__next_->__hash(), __bc)]
                = __cp->__ptr();
    }
    else
    {
        __cp->__next_ = __pn->__next_;
        __pn->__next_ = __cp->__ptr();
        if (__cp->__next_ != nullptr)
        {
            size_t __nhash = __constrain_hash(__cp->__next_->__hash(), __bc);
            if (__nhash != __chash)
                __bucket_list_[__nhash] = __cp->__ptr();
        }
    }
    ++size();
}


template <class _Tp, class _Hash, class _Equal, class _Alloc>
typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::iterator
__hash_table<_Tp, _Hash, _Equal, _Alloc>::__node_insert_multi(__node_pointer __cp)
{
    __cp->__hash_ = hash_function()(__cp->__value_);
    __next_pointer __pn = __node_insert_multi_prepare(__cp->__hash(), __cp->__value_);
    __node_insert_multi_perform(__cp, __pn);




    return iterator(__cp->__ptr());

}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::iterator
__hash_table<_Tp, _Hash, _Equal, _Alloc>::__node_insert_multi(
        const_iterator __p, __node_pointer __cp)
{





    if (__p != end() && key_eq()(*__p, __cp->__value_))
    {
        __next_pointer __np = __p.__node_;
        __cp->__hash_ = __np->__hash();
        size_type __bc = bucket_count();
        if (size()+1 > __bc * max_load_factor() || __bc == 0)
        {
            rehash(std::__1::max<size_type>(2 * __bc + !__is_hash_power2(__bc),
                           size_type(ceil(float(size() + 1) / max_load_factor()))));
            __bc = bucket_count();
        }
        size_t __chash = __constrain_hash(__cp->__hash_, __bc);
        __next_pointer __pp = __bucket_list_[__chash];
        while (__pp->__next_ != __np)
            __pp = __pp->__next_;
        __cp->__next_ = __np;
        __pp->__next_ = static_cast<__next_pointer>(__cp);
        ++size();



        return iterator(static_cast<__next_pointer>(__cp));

    }
    return __node_insert_multi(__cp);
}



template <class _Tp, class _Hash, class _Equal, class _Alloc>
template <class _Key, class ..._Args>
pair<typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::iterator, bool>
__hash_table<_Tp, _Hash, _Equal, _Alloc>::__emplace_unique_key_args(_Key const& __k, _Args&&... __args)
{

    size_t __hash = hash_function()(__k);
    size_type __bc = bucket_count();
    bool __inserted = false;
    __next_pointer __nd;
    size_t __chash;
    if (__bc != 0)
    {
        __chash = __constrain_hash(__hash, __bc);
        __nd = __bucket_list_[__chash];
        if (__nd != nullptr)
        {
            for (__nd = __nd->__next_; __nd != nullptr &&
                (__nd->__hash() == __hash || __constrain_hash(__nd->__hash(), __bc) == __chash);
                                                           __nd = __nd->__next_)
            {
                if (key_eq()(__nd->__upcast()->__value_, __k))
                    goto __done;
            }
        }
    }
    {
        __node_holder __h = __construct_node_hash(__hash, std::__1::forward<_Args>(__args)...);
        if (size()+1 > __bc * max_load_factor() || __bc == 0)
        {
            rehash(std::__1::max<size_type>(2 * __bc + !__is_hash_power2(__bc),
                           size_type(ceil(float(size() + 1) / max_load_factor()))));
            __bc = bucket_count();
            __chash = __constrain_hash(__hash, __bc);
        }

        __next_pointer __pn = __bucket_list_[__chash];
        if (__pn == nullptr)
        {
            __pn = __p1_.first().__ptr();
            __h->__next_ = __pn->__next_;
            __pn->__next_ = __h.get()->__ptr();

            __bucket_list_[__chash] = __pn;
            if (__h->__next_ != nullptr)
                __bucket_list_[__constrain_hash(__h->__next_->__hash(), __bc)]
                    = __h.get()->__ptr();
        }
        else
        {
            __h->__next_ = __pn->__next_;
            __pn->__next_ = static_cast<__next_pointer>(__h.get());
        }
        __nd = static_cast<__next_pointer>(__h.release());

        ++size();
        __inserted = true;
    }
__done:



    return pair<iterator, bool>(iterator(__nd), __inserted);

}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
template <class... _Args>
pair<typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::iterator, bool>
__hash_table<_Tp, _Hash, _Equal, _Alloc>::__emplace_unique_impl(_Args&&... __args)
{
    __node_holder __h = __construct_node(std::__1::forward<_Args>(__args)...);
    pair<iterator, bool> __r = __node_insert_unique(__h.get());
    if (__r.second)
        __h.release();
    return __r;
}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
template <class... _Args>
typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::iterator
__hash_table<_Tp, _Hash, _Equal, _Alloc>::__emplace_multi(_Args&&... __args)
{
    __node_holder __h = __construct_node(std::__1::forward<_Args>(__args)...);
    iterator __r = __node_insert_multi(__h.get());
    __h.release();
    return __r;
}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
template <class... _Args>
typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::iterator
__hash_table<_Tp, _Hash, _Equal, _Alloc>::__emplace_hint_multi(
        const_iterator __p, _Args&&... __args)
{





    __node_holder __h = __construct_node(std::__1::forward<_Args>(__args)...);
    iterator __r = __node_insert_multi(__p, __h.get());
    __h.release();
    return __r;
}


template <class _Tp, class _Hash, class _Equal, class _Alloc>
template <class _NodeHandle, class _InsertReturnType>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
_InsertReturnType
__hash_table<_Tp, _Hash, _Equal, _Alloc>::__node_handle_insert_unique(
    _NodeHandle&& __nh)
{
    if (__nh.empty())
        return _InsertReturnType{end(), false, _NodeHandle()};
    pair<iterator, bool> __result = __node_insert_unique(__nh.__ptr_);
    if (__result.second)
        __nh.__release_ptr();
    return _InsertReturnType{__result.first, __result.second, std::__1::move(__nh)};
}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
template <class _NodeHandle>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::iterator
__hash_table<_Tp, _Hash, _Equal, _Alloc>::__node_handle_insert_unique(
    const_iterator, _NodeHandle&& __nh)
{
    if (__nh.empty())
        return end();
    pair<iterator, bool> __result = __node_insert_unique(__nh.__ptr_);
    if (__result.second)
        __nh.__release_ptr();
    return __result.first;
}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
template <class _NodeHandle>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
_NodeHandle
__hash_table<_Tp, _Hash, _Equal, _Alloc>::__node_handle_extract(
    key_type const& __key)
{
    iterator __i = find(__key);
    if (__i == end())
        return _NodeHandle();
    return __node_handle_extract<_NodeHandle>(__i);
}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
template <class _NodeHandle>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
_NodeHandle
__hash_table<_Tp, _Hash, _Equal, _Alloc>::__node_handle_extract(
    const_iterator __p)
{
    allocator_type __alloc(__node_alloc());
    return _NodeHandle(remove(__p).release(), __alloc);
}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
template <class _Table>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void
__hash_table<_Tp, _Hash, _Equal, _Alloc>::__node_handle_merge_unique(
    _Table& __source)
{
    static_assert(is_same<__node, typename _Table::__node>::value, "");

    for (typename _Table::iterator __it = __source.begin();
         __it != __source.end();)
    {
        __node_pointer __src_ptr = __it.__node_->__upcast();
        size_t __hash = hash_function()(__src_ptr->__value_);
        __next_pointer __existing_node =
            __node_insert_unique_prepare(__hash, __src_ptr->__value_);
        auto __prev_iter = __it++;
        if (__existing_node == nullptr)
        {
            (void)__source.remove(__prev_iter).release();
            __src_ptr->__hash_ = __hash;
            __node_insert_unique_perform(__src_ptr);
        }
    }
}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
template <class _NodeHandle>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::iterator
__hash_table<_Tp, _Hash, _Equal, _Alloc>::__node_handle_insert_multi(
    _NodeHandle&& __nh)
{
    if (__nh.empty())
        return end();
    iterator __result = __node_insert_multi(__nh.__ptr_);
    __nh.__release_ptr();
    return __result;
}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
template <class _NodeHandle>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::iterator
__hash_table<_Tp, _Hash, _Equal, _Alloc>::__node_handle_insert_multi(
    const_iterator __hint, _NodeHandle&& __nh)
{
    if (__nh.empty())
        return end();
    iterator __result = __node_insert_multi(__hint, __nh.__ptr_);
    __nh.__release_ptr();
    return __result;
}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
template <class _Table>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void
__hash_table<_Tp, _Hash, _Equal, _Alloc>::__node_handle_merge_multi(
    _Table& __source)
{
    static_assert(is_same<typename _Table::__node, __node>::value, "");

    for (typename _Table::iterator __it = __source.begin();
         __it != __source.end();)
    {
        __node_pointer __src_ptr = __it.__node_->__upcast();
        size_t __src_hash = hash_function()(__src_ptr->__value_);
        __next_pointer __pn =
            __node_insert_multi_prepare(__src_hash, __src_ptr->__value_);
        (void)__source.remove(__it++).release();
        __src_ptr->__hash_ = __src_hash;
        __node_insert_multi_perform(__src_ptr, __pn);
    }
}


template <class _Tp, class _Hash, class _Equal, class _Alloc>
void
__hash_table<_Tp, _Hash, _Equal, _Alloc>::rehash(size_type __n)
__attribute__((__no_sanitize__("unsigned-integer-overflow")))
{
    if (__n == 1)
        __n = 2;
    else if (__n & (__n - 1))
        __n = __next_prime(__n);
    size_type __bc = bucket_count();
    if (__n > __bc)
        __rehash(__n);
    else if (__n < __bc)
    {
        __n = std::__1::max<size_type>
              (
                  __n,
                  __is_hash_power2(__bc) ? __next_hash_pow2(size_t(ceil(float(size()) / max_load_factor()))) :
                                           __next_prime(size_t(ceil(float(size()) / max_load_factor())))
              );
        if (__n < __bc)
            __rehash(__n);
    }
}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
void
__hash_table<_Tp, _Hash, _Equal, _Alloc>::__rehash(size_type __nbc)
{



    __pointer_allocator& __npa = __bucket_list_.get_deleter().__alloc();
    __bucket_list_.reset(__nbc > 0 ?
                      __pointer_alloc_traits::allocate(__npa, __nbc) : nullptr);
    __bucket_list_.get_deleter().size() = __nbc;
    if (__nbc > 0)
    {
        for (size_type __i = 0; __i < __nbc; ++__i)
            __bucket_list_[__i] = nullptr;
        __next_pointer __pp = __p1_.first().__ptr();
        __next_pointer __cp = __pp->__next_;
        if (__cp != nullptr)
        {
            size_type __chash = __constrain_hash(__cp->__hash(), __nbc);
            __bucket_list_[__chash] = __pp;
            size_type __phash = __chash;
            for (__pp = __cp, __cp = __cp->__next_; __cp != nullptr;
                                                           __cp = __pp->__next_)
            {
                __chash = __constrain_hash(__cp->__hash(), __nbc);
                if (__chash == __phash)
                    __pp = __cp;
                else
                {
                    if (__bucket_list_[__chash] == nullptr)
                    {
                        __bucket_list_[__chash] = __pp;
                        __pp = __cp;
                        __phash = __chash;
                    }
                    else
                    {
                        __next_pointer __np = __cp;
                        for (; __np->__next_ != nullptr &&
                               key_eq()(__cp->__upcast()->__value_,
                                        __np->__next_->__upcast()->__value_);
                                                           __np = __np->__next_)
                            ;
                        __pp->__next_ = __np->__next_;
                        __np->__next_ = __bucket_list_[__chash]->__next_;
                        __bucket_list_[__chash]->__next_ = __cp;

                    }
                }
            }
        }
    }
}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
template <class _Key>
typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::iterator
__hash_table<_Tp, _Hash, _Equal, _Alloc>::find(const _Key& __k)
{
    size_t __hash = hash_function()(__k);
    size_type __bc = bucket_count();
    if (__bc != 0)
    {
        size_t __chash = __constrain_hash(__hash, __bc);
        __next_pointer __nd = __bucket_list_[__chash];
        if (__nd != nullptr)
        {
            for (__nd = __nd->__next_; __nd != nullptr &&
                (__nd->__hash() == __hash
                  || __constrain_hash(__nd->__hash(), __bc) == __chash);
                                                           __nd = __nd->__next_)
            {
                if ((__nd->__hash() == __hash)
                    && key_eq()(__nd->__upcast()->__value_, __k))



                    return iterator(__nd);

            }
        }
    }
    return end();
}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
template <class _Key>
typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::const_iterator
__hash_table<_Tp, _Hash, _Equal, _Alloc>::find(const _Key& __k) const
{
    size_t __hash = hash_function()(__k);
    size_type __bc = bucket_count();
    if (__bc != 0)
    {
        size_t __chash = __constrain_hash(__hash, __bc);
        __next_pointer __nd = __bucket_list_[__chash];
        if (__nd != nullptr)
        {
            for (__nd = __nd->__next_; __nd != nullptr &&
                (__hash == __nd->__hash()
                    || __constrain_hash(__nd->__hash(), __bc) == __chash);
                                                           __nd = __nd->__next_)
            {
                if ((__nd->__hash() == __hash)
                    && key_eq()(__nd->__upcast()->__value_, __k))



                    return const_iterator(__nd);

            }
        }

    }
    return end();
}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
template <class ..._Args>
typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::__node_holder
__hash_table<_Tp, _Hash, _Equal, _Alloc>::__construct_node(_Args&& ...__args)
{
    static_assert(!__is_hash_value_type<_Args...>::value,
                  "Construct cannot be called with a hash value type");
    __node_allocator& __na = __node_alloc();
    __node_holder __h(__node_traits::allocate(__na, 1), _Dp(__na));
    __node_traits::construct(__na, _NodeTypes::__get_ptr(__h->__value_), std::__1::forward<_Args>(__args)...);
    __h.get_deleter().__value_constructed = true;
    __h->__hash_ = hash_function()(__h->__value_);
    __h->__next_ = nullptr;
    return __h;
}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
template <class _First, class ..._Rest>
typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::__node_holder
__hash_table<_Tp, _Hash, _Equal, _Alloc>::__construct_node_hash(
    size_t __hash, _First&& __f, _Rest&& ...__rest)
{
    static_assert(!__is_hash_value_type<_First, _Rest...>::value,
                  "Construct cannot be called with a hash value type");
    __node_allocator& __na = __node_alloc();
    __node_holder __h(__node_traits::allocate(__na, 1), _Dp(__na));
    __node_traits::construct(__na, _NodeTypes::__get_ptr(__h->__value_),
                             std::__1::forward<_First>(__f),
                             std::__1::forward<_Rest>(__rest)...);
    __h.get_deleter().__value_constructed = true;
    __h->__hash_ = __hash;
    __h->__next_ = nullptr;
    return __h;
}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::iterator
__hash_table<_Tp, _Hash, _Equal, _Alloc>::erase(const_iterator __p)
{
    __next_pointer __np = __p.__node_;
# 2495 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__hash_table" 3
    iterator __r(__np);

    ++__r;
    remove(__p);
    return __r;
}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::iterator
__hash_table<_Tp, _Hash, _Equal, _Alloc>::erase(const_iterator __first,
                                                const_iterator __last)
{
# 2515 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__hash_table" 3
    for (const_iterator __p = __first; __first != __last; __p = __first)
    {
        ++__first;
        erase(__p);
    }
    __next_pointer __np = __last.__node_;



    return iterator (__np);

}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
template <class _Key>
typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::size_type
__hash_table<_Tp, _Hash, _Equal, _Alloc>::__erase_unique(const _Key& __k)
{
    iterator __i = find(__k);
    if (__i == end())
        return 0;
    erase(__i);
    return 1;
}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
template <class _Key>
typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::size_type
__hash_table<_Tp, _Hash, _Equal, _Alloc>::__erase_multi(const _Key& __k)
{
    size_type __r = 0;
    iterator __i = find(__k);
    if (__i != end())
    {
        iterator __e = end();
        do
        {
            erase(__i++);
            ++__r;
        } while (__i != __e && key_eq()(*__i, __k));
    }
    return __r;
}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::__node_holder
__hash_table<_Tp, _Hash, _Equal, _Alloc>::remove(const_iterator __p) noexcept
{

    __next_pointer __cn = __p.__node_;
    size_type __bc = bucket_count();
    size_t __chash = __constrain_hash(__cn->__hash(), __bc);

    __next_pointer __pn = __bucket_list_[__chash];
    for (; __pn->__next_ != __cn; __pn = __pn->__next_)
        ;



    if (__pn == __p1_.first().__ptr()
            || __constrain_hash(__pn->__hash(), __bc) != __chash)
    {
        if (__cn->__next_ == nullptr
            || __constrain_hash(__cn->__next_->__hash(), __bc) != __chash)
            __bucket_list_[__chash] = nullptr;
    }

    if (__cn->__next_ != nullptr)
    {
        size_t __nhash = __constrain_hash(__cn->__next_->__hash(), __bc);
        if (__nhash != __chash)
            __bucket_list_[__nhash] = __pn;
    }

    __pn->__next_ = __cn->__next_;
    __cn->__next_ = nullptr;
    --size();
# 2607 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__hash_table" 3
    return __node_holder(__cn->__upcast(), _Dp(__node_alloc(), true));
}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
template <class _Key>
inline
typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::size_type
__hash_table<_Tp, _Hash, _Equal, _Alloc>::__count_unique(const _Key& __k) const
{
    return static_cast<size_type>(find(__k) != end());
}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
template <class _Key>
typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::size_type
__hash_table<_Tp, _Hash, _Equal, _Alloc>::__count_multi(const _Key& __k) const
{
    size_type __r = 0;
    const_iterator __i = find(__k);
    if (__i != end())
    {
        const_iterator __e = end();
        do
        {
            ++__i;
            ++__r;
        } while (__i != __e && key_eq()(*__i, __k));
    }
    return __r;
}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
template <class _Key>
pair<typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::iterator,
     typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::iterator>
__hash_table<_Tp, _Hash, _Equal, _Alloc>::__equal_range_unique(
        const _Key& __k)
{
    iterator __i = find(__k);
    iterator __j = __i;
    if (__i != end())
        ++__j;
    return pair<iterator, iterator>(__i, __j);
}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
template <class _Key>
pair<typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::const_iterator,
     typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::const_iterator>
__hash_table<_Tp, _Hash, _Equal, _Alloc>::__equal_range_unique(
        const _Key& __k) const
{
    const_iterator __i = find(__k);
    const_iterator __j = __i;
    if (__i != end())
        ++__j;
    return pair<const_iterator, const_iterator>(__i, __j);
}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
template <class _Key>
pair<typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::iterator,
     typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::iterator>
__hash_table<_Tp, _Hash, _Equal, _Alloc>::__equal_range_multi(
        const _Key& __k)
{
    iterator __i = find(__k);
    iterator __j = __i;
    if (__i != end())
    {
        iterator __e = end();
        do
        {
            ++__j;
        } while (__j != __e && key_eq()(*__j, __k));
    }
    return pair<iterator, iterator>(__i, __j);
}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
template <class _Key>
pair<typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::const_iterator,
     typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::const_iterator>
__hash_table<_Tp, _Hash, _Equal, _Alloc>::__equal_range_multi(
        const _Key& __k) const
{
    const_iterator __i = find(__k);
    const_iterator __j = __i;
    if (__i != end())
    {
        const_iterator __e = end();
        do
        {
            ++__j;
        } while (__j != __e && key_eq()(*__j, __k));
    }
    return pair<const_iterator, const_iterator>(__i, __j);
}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
void
__hash_table<_Tp, _Hash, _Equal, _Alloc>::swap(__hash_table& __u)
# 2718 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__hash_table" 3
  noexcept(__is_nothrow_swappable<hasher>::value && __is_nothrow_swappable<key_equal>::value)

{
    ((void)0);



    {
    __node_pointer_pointer __npp = __bucket_list_.release();
    __bucket_list_.reset(__u.__bucket_list_.release());
    __u.__bucket_list_.reset(__npp);
    }
    std::__1::swap(__bucket_list_.get_deleter().size(), __u.__bucket_list_.get_deleter().size());
    std::__1::__swap_allocator(__bucket_list_.get_deleter().__alloc(),
             __u.__bucket_list_.get_deleter().__alloc());
    std::__1::__swap_allocator(__node_alloc(), __u.__node_alloc());
    std::__1::swap(__p1_.first().__next_, __u.__p1_.first().__next_);
    __p2_.swap(__u.__p2_);
    __p3_.swap(__u.__p3_);
    if (size() > 0)
        __bucket_list_[__constrain_hash(__p1_.first().__next_->__hash(), bucket_count())] =
            __p1_.first().__ptr();
    if (__u.size() > 0)
        __u.__bucket_list_[__constrain_hash(__u.__p1_.first().__next_->__hash(), __u.bucket_count())] =
            __u.__p1_.first().__ptr();



}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::size_type
__hash_table<_Tp, _Hash, _Equal, _Alloc>::bucket_size(size_type __n) const
{
    ((void)0);

    __next_pointer __np = __bucket_list_[__n];
    size_type __bc = bucket_count();
    size_type __r = 0;
    if (__np != nullptr)
    {
        for (__np = __np->__next_; __np != nullptr &&
                                   __constrain_hash(__np->__hash(), __bc) == __n;
                                                    __np = __np->__next_, ++__r)
            ;
    }
    return __r;
}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void
swap(__hash_table<_Tp, _Hash, _Equal, _Alloc>& __x,
     __hash_table<_Tp, _Hash, _Equal, _Alloc>& __y)
    noexcept(noexcept(__x.swap(__y)))
{
    __x.swap(__y);
}
# 2809 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__hash_table" 3
} }
# 438 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/unordered_map" 2 3
# 449 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/unordered_map" 3


namespace std { inline namespace __1 {

template <class _Key, class _Cp, class _Hash, class _Pred,
          bool = is_empty<_Hash>::value && !__libcpp_is_final<_Hash>::value>
class __unordered_map_hasher
    : private _Hash
{
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __unordered_map_hasher()
        noexcept(is_nothrow_default_constructible<_Hash>::value)
        : _Hash() {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __unordered_map_hasher(const _Hash& __h)
        noexcept(is_nothrow_copy_constructible<_Hash>::value)
        : _Hash(__h) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const _Hash& hash_function() const noexcept {return *this;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_t operator()(const _Cp& __x) const
        {return static_cast<const _Hash&>(*this)(__x.__get_value().first);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_t operator()(const _Key& __x) const
        {return static_cast<const _Hash&>(*this)(__x);}






    void swap(__unordered_map_hasher&__y)
        noexcept(__is_nothrow_swappable<_Hash>::value)
    {
        using std::__1::swap;
        swap(static_cast<_Hash&>(*this), static_cast<_Hash&>(__y));
    }
};

template <class _Key, class _Cp, class _Hash, class _Pred>
class __unordered_map_hasher<_Key, _Cp, _Hash, _Pred, false>
{
    _Hash __hash_;
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __unordered_map_hasher()
        noexcept(is_nothrow_default_constructible<_Hash>::value)
        : __hash_() {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __unordered_map_hasher(const _Hash& __h)
        noexcept(is_nothrow_copy_constructible<_Hash>::value)
        : __hash_(__h) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const _Hash& hash_function() const noexcept {return __hash_;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_t operator()(const _Cp& __x) const
        {return __hash_(__x.__get_value().first);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_t operator()(const _Key& __x) const
        {return __hash_(__x);}






    void swap(__unordered_map_hasher&__y)
        noexcept(__is_nothrow_swappable<_Hash>::value)
    {
        using std::__1::swap;
        swap(__hash_, __y.__hash_);
    }
};

template <class _Key, class _Cp, class _Hash, class _Pred, bool __b>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void
swap(__unordered_map_hasher<_Key, _Cp, _Hash, _Pred, __b>& __x,
     __unordered_map_hasher<_Key, _Cp, _Hash, _Pred, __b>& __y)
    noexcept(noexcept(__x.swap(__y)))
{
    __x.swap(__y);
}

template <class _Key, class _Cp, class _Pred, class _Hash,
          bool = is_empty<_Pred>::value && !__libcpp_is_final<_Pred>::value>
class __unordered_map_equal
    : private _Pred
{
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __unordered_map_equal()
        noexcept(is_nothrow_default_constructible<_Pred>::value)
        : _Pred() {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __unordered_map_equal(const _Pred& __p)
        noexcept(is_nothrow_copy_constructible<_Pred>::value)
        : _Pred(__p) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const _Pred& key_eq() const noexcept {return *this;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    bool operator()(const _Cp& __x, const _Cp& __y) const
        {return static_cast<const _Pred&>(*this)(__x.__get_value().first, __y.__get_value().first);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    bool operator()(const _Cp& __x, const _Key& __y) const
        {return static_cast<const _Pred&>(*this)(__x.__get_value().first, __y);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    bool operator()(const _Key& __x, const _Cp& __y) const
        {return static_cast<const _Pred&>(*this)(__x, __y.__get_value().first);}
# 577 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/unordered_map" 3
    void swap(__unordered_map_equal&__y)
        noexcept(__is_nothrow_swappable<_Pred>::value)
    {
        using std::__1::swap;
        swap(static_cast<_Pred&>(*this), static_cast<_Pred&>(__y));
    }
};

template <class _Key, class _Cp, class _Pred, class _Hash>
class __unordered_map_equal<_Key, _Cp, _Pred, _Hash, false>
{
    _Pred __pred_;
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __unordered_map_equal()
        noexcept(is_nothrow_default_constructible<_Pred>::value)
        : __pred_() {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __unordered_map_equal(const _Pred& __p)
        noexcept(is_nothrow_copy_constructible<_Pred>::value)
        : __pred_(__p) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const _Pred& key_eq() const noexcept {return __pred_;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    bool operator()(const _Cp& __x, const _Cp& __y) const
        {return __pred_(__x.__get_value().first, __y.__get_value().first);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    bool operator()(const _Cp& __x, const _Key& __y) const
        {return __pred_(__x.__get_value().first, __y);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    bool operator()(const _Key& __x, const _Cp& __y) const
        {return __pred_(__x, __y.__get_value().first);}
# 627 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/unordered_map" 3
    void swap(__unordered_map_equal&__y)
        noexcept(__is_nothrow_swappable<_Pred>::value)
    {
        using std::__1::swap;
        swap(__pred_, __y.__pred_);
    }
};

template <class _Key, class _Cp, class _Pred, class _Hash, bool __b>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void
swap(__unordered_map_equal<_Key, _Cp, _Pred, _Hash, __b>& __x,
     __unordered_map_equal<_Key, _Cp, _Pred, _Hash, __b>& __y)
    noexcept(noexcept(__x.swap(__y)))
{
    __x.swap(__y);
}

template <class _Alloc>
class __hash_map_node_destructor
{
    typedef _Alloc allocator_type;
    typedef allocator_traits<allocator_type> __alloc_traits;

public:

    typedef typename __alloc_traits::pointer pointer;
private:

    allocator_type& __na_;

    __hash_map_node_destructor& operator=(const __hash_map_node_destructor&);

public:
    bool __first_constructed;
    bool __second_constructed;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit __hash_map_node_destructor(allocator_type& __na) noexcept
        : __na_(__na),
          __first_constructed(false),
          __second_constructed(false)
        {}


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __hash_map_node_destructor(__hash_node_destructor<allocator_type>&& __x)
        noexcept
        : __na_(__x.__na_),
          __first_constructed(__x.__value_constructed),
          __second_constructed(__x.__value_constructed)
        {
            __x.__value_constructed = false;
        }
# 692 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/unordered_map" 3
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void operator()(pointer __p) noexcept
    {
        if (__second_constructed)
            __alloc_traits::destroy(__na_, std::__1::addressof(__p->__value_.__get_value().second));
        if (__first_constructed)
            __alloc_traits::destroy(__na_, std::__1::addressof(__p->__value_.__get_value().first));
        if (__p)
            __alloc_traits::deallocate(__na_, __p, 1);
    }
};


template <class _Key, class _Tp>
struct __attribute__((__standalone_debug__)) __hash_value_type
{
    typedef _Key key_type;
    typedef _Tp mapped_type;
    typedef pair<const key_type, mapped_type> value_type;
    typedef pair<key_type&, mapped_type&> __nc_ref_pair_type;
    typedef pair<key_type&&, mapped_type&&> __nc_rref_pair_type;

private:
    value_type __cc;

public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    value_type& __get_value()
    {

        return *std::__1::launder(std::__1::addressof(__cc));



    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const value_type& __get_value() const
    {

        return *std::__1::launder(std::__1::addressof(__cc));



    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __nc_ref_pair_type __ref()
    {
        value_type& __v = __get_value();
        return __nc_ref_pair_type(const_cast<key_type&>(__v.first), __v.second);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __nc_rref_pair_type __move()
    {
        value_type& __v = __get_value();
        return __nc_rref_pair_type(
            std::__1::move(const_cast<key_type&>(__v.first)),
            std::__1::move(__v.second));
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __hash_value_type& operator=(const __hash_value_type& __v)
    {
        __ref() = __v.__get_value();
        return *this;
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __hash_value_type& operator=(__hash_value_type&& __v)
    {
        __ref() = __v.__move();
        return *this;
    }

    template <class _ValueTp,
              class = typename enable_if<
                    __is_same_uncvref<_ValueTp, value_type>::value
                 >::type
             >
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __hash_value_type& operator=(_ValueTp&& __v)
    {
        __ref() = std::__1::forward<_ValueTp>(__v);
        return *this;
    }

private:
    __hash_value_type(const __hash_value_type& __v) = delete;
    __hash_value_type(__hash_value_type&& __v) = delete;
    template <class ..._Args>
    explicit __hash_value_type(_Args&& ...__args) = delete;

    ~__hash_value_type() = delete;
};
# 813 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/unordered_map" 3
template <class _HashIterator>
class __attribute__ ((__type_visibility__("default"))) __hash_map_iterator
{
    _HashIterator __i_;

    typedef __hash_node_types_from_iterator<_HashIterator> _NodeTypes;

public:
    typedef forward_iterator_tag iterator_category;
    typedef typename _NodeTypes::__map_value_type value_type;
    typedef typename _NodeTypes::difference_type difference_type;
    typedef value_type& reference;
    typedef typename _NodeTypes::__map_value_type_pointer pointer;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __hash_map_iterator() noexcept {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __hash_map_iterator(_HashIterator __i) noexcept : __i_(__i) {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    reference operator*() const {return __i_->__get_value();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    pointer operator->() const {return pointer_traits<pointer>::pointer_to(__i_->__get_value());}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __hash_map_iterator& operator++() {++__i_; return *this;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __hash_map_iterator operator++(int)
    {
        __hash_map_iterator __t(*this);
        ++(*this);
        return __t;
    }

    friend __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        bool operator==(const __hash_map_iterator& __x, const __hash_map_iterator& __y)
        {return __x.__i_ == __y.__i_;}
    friend __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        bool operator!=(const __hash_map_iterator& __x, const __hash_map_iterator& __y)
        {return __x.__i_ != __y.__i_;}

    template <class, class, class, class, class> friend class __attribute__ ((__type_visibility__("default"))) unordered_map;
    template <class, class, class, class, class> friend class __attribute__ ((__type_visibility__("default"))) unordered_multimap;
    template <class> friend class __attribute__ ((__type_visibility__("default"))) __hash_const_iterator;
    template <class> friend class __attribute__ ((__type_visibility__("default"))) __hash_const_local_iterator;
    template <class> friend class __attribute__ ((__type_visibility__("default"))) __hash_map_const_iterator;
};

template <class _HashIterator>
class __attribute__ ((__type_visibility__("default"))) __hash_map_const_iterator
{
    _HashIterator __i_;

    typedef __hash_node_types_from_iterator<_HashIterator> _NodeTypes;

public:
    typedef forward_iterator_tag iterator_category;
    typedef typename _NodeTypes::__map_value_type value_type;
    typedef typename _NodeTypes::difference_type difference_type;
    typedef const value_type& reference;
    typedef typename _NodeTypes::__const_map_value_type_pointer pointer;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __hash_map_const_iterator() noexcept {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __hash_map_const_iterator(_HashIterator __i) noexcept : __i_(__i) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __hash_map_const_iterator(
            __hash_map_iterator<typename _HashIterator::__non_const_iterator> __i)
                 noexcept
                : __i_(__i.__i_) {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    reference operator*() const {return __i_->__get_value();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    pointer operator->() const {return pointer_traits<pointer>::pointer_to(__i_->__get_value());}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __hash_map_const_iterator& operator++() {++__i_; return *this;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __hash_map_const_iterator operator++(int)
    {
        __hash_map_const_iterator __t(*this);
        ++(*this);
        return __t;
    }

    friend __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        bool operator==(const __hash_map_const_iterator& __x, const __hash_map_const_iterator& __y)
        {return __x.__i_ == __y.__i_;}
    friend __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        bool operator!=(const __hash_map_const_iterator& __x, const __hash_map_const_iterator& __y)
        {return __x.__i_ != __y.__i_;}

    template <class, class, class, class, class> friend class __attribute__ ((__type_visibility__("default"))) unordered_map;
    template <class, class, class, class, class> friend class __attribute__ ((__type_visibility__("default"))) unordered_multimap;
    template <class> friend class __attribute__ ((__type_visibility__("default"))) __hash_const_iterator;
    template <class> friend class __attribute__ ((__type_visibility__("default"))) __hash_const_local_iterator;
};

template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
class unordered_multimap;

template <class _Key, class _Tp, class _Hash = hash<_Key>, class _Pred = equal_to<_Key>,
          class _Alloc = allocator<pair<const _Key, _Tp> > >
class __attribute__ ((__type_visibility__("default"))) unordered_map
{
public:

    typedef _Key key_type;
    typedef _Tp mapped_type;
    typedef __identity_t<_Hash> hasher;
    typedef __identity_t<_Pred> key_equal;
    typedef __identity_t<_Alloc> allocator_type;
    typedef pair<const key_type, mapped_type> value_type;
    typedef value_type& reference;
    typedef const value_type& const_reference;
    static_assert((is_same<value_type, typename allocator_type::value_type>::value),
                  "Invalid allocator::value_type");

private:
    typedef __hash_value_type<key_type, mapped_type> __value_type;
    typedef __unordered_map_hasher<key_type, __value_type, hasher, key_equal> __hasher;
    typedef __unordered_map_equal<key_type, __value_type, key_equal, hasher> __key_equal;
    typedef typename __rebind_alloc_helper<allocator_traits<allocator_type>,
                                                 __value_type>::type __allocator_type;

    typedef __hash_table<__value_type, __hasher,
                         __key_equal, __allocator_type> __table;

    __table __table_;

    typedef typename __table::_NodeTypes _NodeTypes;
    typedef typename __table::__node_pointer __node_pointer;
    typedef typename __table::__node_const_pointer __node_const_pointer;
    typedef typename __table::__node_traits __node_traits;
    typedef typename __table::__node_allocator __node_allocator;
    typedef typename __table::__node __node;
    typedef __hash_map_node_destructor<__node_allocator> _Dp;
    typedef unique_ptr<__node, _Dp> __node_holder;
    typedef allocator_traits<allocator_type> __alloc_traits;

    static_assert((is_same<typename __table::__container_value_type, value_type>::value), "");
    static_assert((is_same<typename __table::__node_value_type, __value_type>::value), "");
public:
    typedef typename __alloc_traits::pointer pointer;
    typedef typename __alloc_traits::const_pointer const_pointer;
    typedef typename __table::size_type size_type;
    typedef typename __table::difference_type difference_type;

    typedef __hash_map_iterator<typename __table::iterator> iterator;
    typedef __hash_map_const_iterator<typename __table::const_iterator> const_iterator;
    typedef __hash_map_iterator<typename __table::local_iterator> local_iterator;
    typedef __hash_map_const_iterator<typename __table::const_local_iterator> const_local_iterator;


    typedef __map_node_handle<__node, allocator_type> node_type;
    typedef __insert_return_type<iterator, node_type> insert_return_type;


    template <class _Key2, class _Tp2, class _Hash2, class _Pred2, class _Alloc2>
        friend class __attribute__ ((__type_visibility__("default"))) unordered_map;
    template <class _Key2, class _Tp2, class _Hash2, class _Pred2, class _Alloc2>
        friend class __attribute__ ((__type_visibility__("default"))) unordered_multimap;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    unordered_map()
        noexcept(is_nothrow_default_constructible<__table>::value)
        {



        }
    explicit unordered_map(size_type __n, const hasher& __hf = hasher(),
                           const key_equal& __eql = key_equal());
    unordered_map(size_type __n, const hasher& __hf,
                  const key_equal& __eql,
                  const allocator_type& __a);
    template <class _InputIterator>
        unordered_map(_InputIterator __first, _InputIterator __last);
    template <class _InputIterator>
        unordered_map(_InputIterator __first, _InputIterator __last,
                      size_type __n, const hasher& __hf = hasher(),
                      const key_equal& __eql = key_equal());
    template <class _InputIterator>
        unordered_map(_InputIterator __first, _InputIterator __last,
                      size_type __n, const hasher& __hf,
                      const key_equal& __eql,
                      const allocator_type& __a);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit unordered_map(const allocator_type& __a);
    unordered_map(const unordered_map& __u);
    unordered_map(const unordered_map& __u, const allocator_type& __a);

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    unordered_map(unordered_map&& __u)
        noexcept(is_nothrow_move_constructible<__table>::value);
    unordered_map(unordered_map&& __u, const allocator_type& __a);
    unordered_map(initializer_list<value_type> __il);
    unordered_map(initializer_list<value_type> __il, size_type __n,
                  const hasher& __hf = hasher(), const key_equal& __eql = key_equal());
    unordered_map(initializer_list<value_type> __il, size_type __n,
                  const hasher& __hf, const key_equal& __eql,
                  const allocator_type& __a);


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    unordered_map(size_type __n, const allocator_type& __a)
      : unordered_map(__n, hasher(), key_equal(), __a) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    unordered_map(size_type __n, const hasher& __hf, const allocator_type& __a)
      : unordered_map(__n, __hf, key_equal(), __a) {}
    template <class _InputIterator>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
      unordered_map(_InputIterator __first, _InputIterator __last, size_type __n, const allocator_type& __a)
      : unordered_map(__first, __last, __n, hasher(), key_equal(), __a) {}
    template <class _InputIterator>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
      unordered_map(_InputIterator __first, _InputIterator __last, size_type __n, const hasher& __hf,
        const allocator_type& __a)
      : unordered_map(__first, __last, __n, __hf, key_equal(), __a) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    unordered_map(initializer_list<value_type> __il, size_type __n, const allocator_type& __a)
      : unordered_map(__il, __n, hasher(), key_equal(), __a) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    unordered_map(initializer_list<value_type> __il, size_type __n, const hasher& __hf,
      const allocator_type& __a)
      : unordered_map(__il, __n, __hf, key_equal(), __a) {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    ~unordered_map() {
        static_assert(sizeof(__diagnose_unordered_container_requirements<_Key, _Hash, _Pred>(0)), "");
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    unordered_map& operator=(const unordered_map& __u)
    {

        __table_ = __u.__table_;
# 1064 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/unordered_map" 3
        return *this;
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    unordered_map& operator=(unordered_map&& __u)
        noexcept(is_nothrow_move_assignable<__table>::value);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    unordered_map& operator=(initializer_list<value_type> __il);


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    allocator_type get_allocator() const noexcept
        {return allocator_type(__table_.__node_alloc());}

                                  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    bool empty() const noexcept {return __table_.size() == 0;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_type size() const noexcept {return __table_.size();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_type max_size() const noexcept {return __table_.max_size();}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iterator begin() noexcept {return __table_.begin();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iterator end() noexcept {return __table_.end();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_iterator begin() const noexcept {return __table_.begin();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_iterator end() const noexcept {return __table_.end();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_iterator cbegin() const noexcept {return __table_.begin();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_iterator cend() const noexcept {return __table_.end();}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    pair<iterator, bool> insert(const value_type& __x)
        {return __table_.__insert_unique(__x);}

    iterator insert(const_iterator __p, const value_type& __x) {





        ((void)__p);

        return insert(__x).first;
    }

    template <class _InputIterator>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        void insert(_InputIterator __first, _InputIterator __last);


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void insert(initializer_list<value_type> __il)
        {insert(__il.begin(), __il.end());}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    pair<iterator, bool> insert(value_type&& __x)
        {return __table_.__insert_unique(std::__1::move(__x));}

    iterator insert(const_iterator __p, value_type&& __x) {





        ((void)__p);

        return __table_.__insert_unique(std::__1::move(__x)).first;
    }

    template <class _Pp,
              class = typename enable_if<is_constructible<value_type, _Pp>::value>::type>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        pair<iterator, bool> insert(_Pp&& __x)
            {return __table_.__insert_unique(std::__1::forward<_Pp>(__x));}

    template <class _Pp,
              class = typename enable_if<is_constructible<value_type, _Pp>::value>::type>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        iterator insert(const_iterator __p, _Pp&& __x)
        {





          ((void)__p);

            return insert(std::__1::forward<_Pp>(__x)).first;
        }

    template <class... _Args>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    pair<iterator, bool> emplace(_Args&&... __args) {
        return __table_.__emplace_unique(std::__1::forward<_Args>(__args)...);
    }

    template <class... _Args>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iterator emplace_hint(const_iterator __p, _Args&&... __args) {





          ((void)__p);

        return __table_.__emplace_unique(std::__1::forward<_Args>(__args)...).first;
    }




    template <class... _Args>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        pair<iterator, bool> try_emplace(const key_type& __k, _Args&&... __args)
    {
        return __table_.__emplace_unique_key_args(__k, piecewise_construct,
            std::__1::forward_as_tuple(__k),
            std::__1::forward_as_tuple(std::__1::forward<_Args>(__args)...));
    }

    template <class... _Args>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        pair<iterator, bool> try_emplace(key_type&& __k, _Args&&... __args)
    {
        return __table_.__emplace_unique_key_args(__k, piecewise_construct,
            std::__1::forward_as_tuple(std::__1::move(__k)),
            std::__1::forward_as_tuple(std::__1::forward<_Args>(__args)...));
    }

    template <class... _Args>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        iterator try_emplace(const_iterator __h, const key_type& __k, _Args&&... __args)
    {





        ((void)__h);

        return try_emplace(__k, std::__1::forward<_Args>(__args)...).first;
    }

    template <class... _Args>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        iterator try_emplace(const_iterator __h, key_type&& __k, _Args&&... __args)
    {





        ((void)__h);

        return try_emplace(std::__1::move(__k), std::__1::forward<_Args>(__args)...).first;
    }

    template <class _Vp>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        pair<iterator, bool> insert_or_assign(const key_type& __k, _Vp&& __v)
    {
        pair<iterator, bool> __res = __table_.__emplace_unique_key_args(__k,
            __k, std::__1::forward<_Vp>(__v));
        if (!__res.second) {
            __res.first->second = std::__1::forward<_Vp>(__v);
        }
        return __res;
    }

    template <class _Vp>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        pair<iterator, bool> insert_or_assign(key_type&& __k, _Vp&& __v)
    {
        pair<iterator, bool> __res = __table_.__emplace_unique_key_args(__k,
            std::__1::move(__k), std::__1::forward<_Vp>(__v));
        if (!__res.second) {
            __res.first->second = std::__1::forward<_Vp>(__v);
        }
        return __res;
    }

    template <class _Vp>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        iterator insert_or_assign(const_iterator, const key_type& __k, _Vp&& __v)
     {

          return insert_or_assign(__k, std::__1::forward<_Vp>(__v)).first;
     }

    template <class _Vp>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        iterator insert_or_assign(const_iterator, key_type&& __k, _Vp&& __v)
     {

        return insert_or_assign(std::__1::move(__k), std::__1::forward<_Vp>(__v)).first;
     }


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iterator erase(const_iterator __p) {return __table_.erase(__p.__i_);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iterator erase(iterator __p) {return __table_.erase(__p.__i_);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_type erase(const key_type& __k) {return __table_.__erase_unique(__k);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iterator erase(const_iterator __first, const_iterator __last)
        {return __table_.erase(__first.__i_, __last.__i_);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        void clear() noexcept {__table_.clear();}


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    insert_return_type insert(node_type&& __nh)
    {
        ((void)0);

        return __table_.template __node_handle_insert_unique<
            node_type, insert_return_type>(std::__1::move(__nh));
    }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iterator insert(const_iterator __hint, node_type&& __nh)
    {
        ((void)0);

        return __table_.template __node_handle_insert_unique<node_type>(
            __hint.__i_, std::__1::move(__nh));
    }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    node_type extract(key_type const& __key)
    {
        return __table_.template __node_handle_extract<node_type>(__key);
    }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    node_type extract(const_iterator __it)
    {
        return __table_.template __node_handle_extract<node_type>(
            __it.__i_);
    }

    template <class _H2, class _P2>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void merge(unordered_map<key_type, mapped_type, _H2, _P2, allocator_type>& __source)
    {
        ((void)0);

        return __table_.__node_handle_merge_unique(__source.__table_);
    }
    template <class _H2, class _P2>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void merge(unordered_map<key_type, mapped_type, _H2, _P2, allocator_type>&& __source)
    {
        ((void)0);

        return __table_.__node_handle_merge_unique(__source.__table_);
    }
    template <class _H2, class _P2>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void merge(unordered_multimap<key_type, mapped_type, _H2, _P2, allocator_type>& __source)
    {
        ((void)0);

        return __table_.__node_handle_merge_unique(__source.__table_);
    }
    template <class _H2, class _P2>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void merge(unordered_multimap<key_type, mapped_type, _H2, _P2, allocator_type>&& __source)
    {
        ((void)0);

        return __table_.__node_handle_merge_unique(__source.__table_);
    }


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void swap(unordered_map& __u)
        noexcept(__is_nothrow_swappable<__table>::value)
        { __table_.swap(__u.__table_);}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    hasher hash_function() const
        {return __table_.hash_function().hash_function();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    key_equal key_eq() const
        {return __table_.key_eq().key_eq();}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iterator find(const key_type& __k) {return __table_.find(__k);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_iterator find(const key_type& __k) const {return __table_.find(__k);}
# 1370 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/unordered_map" 3
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_type count(const key_type& __k) const {return __table_.__count_unique(__k);}
# 1387 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/unordered_map" 3
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    pair<iterator, iterator> equal_range(const key_type& __k)
        {return __table_.__equal_range_unique(__k);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    pair<const_iterator, const_iterator> equal_range(const key_type& __k) const
        {return __table_.__equal_range_unique(__k);}
# 1404 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/unordered_map" 3
    mapped_type& operator[](const key_type& __k);

    mapped_type& operator[](key_type&& __k);


    mapped_type& at(const key_type& __k);
    const mapped_type& at(const key_type& __k) const;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_type bucket_count() const noexcept {return __table_.bucket_count();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_type max_bucket_count() const noexcept {return __table_.max_bucket_count();}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_type bucket_size(size_type __n) const
        {return __table_.bucket_size(__n);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_type bucket(const key_type& __k) const {return __table_.bucket(__k);}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    local_iterator begin(size_type __n) {return __table_.begin(__n);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    local_iterator end(size_type __n) {return __table_.end(__n);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_local_iterator begin(size_type __n) const {return __table_.cbegin(__n);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_local_iterator end(size_type __n) const {return __table_.cend(__n);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_local_iterator cbegin(size_type __n) const {return __table_.cbegin(__n);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_local_iterator cend(size_type __n) const {return __table_.cend(__n);}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    float load_factor() const noexcept {return __table_.load_factor();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    float max_load_factor() const noexcept {return __table_.max_load_factor();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void max_load_factor(float __mlf) {__table_.max_load_factor(__mlf);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void rehash(size_type __n) {__table_.rehash(__n);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void reserve(size_type __n) {__table_.reserve(__n);}
# 1460 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/unordered_map" 3
private:




};


template<class _InputIterator,
         class _Hash = hash<__iter_key_type<_InputIterator>>,
         class _Pred = equal_to<__iter_key_type<_InputIterator>>,
         class _Allocator = allocator<__iter_to_alloc_type<_InputIterator>>,
         class = _EnableIf<!__is_allocator<_Hash>::value>,
         class = _EnableIf<!is_integral<_Hash>::value>,
         class = _EnableIf<!__is_allocator<_Pred>::value>,
         class = _EnableIf<__is_allocator<_Allocator>::value>>
unordered_map(_InputIterator, _InputIterator, typename allocator_traits<_Allocator>::size_type = 0,
              _Hash = _Hash(), _Pred = _Pred(), _Allocator = _Allocator())
  -> unordered_map<__iter_key_type<_InputIterator>, __iter_mapped_type<_InputIterator>, _Hash, _Pred, _Allocator>;

template<class _Key, class _Tp, class _Hash = hash<remove_const_t<_Key>>,
         class _Pred = equal_to<remove_const_t<_Key>>,
         class _Allocator = allocator<pair<const _Key, _Tp>>,
         class = _EnableIf<!__is_allocator<_Hash>::value>,
         class = _EnableIf<!is_integral<_Hash>::value>,
         class = _EnableIf<!__is_allocator<_Pred>::value>,
         class = _EnableIf<__is_allocator<_Allocator>::value>>
unordered_map(initializer_list<pair<_Key, _Tp>>, typename allocator_traits<_Allocator>::size_type = 0,
              _Hash = _Hash(), _Pred = _Pred(), _Allocator = _Allocator())
  -> unordered_map<remove_const_t<_Key>, _Tp, _Hash, _Pred, _Allocator>;

template<class _InputIterator, class _Allocator,
         class = _EnableIf<__is_allocator<_Allocator>::value>>
unordered_map(_InputIterator, _InputIterator, typename allocator_traits<_Allocator>::size_type, _Allocator)
  -> unordered_map<__iter_key_type<_InputIterator>, __iter_mapped_type<_InputIterator>,
                   hash<__iter_key_type<_InputIterator>>, equal_to<__iter_key_type<_InputIterator>>, _Allocator>;

template<class _InputIterator, class _Allocator,
         class = _EnableIf<__is_allocator<_Allocator>::value>>
unordered_map(_InputIterator, _InputIterator, _Allocator)
  -> unordered_map<__iter_key_type<_InputIterator>, __iter_mapped_type<_InputIterator>,
                   hash<__iter_key_type<_InputIterator>>, equal_to<__iter_key_type<_InputIterator>>, _Allocator>;

template<class _InputIterator, class _Hash, class _Allocator,
         class = _EnableIf<!__is_allocator<_Hash>::value>,
         class = _EnableIf<!is_integral<_Hash>::value>,
         class = _EnableIf<__is_allocator<_Allocator>::value>>
unordered_map(_InputIterator, _InputIterator, typename allocator_traits<_Allocator>::size_type, _Hash, _Allocator)
  -> unordered_map<__iter_key_type<_InputIterator>, __iter_mapped_type<_InputIterator>,
                   _Hash, equal_to<__iter_key_type<_InputIterator>>, _Allocator>;

template<class _Key, class _Tp, class _Allocator,
         class = _EnableIf<__is_allocator<_Allocator>::value>>
unordered_map(initializer_list<pair<_Key, _Tp>>, typename allocator_traits<_Allocator>::size_type, _Allocator)
  -> unordered_map<remove_const_t<_Key>, _Tp,
                   hash<remove_const_t<_Key>>,
                   equal_to<remove_const_t<_Key>>, _Allocator>;

template<class _Key, class _Tp, class _Allocator,
         class = _EnableIf<__is_allocator<_Allocator>::value>>
unordered_map(initializer_list<pair<_Key, _Tp>>, _Allocator)
  -> unordered_map<remove_const_t<_Key>, _Tp,
                   hash<remove_const_t<_Key>>,
                   equal_to<remove_const_t<_Key>>, _Allocator>;

template<class _Key, class _Tp, class _Hash, class _Allocator,
         class = _EnableIf<!__is_allocator<_Hash>::value>,
         class = _EnableIf<!is_integral<_Hash>::value>,
         class = _EnableIf<__is_allocator<_Allocator>::value>>
unordered_map(initializer_list<pair<_Key, _Tp>>, typename allocator_traits<_Allocator>::size_type, _Hash, _Allocator)
  -> unordered_map<remove_const_t<_Key>, _Tp, _Hash,
                   equal_to<remove_const_t<_Key>>, _Allocator>;


template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_map(
        size_type __n, const hasher& __hf, const key_equal& __eql)
    : __table_(__hf, __eql)
{



    __table_.rehash(__n);
}

template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_map(
        size_type __n, const hasher& __hf, const key_equal& __eql,
        const allocator_type& __a)
    : __table_(__hf, __eql, typename __table::allocator_type(__a))
{



    __table_.rehash(__n);
}

template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
inline
unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_map(
        const allocator_type& __a)
    : __table_(typename __table::allocator_type(__a))
{



}

template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
template <class _InputIterator>
unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_map(
        _InputIterator __first, _InputIterator __last)
{



    insert(__first, __last);
}

template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
template <class _InputIterator>
unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_map(
        _InputIterator __first, _InputIterator __last, size_type __n,
        const hasher& __hf, const key_equal& __eql)
    : __table_(__hf, __eql)
{



    __table_.rehash(__n);
    insert(__first, __last);
}

template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
template <class _InputIterator>
unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_map(
        _InputIterator __first, _InputIterator __last, size_type __n,
        const hasher& __hf, const key_equal& __eql, const allocator_type& __a)
    : __table_(__hf, __eql, typename __table::allocator_type(__a))
{



    __table_.rehash(__n);
    insert(__first, __last);
}

template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_map(
        const unordered_map& __u)
    : __table_(__u.__table_)
{



    __table_.rehash(__u.bucket_count());
    insert(__u.begin(), __u.end());
}

template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_map(
        const unordered_map& __u, const allocator_type& __a)
    : __table_(__u.__table_, typename __table::allocator_type(__a))
{



    __table_.rehash(__u.bucket_count());
    insert(__u.begin(), __u.end());
}



template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
inline
unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_map(
        unordered_map&& __u)
    noexcept(is_nothrow_move_constructible<__table>::value)
    : __table_(std::__1::move(__u.__table_))
{




}

template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_map(
        unordered_map&& __u, const allocator_type& __a)
    : __table_(std::__1::move(__u.__table_), typename __table::allocator_type(__a))
{



    if (__a != __u.get_allocator())
    {
        iterator __i = __u.begin();
        while (__u.size() != 0) {
            __table_.__emplace_unique(
                __u.__table_.remove((__i++).__i_)->__value_.__move());
        }
    }




}

template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_map(
        initializer_list<value_type> __il)
{



    insert(__il.begin(), __il.end());
}

template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_map(
        initializer_list<value_type> __il, size_type __n, const hasher& __hf,
        const key_equal& __eql)
    : __table_(__hf, __eql)
{



    __table_.rehash(__n);
    insert(__il.begin(), __il.end());
}

template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_map(
        initializer_list<value_type> __il, size_type __n, const hasher& __hf,
        const key_equal& __eql, const allocator_type& __a)
    : __table_(__hf, __eql, typename __table::allocator_type(__a))
{



    __table_.rehash(__n);
    insert(__il.begin(), __il.end());
}

template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
inline
unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&
unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::operator=(unordered_map&& __u)
    noexcept(is_nothrow_move_assignable<__table>::value)
{
    __table_ = std::__1::move(__u.__table_);
    return *this;
}

template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
inline
unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&
unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::operator=(
        initializer_list<value_type> __il)
{
    __table_.__assign_unique(__il.begin(), __il.end());
    return *this;
}



template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
template <class _InputIterator>
inline
void
unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::insert(_InputIterator __first,
                                                       _InputIterator __last)
{
    for (; __first != __last; ++__first)
        __table_.__insert_unique(*__first);
}



template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
_Tp&
unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::operator[](const key_type& __k)
{
    return __table_.__emplace_unique_key_args(__k,
        piecewise_construct, std::__1::forward_as_tuple(__k),
                             std::__1::forward_as_tuple()).first->__get_value().second;
}

template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
_Tp&
unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::operator[](key_type&& __k)
{
    return __table_.__emplace_unique_key_args(__k,
        piecewise_construct, std::__1::forward_as_tuple(std::__1::move(__k)),
                             std::__1::forward_as_tuple()).first->__get_value().second;
}
# 1786 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/unordered_map" 3
template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
_Tp&
unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::at(const key_type& __k)
{
    iterator __i = find(__k);
    if (__i == end())
        __throw_out_of_range("unordered_map::at: key not found");
    return __i->second;
}

template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
const _Tp&
unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::at(const key_type& __k) const
{
    const_iterator __i = find(__k);
    if (__i == end())
        __throw_out_of_range("unordered_map::at: key not found");
    return __i->second;
}

template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void
swap(unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
     unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __y)
    noexcept(noexcept(__x.swap(__y)))
{
    __x.swap(__y);
}
# 1827 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/unordered_map" 3
template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
bool
operator==(const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
           const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __y)
{
    if (__x.size() != __y.size())
        return false;
    typedef typename unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::const_iterator
                                                                 const_iterator;
    for (const_iterator __i = __x.begin(), __ex = __x.end(), __ey = __y.end();
            __i != __ex; ++__i)
    {
        const_iterator __j = __y.find(__i->first);
        if (__j == __ey || !(*__i == *__j))
            return false;
    }
    return true;
}

template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator!=(const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
           const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __y)
{
    return !(__x == __y);
}

template <class _Key, class _Tp, class _Hash = hash<_Key>, class _Pred = equal_to<_Key>,
          class _Alloc = allocator<pair<const _Key, _Tp> > >
class __attribute__ ((__type_visibility__("default"))) unordered_multimap
{
public:

    typedef _Key key_type;
    typedef _Tp mapped_type;
    typedef __identity_t<_Hash> hasher;
    typedef __identity_t<_Pred> key_equal;
    typedef __identity_t<_Alloc> allocator_type;
    typedef pair<const key_type, mapped_type> value_type;
    typedef value_type& reference;
    typedef const value_type& const_reference;
    static_assert((is_same<value_type, typename allocator_type::value_type>::value),
                  "Invalid allocator::value_type");

private:
    typedef __hash_value_type<key_type, mapped_type> __value_type;
    typedef __unordered_map_hasher<key_type, __value_type, hasher, key_equal> __hasher;
    typedef __unordered_map_equal<key_type, __value_type, key_equal, hasher> __key_equal;
    typedef typename __rebind_alloc_helper<allocator_traits<allocator_type>,
                                                 __value_type>::type __allocator_type;

    typedef __hash_table<__value_type, __hasher,
                         __key_equal, __allocator_type> __table;

    __table __table_;

    typedef typename __table::_NodeTypes _NodeTypes;
    typedef typename __table::__node_traits __node_traits;
    typedef typename __table::__node_allocator __node_allocator;
    typedef typename __table::__node __node;
    typedef __hash_map_node_destructor<__node_allocator> _Dp;
    typedef unique_ptr<__node, _Dp> __node_holder;
    typedef allocator_traits<allocator_type> __alloc_traits;
    static_assert((is_same<typename __node_traits::size_type,
                          typename __alloc_traits::size_type>::value),
                 "Allocator uses different size_type for different types");
public:
    typedef typename __alloc_traits::pointer pointer;
    typedef typename __alloc_traits::const_pointer const_pointer;
    typedef typename __table::size_type size_type;
    typedef typename __table::difference_type difference_type;

    typedef __hash_map_iterator<typename __table::iterator> iterator;
    typedef __hash_map_const_iterator<typename __table::const_iterator> const_iterator;
    typedef __hash_map_iterator<typename __table::local_iterator> local_iterator;
    typedef __hash_map_const_iterator<typename __table::const_local_iterator> const_local_iterator;


    typedef __map_node_handle<__node, allocator_type> node_type;


    template <class _Key2, class _Tp2, class _Hash2, class _Pred2, class _Alloc2>
        friend class __attribute__ ((__type_visibility__("default"))) unordered_map;
    template <class _Key2, class _Tp2, class _Hash2, class _Pred2, class _Alloc2>
        friend class __attribute__ ((__type_visibility__("default"))) unordered_multimap;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    unordered_multimap()
        noexcept(is_nothrow_default_constructible<__table>::value)
        {



        }
    explicit unordered_multimap(size_type __n, const hasher& __hf = hasher(),
                                const key_equal& __eql = key_equal());
    unordered_multimap(size_type __n, const hasher& __hf,
                                const key_equal& __eql,
                                const allocator_type& __a);
    template <class _InputIterator>
        unordered_multimap(_InputIterator __first, _InputIterator __last);
    template <class _InputIterator>
        unordered_multimap(_InputIterator __first, _InputIterator __last,
                      size_type __n, const hasher& __hf = hasher(),
                      const key_equal& __eql = key_equal());
    template <class _InputIterator>
        unordered_multimap(_InputIterator __first, _InputIterator __last,
                      size_type __n, const hasher& __hf,
                      const key_equal& __eql,
                      const allocator_type& __a);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit unordered_multimap(const allocator_type& __a);
    unordered_multimap(const unordered_multimap& __u);
    unordered_multimap(const unordered_multimap& __u, const allocator_type& __a);

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    unordered_multimap(unordered_multimap&& __u)
        noexcept(is_nothrow_move_constructible<__table>::value);
    unordered_multimap(unordered_multimap&& __u, const allocator_type& __a);
    unordered_multimap(initializer_list<value_type> __il);
    unordered_multimap(initializer_list<value_type> __il, size_type __n,
                       const hasher& __hf = hasher(),
                       const key_equal& __eql = key_equal());
    unordered_multimap(initializer_list<value_type> __il, size_type __n,
                       const hasher& __hf, const key_equal& __eql,
                       const allocator_type& __a);


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    unordered_multimap(size_type __n, const allocator_type& __a)
      : unordered_multimap(__n, hasher(), key_equal(), __a) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    unordered_multimap(size_type __n, const hasher& __hf, const allocator_type& __a)
      : unordered_multimap(__n, __hf, key_equal(), __a) {}
    template <class _InputIterator>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
      unordered_multimap(_InputIterator __first, _InputIterator __last, size_type __n, const allocator_type& __a)
      : unordered_multimap(__first, __last, __n, hasher(), key_equal(), __a) {}
    template <class _InputIterator>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
      unordered_multimap(_InputIterator __first, _InputIterator __last, size_type __n, const hasher& __hf,
        const allocator_type& __a)
      : unordered_multimap(__first, __last, __n, __hf, key_equal(), __a) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    unordered_multimap(initializer_list<value_type> __il, size_type __n, const allocator_type& __a)
      : unordered_multimap(__il, __n, hasher(), key_equal(), __a) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    unordered_multimap(initializer_list<value_type> __il, size_type __n, const hasher& __hf,
      const allocator_type& __a)
      : unordered_multimap(__il, __n, __hf, key_equal(), __a) {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    ~unordered_multimap() {
        static_assert(sizeof(__diagnose_unordered_container_requirements<_Key, _Hash, _Pred>(0)), "");
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    unordered_multimap& operator=(const unordered_multimap& __u)
    {

        __table_ = __u.__table_;
# 1999 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/unordered_map" 3
        return *this;
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    unordered_multimap& operator=(unordered_multimap&& __u)
        noexcept(is_nothrow_move_assignable<__table>::value);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    unordered_multimap& operator=(initializer_list<value_type> __il);


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    allocator_type get_allocator() const noexcept
        {return allocator_type(__table_.__node_alloc());}

                                  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    bool empty() const noexcept {return __table_.size() == 0;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_type size() const noexcept {return __table_.size();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_type max_size() const noexcept {return __table_.max_size();}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iterator begin() noexcept {return __table_.begin();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iterator end() noexcept {return __table_.end();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_iterator begin() const noexcept {return __table_.begin();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_iterator end() const noexcept {return __table_.end();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_iterator cbegin() const noexcept {return __table_.begin();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_iterator cend() const noexcept {return __table_.end();}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iterator insert(const value_type& __x) {return __table_.__insert_multi(__x);}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iterator insert(const_iterator __p, const value_type& __x)
        {return __table_.__insert_multi(__p.__i_, __x);}

    template <class _InputIterator>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void insert(_InputIterator __first, _InputIterator __last);


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void insert(initializer_list<value_type> __il)
        {insert(__il.begin(), __il.end());}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iterator insert(value_type&& __x) {return __table_.__insert_multi(std::__1::move(__x));}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iterator insert(const_iterator __p, value_type&& __x)
        {return __table_.__insert_multi(__p.__i_, std::__1::move(__x));}

    template <class _Pp,
              class = typename enable_if<is_constructible<value_type, _Pp>::value>::type>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iterator insert(_Pp&& __x)
        {return __table_.__insert_multi(std::__1::forward<_Pp>(__x));}

    template <class _Pp,
              class = typename enable_if<is_constructible<value_type, _Pp>::value>::type>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iterator insert(const_iterator __p, _Pp&& __x)
        {return __table_.__insert_multi(__p.__i_, std::__1::forward<_Pp>(__x));}

    template <class... _Args>
    iterator emplace(_Args&&... __args) {
        return __table_.__emplace_multi(std::__1::forward<_Args>(__args)...);
    }

    template <class... _Args>
    iterator emplace_hint(const_iterator __p, _Args&&... __args) {
        return __table_.__emplace_hint_multi(__p.__i_, std::__1::forward<_Args>(__args)...);
    }



    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iterator erase(const_iterator __p) {return __table_.erase(__p.__i_);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iterator erase(iterator __p) {return __table_.erase(__p.__i_);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_type erase(const key_type& __k) {return __table_.__erase_multi(__k);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iterator erase(const_iterator __first, const_iterator __last)
        {return __table_.erase(__first.__i_, __last.__i_);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void clear() noexcept {__table_.clear();}


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iterator insert(node_type&& __nh)
    {
        ((void)0);

        return __table_.template __node_handle_insert_multi<node_type>(
            std::__1::move(__nh));
    }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iterator insert(const_iterator __hint, node_type&& __nh)
    {
        ((void)0);

        return __table_.template __node_handle_insert_multi<node_type>(
            __hint.__i_, std::__1::move(__nh));
    }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    node_type extract(key_type const& __key)
    {
        return __table_.template __node_handle_extract<node_type>(__key);
    }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    node_type extract(const_iterator __it)
    {
        return __table_.template __node_handle_extract<node_type>(
            __it.__i_);
    }

    template <class _H2, class _P2>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void merge(unordered_multimap<key_type, mapped_type, _H2, _P2, allocator_type>& __source)
    {
        ((void)0);

        return __table_.__node_handle_merge_multi(__source.__table_);
    }
    template <class _H2, class _P2>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void merge(unordered_multimap<key_type, mapped_type, _H2, _P2, allocator_type>&& __source)
    {
        ((void)0);

        return __table_.__node_handle_merge_multi(__source.__table_);
    }
    template <class _H2, class _P2>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void merge(unordered_map<key_type, mapped_type, _H2, _P2, allocator_type>& __source)
    {
        ((void)0);

        return __table_.__node_handle_merge_multi(__source.__table_);
    }
    template <class _H2, class _P2>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void merge(unordered_map<key_type, mapped_type, _H2, _P2, allocator_type>&& __source)
    {
        ((void)0);

        return __table_.__node_handle_merge_multi(__source.__table_);
    }


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void swap(unordered_multimap& __u)
        noexcept(__is_nothrow_swappable<__table>::value)
        {__table_.swap(__u.__table_);}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    hasher hash_function() const
        {return __table_.hash_function().hash_function();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    key_equal key_eq() const
        {return __table_.key_eq().key_eq();}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iterator find(const key_type& __k) {return __table_.find(__k);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_iterator find(const key_type& __k) const {return __table_.find(__k);}
# 2180 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/unordered_map" 3
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_type count(const key_type& __k) const {return __table_.__count_multi(__k);}
# 2197 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/unordered_map" 3
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    pair<iterator, iterator> equal_range(const key_type& __k)
        {return __table_.__equal_range_multi(__k);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    pair<const_iterator, const_iterator> equal_range(const key_type& __k) const
        {return __table_.__equal_range_multi(__k);}
# 2214 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/unordered_map" 3
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_type bucket_count() const noexcept {return __table_.bucket_count();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_type max_bucket_count() const noexcept
        {return __table_.max_bucket_count();}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_type bucket_size(size_type __n) const
        {return __table_.bucket_size(__n);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_type bucket(const key_type& __k) const {return __table_.bucket(__k);}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    local_iterator begin(size_type __n) {return __table_.begin(__n);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    local_iterator end(size_type __n) {return __table_.end(__n);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_local_iterator begin(size_type __n) const {return __table_.cbegin(__n);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_local_iterator end(size_type __n) const {return __table_.cend(__n);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_local_iterator cbegin(size_type __n) const {return __table_.cbegin(__n);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_local_iterator cend(size_type __n) const {return __table_.cend(__n);}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    float load_factor() const noexcept {return __table_.load_factor();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    float max_load_factor() const noexcept {return __table_.max_load_factor();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void max_load_factor(float __mlf) {__table_.max_load_factor(__mlf);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void rehash(size_type __n) {__table_.rehash(__n);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void reserve(size_type __n) {__table_.reserve(__n);}
# 2264 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/unordered_map" 3
};


template<class _InputIterator,
         class _Hash = hash<__iter_key_type<_InputIterator>>,
         class _Pred = equal_to<__iter_key_type<_InputIterator>>,
         class _Allocator = allocator<__iter_to_alloc_type<_InputIterator>>,
         class = _EnableIf<!__is_allocator<_Hash>::value>,
         class = _EnableIf<!is_integral<_Hash>::value>,
         class = _EnableIf<!__is_allocator<_Pred>::value>,
         class = _EnableIf<__is_allocator<_Allocator>::value>>
unordered_multimap(_InputIterator, _InputIterator, typename allocator_traits<_Allocator>::size_type = 0,
                   _Hash = _Hash(), _Pred = _Pred(), _Allocator = _Allocator())
  -> unordered_multimap<__iter_key_type<_InputIterator>, __iter_mapped_type<_InputIterator>, _Hash, _Pred, _Allocator>;

template<class _Key, class _Tp, class _Hash = hash<remove_const_t<_Key>>,
         class _Pred = equal_to<remove_const_t<_Key>>,
         class _Allocator = allocator<pair<const _Key, _Tp>>,
         class = _EnableIf<!__is_allocator<_Hash>::value>,
         class = _EnableIf<!is_integral<_Hash>::value>,
         class = _EnableIf<!__is_allocator<_Pred>::value>,
         class = _EnableIf<__is_allocator<_Allocator>::value>>
unordered_multimap(initializer_list<pair<_Key, _Tp>>, typename allocator_traits<_Allocator>::size_type = 0,
                   _Hash = _Hash(), _Pred = _Pred(), _Allocator = _Allocator())
  -> unordered_multimap<remove_const_t<_Key>, _Tp, _Hash, _Pred, _Allocator>;

template<class _InputIterator, class _Allocator,
         class = _EnableIf<__is_allocator<_Allocator>::value>>
unordered_multimap(_InputIterator, _InputIterator, typename allocator_traits<_Allocator>::size_type, _Allocator)
  -> unordered_multimap<__iter_key_type<_InputIterator>, __iter_mapped_type<_InputIterator>,
                        hash<__iter_key_type<_InputIterator>>, equal_to<__iter_key_type<_InputIterator>>, _Allocator>;

template<class _InputIterator, class _Allocator,
         class = _EnableIf<__is_allocator<_Allocator>::value>>
unordered_multimap(_InputIterator, _InputIterator, _Allocator)
  -> unordered_multimap<__iter_key_type<_InputIterator>, __iter_mapped_type<_InputIterator>,
                        hash<__iter_key_type<_InputIterator>>, equal_to<__iter_key_type<_InputIterator>>, _Allocator>;

template<class _InputIterator, class _Hash, class _Allocator,
         class = _EnableIf<!__is_allocator<_Hash>::value>,
         class = _EnableIf<!is_integral<_Hash>::value>,
         class = _EnableIf<__is_allocator<_Allocator>::value>>
unordered_multimap(_InputIterator, _InputIterator, typename allocator_traits<_Allocator>::size_type, _Hash, _Allocator)
  -> unordered_multimap<__iter_key_type<_InputIterator>, __iter_mapped_type<_InputIterator>,
                        _Hash, equal_to<__iter_key_type<_InputIterator>>, _Allocator>;

template<class _Key, class _Tp, class _Allocator,
         class = _EnableIf<__is_allocator<_Allocator>::value>>
unordered_multimap(initializer_list<pair<_Key, _Tp>>, typename allocator_traits<_Allocator>::size_type, _Allocator)
  -> unordered_multimap<remove_const_t<_Key>, _Tp,
                        hash<remove_const_t<_Key>>,
                        equal_to<remove_const_t<_Key>>, _Allocator>;

template<class _Key, class _Tp, class _Allocator,
         class = _EnableIf<__is_allocator<_Allocator>::value>>
unordered_multimap(initializer_list<pair<_Key, _Tp>>, _Allocator)
  -> unordered_multimap<remove_const_t<_Key>, _Tp,
                        hash<remove_const_t<_Key>>,
                        equal_to<remove_const_t<_Key>>, _Allocator>;

template<class _Key, class _Tp, class _Hash, class _Allocator,
         class = _EnableIf<!__is_allocator<_Hash>::value>,
         class = _EnableIf<!is_integral<_Hash>::value>,
         class = _EnableIf<__is_allocator<_Allocator>::value>>
unordered_multimap(initializer_list<pair<_Key, _Tp>>, typename allocator_traits<_Allocator>::size_type, _Hash, _Allocator)
  -> unordered_multimap<remove_const_t<_Key>, _Tp, _Hash,
                        equal_to<remove_const_t<_Key>>, _Allocator>;


template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_multimap(
        size_type __n, const hasher& __hf, const key_equal& __eql)
    : __table_(__hf, __eql)
{



    __table_.rehash(__n);
}

template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_multimap(
        size_type __n, const hasher& __hf, const key_equal& __eql,
        const allocator_type& __a)
    : __table_(__hf, __eql, typename __table::allocator_type(__a))
{



    __table_.rehash(__n);
}

template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
template <class _InputIterator>
unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_multimap(
        _InputIterator __first, _InputIterator __last)
{



    insert(__first, __last);
}

template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
template <class _InputIterator>
unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_multimap(
        _InputIterator __first, _InputIterator __last, size_type __n,
        const hasher& __hf, const key_equal& __eql)
    : __table_(__hf, __eql)
{



    __table_.rehash(__n);
    insert(__first, __last);
}

template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
template <class _InputIterator>
unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_multimap(
        _InputIterator __first, _InputIterator __last, size_type __n,
        const hasher& __hf, const key_equal& __eql, const allocator_type& __a)
    : __table_(__hf, __eql, typename __table::allocator_type(__a))
{



    __table_.rehash(__n);
    insert(__first, __last);
}

template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
inline
unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_multimap(
        const allocator_type& __a)
    : __table_(typename __table::allocator_type(__a))
{



}

template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_multimap(
        const unordered_multimap& __u)
    : __table_(__u.__table_)
{



    __table_.rehash(__u.bucket_count());
    insert(__u.begin(), __u.end());
}

template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_multimap(
        const unordered_multimap& __u, const allocator_type& __a)
    : __table_(__u.__table_, typename __table::allocator_type(__a))
{



    __table_.rehash(__u.bucket_count());
    insert(__u.begin(), __u.end());
}



template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
inline
unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_multimap(
        unordered_multimap&& __u)
    noexcept(is_nothrow_move_constructible<__table>::value)
    : __table_(std::__1::move(__u.__table_))
{




}

template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_multimap(
        unordered_multimap&& __u, const allocator_type& __a)
    : __table_(std::__1::move(__u.__table_), typename __table::allocator_type(__a))
{



    if (__a != __u.get_allocator())
    {
        iterator __i = __u.begin();
        while (__u.size() != 0)
        {
            __table_.__insert_multi(
                __u.__table_.remove((__i++).__i_)->__value_.__move());
        }
    }




}

template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_multimap(
        initializer_list<value_type> __il)
{



    insert(__il.begin(), __il.end());
}

template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_multimap(
        initializer_list<value_type> __il, size_type __n, const hasher& __hf,
        const key_equal& __eql)
    : __table_(__hf, __eql)
{



    __table_.rehash(__n);
    insert(__il.begin(), __il.end());
}

template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_multimap(
        initializer_list<value_type> __il, size_type __n, const hasher& __hf,
        const key_equal& __eql, const allocator_type& __a)
    : __table_(__hf, __eql, typename __table::allocator_type(__a))
{



    __table_.rehash(__n);
    insert(__il.begin(), __il.end());
}

template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
inline
unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&
unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::operator=(unordered_multimap&& __u)
    noexcept(is_nothrow_move_assignable<__table>::value)
{
    __table_ = std::__1::move(__u.__table_);
    return *this;
}

template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
inline
unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&
unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::operator=(
        initializer_list<value_type> __il)
{
    __table_.__assign_multi(__il.begin(), __il.end());
    return *this;
}





template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
template <class _InputIterator>
inline
void
unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::insert(_InputIterator __first,
                                                            _InputIterator __last)
{
    for (; __first != __last; ++__first)
        __table_.__insert_multi(*__first);
}

template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void
swap(unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
     unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __y)
    noexcept(noexcept(__x.swap(__y)))
{
    __x.swap(__y);
}
# 2560 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/unordered_map" 3
template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
bool
operator==(const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
           const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __y)
{
    if (__x.size() != __y.size())
        return false;
    typedef typename unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::const_iterator
                                                                 const_iterator;
    typedef pair<const_iterator, const_iterator> _EqRng;
    for (const_iterator __i = __x.begin(), __ex = __x.end(); __i != __ex;)
    {
        _EqRng __xeq = __x.equal_range(__i->first);
        _EqRng __yeq = __y.equal_range(__i->first);
        if (std::__1::distance(__xeq.first, __xeq.second) !=
            std::__1::distance(__yeq.first, __yeq.second) ||
                  !std::__1::is_permutation(__xeq.first, __xeq.second, __yeq.first))
            return false;
        __i = __xeq.second;
    }
    return true;
}

template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator!=(const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
           const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __y)
{
    return !(__x == __y);
}

} }
# 271 "/usr/local/include/bits/stdc++.h" 2


# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/unordered_set" 1 3
# 402 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/unordered_set" 3


namespace std { inline namespace __1 {

template <class _Value, class _Hash, class _Pred, class _Alloc>
class unordered_multiset;

template <class _Value, class _Hash = hash<_Value>, class _Pred = equal_to<_Value>,
          class _Alloc = allocator<_Value> >
class __attribute__ ((__type_visibility__("default"))) unordered_set
{
public:

    typedef _Value key_type;
    typedef key_type value_type;
    typedef __identity_t<_Hash> hasher;
    typedef __identity_t<_Pred> key_equal;
    typedef __identity_t<_Alloc> allocator_type;
    typedef value_type& reference;
    typedef const value_type& const_reference;
    static_assert((is_same<value_type, typename allocator_type::value_type>::value),
                  "Invalid allocator::value_type");

private:
    typedef __hash_table<value_type, hasher, key_equal, allocator_type> __table;

    __table __table_;

public:
    typedef typename __table::pointer pointer;
    typedef typename __table::const_pointer const_pointer;
    typedef typename __table::size_type size_type;
    typedef typename __table::difference_type difference_type;

    typedef typename __table::const_iterator iterator;
    typedef typename __table::const_iterator const_iterator;
    typedef typename __table::const_local_iterator local_iterator;
    typedef typename __table::const_local_iterator const_local_iterator;


    typedef __set_node_handle<typename __table::__node, allocator_type> node_type;
    typedef __insert_return_type<iterator, node_type> insert_return_type;


    template <class _Value2, class _Hash2, class _Pred2, class _Alloc2>
        friend class __attribute__ ((__type_visibility__("default"))) unordered_set;
    template <class _Value2, class _Hash2, class _Pred2, class _Alloc2>
        friend class __attribute__ ((__type_visibility__("default"))) unordered_multiset;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    unordered_set()
        noexcept(is_nothrow_default_constructible<__table>::value)
        {



        }
    explicit unordered_set(size_type __n, const hasher& __hf = hasher(),
                           const key_equal& __eql = key_equal());

    inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    unordered_set(size_type __n, const allocator_type& __a)
        : unordered_set(__n, hasher(), key_equal(), __a) {}
    inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    unordered_set(size_type __n, const hasher& __hf, const allocator_type& __a)
        : unordered_set(__n, __hf, key_equal(), __a) {}

    unordered_set(size_type __n, const hasher& __hf, const key_equal& __eql,
                  const allocator_type& __a);
    template <class _InputIterator>
        unordered_set(_InputIterator __first, _InputIterator __last);
    template <class _InputIterator>
        unordered_set(_InputIterator __first, _InputIterator __last,
                      size_type __n, const hasher& __hf = hasher(),
                      const key_equal& __eql = key_equal());
    template <class _InputIterator>
        unordered_set(_InputIterator __first, _InputIterator __last,
                      size_type __n, const hasher& __hf, const key_equal& __eql,
                      const allocator_type& __a);

    template <class _InputIterator>
    inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        unordered_set(_InputIterator __first, _InputIterator __last,
                    size_type __n, const allocator_type& __a)
            : unordered_set(__first, __last, __n, hasher(), key_equal(), __a) {}
    template <class _InputIterator>
        unordered_set(_InputIterator __first, _InputIterator __last,
                      size_type __n, const hasher& __hf, const allocator_type& __a)
            : unordered_set(__first, __last, __n, __hf, key_equal(), __a) {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit unordered_set(const allocator_type& __a);
    unordered_set(const unordered_set& __u);
    unordered_set(const unordered_set& __u, const allocator_type& __a);

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    unordered_set(unordered_set&& __u)
        noexcept(is_nothrow_move_constructible<__table>::value);
    unordered_set(unordered_set&& __u, const allocator_type& __a);
    unordered_set(initializer_list<value_type> __il);
    unordered_set(initializer_list<value_type> __il, size_type __n,
                  const hasher& __hf = hasher(),
                  const key_equal& __eql = key_equal());
    unordered_set(initializer_list<value_type> __il, size_type __n,
                  const hasher& __hf, const key_equal& __eql,
                  const allocator_type& __a);

    inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    unordered_set(initializer_list<value_type> __il, size_type __n,
                                                      const allocator_type& __a)
        : unordered_set(__il, __n, hasher(), key_equal(), __a) {}
    inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    unordered_set(initializer_list<value_type> __il, size_type __n,
                                  const hasher& __hf, const allocator_type& __a)
        : unordered_set(__il, __n, __hf, key_equal(), __a) {}


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    ~unordered_set() {
        static_assert(sizeof(__diagnose_unordered_container_requirements<_Value, _Hash, _Pred>(0)), "");
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    unordered_set& operator=(const unordered_set& __u)
    {
        __table_ = __u.__table_;
        return *this;
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    unordered_set& operator=(unordered_set&& __u)
        noexcept(is_nothrow_move_assignable<__table>::value);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    unordered_set& operator=(initializer_list<value_type> __il);


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    allocator_type get_allocator() const noexcept
        {return allocator_type(__table_.__node_alloc());}

                                  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    bool empty() const noexcept {return __table_.size() == 0;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_type size() const noexcept {return __table_.size();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_type max_size() const noexcept {return __table_.max_size();}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iterator begin() noexcept {return __table_.begin();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iterator end() noexcept {return __table_.end();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_iterator begin() const noexcept {return __table_.begin();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_iterator end() const noexcept {return __table_.end();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_iterator cbegin() const noexcept {return __table_.begin();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_iterator cend() const noexcept {return __table_.end();}


    template <class... _Args>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        pair<iterator, bool> emplace(_Args&&... __args)
            {return __table_.__emplace_unique(std::__1::forward<_Args>(__args)...);}
    template <class... _Args>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
# 578 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/unordered_set" 3
        iterator emplace_hint(const_iterator, _Args&&... __args)
            {return __table_.__emplace_unique(std::__1::forward<_Args>(__args)...).first;}


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    pair<iterator, bool> insert(value_type&& __x)
        {return __table_.__insert_unique(std::__1::move(__x));}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
# 595 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/unordered_set" 3
    iterator insert(const_iterator, value_type&& __x)
        {return insert(std::__1::move(__x)).first;}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void insert(initializer_list<value_type> __il)
        {insert(__il.begin(), __il.end());}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    pair<iterator, bool> insert(const value_type& __x)
        {return __table_.__insert_unique(__x);}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
# 616 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/unordered_set" 3
    iterator insert(const_iterator, const value_type& __x)
        {return insert(__x).first;}

    template <class _InputIterator>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        void insert(_InputIterator __first, _InputIterator __last);

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iterator erase(const_iterator __p) {return __table_.erase(__p);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_type erase(const key_type& __k) {return __table_.__erase_unique(__k);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iterator erase(const_iterator __first, const_iterator __last)
        {return __table_.erase(__first, __last);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void clear() noexcept {__table_.clear();}


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    insert_return_type insert(node_type&& __nh)
    {
        ((void)0);

        return __table_.template __node_handle_insert_unique<
            node_type, insert_return_type>(std::__1::move(__nh));
    }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iterator insert(const_iterator __h, node_type&& __nh)
    {
        ((void)0);

        return __table_.template __node_handle_insert_unique<node_type>(
            __h, std::__1::move(__nh));
    }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    node_type extract(key_type const& __key)
    {
        return __table_.template __node_handle_extract<node_type>(__key);
    }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    node_type extract(const_iterator __it)
    {
        return __table_.template __node_handle_extract<node_type>(__it);
    }

    template<class _H2, class _P2>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void merge(unordered_set<key_type, _H2, _P2, allocator_type>& __source)
    {
        ((void)0);

        __table_.__node_handle_merge_unique(__source.__table_);
    }
    template<class _H2, class _P2>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void merge(unordered_set<key_type, _H2, _P2, allocator_type>&& __source)
    {
        ((void)0);

        __table_.__node_handle_merge_unique(__source.__table_);
    }
    template<class _H2, class _P2>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void merge(unordered_multiset<key_type, _H2, _P2, allocator_type>& __source)
    {
        ((void)0);

        __table_.__node_handle_merge_unique(__source.__table_);
    }
    template<class _H2, class _P2>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void merge(unordered_multiset<key_type, _H2, _P2, allocator_type>&& __source)
    {
        ((void)0);

        __table_.__node_handle_merge_unique(__source.__table_);
    }


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void swap(unordered_set& __u)
        noexcept(__is_nothrow_swappable<__table>::value)
        {__table_.swap(__u.__table_);}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    hasher hash_function() const {return __table_.hash_function();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    key_equal key_eq() const {return __table_.key_eq();}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iterator find(const key_type& __k) {return __table_.find(__k);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_iterator find(const key_type& __k) const {return __table_.find(__k);}
# 719 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/unordered_set" 3
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_type count(const key_type& __k) const {return __table_.__count_unique(__k);}
# 736 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/unordered_set" 3
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    pair<iterator, iterator> equal_range(const key_type& __k)
        {return __table_.__equal_range_unique(__k);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    pair<const_iterator, const_iterator> equal_range(const key_type& __k) const
        {return __table_.__equal_range_unique(__k);}
# 753 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/unordered_set" 3
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_type bucket_count() const noexcept {return __table_.bucket_count();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_type max_bucket_count() const noexcept {return __table_.max_bucket_count();}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_type bucket_size(size_type __n) const {return __table_.bucket_size(__n);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_type bucket(const key_type& __k) const {return __table_.bucket(__k);}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    local_iterator begin(size_type __n) {return __table_.begin(__n);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    local_iterator end(size_type __n) {return __table_.end(__n);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_local_iterator begin(size_type __n) const {return __table_.cbegin(__n);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_local_iterator end(size_type __n) const {return __table_.cend(__n);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_local_iterator cbegin(size_type __n) const {return __table_.cbegin(__n);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_local_iterator cend(size_type __n) const {return __table_.cend(__n);}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    float load_factor() const noexcept {return __table_.load_factor();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    float max_load_factor() const noexcept {return __table_.max_load_factor();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void max_load_factor(float __mlf) {__table_.max_load_factor(__mlf);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void rehash(size_type __n) {__table_.rehash(__n);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void reserve(size_type __n) {__table_.reserve(__n);}
# 800 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/unordered_set" 3
};


template<class _InputIterator,
         class _Hash = hash<__iter_value_type<_InputIterator>>,
         class _Pred = equal_to<__iter_value_type<_InputIterator>>,
         class _Allocator = allocator<__iter_value_type<_InputIterator>>,
         class = _EnableIf<!__is_allocator<_Hash>::value>,
         class = _EnableIf<!is_integral<_Hash>::value>,
         class = _EnableIf<!__is_allocator<_Pred>::value>,
         class = _EnableIf<__is_allocator<_Allocator>::value>>
unordered_set(_InputIterator, _InputIterator, typename allocator_traits<_Allocator>::size_type = 0,
              _Hash = _Hash(), _Pred = _Pred(), _Allocator = _Allocator())
  -> unordered_set<__iter_value_type<_InputIterator>, _Hash, _Pred, _Allocator>;

template<class _Tp, class _Hash = hash<_Tp>,
         class _Pred = equal_to<_Tp>,
         class _Allocator = allocator<_Tp>,
         class = _EnableIf<!__is_allocator<_Hash>::value>,
         class = _EnableIf<!is_integral<_Hash>::value>,
         class = _EnableIf<!__is_allocator<_Pred>::value>,
         class = _EnableIf<__is_allocator<_Allocator>::value>>
unordered_set(initializer_list<_Tp>, typename allocator_traits<_Allocator>::size_type = 0,
              _Hash = _Hash(), _Pred = _Pred(), _Allocator = _Allocator())
  -> unordered_set<_Tp, _Hash, _Pred, _Allocator>;

template<class _InputIterator, class _Allocator,
         class = _EnableIf<__is_allocator<_Allocator>::value>>
unordered_set(_InputIterator, _InputIterator,
              typename allocator_traits<_Allocator>::size_type, _Allocator)
  -> unordered_set<__iter_value_type<_InputIterator>,
                   hash<__iter_value_type<_InputIterator>>,
                   equal_to<__iter_value_type<_InputIterator>>,
                   _Allocator>;

template<class _InputIterator, class _Hash, class _Allocator,
         class = _EnableIf<!__is_allocator<_Hash>::value>,
         class = _EnableIf<!is_integral<_Hash>::value>,
         class = _EnableIf<__is_allocator<_Allocator>::value>>
unordered_set(_InputIterator, _InputIterator,
              typename allocator_traits<_Allocator>::size_type, _Hash, _Allocator)
  -> unordered_set<__iter_value_type<_InputIterator>, _Hash,
                   equal_to<__iter_value_type<_InputIterator>>,
                   _Allocator>;

template<class _Tp, class _Allocator,
         class = _EnableIf<__is_allocator<_Allocator>::value>>
unordered_set(initializer_list<_Tp>, typename allocator_traits<_Allocator>::size_type, _Allocator)
  -> unordered_set<_Tp, hash<_Tp>, equal_to<_Tp>, _Allocator>;

template<class _Tp, class _Hash, class _Allocator,
         class = _EnableIf<!__is_allocator<_Hash>::value>,
         class = _EnableIf<!is_integral<_Hash>::value>,
         class = _EnableIf<__is_allocator<_Allocator>::value>>
unordered_set(initializer_list<_Tp>, typename allocator_traits<_Allocator>::size_type, _Hash, _Allocator)
  -> unordered_set<_Tp, _Hash, equal_to<_Tp>, _Allocator>;


template <class _Value, class _Hash, class _Pred, class _Alloc>
unordered_set<_Value, _Hash, _Pred, _Alloc>::unordered_set(size_type __n,
        const hasher& __hf, const key_equal& __eql)
    : __table_(__hf, __eql)
{



    __table_.rehash(__n);
}

template <class _Value, class _Hash, class _Pred, class _Alloc>
unordered_set<_Value, _Hash, _Pred, _Alloc>::unordered_set(size_type __n,
        const hasher& __hf, const key_equal& __eql, const allocator_type& __a)
    : __table_(__hf, __eql, __a)
{



    __table_.rehash(__n);
}

template <class _Value, class _Hash, class _Pred, class _Alloc>
template <class _InputIterator>
unordered_set<_Value, _Hash, _Pred, _Alloc>::unordered_set(
        _InputIterator __first, _InputIterator __last)
{



    insert(__first, __last);
}

template <class _Value, class _Hash, class _Pred, class _Alloc>
template <class _InputIterator>
unordered_set<_Value, _Hash, _Pred, _Alloc>::unordered_set(
        _InputIterator __first, _InputIterator __last, size_type __n,
        const hasher& __hf, const key_equal& __eql)
    : __table_(__hf, __eql)
{



    __table_.rehash(__n);
    insert(__first, __last);
}

template <class _Value, class _Hash, class _Pred, class _Alloc>
template <class _InputIterator>
unordered_set<_Value, _Hash, _Pred, _Alloc>::unordered_set(
        _InputIterator __first, _InputIterator __last, size_type __n,
        const hasher& __hf, const key_equal& __eql, const allocator_type& __a)
    : __table_(__hf, __eql, __a)
{



    __table_.rehash(__n);
    insert(__first, __last);
}

template <class _Value, class _Hash, class _Pred, class _Alloc>
inline
unordered_set<_Value, _Hash, _Pred, _Alloc>::unordered_set(
        const allocator_type& __a)
    : __table_(__a)
{



}

template <class _Value, class _Hash, class _Pred, class _Alloc>
unordered_set<_Value, _Hash, _Pred, _Alloc>::unordered_set(
        const unordered_set& __u)
    : __table_(__u.__table_)
{



    __table_.rehash(__u.bucket_count());
    insert(__u.begin(), __u.end());
}

template <class _Value, class _Hash, class _Pred, class _Alloc>
unordered_set<_Value, _Hash, _Pred, _Alloc>::unordered_set(
        const unordered_set& __u, const allocator_type& __a)
    : __table_(__u.__table_, __a)
{



    __table_.rehash(__u.bucket_count());
    insert(__u.begin(), __u.end());
}



template <class _Value, class _Hash, class _Pred, class _Alloc>
inline
unordered_set<_Value, _Hash, _Pred, _Alloc>::unordered_set(
        unordered_set&& __u)
    noexcept(is_nothrow_move_constructible<__table>::value)
    : __table_(std::__1::move(__u.__table_))
{




}

template <class _Value, class _Hash, class _Pred, class _Alloc>
unordered_set<_Value, _Hash, _Pred, _Alloc>::unordered_set(
        unordered_set&& __u, const allocator_type& __a)
    : __table_(std::__1::move(__u.__table_), __a)
{



    if (__a != __u.get_allocator())
    {
        iterator __i = __u.begin();
        while (__u.size() != 0)
            __table_.__insert_unique(std::__1::move(__u.__table_.remove(__i++)->__value_));
    }




}

template <class _Value, class _Hash, class _Pred, class _Alloc>
unordered_set<_Value, _Hash, _Pred, _Alloc>::unordered_set(
        initializer_list<value_type> __il)
{



    insert(__il.begin(), __il.end());
}

template <class _Value, class _Hash, class _Pred, class _Alloc>
unordered_set<_Value, _Hash, _Pred, _Alloc>::unordered_set(
        initializer_list<value_type> __il, size_type __n, const hasher& __hf,
        const key_equal& __eql)
    : __table_(__hf, __eql)
{



    __table_.rehash(__n);
    insert(__il.begin(), __il.end());
}

template <class _Value, class _Hash, class _Pred, class _Alloc>
unordered_set<_Value, _Hash, _Pred, _Alloc>::unordered_set(
        initializer_list<value_type> __il, size_type __n, const hasher& __hf,
        const key_equal& __eql, const allocator_type& __a)
    : __table_(__hf, __eql, __a)
{



    __table_.rehash(__n);
    insert(__il.begin(), __il.end());
}

template <class _Value, class _Hash, class _Pred, class _Alloc>
inline
unordered_set<_Value, _Hash, _Pred, _Alloc>&
unordered_set<_Value, _Hash, _Pred, _Alloc>::operator=(unordered_set&& __u)
    noexcept(is_nothrow_move_assignable<__table>::value)
{
    __table_ = std::__1::move(__u.__table_);
    return *this;
}

template <class _Value, class _Hash, class _Pred, class _Alloc>
inline
unordered_set<_Value, _Hash, _Pred, _Alloc>&
unordered_set<_Value, _Hash, _Pred, _Alloc>::operator=(
        initializer_list<value_type> __il)
{
    __table_.__assign_unique(__il.begin(), __il.end());
    return *this;
}



template <class _Value, class _Hash, class _Pred, class _Alloc>
template <class _InputIterator>
inline
void
unordered_set<_Value, _Hash, _Pred, _Alloc>::insert(_InputIterator __first,
                                                    _InputIterator __last)
{
    for (; __first != __last; ++__first)
        __table_.__insert_unique(*__first);
}

template <class _Value, class _Hash, class _Pred, class _Alloc>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void
swap(unordered_set<_Value, _Hash, _Pred, _Alloc>& __x,
     unordered_set<_Value, _Hash, _Pred, _Alloc>& __y)
    noexcept(noexcept(__x.swap(__y)))
{
    __x.swap(__y);
}
# 1079 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/unordered_set" 3
template <class _Value, class _Hash, class _Pred, class _Alloc>
bool
operator==(const unordered_set<_Value, _Hash, _Pred, _Alloc>& __x,
           const unordered_set<_Value, _Hash, _Pred, _Alloc>& __y)
{
    if (__x.size() != __y.size())
        return false;
    typedef typename unordered_set<_Value, _Hash, _Pred, _Alloc>::const_iterator
                                                                 const_iterator;
    for (const_iterator __i = __x.begin(), __ex = __x.end(), __ey = __y.end();
            __i != __ex; ++__i)
    {
        const_iterator __j = __y.find(*__i);
        if (__j == __ey || !(*__i == *__j))
            return false;
    }
    return true;
}

template <class _Value, class _Hash, class _Pred, class _Alloc>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator!=(const unordered_set<_Value, _Hash, _Pred, _Alloc>& __x,
           const unordered_set<_Value, _Hash, _Pred, _Alloc>& __y)
{
    return !(__x == __y);
}

template <class _Value, class _Hash = hash<_Value>, class _Pred = equal_to<_Value>,
          class _Alloc = allocator<_Value> >
class __attribute__ ((__type_visibility__("default"))) unordered_multiset
{
public:

    typedef _Value key_type;
    typedef key_type value_type;
    typedef __identity_t<_Hash> hasher;
    typedef __identity_t<_Pred> key_equal;
    typedef __identity_t<_Alloc> allocator_type;
    typedef value_type& reference;
    typedef const value_type& const_reference;
    static_assert((is_same<value_type, typename allocator_type::value_type>::value),
                  "Invalid allocator::value_type");

private:
    typedef __hash_table<value_type, hasher, key_equal, allocator_type> __table;

    __table __table_;

public:
    typedef typename __table::pointer pointer;
    typedef typename __table::const_pointer const_pointer;
    typedef typename __table::size_type size_type;
    typedef typename __table::difference_type difference_type;

    typedef typename __table::const_iterator iterator;
    typedef typename __table::const_iterator const_iterator;
    typedef typename __table::const_local_iterator local_iterator;
    typedef typename __table::const_local_iterator const_local_iterator;


    typedef __set_node_handle<typename __table::__node, allocator_type> node_type;


    template <class _Value2, class _Hash2, class _Pred2, class _Alloc2>
        friend class __attribute__ ((__type_visibility__("default"))) unordered_set;
    template <class _Value2, class _Hash2, class _Pred2, class _Alloc2>
        friend class __attribute__ ((__type_visibility__("default"))) unordered_multiset;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    unordered_multiset()
        noexcept(is_nothrow_default_constructible<__table>::value)
        {



        }
    explicit unordered_multiset(size_type __n, const hasher& __hf = hasher(),
                                const key_equal& __eql = key_equal());
    unordered_multiset(size_type __n, const hasher& __hf,
                       const key_equal& __eql, const allocator_type& __a);

    inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    unordered_multiset(size_type __n, const allocator_type& __a)
        : unordered_multiset(__n, hasher(), key_equal(), __a) {}
    inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    unordered_multiset(size_type __n, const hasher& __hf, const allocator_type& __a)
        : unordered_multiset(__n, __hf, key_equal(), __a) {}

    template <class _InputIterator>
        unordered_multiset(_InputIterator __first, _InputIterator __last);
    template <class _InputIterator>
        unordered_multiset(_InputIterator __first, _InputIterator __last,
                      size_type __n, const hasher& __hf = hasher(),
                      const key_equal& __eql = key_equal());
    template <class _InputIterator>
        unordered_multiset(_InputIterator __first, _InputIterator __last,
                      size_type __n , const hasher& __hf,
                      const key_equal& __eql, const allocator_type& __a);

    template <class _InputIterator>
    inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    unordered_multiset(_InputIterator __first, _InputIterator __last,
                       size_type __n, const allocator_type& __a)
        : unordered_multiset(__first, __last, __n, hasher(), key_equal(), __a) {}
    template <class _InputIterator>
    inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    unordered_multiset(_InputIterator __first, _InputIterator __last,
                       size_type __n, const hasher& __hf, const allocator_type& __a)
        : unordered_multiset(__first, __last, __n, __hf, key_equal(), __a) {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit unordered_multiset(const allocator_type& __a);
    unordered_multiset(const unordered_multiset& __u);
    unordered_multiset(const unordered_multiset& __u, const allocator_type& __a);

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    unordered_multiset(unordered_multiset&& __u)
        noexcept(is_nothrow_move_constructible<__table>::value);
    unordered_multiset(unordered_multiset&& __u, const allocator_type& __a);
    unordered_multiset(initializer_list<value_type> __il);
    unordered_multiset(initializer_list<value_type> __il, size_type __n,
                       const hasher& __hf = hasher(),
                       const key_equal& __eql = key_equal());
    unordered_multiset(initializer_list<value_type> __il, size_type __n,
                       const hasher& __hf, const key_equal& __eql,
                       const allocator_type& __a);

    inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    unordered_multiset(initializer_list<value_type> __il, size_type __n, const allocator_type& __a)
      : unordered_multiset(__il, __n, hasher(), key_equal(), __a) {}
    inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    unordered_multiset(initializer_list<value_type> __il, size_type __n, const hasher& __hf, const allocator_type& __a)
      : unordered_multiset(__il, __n, __hf, key_equal(), __a) {}


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    ~unordered_multiset() {
        static_assert(sizeof(__diagnose_unordered_container_requirements<_Value, _Hash, _Pred>(0)), "");
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    unordered_multiset& operator=(const unordered_multiset& __u)
    {
        __table_ = __u.__table_;
        return *this;
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    unordered_multiset& operator=(unordered_multiset&& __u)
        noexcept(is_nothrow_move_assignable<__table>::value);
    unordered_multiset& operator=(initializer_list<value_type> __il);


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    allocator_type get_allocator() const noexcept
        {return allocator_type(__table_.__node_alloc());}

                                  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    bool empty() const noexcept {return __table_.size() == 0;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_type size() const noexcept {return __table_.size();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_type max_size() const noexcept {return __table_.max_size();}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iterator begin() noexcept {return __table_.begin();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iterator end() noexcept {return __table_.end();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_iterator begin() const noexcept {return __table_.begin();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_iterator end() const noexcept {return __table_.end();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_iterator cbegin() const noexcept {return __table_.begin();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_iterator cend() const noexcept {return __table_.end();}


    template <class... _Args>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        iterator emplace(_Args&&... __args)
            {return __table_.__emplace_multi(std::__1::forward<_Args>(__args)...);}
    template <class... _Args>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        iterator emplace_hint(const_iterator __p, _Args&&... __args)
            {return __table_.__emplace_hint_multi(__p, std::__1::forward<_Args>(__args)...);}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iterator insert(value_type&& __x) {return __table_.__insert_multi(std::__1::move(__x));}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iterator insert(const_iterator __p, value_type&& __x)
        {return __table_.__insert_multi(__p, std::__1::move(__x));}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void insert(initializer_list<value_type> __il)
        {insert(__il.begin(), __il.end());}


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iterator insert(const value_type& __x) {return __table_.__insert_multi(__x);}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iterator insert(const_iterator __p, const value_type& __x)
        {return __table_.__insert_multi(__p, __x);}

    template <class _InputIterator>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        void insert(_InputIterator __first, _InputIterator __last);


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iterator insert(node_type&& __nh)
    {
        ((void)0);

        return __table_.template __node_handle_insert_multi<node_type>(
            std::__1::move(__nh));
    }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iterator insert(const_iterator __hint, node_type&& __nh)
    {
        ((void)0);

        return __table_.template __node_handle_insert_multi<node_type>(
            __hint, std::__1::move(__nh));
    }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    node_type extract(const_iterator __position)
    {
        return __table_.template __node_handle_extract<node_type>(
            __position);
    }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    node_type extract(key_type const& __key)
    {
        return __table_.template __node_handle_extract<node_type>(__key);
    }

    template <class _H2, class _P2>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void merge(unordered_multiset<key_type, _H2, _P2, allocator_type>& __source)
    {
        ((void)0);

        return __table_.__node_handle_merge_multi(__source.__table_);
    }
    template <class _H2, class _P2>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void merge(unordered_multiset<key_type, _H2, _P2, allocator_type>&& __source)
    {
        ((void)0);

        return __table_.__node_handle_merge_multi(__source.__table_);
    }
    template <class _H2, class _P2>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void merge(unordered_set<key_type, _H2, _P2, allocator_type>& __source)
    {
        ((void)0);

        return __table_.__node_handle_merge_multi(__source.__table_);
    }
    template <class _H2, class _P2>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void merge(unordered_set<key_type, _H2, _P2, allocator_type>&& __source)
    {
        ((void)0);

        return __table_.__node_handle_merge_multi(__source.__table_);
    }


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iterator erase(const_iterator __p) {return __table_.erase(__p);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_type erase(const key_type& __k) {return __table_.__erase_multi(__k);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iterator erase(const_iterator __first, const_iterator __last)
        {return __table_.erase(__first, __last);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void clear() noexcept {__table_.clear();}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void swap(unordered_multiset& __u)
        noexcept(__is_nothrow_swappable<__table>::value)
        {__table_.swap(__u.__table_);}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    hasher hash_function() const {return __table_.hash_function();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    key_equal key_eq() const {return __table_.key_eq();}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iterator find(const key_type& __k) {return __table_.find(__k);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_iterator find(const key_type& __k) const {return __table_.find(__k);}
# 1385 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/unordered_set" 3
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_type count(const key_type& __k) const {return __table_.__count_multi(__k);}
# 1402 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/unordered_set" 3
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    pair<iterator, iterator> equal_range(const key_type& __k)
        {return __table_.__equal_range_multi(__k);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    pair<const_iterator, const_iterator> equal_range(const key_type& __k) const
        {return __table_.__equal_range_multi(__k);}
# 1419 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/unordered_set" 3
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_type bucket_count() const noexcept {return __table_.bucket_count();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_type max_bucket_count() const noexcept {return __table_.max_bucket_count();}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_type bucket_size(size_type __n) const {return __table_.bucket_size(__n);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_type bucket(const key_type& __k) const {return __table_.bucket(__k);}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    local_iterator begin(size_type __n) {return __table_.begin(__n);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    local_iterator end(size_type __n) {return __table_.end(__n);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_local_iterator begin(size_type __n) const {return __table_.cbegin(__n);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_local_iterator end(size_type __n) const {return __table_.cend(__n);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_local_iterator cbegin(size_type __n) const {return __table_.cbegin(__n);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_local_iterator cend(size_type __n) const {return __table_.cend(__n);}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    float load_factor() const noexcept {return __table_.load_factor();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    float max_load_factor() const noexcept {return __table_.max_load_factor();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void max_load_factor(float __mlf) {__table_.max_load_factor(__mlf);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void rehash(size_type __n) {__table_.rehash(__n);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void reserve(size_type __n) {__table_.reserve(__n);}
# 1466 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/unordered_set" 3
};


template<class _InputIterator,
         class _Hash = hash<__iter_value_type<_InputIterator>>,
         class _Pred = equal_to<__iter_value_type<_InputIterator>>,
         class _Allocator = allocator<__iter_value_type<_InputIterator>>,
         class = _EnableIf<!__is_allocator<_Hash>::value>,
         class = _EnableIf<!is_integral<_Hash>::value>,
         class = _EnableIf<!__is_allocator<_Pred>::value>,
         class = _EnableIf<__is_allocator<_Allocator>::value>>
unordered_multiset(_InputIterator, _InputIterator, typename allocator_traits<_Allocator>::size_type = 0,
              _Hash = _Hash(), _Pred = _Pred(), _Allocator = _Allocator())
  -> unordered_multiset<__iter_value_type<_InputIterator>, _Hash, _Pred, _Allocator>;

template<class _Tp, class _Hash = hash<_Tp>,
         class _Pred = equal_to<_Tp>, class _Allocator = allocator<_Tp>,
         class = _EnableIf<!__is_allocator<_Hash>::value>,
         class = _EnableIf<!is_integral<_Hash>::value>,
         class = _EnableIf<!__is_allocator<_Pred>::value>,
         class = _EnableIf<__is_allocator<_Allocator>::value>>
unordered_multiset(initializer_list<_Tp>, typename allocator_traits<_Allocator>::size_type = 0,
              _Hash = _Hash(), _Pred = _Pred(), _Allocator = _Allocator())
  -> unordered_multiset<_Tp, _Hash, _Pred, _Allocator>;

template<class _InputIterator, class _Allocator,
         class = _EnableIf<__is_allocator<_Allocator>::value>>
unordered_multiset(_InputIterator, _InputIterator, typename allocator_traits<_Allocator>::size_type, _Allocator)
  -> unordered_multiset<__iter_value_type<_InputIterator>,
                   hash<__iter_value_type<_InputIterator>>,
                   equal_to<__iter_value_type<_InputIterator>>,
                   _Allocator>;

template<class _InputIterator, class _Hash, class _Allocator,
         class = _EnableIf<!__is_allocator<_Hash>::value>,
         class = _EnableIf<!is_integral<_Hash>::value>,
         class = _EnableIf<__is_allocator<_Allocator>::value>>
unordered_multiset(_InputIterator, _InputIterator, typename allocator_traits<_Allocator>::size_type,
              _Hash, _Allocator)
  -> unordered_multiset<__iter_value_type<_InputIterator>, _Hash,
                   equal_to<__iter_value_type<_InputIterator>>,
                   _Allocator>;

template<class _Tp, class _Allocator,
         class = _EnableIf<__is_allocator<_Allocator>::value>>
unordered_multiset(initializer_list<_Tp>, typename allocator_traits<_Allocator>::size_type, _Allocator)
  -> unordered_multiset<_Tp, hash<_Tp>, equal_to<_Tp>, _Allocator>;

template<class _Tp, class _Hash, class _Allocator,
         class = _EnableIf<!__is_allocator<_Hash>::value>,
         class = _EnableIf<!is_integral<_Hash>::value>,
         class = _EnableIf<__is_allocator<_Allocator>::value>>
unordered_multiset(initializer_list<_Tp>, typename allocator_traits<_Allocator>::size_type, _Hash, _Allocator)
  -> unordered_multiset<_Tp, _Hash, equal_to<_Tp>, _Allocator>;


template <class _Value, class _Hash, class _Pred, class _Alloc>
unordered_multiset<_Value, _Hash, _Pred, _Alloc>::unordered_multiset(
        size_type __n, const hasher& __hf, const key_equal& __eql)
    : __table_(__hf, __eql)
{



    __table_.rehash(__n);
}

template <class _Value, class _Hash, class _Pred, class _Alloc>
unordered_multiset<_Value, _Hash, _Pred, _Alloc>::unordered_multiset(
        size_type __n, const hasher& __hf, const key_equal& __eql,
        const allocator_type& __a)
    : __table_(__hf, __eql, __a)
{



    __table_.rehash(__n);
}

template <class _Value, class _Hash, class _Pred, class _Alloc>
template <class _InputIterator>
unordered_multiset<_Value, _Hash, _Pred, _Alloc>::unordered_multiset(
        _InputIterator __first, _InputIterator __last)
{



    insert(__first, __last);
}

template <class _Value, class _Hash, class _Pred, class _Alloc>
template <class _InputIterator>
unordered_multiset<_Value, _Hash, _Pred, _Alloc>::unordered_multiset(
        _InputIterator __first, _InputIterator __last, size_type __n,
        const hasher& __hf, const key_equal& __eql)
    : __table_(__hf, __eql)
{



    __table_.rehash(__n);
    insert(__first, __last);
}

template <class _Value, class _Hash, class _Pred, class _Alloc>
template <class _InputIterator>
unordered_multiset<_Value, _Hash, _Pred, _Alloc>::unordered_multiset(
        _InputIterator __first, _InputIterator __last, size_type __n,
        const hasher& __hf, const key_equal& __eql, const allocator_type& __a)
    : __table_(__hf, __eql, __a)
{



    __table_.rehash(__n);
    insert(__first, __last);
}

template <class _Value, class _Hash, class _Pred, class _Alloc>
inline
unordered_multiset<_Value, _Hash, _Pred, _Alloc>::unordered_multiset(
        const allocator_type& __a)
    : __table_(__a)
{



}

template <class _Value, class _Hash, class _Pred, class _Alloc>
unordered_multiset<_Value, _Hash, _Pred, _Alloc>::unordered_multiset(
        const unordered_multiset& __u)
    : __table_(__u.__table_)
{



    __table_.rehash(__u.bucket_count());
    insert(__u.begin(), __u.end());
}

template <class _Value, class _Hash, class _Pred, class _Alloc>
unordered_multiset<_Value, _Hash, _Pred, _Alloc>::unordered_multiset(
        const unordered_multiset& __u, const allocator_type& __a)
    : __table_(__u.__table_, __a)
{



    __table_.rehash(__u.bucket_count());
    insert(__u.begin(), __u.end());
}



template <class _Value, class _Hash, class _Pred, class _Alloc>
inline
unordered_multiset<_Value, _Hash, _Pred, _Alloc>::unordered_multiset(
        unordered_multiset&& __u)
    noexcept(is_nothrow_move_constructible<__table>::value)
    : __table_(std::__1::move(__u.__table_))
{




}

template <class _Value, class _Hash, class _Pred, class _Alloc>
unordered_multiset<_Value, _Hash, _Pred, _Alloc>::unordered_multiset(
        unordered_multiset&& __u, const allocator_type& __a)
    : __table_(std::__1::move(__u.__table_), __a)
{



    if (__a != __u.get_allocator())
    {
        iterator __i = __u.begin();
        while (__u.size() != 0)
            __table_.__insert_multi(std::__1::move(__u.__table_.remove(__i++)->__value_));
    }




}

template <class _Value, class _Hash, class _Pred, class _Alloc>
unordered_multiset<_Value, _Hash, _Pred, _Alloc>::unordered_multiset(
        initializer_list<value_type> __il)
{



    insert(__il.begin(), __il.end());
}

template <class _Value, class _Hash, class _Pred, class _Alloc>
unordered_multiset<_Value, _Hash, _Pred, _Alloc>::unordered_multiset(
        initializer_list<value_type> __il, size_type __n, const hasher& __hf,
        const key_equal& __eql)
    : __table_(__hf, __eql)
{



    __table_.rehash(__n);
    insert(__il.begin(), __il.end());
}

template <class _Value, class _Hash, class _Pred, class _Alloc>
unordered_multiset<_Value, _Hash, _Pred, _Alloc>::unordered_multiset(
        initializer_list<value_type> __il, size_type __n, const hasher& __hf,
        const key_equal& __eql, const allocator_type& __a)
    : __table_(__hf, __eql, __a)
{



    __table_.rehash(__n);
    insert(__il.begin(), __il.end());
}

template <class _Value, class _Hash, class _Pred, class _Alloc>
inline
unordered_multiset<_Value, _Hash, _Pred, _Alloc>&
unordered_multiset<_Value, _Hash, _Pred, _Alloc>::operator=(
        unordered_multiset&& __u)
    noexcept(is_nothrow_move_assignable<__table>::value)
{
    __table_ = std::__1::move(__u.__table_);
    return *this;
}

template <class _Value, class _Hash, class _Pred, class _Alloc>
inline
unordered_multiset<_Value, _Hash, _Pred, _Alloc>&
unordered_multiset<_Value, _Hash, _Pred, _Alloc>::operator=(
        initializer_list<value_type> __il)
{
    __table_.__assign_multi(__il.begin(), __il.end());
    return *this;
}



template <class _Value, class _Hash, class _Pred, class _Alloc>
template <class _InputIterator>
inline
void
unordered_multiset<_Value, _Hash, _Pred, _Alloc>::insert(_InputIterator __first,
                                                         _InputIterator __last)
{
    for (; __first != __last; ++__first)
        __table_.__insert_multi(*__first);
}

template <class _Value, class _Hash, class _Pred, class _Alloc>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void
swap(unordered_multiset<_Value, _Hash, _Pred, _Alloc>& __x,
     unordered_multiset<_Value, _Hash, _Pred, _Alloc>& __y)
    noexcept(noexcept(__x.swap(__y)))
{
    __x.swap(__y);
}
# 1745 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/unordered_set" 3
template <class _Value, class _Hash, class _Pred, class _Alloc>
bool
operator==(const unordered_multiset<_Value, _Hash, _Pred, _Alloc>& __x,
           const unordered_multiset<_Value, _Hash, _Pred, _Alloc>& __y)
{
    if (__x.size() != __y.size())
        return false;
    typedef typename unordered_multiset<_Value, _Hash, _Pred, _Alloc>::const_iterator
                                                                 const_iterator;
    typedef pair<const_iterator, const_iterator> _EqRng;
    for (const_iterator __i = __x.begin(), __ex = __x.end(); __i != __ex;)
    {
        _EqRng __xeq = __x.equal_range(*__i);
        _EqRng __yeq = __y.equal_range(*__i);
        if (std::__1::distance(__xeq.first, __xeq.second) !=
            std::__1::distance(__yeq.first, __yeq.second) ||
                  !std::__1::is_permutation(__xeq.first, __xeq.second, __yeq.first))
            return false;
        __i = __xeq.second;
    }
    return true;
}

template <class _Value, class _Hash, class _Pred, class _Alloc>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator!=(const unordered_multiset<_Value, _Hash, _Pred, _Alloc>& __x,
           const unordered_multiset<_Value, _Hash, _Pred, _Alloc>& __y)
{
    return !(__x == __y);
}

} }
# 274 "/usr/local/include/bits/stdc++.h" 2





# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/shared_mutex" 1 3
# 130 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/shared_mutex" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 131 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/shared_mutex" 2 3
# 139 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/shared_mutex" 3






namespace std { inline namespace __1 {

struct __attribute__ ((__visibility__("default"))) __attribute__((availability(macosx,strict,introduced=10.12))) __attribute__((availability(ios,strict,introduced=10.0))) __attribute__((availability(tvos,strict,introduced=10.0))) __attribute__((availability(watchos,strict,introduced=3.0)))
__shared_mutex_base
{
    mutex __mut_;
    condition_variable __gate1_;
    condition_variable __gate2_;
    unsigned __state_;

    static const unsigned __write_entered_ = 1U << (sizeof(unsigned)*8 - 1);
    static const unsigned __n_readers_ = ~__write_entered_;

    __shared_mutex_base();
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) ~__shared_mutex_base() = default;

    __shared_mutex_base(const __shared_mutex_base&) = delete;
    __shared_mutex_base& operator=(const __shared_mutex_base&) = delete;


    void lock() ;
    bool try_lock() ;
    void unlock() ;


    void lock_shared() ;
    bool try_lock_shared() ;
    void unlock_shared() ;



};



class __attribute__ ((__visibility__("default"))) __attribute__((availability(macosx,strict,introduced=10.12))) __attribute__((availability(ios,strict,introduced=10.0))) __attribute__((availability(tvos,strict,introduced=10.0))) __attribute__((availability(watchos,strict,introduced=3.0))) shared_mutex
{
    __shared_mutex_base __base;
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) shared_mutex() : __base() {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) ~shared_mutex() = default;

    shared_mutex(const shared_mutex&) = delete;
    shared_mutex& operator=(const shared_mutex&) = delete;


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) void lock() { return __base.lock(); }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) bool try_lock() { return __base.try_lock(); }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) void unlock() { return __base.unlock(); }


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) void lock_shared() { return __base.lock_shared(); }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) bool try_lock_shared() { return __base.try_lock_shared(); }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) void unlock_shared() { return __base.unlock_shared(); }



};



class __attribute__ ((__visibility__("default"))) __attribute__((availability(macosx,strict,introduced=10.12))) __attribute__((availability(ios,strict,introduced=10.0))) __attribute__((availability(tvos,strict,introduced=10.0))) __attribute__((availability(watchos,strict,introduced=3.0))) shared_timed_mutex
{
    __shared_mutex_base __base;
public:
    shared_timed_mutex();
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) ~shared_timed_mutex() = default;

    shared_timed_mutex(const shared_timed_mutex&) = delete;
    shared_timed_mutex& operator=(const shared_timed_mutex&) = delete;


    void lock();
    bool try_lock();
    template <class _Rep, class _Period>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        bool
        try_lock_for(const chrono::duration<_Rep, _Period>& __rel_time)
        {
            return try_lock_until(chrono::steady_clock::now() + __rel_time);
        }
    template <class _Clock, class _Duration>
        inline __attribute__ ((__visibility__("hidden")))
        bool
        try_lock_until(const chrono::time_point<_Clock, _Duration>& __abs_time);
    void unlock();


    void lock_shared();
    bool try_lock_shared();
    template <class _Rep, class _Period>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        bool
        try_lock_shared_for(const chrono::duration<_Rep, _Period>& __rel_time)
        {
            return try_lock_shared_until(chrono::steady_clock::now() + __rel_time);
        }
    template <class _Clock, class _Duration>
        inline __attribute__ ((__visibility__("hidden")))
        bool
        try_lock_shared_until(const chrono::time_point<_Clock, _Duration>& __abs_time);
    void unlock_shared();
};

template <class _Clock, class _Duration>
bool
shared_timed_mutex::try_lock_until(
                        const chrono::time_point<_Clock, _Duration>& __abs_time)
{
    unique_lock<mutex> __lk(__base.__mut_);
    if (__base.__state_ & __base.__write_entered_)
    {
        while (true)
        {
            cv_status __status = __base.__gate1_.wait_until(__lk, __abs_time);
            if ((__base.__state_ & __base.__write_entered_) == 0)
                break;
            if (__status == cv_status::timeout)
                return false;
        }
    }
    __base.__state_ |= __base.__write_entered_;
    if (__base.__state_ & __base.__n_readers_)
    {
        while (true)
        {
            cv_status __status = __base.__gate2_.wait_until(__lk, __abs_time);
            if ((__base.__state_ & __base.__n_readers_) == 0)
                break;
            if (__status == cv_status::timeout)
            {
                __base.__state_ &= ~__base.__write_entered_;
                __base.__gate1_.notify_all();
                return false;
            }
        }
    }
    return true;
}

template <class _Clock, class _Duration>
bool
shared_timed_mutex::try_lock_shared_until(
                        const chrono::time_point<_Clock, _Duration>& __abs_time)
{
    unique_lock<mutex> __lk(__base.__mut_);
    if ((__base.__state_ & __base.__write_entered_) || (__base.__state_ & __base.__n_readers_) == __base.__n_readers_)
    {
        while (true)
        {
            cv_status status = __base.__gate1_.wait_until(__lk, __abs_time);
            if ((__base.__state_ & __base.__write_entered_) == 0 &&
                                       (__base.__state_ & __base.__n_readers_) < __base.__n_readers_)
                break;
            if (status == cv_status::timeout)
                return false;
        }
    }
    unsigned __num_readers = (__base.__state_ & __base.__n_readers_) + 1;
    __base.__state_ &= ~__base.__n_readers_;
    __base.__state_ |= __num_readers;
    return true;
}

template <class _Mutex>
class shared_lock
{
public:
    typedef _Mutex mutex_type;

private:
    mutex_type* __m_;
    bool __owns_;

public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    shared_lock() noexcept
        : __m_(nullptr),
          __owns_(false)
        {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit shared_lock(mutex_type& __m)
        : __m_(std::__1::addressof(__m)),
          __owns_(true)
        {__m_->lock_shared();}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    shared_lock(mutex_type& __m, defer_lock_t) noexcept
        : __m_(std::__1::addressof(__m)),
          __owns_(false)
        {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    shared_lock(mutex_type& __m, try_to_lock_t)
        : __m_(std::__1::addressof(__m)),
          __owns_(__m.try_lock_shared())
        {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    shared_lock(mutex_type& __m, adopt_lock_t)
        : __m_(std::__1::addressof(__m)),
          __owns_(true)
        {}

    template <class _Clock, class _Duration>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        shared_lock(mutex_type& __m,
                    const chrono::time_point<_Clock, _Duration>& __abs_time)
            : __m_(std::__1::addressof(__m)),
              __owns_(__m.try_lock_shared_until(__abs_time))
            {}

    template <class _Rep, class _Period>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        shared_lock(mutex_type& __m,
                    const chrono::duration<_Rep, _Period>& __rel_time)
            : __m_(std::__1::addressof(__m)),
              __owns_(__m.try_lock_shared_for(__rel_time))
            {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    ~shared_lock()
    {
        if (__owns_)
            __m_->unlock_shared();
    }

    shared_lock(shared_lock const&) = delete;
    shared_lock& operator=(shared_lock const&) = delete;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    shared_lock(shared_lock&& __u) noexcept
        : __m_(__u.__m_),
          __owns_(__u.__owns_)
        {
            __u.__m_ = nullptr;
            __u.__owns_ = false;
        }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    shared_lock& operator=(shared_lock&& __u) noexcept
    {
        if (__owns_)
            __m_->unlock_shared();
        __m_ = nullptr;
        __owns_ = false;
        __m_ = __u.__m_;
        __owns_ = __u.__owns_;
        __u.__m_ = nullptr;
        __u.__owns_ = false;
        return *this;
    }

    void lock();
    bool try_lock();
    template <class Rep, class Period>
        bool try_lock_for(const chrono::duration<Rep, Period>& rel_time);
    template <class Clock, class Duration>
        bool try_lock_until(const chrono::time_point<Clock, Duration>& abs_time);
    void unlock();


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void swap(shared_lock& __u) noexcept
    {
        std::__1::swap(__m_, __u.__m_);
        std::__1::swap(__owns_, __u.__owns_);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    mutex_type* release() noexcept
    {
        mutex_type* __m = __m_;
        __m_ = nullptr;
        __owns_ = false;
        return __m;
    }


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    bool owns_lock() const noexcept {return __owns_;}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit operator bool () const noexcept {return __owns_;}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    mutex_type* mutex() const noexcept {return __m_;}
};

template <class _Mutex>
void
shared_lock<_Mutex>::lock()
{
    if (__m_ == nullptr)
        __throw_system_error(1, "shared_lock::lock: references null mutex");
    if (__owns_)
        __throw_system_error(11, "shared_lock::lock: already locked");
    __m_->lock_shared();
    __owns_ = true;
}

template <class _Mutex>
bool
shared_lock<_Mutex>::try_lock()
{
    if (__m_ == nullptr)
        __throw_system_error(1, "shared_lock::try_lock: references null mutex");
    if (__owns_)
        __throw_system_error(11, "shared_lock::try_lock: already locked");
    __owns_ = __m_->try_lock_shared();
    return __owns_;
}

template <class _Mutex>
template <class _Rep, class _Period>
bool
shared_lock<_Mutex>::try_lock_for(const chrono::duration<_Rep, _Period>& __d)
{
    if (__m_ == nullptr)
        __throw_system_error(1, "shared_lock::try_lock_for: references null mutex");
    if (__owns_)
        __throw_system_error(11, "shared_lock::try_lock_for: already locked");
    __owns_ = __m_->try_lock_shared_for(__d);
    return __owns_;
}

template <class _Mutex>
template <class _Clock, class _Duration>
bool
shared_lock<_Mutex>::try_lock_until(const chrono::time_point<_Clock, _Duration>& __t)
{
    if (__m_ == nullptr)
        __throw_system_error(1, "shared_lock::try_lock_until: references null mutex");
    if (__owns_)
        __throw_system_error(11, "shared_lock::try_lock_until: already locked");
    __owns_ = __m_->try_lock_shared_until(__t);
    return __owns_;
}

template <class _Mutex>
void
shared_lock<_Mutex>::unlock()
{
    if (!__owns_)
        __throw_system_error(1, "shared_lock::unlock: not locked");
    __m_->unlock_shared();
    __owns_ = false;
}

template <class _Mutex>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void
swap(shared_lock<_Mutex>& __x, shared_lock<_Mutex>& __y) noexcept
    {__x.swap(__y);}

} }
# 280 "/usr/local/include/bits/stdc++.h" 2





# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/any" 1 3
# 87 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/any" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/memory" 1 3
# 974 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/memory" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 1 3
# 20 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/assert.h" 1 3 4
# 44 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/assert.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/stdlib.h" 1 3 4
# 45 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/assert.h" 2 3 4
# 81 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/assert.h" 3 4
extern "C" {
void __assert_rtn(const char *, const char *, int, const char *) __attribute__((__noreturn__)) __attribute__((__cold__)) __attribute__((__disable_tail_calls__));



}
# 21 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 2 3
# 24 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 3
# 975 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/memory" 2 3
# 88 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/any" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 1 3
# 89 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/any" 2 3
# 94 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/any" 3


namespace std {
class __attribute__ ((__visibility__("default"))) __attribute__((availability(macosx,strict,introduced=10.13))) __attribute__((availability(ios,strict,introduced=11.0))) __attribute__((availability(tvos,strict,introduced=11.0))) __attribute__((availability(watchos,strict,introduced=4.0))) bad_any_cast : public bad_cast
{
public:
    virtual const char* what() const noexcept;
};
}

namespace std { inline namespace __1 {



[[noreturn]] inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
__attribute__((availability(macosx,strict,introduced=10.13))) __attribute__((availability(ios,strict,introduced=11.0))) __attribute__((availability(tvos,strict,introduced=11.0))) __attribute__((availability(watchos,strict,introduced=4.0)))
void __throw_bad_any_cast()
{

    throw bad_any_cast();



}


class __attribute__ ((__type_visibility__("default"))) any;

template <class _ValueType>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
add_pointer_t<add_const_t<_ValueType>>
any_cast(any const *) noexcept;

template <class _ValueType>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
add_pointer_t<_ValueType> any_cast(any *) noexcept;

namespace __any_imp
{
  using _Buffer = aligned_storage_t<3*sizeof(void*), alignment_of<void*>::value>;

  template <class _Tp>
  using _IsSmallObject = integral_constant<bool
        , sizeof(_Tp) <= sizeof(_Buffer)
          && alignment_of<_Buffer>::value
             % alignment_of<_Tp>::value == 0
          && is_nothrow_move_constructible<_Tp>::value
        >;

  enum class _Action {
    _Destroy,
    _Copy,
    _Move,
    _Get,
    _TypeInfo
  };

  template <class _Tp> struct _SmallHandler;
  template <class _Tp> struct _LargeHandler;

  template <class _Tp>
  struct __attribute__ ((__type_visibility__("default"))) __unique_typeinfo { static constexpr int __id = 0; };
  template <class _Tp> constexpr int __unique_typeinfo<_Tp>::__id;

  template <class _Tp>
  inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  constexpr const void* __get_fallback_typeid() {
      return &__unique_typeinfo<remove_cv_t<remove_reference_t<_Tp>>>::__id;
  }

  template <class _Tp>
  inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  bool __compare_typeid(type_info const* __id, const void* __fallback_id)
  {

      if (__id && *__id == typeid(_Tp))
          return true;

      if (!__id && __fallback_id == __any_imp::__get_fallback_typeid<_Tp>())
          return true;
      return false;
  }

  template <class _Tp>
  using _Handler = conditional_t<
    _IsSmallObject<_Tp>::value, _SmallHandler<_Tp>, _LargeHandler<_Tp>>;

}

class __attribute__ ((__type_visibility__("default"))) any
{
public:

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  constexpr any() noexcept : __h(nullptr) {}

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  any(any const & __other) : __h(nullptr)
  {
    if (__other.__h) __other.__call(_Action::_Copy, this);
  }

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  any(any && __other) noexcept : __h(nullptr)
  {
    if (__other.__h) __other.__call(_Action::_Move, this);
  }

  template <
      class _ValueType
    , class _Tp = decay_t<_ValueType>
    , class = enable_if_t<
        !is_same<_Tp, any>::value &&
        !__is_inplace_type<_ValueType>::value &&
        is_copy_constructible<_Tp>::value>
    >
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  any(_ValueType && __value);

  template <class _ValueType, class ..._Args,
    class _Tp = decay_t<_ValueType>,
    class = enable_if_t<
        is_constructible<_Tp, _Args...>::value &&
        is_copy_constructible<_Tp>::value
    >
  >
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  explicit any(in_place_type_t<_ValueType>, _Args&&... __args);

  template <class _ValueType, class _Up, class ..._Args,
    class _Tp = decay_t<_ValueType>,
    class = enable_if_t<
        is_constructible<_Tp, initializer_list<_Up>&, _Args...>::value &&
        is_copy_constructible<_Tp>::value>
  >
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  explicit any(in_place_type_t<_ValueType>, initializer_list<_Up>, _Args&&... __args);

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  ~any() { this->reset(); }


  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  any & operator=(any const & __rhs) {
    any(__rhs).swap(*this);
    return *this;
  }

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  any & operator=(any && __rhs) noexcept {
    any(std::__1::move(__rhs)).swap(*this);
    return *this;
  }

  template <
      class _ValueType
    , class _Tp = decay_t<_ValueType>
    , class = enable_if_t<
          !is_same<_Tp, any>::value
          && is_copy_constructible<_Tp>::value>
    >
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  any & operator=(_ValueType && __rhs);

  template <class _ValueType, class ..._Args,
    class _Tp = decay_t<_ValueType>,
    class = enable_if_t<
        is_constructible<_Tp, _Args...>::value &&
        is_copy_constructible<_Tp>::value>
    >
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  _Tp& emplace(_Args&&... args);

  template <class _ValueType, class _Up, class ..._Args,
    class _Tp = decay_t<_ValueType>,
    class = enable_if_t<
        is_constructible<_Tp, initializer_list<_Up>&, _Args...>::value &&
        is_copy_constructible<_Tp>::value>
  >
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  _Tp& emplace(initializer_list<_Up>, _Args&&...);


  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  void reset() noexcept { if (__h) this->__call(_Action::_Destroy); }

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  void swap(any & __rhs) noexcept;


  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  bool has_value() const noexcept { return __h != nullptr; }


  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  const type_info & type() const noexcept {
    if (__h) {
        return *static_cast<type_info const *>(this->__call(_Action::_TypeInfo));
    } else {
        return typeid(void);
    }
  }


private:
    typedef __any_imp::_Action _Action;
    using _HandleFuncPtr = void* (*)(_Action, any const *, any *, const type_info *,
      const void* __fallback_info);

    union _Storage {
        constexpr _Storage() : __ptr(nullptr) {}
        void * __ptr;
        __any_imp::_Buffer __buf;
    };

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void * __call(_Action __a, any * __other = nullptr,
                  type_info const * __info = nullptr,
                   const void* __fallback_info = nullptr) const
    {
        return __h(__a, this, __other, __info, __fallback_info);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void * __call(_Action __a, any * __other = nullptr,
                  type_info const * __info = nullptr,
                  const void* __fallback_info = nullptr)
    {
        return __h(__a, this, __other, __info, __fallback_info);
    }

    template <class>
    friend struct __any_imp::_SmallHandler;
    template <class>
    friend struct __any_imp::_LargeHandler;

    template <class _ValueType>
    friend add_pointer_t<add_const_t<_ValueType>>
    any_cast(any const *) noexcept;

    template <class _ValueType>
    friend add_pointer_t<_ValueType>
    any_cast(any *) noexcept;

    _HandleFuncPtr __h = nullptr;
    _Storage __s;
};

namespace __any_imp
{
  template <class _Tp>
  struct __attribute__ ((__type_visibility__("default"))) _SmallHandler
  {
     __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
     static void* __handle(_Action __act, any const * __this, any * __other,
                           type_info const * __info, const void* __fallback_info)
     {
        switch (__act)
        {
        case _Action::_Destroy:
          __destroy(const_cast<any &>(*__this));
          return nullptr;
        case _Action::_Copy:
            __copy(*__this, *__other);
            return nullptr;
        case _Action::_Move:
          __move(const_cast<any &>(*__this), *__other);
          return nullptr;
        case _Action::_Get:
            return __get(const_cast<any &>(*__this), __info, __fallback_info);
        case _Action::_TypeInfo:
          return __type_info();
        }
    }

    template <class ..._Args>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    static _Tp& __create(any & __dest, _Args&&... __args) {
        typedef allocator<_Tp> _Alloc;
        typedef allocator_traits<_Alloc> _ATraits;
        _Alloc __a;
        _Tp * __ret = static_cast<_Tp*>(static_cast<void*>(&__dest.__s.__buf));
        _ATraits::construct(__a, __ret, std::__1::forward<_Args>(__args)...);
        __dest.__h = &_SmallHandler::__handle;
        return *__ret;
    }

  private:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    static void __destroy(any & __this) {
        typedef allocator<_Tp> _Alloc;
        typedef allocator_traits<_Alloc> _ATraits;
        _Alloc __a;
        _Tp * __p = static_cast<_Tp *>(static_cast<void*>(&__this.__s.__buf));
        _ATraits::destroy(__a, __p);
        __this.__h = nullptr;
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    static void __copy(any const & __this, any & __dest) {
        _SmallHandler::__create(__dest, *static_cast<_Tp const *>(
            static_cast<void const *>(&__this.__s.__buf)));
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    static void __move(any & __this, any & __dest) {
        _SmallHandler::__create(__dest, std::__1::move(
            *static_cast<_Tp*>(static_cast<void*>(&__this.__s.__buf))));
        __destroy(__this);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    static void* __get(any & __this,
                       type_info const * __info,
                       const void* __fallback_id)
    {
        if (__any_imp::__compare_typeid<_Tp>(__info, __fallback_id))
            return static_cast<void*>(&__this.__s.__buf);
        return nullptr;
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    static void* __type_info()
    {

        return const_cast<void*>(static_cast<void const *>(&typeid(_Tp)));



    }
  };

  template <class _Tp>
  struct __attribute__ ((__type_visibility__("default"))) _LargeHandler
  {
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    static void* __handle(_Action __act, any const * __this,
                          any * __other, type_info const * __info,
                          void const* __fallback_info)
    {
        switch (__act)
        {
        case _Action::_Destroy:
          __destroy(const_cast<any &>(*__this));
          return nullptr;
        case _Action::_Copy:
          __copy(*__this, *__other);
          return nullptr;
        case _Action::_Move:
          __move(const_cast<any &>(*__this), *__other);
          return nullptr;
        case _Action::_Get:
            return __get(const_cast<any &>(*__this), __info, __fallback_info);
        case _Action::_TypeInfo:
          return __type_info();
        }
    }

    template <class ..._Args>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    static _Tp& __create(any & __dest, _Args&&... __args) {
        typedef allocator<_Tp> _Alloc;
        typedef allocator_traits<_Alloc> _ATraits;
        typedef __allocator_destructor<_Alloc> _Dp;
        _Alloc __a;
        unique_ptr<_Tp, _Dp> __hold(_ATraits::allocate(__a, 1), _Dp(__a, 1));
        _Tp * __ret = __hold.get();
        _ATraits::construct(__a, __ret, std::__1::forward<_Args>(__args)...);
        __dest.__s.__ptr = __hold.release();
        __dest.__h = &_LargeHandler::__handle;
        return *__ret;
    }

  private:

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    static void __destroy(any & __this){
        typedef allocator<_Tp> _Alloc;
        typedef allocator_traits<_Alloc> _ATraits;
        _Alloc __a;
        _Tp * __p = static_cast<_Tp *>(__this.__s.__ptr);
        _ATraits::destroy(__a, __p);
        _ATraits::deallocate(__a, __p, 1);
        __this.__h = nullptr;
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    static void __copy(any const & __this, any & __dest) {
        _LargeHandler::__create(__dest, *static_cast<_Tp const *>(__this.__s.__ptr));
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    static void __move(any & __this, any & __dest) {
      __dest.__s.__ptr = __this.__s.__ptr;
      __dest.__h = &_LargeHandler::__handle;
      __this.__h = nullptr;
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    static void* __get(any & __this, type_info const * __info,
                       void const* __fallback_info)
    {
        if (__any_imp::__compare_typeid<_Tp>(__info, __fallback_info))
            return static_cast<void*>(__this.__s.__ptr);
        return nullptr;

    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    static void* __type_info()
    {

        return const_cast<void*>(static_cast<void const *>(&typeid(_Tp)));



    }
  };

}


template <class _ValueType, class _Tp, class>
any::any(_ValueType && __v) : __h(nullptr)
{
  __any_imp::_Handler<_Tp>::__create(*this, std::__1::forward<_ValueType>(__v));
}

template <class _ValueType, class ..._Args, class _Tp, class>
any::any(in_place_type_t<_ValueType>, _Args&&... __args) {
  __any_imp::_Handler<_Tp>::__create(*this, std::__1::forward<_Args>(__args)...);
}

template <class _ValueType, class _Up, class ..._Args, class _Tp, class>
any::any(in_place_type_t<_ValueType>, initializer_list<_Up> __il, _Args&&... __args) {
  __any_imp::_Handler<_Tp>::__create(*this, __il, std::__1::forward<_Args>(__args)...);
}

template <class _ValueType, class, class>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
any & any::operator=(_ValueType && __v)
{
  any(std::__1::forward<_ValueType>(__v)).swap(*this);
  return *this;
}

template <class _ValueType, class ..._Args, class _Tp, class>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
_Tp& any::emplace(_Args&&... __args) {
  reset();
  return __any_imp::_Handler<_Tp>::__create(*this, std::__1::forward<_Args>(__args)...);
}

template <class _ValueType, class _Up, class ..._Args, class _Tp, class>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
_Tp& any::emplace(initializer_list<_Up> __il, _Args&&... __args) {
  reset();
  return __any_imp::_Handler<_Tp>::__create(*this, __il, std::__1::forward<_Args>(__args)...);
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void any::swap(any & __rhs) noexcept
{
    if (this == &__rhs)
      return;
    if (__h && __rhs.__h) {
        any __tmp;
        __rhs.__call(_Action::_Move, &__tmp);
        this->__call(_Action::_Move, &__rhs);
        __tmp.__call(_Action::_Move, this);
    }
    else if (__h) {
        this->__call(_Action::_Move, &__rhs);
    }
    else if (__rhs.__h) {
        __rhs.__call(_Action::_Move, this);
    }
}



inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void swap(any & __lhs, any & __rhs) noexcept
{
    __lhs.swap(__rhs);
}

template <class _Tp, class ..._Args>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
any make_any(_Args&&... __args) {
    return any(in_place_type<_Tp>, std::__1::forward<_Args>(__args)...);
}

template <class _Tp, class _Up, class ..._Args>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
any make_any(initializer_list<_Up> __il, _Args&&... __args) {
    return any(in_place_type<_Tp>, __il, std::__1::forward<_Args>(__args)...);
}

template <class _ValueType>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
__attribute__((availability(macosx,strict,introduced=10.13))) __attribute__((availability(ios,strict,introduced=11.0))) __attribute__((availability(tvos,strict,introduced=11.0))) __attribute__((availability(watchos,strict,introduced=4.0)))
_ValueType any_cast(any const & __v)
{
    using _RawValueType = __uncvref_t<_ValueType>;
    static_assert(is_constructible<_ValueType, _RawValueType const &>::value,
                  "ValueType is required to be a const lvalue reference "
                  "or a CopyConstructible type");
    auto __tmp = std::__1::any_cast<add_const_t<_RawValueType>>(&__v);
    if (__tmp == nullptr)
        __throw_bad_any_cast();
    return static_cast<_ValueType>(*__tmp);
}

template <class _ValueType>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
__attribute__((availability(macosx,strict,introduced=10.13))) __attribute__((availability(ios,strict,introduced=11.0))) __attribute__((availability(tvos,strict,introduced=11.0))) __attribute__((availability(watchos,strict,introduced=4.0)))
_ValueType any_cast(any & __v)
{
    using _RawValueType = __uncvref_t<_ValueType>;
    static_assert(is_constructible<_ValueType, _RawValueType &>::value,
                  "ValueType is required to be an lvalue reference "
                  "or a CopyConstructible type");
    auto __tmp = std::__1::any_cast<_RawValueType>(&__v);
    if (__tmp == nullptr)
        __throw_bad_any_cast();
    return static_cast<_ValueType>(*__tmp);
}

template <class _ValueType>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
__attribute__((availability(macosx,strict,introduced=10.13))) __attribute__((availability(ios,strict,introduced=11.0))) __attribute__((availability(tvos,strict,introduced=11.0))) __attribute__((availability(watchos,strict,introduced=4.0)))
_ValueType any_cast(any && __v)
{
    using _RawValueType = __uncvref_t<_ValueType>;
    static_assert(is_constructible<_ValueType, _RawValueType>::value,
                  "ValueType is required to be an rvalue reference "
                  "or a CopyConstructible type");
    auto __tmp = std::__1::any_cast<_RawValueType>(&__v);
    if (__tmp == nullptr)
        __throw_bad_any_cast();
    return static_cast<_ValueType>(std::__1::move(*__tmp));
}

template <class _ValueType>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
add_pointer_t<add_const_t<_ValueType>>
any_cast(any const * __any) noexcept
{
    static_assert(!is_reference<_ValueType>::value,
                  "_ValueType may not be a reference.");
    return std::__1::any_cast<_ValueType>(const_cast<any *>(__any));
}

template <class _RetType>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
_RetType __pointer_or_func_cast(void* __p, false_type) noexcept {
  return static_cast<_RetType>(__p);
}

template <class _RetType>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
_RetType __pointer_or_func_cast(void*, true_type) noexcept {
  return nullptr;
}

template <class _ValueType>
add_pointer_t<_ValueType>
any_cast(any * __any) noexcept
{
    using __any_imp::_Action;
    static_assert(!is_reference<_ValueType>::value,
                  "_ValueType may not be a reference.");
    typedef typename add_pointer<_ValueType>::type _ReturnType;
    if (__any && __any->__h) {
      void *__p = __any->__call(_Action::_Get, nullptr,

                          &typeid(_ValueType),



                          __any_imp::__get_fallback_typeid<_ValueType>());
        return std::__1::__pointer_or_func_cast<_ReturnType>(
            __p, is_function<_ValueType>{});
    }
    return nullptr;
}



} }
# 286 "/usr/local/include/bits/stdc++.h" 2


# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/charconv" 1 3
# 85 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/charconv" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 1 3
# 86 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/charconv" 2 3
# 91 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/charconv" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 95 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/charconv" 2 3

namespace std { inline namespace __1 {

namespace __itoa {
__attribute__((availability(macosx,strict,introduced=10.15))) __attribute__((availability(ios,strict,introduced=13.0))) __attribute__((availability(tvos,strict,introduced=13.0))) __attribute__((availability(watchos,strict,introduced=6.0))) __attribute__ ((__visibility__("default"))) char* __u64toa(uint64_t __value, char* __buffer) noexcept;
__attribute__((availability(macosx,strict,introduced=10.15))) __attribute__((availability(ios,strict,introduced=13.0))) __attribute__((availability(tvos,strict,introduced=13.0))) __attribute__((availability(watchos,strict,introduced=6.0))) __attribute__ ((__visibility__("default"))) char* __u32toa(uint32_t __value, char* __buffer) noexcept;
}



enum class __attribute__ ((__type_visibility__("default"))) chars_format
{
    scientific = 0x1,
    fixed = 0x2,
    hex = 0x4,
    general = fixed | scientific
};

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr chars_format
operator~(chars_format __x) {
  return chars_format(~std::__1::__to_underlying(__x));
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr chars_format
operator&(chars_format __x, chars_format __y) {
  return chars_format(std::__1::__to_underlying(__x) &
                      std::__1::__to_underlying(__y));
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr chars_format
operator|(chars_format __x, chars_format __y) {
  return chars_format(std::__1::__to_underlying(__x) |
                      std::__1::__to_underlying(__y));
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr chars_format
operator^(chars_format __x, chars_format __y) {
  return chars_format(std::__1::__to_underlying(__x) ^
                      std::__1::__to_underlying(__y));
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr chars_format&
operator&=(chars_format& __x, chars_format __y) {
  __x = __x & __y;
  return __x;
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr chars_format&
operator|=(chars_format& __x, chars_format __y) {
  __x = __x | __y;
  return __x;
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr chars_format&
operator^=(chars_format& __x, chars_format __y) {
  __x = __x ^ __y;
  return __x;
}

struct __attribute__ ((__visibility__("default"))) to_chars_result
{
    char* ptr;
    errc ec;
};

struct __attribute__ ((__visibility__("default"))) from_chars_result
{
    const char* ptr;
    errc ec;
};

void to_chars(char*, char*, bool, int = 10) = delete;
void from_chars(const char*, const char*, bool, int = 10) = delete;

namespace __itoa
{

static constexpr uint64_t __pow10_64[] = {
    (0ULL),
    (10ULL),
    (100ULL),
    (1000ULL),
    (10000ULL),
    (100000ULL),
    (1000000ULL),
    (10000000ULL),
    (100000000ULL),
    (1000000000ULL),
    (10000000000ULL),
    (100000000000ULL),
    (1000000000000ULL),
    (10000000000000ULL),
    (100000000000000ULL),
    (1000000000000000ULL),
    (10000000000000000ULL),
    (100000000000000000ULL),
    (1000000000000000000ULL),
    (10000000000000000000ULL),
};

static constexpr uint32_t __pow10_32[] = {
    (0U), (10U), (100U),
    (1000U), (10000U), (100000U),
    (1000000U), (10000000U), (100000000U),
    (1000000000U),
};

template <typename _Tp, typename = void>
struct __attribute__ ((__visibility__("hidden"))) __traits_base
{
    using type = uint64_t;


    static __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) int __width(_Tp __v)
    {
        auto __t = (64 - __builtin_clzll(__v | 1)) * 1233 >> 12;
        return __t - (__v < __pow10_64[__t]) + 1;
    }


    __attribute__((availability(macosx,strict,introduced=10.15))) __attribute__((availability(ios,strict,introduced=13.0))) __attribute__((availability(tvos,strict,introduced=13.0))) __attribute__((availability(watchos,strict,introduced=6.0)))
    static __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) char* __convert(_Tp __v, char* __p)
    {
        return __u64toa(__v, __p);
    }

    static __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) decltype(__pow10_64)& __pow() { return __pow10_64; }
};

template <typename _Tp>
struct __attribute__ ((__visibility__("hidden")))
    __traits_base<_Tp, decltype(void(uint32_t{declval<_Tp>()}))>
{
    using type = uint32_t;


    static __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) int __width(_Tp __v)
    {
        auto __t = (32 - __builtin_clz(__v | 1)) * 1233 >> 12;
        return __t - (__v < __pow10_32[__t]) + 1;
    }


    __attribute__((availability(macosx,strict,introduced=10.15))) __attribute__((availability(ios,strict,introduced=13.0))) __attribute__((availability(tvos,strict,introduced=13.0))) __attribute__((availability(watchos,strict,introduced=6.0)))
    static __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) char* __convert(_Tp __v, char* __p)
    {
        return __u32toa(__v, __p);
    }

    static __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) decltype(__pow10_32)& __pow() { return __pow10_32; }
};

template <typename _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) bool
__mul_overflowed(unsigned char __a, _Tp __b, unsigned char& __r)
{
    auto __c = __a * __b;
    __r = __c;
    return __c > numeric_limits<unsigned char>::max();
}

template <typename _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) bool
__mul_overflowed(unsigned short __a, _Tp __b, unsigned short& __r)
{
    auto __c = __a * __b;
    __r = __c;
    return __c > numeric_limits<unsigned short>::max();
}

template <typename _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) bool
__mul_overflowed(_Tp __a, _Tp __b, _Tp& __r)
{
    static_assert(is_unsigned<_Tp>::value, "");

    return __builtin_mul_overflow(__a, __b, &__r);





}

template <typename _Tp, typename _Up>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) bool
__mul_overflowed(_Tp __a, _Up __b, _Tp& __r)
{
    return __mul_overflowed(__a, static_cast<_Tp>(__b), __r);
}

template <typename _Tp>
struct __attribute__ ((__visibility__("hidden"))) __traits : __traits_base<_Tp>
{
    static constexpr int digits = numeric_limits<_Tp>::digits10 + 1;
    using __traits_base<_Tp>::__pow;
    using typename __traits_base<_Tp>::type;


    static __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) char const*
    __read(char const* __p, char const* __ep, type& __a, type& __b)
    {
        type __cprod[digits];
        int __j = digits - 1;
        int __i = digits;
        do
        {
            if (!('0' <= *__p && *__p <= '9'))
                break;
            __cprod[--__i] = *__p++ - '0';
        } while (__p != __ep && __i != 0);

        __a = __inner_product(__cprod + __i + 1, __cprod + __j, __pow() + 1,
                              __cprod[__i]);
        if (__mul_overflowed(__cprod[__j], __pow()[__j - __i], __b))
            --__p;
        return __p;
    }

    template <typename _It1, typename _It2, class _Up>
    static __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) _Up
    __inner_product(_It1 __first1, _It1 __last1, _It2 __first2, _Up __init)
    {
        for (; __first1 < __last1; ++__first1, ++__first2)
            __init = __init + *__first1 * *__first2;
        return __init;
    }
};

}

template <typename _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) _Tp
__complement(_Tp __x)
{
    static_assert(is_unsigned<_Tp>::value, "cast to unsigned first");
    return _Tp(~__x + 1);
}

template <typename _Tp>
__attribute__((availability(macosx,strict,introduced=10.15))) __attribute__((availability(ios,strict,introduced=13.0))) __attribute__((availability(tvos,strict,introduced=13.0))) __attribute__((availability(watchos,strict,introduced=6.0)))
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) to_chars_result
__to_chars_itoa(char* __first, char* __last, _Tp __value, true_type)
{
    auto __x = __to_unsigned_like(__value);
    if (__value < 0 && __first != __last)
    {
        *__first++ = '-';
        __x = __complement(__x);
    }

    return __to_chars_itoa(__first, __last, __x, false_type());
}

template <typename _Tp>
__attribute__((availability(macosx,strict,introduced=10.15))) __attribute__((availability(ios,strict,introduced=13.0))) __attribute__((availability(tvos,strict,introduced=13.0))) __attribute__((availability(watchos,strict,introduced=6.0)))
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) to_chars_result
__to_chars_itoa(char* __first, char* __last, _Tp __value, false_type)
{
    using __tx = __itoa::__traits<_Tp>;
    auto __diff = __last - __first;


    if (__tx::digits <= __diff || __tx::__width(__value) <= __diff)
        return {__tx::__convert(__value, __first), errc(0)};
    else
        return {__last, errc::value_too_large};
# 379 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/charconv" 3
}

template <typename _Tp>
__attribute__((availability(macosx,strict,introduced=10.15))) __attribute__((availability(ios,strict,introduced=13.0))) __attribute__((availability(tvos,strict,introduced=13.0))) __attribute__((availability(watchos,strict,introduced=6.0)))
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) to_chars_result
__to_chars_integral(char* __first, char* __last, _Tp __value, int __base,
                    true_type)
{
    auto __x = __to_unsigned_like(__value);
    if (__value < 0 && __first != __last)
    {
        *__first++ = '-';
        __x = __complement(__x);
    }

    return __to_chars_integral(__first, __last, __x, __base, false_type());
}

template <typename _Tp>
__attribute__((availability(macosx,strict,introduced=10.15))) __attribute__((availability(ios,strict,introduced=13.0))) __attribute__((availability(tvos,strict,introduced=13.0))) __attribute__((availability(watchos,strict,introduced=6.0))) __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) int __to_chars_integral_width(_Tp __value, unsigned __base) {
  ((void)0);

  unsigned __base_2 = __base * __base;
  unsigned __base_3 = __base_2 * __base;
  unsigned __base_4 = __base_2 * __base_2;

  int __r = 0;
  while (true) {
    if (__value < __base)
      return __r + 1;
    if (__value < __base_2)
      return __r + 2;
    if (__value < __base_3)
      return __r + 3;
    if (__value < __base_4)
      return __r + 4;

    __value /= __base_4;
    __r += 4;
  }

  __builtin_unreachable();
}

template <typename _Tp>
__attribute__((availability(macosx,strict,introduced=10.15))) __attribute__((availability(ios,strict,introduced=13.0))) __attribute__((availability(tvos,strict,introduced=13.0))) __attribute__((availability(watchos,strict,introduced=6.0)))
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) to_chars_result
__to_chars_integral(char* __first, char* __last, _Tp __value, int __base,
                    false_type)
{
  if (__base == 10)
    return __to_chars_itoa(__first, __last, __value, false_type());

  ptrdiff_t __cap = __last - __first;
  int __n = __to_chars_integral_width(__value, __base);
  if (__n > __cap)
    return {__last, errc::value_too_large};

  __last = __first + __n;
  char* __p = __last;
  do {
    unsigned __c = __value % __base;
    __value /= __base;
    *--__p = "0123456789abcdefghijklmnopqrstuvwxyz"[__c];
  } while (__value != 0);
  return {__last, errc(0)};
}

template <typename _Tp, typename enable_if<is_integral<_Tp>::value, int>::type = 0>
__attribute__((availability(macosx,strict,introduced=10.15))) __attribute__((availability(ios,strict,introduced=13.0))) __attribute__((availability(tvos,strict,introduced=13.0))) __attribute__((availability(watchos,strict,introduced=6.0)))
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) to_chars_result
to_chars(char* __first, char* __last, _Tp __value)
{
    return __to_chars_itoa(__first, __last, __value, is_signed<_Tp>());
}

template <typename _Tp, typename enable_if<is_integral<_Tp>::value, int>::type = 0>
__attribute__((availability(macosx,strict,introduced=10.15))) __attribute__((availability(ios,strict,introduced=13.0))) __attribute__((availability(tvos,strict,introduced=13.0))) __attribute__((availability(watchos,strict,introduced=6.0)))
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) to_chars_result
to_chars(char* __first, char* __last, _Tp __value, int __base)
{
    ((void)0);
    return __to_chars_integral(__first, __last, __value, __base,
                               is_signed<_Tp>());
}

template <typename _It, typename _Tp, typename _Fn, typename... _Ts>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) from_chars_result
__sign_combinator(_It __first, _It __last, _Tp& __value, _Fn __f, _Ts... __args)
{
    using __tl = numeric_limits<_Tp>;
    decltype(__to_unsigned_like(__value)) __x;

    bool __neg = (__first != __last && *__first == '-');
    auto __r = __f(__neg ? __first + 1 : __first, __last, __x, __args...);
    switch (__r.ec)
    {
    case errc::invalid_argument:
        return {__first, __r.ec};
    case errc::result_out_of_range:
        return __r;
    default:
        break;
    }

    if (__neg)
    {
        if (__x <= __complement(__to_unsigned_like(__tl::min())))
        {
            __x = __complement(__x);
            std::__1::memcpy(&__value, &__x, sizeof(__x));
            return __r;
        }
    }
    else
    {
        if (__x <= __tl::max())
        {
            __value = __x;
            return __r;
        }
    }

    return {__r.ptr, errc::result_out_of_range};
}

template <typename _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) bool
__in_pattern(_Tp __c)
{
    return '0' <= __c && __c <= '9';
}

struct __attribute__ ((__visibility__("hidden"))) __in_pattern_result
{
    bool __ok;
    int __val;

    explicit __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) operator bool() const { return __ok; }
};

template <typename _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) __in_pattern_result
__in_pattern(_Tp __c, int __base)
{
    if (__base <= 10)
        return {'0' <= __c && __c < '0' + __base, __c - '0'};
    else if (__in_pattern(__c))
        return {true, __c - '0'};
    else if ('a' <= __c && __c < 'a' + __base - 10)
        return {true, __c - 'a' + 10};
    else
        return {'A' <= __c && __c < 'A' + __base - 10, __c - 'A' + 10};
}

template <typename _It, typename _Tp, typename _Fn, typename... _Ts>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) from_chars_result
__subject_seq_combinator(_It __first, _It __last, _Tp& __value, _Fn __f,
                         _Ts... __args)
{
    auto __find_non_zero = [](_It __first, _It __last) {
        for (; __first != __last; ++__first)
            if (*__first != '0')
                break;
        return __first;
    };

    auto __p = __find_non_zero(__first, __last);
    if (__p == __last || !__in_pattern(*__p, __args...))
    {
        if (__p == __first)
            return {__first, errc::invalid_argument};
        else
        {
            __value = 0;
            return {__p, {}};
        }
    }

    auto __r = __f(__p, __last, __value, __args...);
    if (__r.ec == errc::result_out_of_range)
    {
        for (; __r.ptr != __last; ++__r.ptr)
        {
            if (!__in_pattern(*__r.ptr, __args...))
                break;
        }
    }

    return __r;
}

template <typename _Tp, typename enable_if<is_unsigned<_Tp>::value, int>::type = 0>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) from_chars_result
__from_chars_atoi(const char* __first, const char* __last, _Tp& __value)
{
    using __tx = __itoa::__traits<_Tp>;
    using __output_type = typename __tx::type;

    return __subject_seq_combinator(
        __first, __last, __value,
        [](const char* __first, const char* __last,
           _Tp& __value) -> from_chars_result {
            __output_type __a, __b;
            auto __p = __tx::__read(__first, __last, __a, __b);
            if (__p == __last || !__in_pattern(*__p))
            {
                __output_type __m = numeric_limits<_Tp>::max();
                if (__m >= __a && __m - __a >= __b)
                {
                    __value = __a + __b;
                    return {__p, {}};
                }
            }
            return {__p, errc::result_out_of_range};
        });
}

template <typename _Tp, typename enable_if<is_signed<_Tp>::value, int>::type = 0>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) from_chars_result
__from_chars_atoi(const char* __first, const char* __last, _Tp& __value)
{
    using __t = decltype(__to_unsigned_like(__value));
    return __sign_combinator(__first, __last, __value, __from_chars_atoi<__t>);
}

template <typename _Tp, typename enable_if<is_unsigned<_Tp>::value, int>::type = 0>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) from_chars_result
__from_chars_integral(const char* __first, const char* __last, _Tp& __value,
                      int __base)
{
    if (__base == 10)
        return __from_chars_atoi(__first, __last, __value);

    return __subject_seq_combinator(
        __first, __last, __value,
        [](const char* __p, const char* __lastx, _Tp& __value,
           int __base) -> from_chars_result {
            using __tl = numeric_limits<_Tp>;
            auto __digits = __tl::digits / log2f(float(__base));
            _Tp __a = __in_pattern(*__p++, __base).__val, __b = 0;

            for (int __i = 1; __p != __lastx; ++__i, ++__p)
            {
                if (auto __c = __in_pattern(*__p, __base))
                {
                    if (__i < __digits - 1)
                        __a = __a * __base + __c.__val;
                    else
                    {
                        if (!__itoa::__mul_overflowed(__a, __base, __a))
                            ++__p;
                        __b = __c.__val;
                        break;
                    }
                }
                else
                    break;
            }

            if (__p == __lastx || !__in_pattern(*__p, __base))
            {
                if (__tl::max() - __a >= __b)
                {
                    __value = __a + __b;
                    return {__p, {}};
                }
            }
            return {__p, errc::result_out_of_range};
        },
        __base);
}

template <typename _Tp, typename enable_if<is_signed<_Tp>::value, int>::type = 0>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) from_chars_result
__from_chars_integral(const char* __first, const char* __last, _Tp& __value,
                      int __base)
{
    using __t = decltype(__to_unsigned_like(__value));
    return __sign_combinator(__first, __last, __value,
                             __from_chars_integral<__t>, __base);
}

template <typename _Tp, typename enable_if<is_integral<_Tp>::value, int>::type = 0>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) from_chars_result
from_chars(const char* __first, const char* __last, _Tp& __value)
{
    return __from_chars_atoi(__first, __last, __value);
}

template <typename _Tp, typename enable_if<is_integral<_Tp>::value, int>::type = 0>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) from_chars_result
from_chars(const char* __first, const char* __last, _Tp& __value, int __base)
{
    ((void)0);
    return __from_chars_integral(__first, __last, __value, __base);
}



} }
# 289 "/usr/local/include/bits/stdc++.h" 2
# 2 "tin3.cpp" 2
using namespace std;
# 24 "tin3.cpp"
int main(){
 string s;
 cin>>s;
 long k;
 cin>>k;
 cout<<({ int64_t __begin = 0; int64_t __end = s.size()+1; (__builtin_expect(!(__begin <= __end), 0) ? __assert_rtn(__func__, "tin3.cpp", 51, "__begin <= __end") : (void)0); while (__begin + 1 < __end) { int64_t __center = (__begin + __end) / 2; if (({ long c=0; for (long w=0;w<__center;++w){ if (s[w]=='.'){ c++; } } long min_k=c; for (long w=__center;w<s.size();++w){ if (s[w]=='.'){ c++; } if (s[w-__center]=='.'){ c--; } if (c<min_k){ min_k=c; } } min_k>k; })) { __end = __center; } else { __begin = __center; } } int64_t __center = __begin; if (__begin != __end and (({ long c=0; for (long w=0;w<__center;++w){ if (s[w]=='.'){ c++; } } long min_k=c; for (long w=__center;w<s.size();++w){ if (s[w]=='.'){ c++; } if (s[w-__center]=='.'){ c--; } if (c<min_k){ min_k=c; } } min_k>k; }))) { __end = __center; } __end; })-1<<endl;
# 52 "tin3.cpp"
}

